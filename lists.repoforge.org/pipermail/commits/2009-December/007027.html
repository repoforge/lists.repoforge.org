<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r8232 - in trunk/rpms: . tcp_wrappers
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r8232%20-%20in%20trunk/rpms%3A%20.%20tcp_wrappers&In-Reply-To=%3C200912251436.nBPEaGos010066%40surya.karan.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007026.html">
   <LINK REL="Next"  HREF="007028.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r8232 - in trunk/rpms: . tcp_wrappers</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r8232%20-%20in%20trunk/rpms%3A%20.%20tcp_wrappers&In-Reply-To=%3C200912251436.nBPEaGos010066%40surya.karan.org%3E"
       TITLE="[svn] r8232 - in trunk/rpms: . tcp_wrappers">packagers at lists.rpmforge.net
       </A><BR>
    <I>Fri Dec 25 15:36:16 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="007026.html">[svn] r8231 - in trunk/rpms: . pnp4nagios
</A></li>
        <LI>Next message: <A HREF="007028.html">[svn] r8233 - in trunk/rpms: . powerman
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7027">[ date ]</a>
              <a href="thread.html#7027">[ thread ]</a>
              <a href="subject.html#7027">[ subject ]</a>
              <a href="author.html#7027">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yury
Date: 2009-12-25 14:36:16 +0000 (Fri, 25 Dec 2009)
New Revision: 8232

Added:
   trunk/rpms/tcp_wrappers/
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-162412.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-196326.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-220015.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug11881.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17795.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17847.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-docu.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fix_sig-bug141110.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fixgethostbyname.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-ldflags.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-restore_sigalarm.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-shared.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sig.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sigchld.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-siglongjmp.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-strerror.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers.spec
   trunk/rpms/tcp_wrappers/tcp_wrappers.ume-ipv6.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers.usagi-ipv6.patch
   trunk/rpms/tcp_wrappers/tcp_wrappers_7.6-249430.patch
   trunk/rpms/tcp_wrappers/tcpw7.2-config.patch
   trunk/rpms/tcp_wrappers/tcpw7.2-setenv.patch
   trunk/rpms/tcp_wrappers/tcpw7.6-netgroup.patch
Log:
Port tcp_wrappers over RPMForge from Fedora with minor corrections.



Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-162412.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-162412.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-162412.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,12 @@
+diff -up tcp_wrappers_7.6/inetcf.c.patch16 tcp_wrappers_7.6/inetcf.c
+--- tcp_wrappers_7.6/inetcf.c.patch16	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/inetcf.c	2008-08-29 09:45:12.000000000 +0200
+@@ -61,7 +61,7 @@ char   *inet_cfg(conf)
+ char   *conf;
+ {
+     char    buf[BUFSIZ];
+-    FILE   *fp;
++    FILE   *fp = NULL;
+     char   *service;
+     char   *protocol;
+     char   *user;

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-196326.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-196326.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-196326.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,13 @@
+diff -up tcp_wrappers_7.6/hosts_access.c.patch21 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch21	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -346,6 +346,9 @@ char   *string;
+ 	return (STR_NE(string, unknown));
+     } else if (tok[(n = strlen(tok)) - 1] == '.') {	/* prefix */
+ 	return (STRN_EQ(tok, string, n));
++    } else if ((STR_EQ(tok, &quot;localhost&quot;) || STR_EQ(tok, &quot;localhost.localdomain&quot;))
++	    &amp;&amp; (STR_EQ(string, &quot;localhost&quot;) || STR_EQ(string, &quot;localhost.localdomain&quot;))) {
++	return (YES); /* these localhosts are equivalent */
+     } else {					/* exact match */
+ #ifdef INET6
+ 	struct addrinfo hints, *res;

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-220015.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-220015.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-220015.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,88 @@
+diff -up tcp_wrappers_7.6/hosts_ctl.c.patch17 tcp_wrappers_7.6/hosts_ctl.c
+--- tcp_wrappers_7.6/hosts_ctl.c.patch17	1994-12-28 17:42:28.000000000 +0100
++++ tcp_wrappers_7.6/hosts_ctl.c	2008-08-29 09:45:12.000000000 +0200
+@@ -29,10 +29,12 @@ char   *user;
+ {
+     struct request_info request;
+ 
+-    return (hosts_access(request_init(&amp;request,
+-				      RQ_DAEMON, daemon,
+-				      RQ_CLIENT_NAME, name,
+-				      RQ_CLIENT_ADDR, addr,
+-				      RQ_USER, user,
+-				      0)));
++    request_init(&amp;request, RQ_DAEMON, daemon,
++			   RQ_CLIENT_NAME, name,
++			   RQ_CLIENT_ADDR, addr,
++			   RQ_USER, user,
++			   0);
++    sock_hostnofd(&amp;request);
++
++    return (hosts_access(&amp;request));
+ }
+diff -up tcp_wrappers_7.6/socket.c.patch17 tcp_wrappers_7.6/socket.c
+--- tcp_wrappers_7.6/socket.c.patch17	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/socket.c	2008-08-29 09:45:12.000000000 +0200
+@@ -147,6 +147,51 @@ struct request_info *request;
+ #endif
+ }
+ 
++/* sock_hostnofd - look up endpoint addresses and install conversion methods */
++
++void    sock_hostnofd(request)
++struct request_info *request;
++{
++    static struct sockaddr_storage client;
++    struct addrinfo hints, *res;
++    int     ret;
++    char    *host;
++
++    /* If the address field is non-empty and non-unknown and if the hostname
++     * field is empty or unknown, use the address field to get the sockaddr
++     * and hostname. */
++    if (strlen(request-&gt;client-&gt;addr) &amp;&amp;
++	    HOSTNAME_KNOWN(request-&gt;client-&gt;addr) &amp;&amp;
++	    (!strlen(request-&gt;client-&gt;name) ||
++		!HOSTNAME_KNOWN(request-&gt;client-&gt;name)))
++	host = request-&gt;client-&gt;addr;
++    else
++	return;
++
++    memset(&amp;hints, 0, sizeof(hints));
++    hints.ai_family = AF_INET6;
++    hints.ai_socktype = SOCK_STREAM;
++    hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;
++
++    ret = getaddrinfo(host, NULL, &amp;hints, &amp;res);
++    if (ret != 0) {
++	hints.ai_family = AF_INET;
++	ret = getaddrinfo(host, NULL, &amp;hints, &amp;res);
++    }
++
++    if (ret != 0) {
++	tcpd_warn(&quot;can't resolve hostname (%s): %s&quot;, host, gai_strerror(ret));
++    } else {
++	sock_methods(request);
++
++	memcpy(&amp;client, res-&gt;ai_addr, res-&gt;ai_addrlen);
++	request-&gt;client-&gt;sin = (struct sockaddr *)&amp;client;
++	freeaddrinfo(res);
++
++	request-&gt;client-&gt;name[0] = 0;
++    }
++}
++
+ /* sock_hostaddr - map endpoint address to printable form */
+ 
+ void    sock_hostaddr(host)
+diff -up tcp_wrappers_7.6/tcpd.h.patch17 tcp_wrappers_7.6/tcpd.h
+--- tcp_wrappers_7.6/tcpd.h.patch17	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/tcpd.h	2008-08-29 09:45:12.000000000 +0200
+@@ -167,6 +167,7 @@ extern char *eval_server __P((struct req
+ 
+ /* look up endpoint addresses */
+ extern void sock_host __P((struct request_info *));
++extern void sock_hostnofd __P((struct request_info *));
+ /* translate address to hostname */
+ extern void sock_hostname __P((struct host_info *));
+ /* address to printable address */

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug11881.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug11881.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug11881.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,37 @@
+diff -up tcp_wrappers_7.6/eval.c.patch4 tcp_wrappers_7.6/eval.c
+--- tcp_wrappers_7.6/eval.c.patch4	1995-01-30 19:51:46.000000000 +0100
++++ tcp_wrappers_7.6/eval.c	2008-08-29 09:45:12.000000000 +0200
+@@ -111,7 +111,7 @@ struct request_info *request;
+ 	return (hostinfo);
+ #endif
+     if (STR_NE(eval_user(request), unknown)) {
+-	sprintf(both, &quot;%s@%s&quot;, request-&gt;user, hostinfo);
++	snprintf(both, sizeof(both), &quot;%s@%s&quot;, request-&gt;user, hostinfo);
+ 	return (both);
+     } else {
+ 	return (hostinfo);
+@@ -128,7 +128,7 @@ struct request_info *request;
+     char   *daemon = eval_daemon(request);
+ 
+     if (STR_NE(host, unknown)) {
+-	sprintf(both, &quot;%s@%s&quot;, daemon, host);
++	snprintf(both, sizeof(both), &quot;%s@%s&quot;, daemon, host);
+ 	return (both);
+     } else {
+ 	return (daemon);
+diff -up tcp_wrappers_7.6/tcpd.c.patch4 tcp_wrappers_7.6/tcpd.c
+--- tcp_wrappers_7.6/tcpd.c.patch4	1996-02-11 17:01:33.000000000 +0100
++++ tcp_wrappers_7.6/tcpd.c	2008-08-29 09:45:12.000000000 +0200
+@@ -60,10 +60,10 @@ char  **argv;
+      */
+ 
+     if (argv[0][0] == '/') {
+-	strcpy(path, argv[0]);
++	strncpy(path, argv[0], sizeof(path));
+ 	argv[0] = strrchr(argv[0], '/') + 1;
+     } else {
+-	sprintf(path, &quot;%s/%s&quot;, REAL_DAEMON_DIR, argv[0]);
++	snprintf(path, sizeof(path), &quot;%s/%s&quot;, REAL_DAEMON_DIR, argv[0]);
+     }
+ 
+     /*

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17795.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17795.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17795.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,56 @@
+diff -up tcp_wrappers_7.6/hosts_access.5.patch5 tcp_wrappers_7.6/hosts_access.5
+--- tcp_wrappers_7.6/hosts_access.5.patch5	1995-01-30 19:51:47.000000000 +0100
++++ tcp_wrappers_7.6/hosts_access.5	2008-08-29 09:45:12.000000000 +0200
+@@ -89,6 +89,13 @@ An expression of the form `n.n.n.n/m.m.m
+ bitwise AND of the address and the `mask\'. For example, the net/mask
+ pattern `131.155.72.0/255.255.254.0\' matches every address in the
+ range `131.155.72.0\' through `131.155.73.255\'.
++.IP \(bu
++A string that begins with a `/\' character is treated as a file
++name. A host name or address is matched if it matches any host name
++or address pattern listed in the named file. The file format is
++zero or more lines with zero or more host name or address patterns
++separated by whitespace.  A file name pattern can be used anywhere
++a host name or address pattern can be used.
+ .SH WILDCARDS
+ The access control language supports explicit wildcards:
+ .IP ALL
+diff -up tcp_wrappers_7.6/hosts_access.c.patch5 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch5	1997-02-12 02:13:23.000000000 +0100
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -240,6 +240,26 @@ struct request_info *request;
+     }
+ }
+ 
++/* hostfile_match - look up host patterns from file */
++
++static int hostfile_match(path, host)
++char   *path;
++struct hosts_info *host;
++{
++    char    tok[BUFSIZ];
++    int     match = NO;
++    FILE   *fp;
++
++    if ((fp = fopen(path, &quot;r&quot;)) != 0) {
++	while (fscanf(fp, &quot;%s&quot;, tok) == 1 &amp;&amp; !(match = host_match(tok, host)))
++	     /* void */ ;
++	fclose(fp);
++    } else if (errno != ENOENT) {
++	tcpd_warn(&quot;open %s: %m&quot;, path);
++    }
++    return (match);
++}
++
+ /* host_match - match host name and/or address against pattern */
+ 
+ static int host_match(tok, host)
+@@ -267,6 +287,8 @@ struct host_info *host;
+ 	tcpd_warn(&quot;netgroup support is disabled&quot;);	/* not tcpd_jump() */
+ 	return (NO);
+ #endif
++    } else if (tok[0] == '/') {			/* /file hack */
++	return (hostfile_match(tok, host));
+     } else if (STR_EQ(tok, &quot;KNOWN&quot;)) {		/* check address and name */
+ 	char   *name = eval_hostname(host);
+ 	return (STR_NE(eval_hostaddr(host), unknown) &amp;&amp; HOSTNAME_KNOWN(name));

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17847.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17847.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-bug17847.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,101 @@
+diff -up tcp_wrappers_7.6/hosts_access.5.patch6 tcp_wrappers_7.6/hosts_access.5
+--- tcp_wrappers_7.6/hosts_access.5.patch6	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.5	2008-08-29 09:45:12.000000000 +0200
+@@ -96,6 +96,10 @@ or address pattern listed in the named f
+ zero or more lines with zero or more host name or address patterns
+ separated by whitespace.  A file name pattern can be used anywhere
+ a host name or address pattern can be used.
++.IP \(bu
++Wildcards `*\' and `?\' can be used to match hostnames or IP addresses.  This
++method of matching cannot be used in conjunction with `net/mask\' matching,
++hostname matching beginning with `.\' or IP address matching ending with `.\'.
+ .SH WILDCARDS
+ The access control language supports explicit wildcards:
+ .IP ALL
+diff -up tcp_wrappers_7.6/hosts_access.c.patch6 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch6	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -311,6 +311,11 @@ char   *string;
+ {
+     int     n;
+ 
++#ifndef DISABLE_WILDCARD_MATCHING
++    if (strchr(tok, '*') || strchr(tok,'?')) {  /* contains '*' or '?' */
++        return (match_pattern_ylo(string,tok)); 	       
++    } else 
++#endif    
+     if (tok[0] == '.') {			/* suffix */
+ 	n = strlen(string) - strlen(tok);
+ 	return (n &gt; 0 &amp;&amp; STR_EQ(tok, string + n));
+@@ -351,3 +356,71 @@ char   *string;
+     }
+     return ((addr &amp; mask) == net);
+ }
++
++#ifndef DISABLE_WILDCARD_MATCHING
++/* Note: this feature has been adapted in a pretty straightforward way
++   from Tatu Ylonen's last SSH version under free license by 
++   Pekka Savola &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pekkas at netcore.fi</A>&gt;.
++
++   Copyright (c) 1995 Tatu Ylonen &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ylo at cs.hut.fi</A>&gt;, Espoo, Finland
++*/
++
++/* Returns true if the given string matches the pattern (which may contain
++   ? and * as wildcards), and zero if it does not match. */
++	  
++int match_pattern_ylo(const char *s, const char *pattern)
++{
++  while (1)
++    {
++      /* If at end of pattern, accept if also at end of string. */
++      if (!*pattern)
++        return !*s;
++
++      /* Process '*'. */
++      if (*pattern == '*')
++        {
++	  /* Skip the asterisk. */
++	  pattern++;
++
++	  /* If at end of pattern, accept immediately. */
++          if (!*pattern)
++            return 1;
++
++	  /* If next character in pattern is known, optimize. */
++          if (*pattern != '?' &amp;&amp; *pattern != '*')
++            {
++	      /* Look instances of the next character in pattern, and try
++		 to match starting from those. */
++              for (; *s; s++)
++                if (*s == *pattern &amp;&amp;
++                    match_pattern_ylo(s + 1, pattern + 1))
++                  return 1;
++	      /* Failed. */
++              return 0;
++            }
++
++	  /* Move ahead one character at a time and try to match at each
++	     position. */
++          for (; *s; s++)
++            if (match_pattern_ylo(s, pattern))
++              return 1;
++	  /* Failed. */
++          return 0;
++        }
++
++      /* There must be at least one more character in the string.  If we are
++	 at the end, fail. */
++      if (!*s)
++        return 0;
++
++      /* Check if the next character of the string is acceptable. */
++      if (*pattern != '?' &amp;&amp; *pattern != *s)
++	return 0;
++      
++      /* Move to the next character, both in string and in pattern. */
++      s++;
++      pattern++;
++    }
++  /*NOTREACHED*/
++}
++#endif /* DISABLE_WILDCARD_MATCHING */

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-docu.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-docu.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-docu.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,12 @@
+diff -up tcp_wrappers_7.6/hosts_access.5.patch8 tcp_wrappers_7.6/hosts_access.5
+--- tcp_wrappers_7.6/hosts_access.5.patch8	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.5	2008-08-29 09:45:12.000000000 +0200
+@@ -333,7 +333,7 @@ in.tftpd: LOCAL, .my.domain
+ /etc/hosts.deny:
+ .in +3
+ .nf
+-in.tftpd: ALL: (/some/where/safe_finger -l @%h | \\
++in.tftpd: ALL: spawn (/some/where/safe_finger -l @%h | \\
+ 	/usr/ucb/mail -s %d-%h root) &amp;
+ .fi
+ .PP

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fix_sig-bug141110.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fix_sig-bug141110.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fix_sig-bug141110.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,21 @@
+diff -up tcp_wrappers_7.6/hosts_access.c.patch15 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch15	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -127,7 +127,7 @@ struct request_info *request;
+     verdict = setjmp(tcpd_buf);
+     if (verdict != 0)
+ 	return (verdict == AC_PERMIT);
+-    if (table_match(hosts_allow_table, request))
++    if (table_match(hosts_allow_table, request) == YES)
+ 	return (YES);
+     if (table_match(hosts_deny_table, request) == NO)
+ 	return (YES);
+@@ -177,7 +177,7 @@ struct request_info *request;
+ 	tcpd_warn(&quot;cannot open %s: %m&quot;, table);
+ 	match = ERR;
+     }
+-    if (match) {
++    if (match == YES) {
+ 	if (hosts_access_verbose &gt; 1)
+ 	    syslog(LOG_DEBUG, &quot;matched:  %s line %d&quot;,
+ 		   tcpd_context.file, tcpd_context.line);

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fixgethostbyname.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fixgethostbyname.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-fixgethostbyname.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,28 @@
+diff -up tcp_wrappers_7.6/socket.c.patch7 tcp_wrappers_7.6/socket.c
+--- tcp_wrappers_7.6/socket.c.patch7	1997-03-21 19:27:25.000000000 +0100
++++ tcp_wrappers_7.6/socket.c	2008-08-29 09:45:12.000000000 +0200
+@@ -52,7 +52,8 @@ static struct hostent *gethostbyname_dot
+ char   *name;
+ {
+     char    dot_name[MAXHOSTNAMELEN + 1];
+-
++    struct hostent *hp;
++    
+     /*
+      * Don't append dots to unqualified names. Such names are likely to come
+      * from local hosts files or from NIS.
+@@ -61,8 +62,12 @@ char   *name;
+     if (strchr(name, '.') == 0 || strlen(name) &gt;= MAXHOSTNAMELEN - 1) {
+ 	return (gethostbyname(name));
+     } else {
+-	sprintf(dot_name, &quot;%s.&quot;, name);
+-	return (gethostbyname(dot_name));
++        sprintf(dot_name, &quot;%s.&quot;, name);
++        hp = gethostbyname(dot_name);
++	if (hp)
++	    return hp;
++	else
++	    return (gethostbyname(name));
+     }
+ }
+ 

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-ldflags.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-ldflags.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-ldflags.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,36 @@
+diff -up tcp_wrappers_7.6/Makefile.patch14 tcp_wrappers_7.6/Makefile
+--- tcp_wrappers_7.6/Makefile.patch14	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/Makefile	2008-08-29 09:45:12.000000000 +0200
+@@ -732,26 +732,26 @@ $(SHLIB): $(LIB_OBJ)
+ 	ln -s $(SHLIB).$(MAJOR).$(MINOR).$(REL) $(SHLIB)
+ 
+ tcpd:	tcpd.o $(LIB)
+-	$(CC) $(CFLAGS) -o $@ tcpd.o $(LIB) $(LIBS)
++	$(CC) $(CFLAGS) -o $@ tcpd.o $(LDFLAGS) $(LIB) $(LIBS)
+ 
+ miscd:	miscd.o $(LIB)
+-	$(CC) $(CFLAGS) -o $@ miscd.o $(LIB) $(LIBS)
++	$(CC) $(CFLAGS) -o $@ miscd.o $(LDFLAGS) $(LIB) $(LIBS)
+ 
+ safe_finger: safe_finger.o $(LIB)
+-	$(CC) $(CFLAGS) -o $@ safe_finger.o $(LIB) $(LIBS)
++	$(CC) $(CFLAGS) -o $@ safe_finger.o $(LDFLAGS) $(LIB) $(LIBS)
+ 
+ TCPDMATCH_OBJ = tcpdmatch.o fakelog.o inetcf.o scaffold.o
+ 
+ tcpdmatch: $(TCPDMATCH_OBJ) $(LIB)
+-	$(CC) $(CFLAGS) -o $@ $(TCPDMATCH_OBJ) $(LIB) $(LIBS)
++	$(CC) $(CFLAGS) -o $@ $(TCPDMATCH_OBJ) $(LDFLAGS) $(LIB) $(LIBS)
+ 
+ try-from: try-from.o fakelog.o $(LIB)
+-	$(CC) $(CFLAGS) -o $@ try-from.o fakelog.o $(LIB) $(LIBS)
++	$(CC) $(CFLAGS) -o $@ try-from.o fakelog.o $(LDFLAGS) $(LIB) $(LIBS)
+ 
+ TCPDCHK_OBJ = tcpdchk.o fakelog.o inetcf.o scaffold.o
+ 
+ tcpdchk: $(TCPDCHK_OBJ) $(LIB)
+-	$(CC) $(CFLAGS) -o $@ $(TCPDCHK_OBJ) $(LIB) $(LIBS)
++	$(CC) $(CFLAGS) -o $@ $(TCPDCHK_OBJ) $(LDFLAGS) $(LIB) $(LIBS)
+ 
+ shar:	$(KIT)
+ 	@shar $(KIT)

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-restore_sigalarm.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-restore_sigalarm.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-restore_sigalarm.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,37 @@
+diff -up tcp_wrappers_7.6/rfc931.c.patch18 tcp_wrappers_7.6/rfc931.c
+--- tcp_wrappers_7.6/rfc931.c.patch18	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/rfc931.c	2008-08-29 09:45:12.000000000 +0200
+@@ -92,6 +92,8 @@ char   *dest;
+     char   *cp;
+     char   *result = unknown;
+     FILE   *fp;
++    unsigned saved_timeout;
++    struct sigaction nact, oact;
+ 
+ #ifdef INET6
+     /* address family must be the same */
+@@ -134,7 +136,12 @@ char   *dest;
+ 	 */
+ 
+ 	if (setjmp(timebuf) == 0) {
+-	    signal(SIGALRM, timeout);
++	    /* Save SIGALRM timer and handler. Sudheer Abdul-Salam, SUN. */
++	    saved_timeout = alarm(0);
++	    nact.sa_handler = timeout;
++	    nact.sa_flags = 0;
++	    (void) sigemptyset(&amp;nact.sa_mask);
++	    (void) sigaction(SIGALRM, &amp;nact, &amp;oact);
+ 	    alarm(rfc931_timeout);
+ 
+ 	    /*
+@@ -223,6 +230,10 @@ char   *dest;
+ 	    }
+ 	    alarm(0);
+ 	}
++	/* Restore SIGALRM timer and handler. Sudheer Abdul-Salam, SUN. */
++	(void) sigaction(SIGALRM, &amp;oact, NULL);
++	if (saved_timeout &gt; 0)
++	    alarm(saved_timeout);
+ 	fclose(fp);
+     }
+     STRN_CPY(dest, result, STRING_LENGTH);

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-shared.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-shared.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-shared.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,256 @@
+diff -up tcp_wrappers_7.6/Makefile.patch11 tcp_wrappers_7.6/Makefile
+--- tcp_wrappers_7.6/Makefile.patch11	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/Makefile	2008-08-29 09:45:12.000000000 +0200
+@@ -150,8 +150,8 @@ netbsd:
+ 
+ linux:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+-	LIBS=&quot;-lnsl&quot; RANLIB=ranlib ARFLAGS=rv AUX_OBJ= \
+-	NETGROUP=&quot;-DNETGROUP&quot; TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER -DINET6=1 -Dss_family=__ss_family -Dss_len=__ss_len&quot; all
++	LIBS=&quot;-lnsl&quot; RANLIB=ranlib ARFLAGS=rv AUX_OBJ=weak_symbols.o \
++	NETGROUP=&quot;-DNETGROUP&quot; TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS)  -fPIC -DPIC -D_REENTRANT -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER -DINET6=1 -Dss_family=__ss_family -Dss_len=__ss_len -DHAVE_WEAKSYMS&quot; all
+ 
+ linux-old:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+@@ -249,7 +249,7 @@ tandem:
+ 
+ # Amdahl UTS 2.1.5 (<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Richard.Richmond at bridge.bst.bls.com</A>)
+ uts215:
+-	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \   
++	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+ 	LIBS=&quot;-lsocket&quot; RANLIB=echo \
+ 	ARFLAGS=rv AUX_OBJ=setenv.o NETGROUP=-DNO_NETGROUP TLI= all
+ 
+@@ -706,8 +706,9 @@ KIT	= README miscd.c tcpd.c fromhost.c h
+ 	scaffold.h tcpdmatch.8 README.NIS
+ 
+ LIB	= libwrap.a
++SHLIB 	= libwrap.so
+ 
+-all other: config-check tcpd tcpdmatch try-from safe_finger tcpdchk
++all other: config-check tcpd tcpdmatch try-from safe_finger tcpdchk $(SHLIB)
+ 
+ # Invalidate all object files when the compiler options (CFLAGS) have changed.
+ 
+@@ -724,6 +725,12 @@ $(LIB):	$(LIB_OBJ)
+ 	$(AR) $(ARFLAGS) $(LIB) $(LIB_OBJ)
+ 	-$(RANLIB) $(LIB)
+ 
++$(SHLIB): $(LIB_OBJ)
++	gcc -shared -fPIC -Wl,-soname -Wl,$(SHLIB).$(MAJOR) \
++		-o $(SHLIB).$(MAJOR).$(MINOR).$(REL) $^ $(LIBS)
++	ln -s $(SHLIB).$(MAJOR).$(MINOR).$(REL) $(SHLIB).$(MAJOR)
++	ln -s $(SHLIB).$(MAJOR).$(MINOR).$(REL) $(SHLIB)
++
+ tcpd:	tcpd.o $(LIB)
+ 	$(CC) $(CFLAGS) -o $@ tcpd.o $(LIB) $(LIBS)
+ 
+@@ -906,5 +913,6 @@ update.o: cflags
+ update.o: mystdarg.h
+ update.o: tcpd.h
+ vfprintf.o: cflags
++weak_symbols.o: tcpd.h
+ workarounds.o: cflags
+ workarounds.o: tcpd.h
+diff -up tcp_wrappers_7.6/scaffold.c.patch11 tcp_wrappers_7.6/scaffold.c
+--- tcp_wrappers_7.6/scaffold.c.patch11	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/scaffold.c	2008-08-29 09:45:12.000000000 +0200
+@@ -237,10 +237,17 @@ struct request_info *request;
+ 
+ /* ARGSUSED */
+ 
+-void    rfc931(request)
+-struct request_info *request;
++void    rfc931(rmt_sin, our_sin, dest)
++#ifndef INET6
++struct sockaddr_in *rmt_sin;
++struct sockaddr_in *our_sin;
++#else
++struct sockaddr *rmt_sin;
++struct sockaddr *our_sin;
++#endif
++char   *dest;
+ {
+-    strcpy(request-&gt;user, unknown);
++    strcpy(dest, unknown);
+ }
+ 
+ /* check_path - examine accessibility */
+diff -up tcp_wrappers_7.6/tcpd.h.patch11 tcp_wrappers_7.6/tcpd.h
+--- tcp_wrappers_7.6/tcpd.h.patch11	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/tcpd.h	2008-08-29 09:45:12.000000000 +0200
+@@ -4,6 +4,25 @@
+   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
+   */
+ 
++#ifndef _TCPWRAPPERS_TCPD_H
++#define _TCPWRAPPERS_TCPD_H
++
++/* someone else may have defined this */
++#undef  __P
++
++/* use prototypes if we have an ANSI C compiler or are using C++ */
++#if defined(__STDC__) || defined(__cplusplus)
++#define __P(args)       args
++#else
++#define __P(args)       ()
++#endif
++
++/* Need definitions of struct sockaddr_in and FILE. */
++#include &lt;netinet/in.h&gt;
++#include &lt;stdio.h&gt;
++
++__BEGIN_DECLS
++
+ /* Structure to describe one communications endpoint. */
+ 
+ #define STRING_LENGTH	128		/* hosts, users, processes */
+@@ -29,10 +48,10 @@ struct request_info {
+     char    pid[10];			/* access via eval_pid(request) */
+     struct host_info client[1];		/* client endpoint info */
+     struct host_info server[1];		/* server endpoint info */
+-    void  (*sink) ();			/* datagram sink function or 0 */
+-    void  (*hostname) ();		/* address to printable hostname */
+-    void  (*hostaddr) ();		/* address to printable address */
+-    void  (*cleanup) ();		/* cleanup function or 0 */
++    void  (*sink) __P((int));		/* datagram sink function or 0 */
++    void  (*hostname) __P((struct host_info *)); /* address to printable hostname */
++    void  (*hostaddr) __P((struct host_info *)); /* address to printable address */
++    void  (*cleanup) __P((struct request_info *)); /* cleanup function or 0 */
+     struct netconfig *config;		/* netdir handle */
+ };
+ 
+@@ -65,25 +84,34 @@ extern char paranoid[];
+ /* Global functions. */
+ 
+ #if defined(TLI) || defined(PTX) || defined(TLI_SEQUENT)
+-extern void fromhost();			/* get/validate client host info */
++extern void fromhost __P((struct request_info *));	/* get/validate client host info */
+ #else
+ #define fromhost sock_host		/* no TLI support needed */
+ #endif
+ 
+-extern int hosts_access();		/* access control */
+-extern void shell_cmd();		/* execute shell command */
+-extern char *percent_x();		/* do %&lt;char&gt; expansion */
+-extern void rfc931();			/* client name from RFC 931 daemon */
+-extern void clean_exit();		/* clean up and exit */
+-extern void refuse();			/* clean up and exit */
+-extern char *xgets();			/* fgets() on steroids */
+-extern char *split_at();		/* strchr() and split */
+-extern unsigned long dot_quad_addr();	/* restricted inet_addr() */
++extern void shell_cmd __P((char *));	/* execute shell command */
++extern char *percent_x __P((char *, int, char *, struct request_info *)); /* do %&lt;char&gt; expansion */
++#ifdef INET6
++extern void rfc931 __P((struct sockaddr *, struct sockaddr *, char *)); /* client name from RFC 931 daemon */
++#else
++extern void rfc931 __P((struct sockaddr_in *, struct sockaddr_in *, char *)); /* client name from RFC 931 daemon */
++#endif
++extern void clean_exit __P((struct request_info *)); /* clean up and exit */
++extern void refuse __P((struct request_info *));	/* clean up and exit */
++extern char *xgets __P((char *, int, FILE *));	/* fgets() on steroids */
++extern char *split_at __P((char *, int));	/* strchr() and split */
++extern unsigned long dot_quad_addr __P((char *)); /* restricted inet_addr() */
+ 
+ /* Global variables. */
+ 
++#ifdef HAVE_WEAKSYMS
++extern int allow_severity __attribute__ ((weak)); /* for connection logging */
++extern int deny_severity __attribute__ ((weak)); /* for connection logging */
++#else
+ extern int allow_severity;		/* for connection logging */
+ extern int deny_severity;		/* for connection logging */
++#endif
++
+ extern char *hosts_allow_table;		/* for verification mode redirection */
+ extern char *hosts_deny_table;		/* for verification mode redirection */
+ extern int hosts_access_verbose;	/* for verbose matching mode */
+@@ -96,9 +124,14 @@ extern int resident;			/* &gt; 0 if residen
+   */
+ 
+ #ifdef __STDC__
++extern int hosts_access(struct request_info *request);
++extern int hosts_ctl(char *daemon, char *client_name, char *client_addr, 
++                     char *client_user);
+ extern struct request_info *request_init(struct request_info *,...);
+ extern struct request_info *request_set(struct request_info *,...);
+ #else
++extern int hosts_access();
++extern int hosts_ctl();
+ extern struct request_info *request_init();	/* initialize request */
+ extern struct request_info *request_set();	/* update request structure */
+ #endif
+@@ -121,27 +154,31 @@ extern struct request_info *request_set(
+   * host_info structures serve as caches for the lookup results.
+   */
+ 
+-extern char *eval_user();		/* client user */
+-extern char *eval_hostname();		/* printable hostname */
+-extern char *eval_hostaddr();		/* printable host address */
+-extern char *eval_hostinfo();		/* host name or address */
+-extern char *eval_client();		/* whatever is available */
+-extern char *eval_server();		/* whatever is available */
++extern char *eval_user __P((struct request_info *));	/* client user */
++extern char *eval_hostname __P((struct host_info *));	/* printable hostname */
++extern char *eval_hostaddr __P((struct host_info *));	/* printable host address */
++extern char *eval_hostinfo __P((struct host_info *));	/* host name or address */
++extern char *eval_client __P((struct request_info *));	/* whatever is available */
++extern char *eval_server __P((struct request_info *));	/* whatever is available */
+ #define eval_daemon(r)	((r)-&gt;daemon)	/* daemon process name */
+ #define eval_pid(r)	((r)-&gt;pid)	/* process id */
+ 
+ /* Socket-specific methods, including DNS hostname lookups. */
+ 
+-extern void sock_host();		/* look up endpoint addresses */
+-extern void sock_hostname();		/* translate address to hostname */
+-extern void sock_hostaddr();		/* address to printable address */
++/* look up endpoint addresses */
++extern void sock_host __P((struct request_info *));
++/* translate address to hostname */
++extern void sock_hostname __P((struct host_info *));
++/* address to printable address */
++extern void sock_hostaddr __P((struct host_info *));
++
+ #define sock_methods(r) \
+ 	{ (r)-&gt;hostname = sock_hostname; (r)-&gt;hostaddr = sock_hostaddr; }
+ 
+ /* The System V Transport-Level Interface (TLI) interface. */
+ 
+ #if defined(TLI) || defined(PTX) || defined(TLI_SEQUENT)
+-extern void tli_host();			/* look up endpoint addresses etc. */
++extern void tli_host __P((struct request_info *));	/* look up endpoint addresses etc. */
+ #endif
+ 
+  /*
+@@ -182,7 +219,7 @@ extern struct tcpd_context tcpd_context;
+   * behavior.
+   */
+ 
+-extern void process_options();		/* execute options */
++extern void process_options __P((char *, struct request_info *)); /* execute options */
+ extern int dry_run;			/* verification flag */
+ 
+ /* Bug workarounds. */
+@@ -221,3 +258,7 @@ extern char *fix_strtok();
+ #define strtok	my_strtok
+ extern char *my_strtok();
+ #endif
++
++__END_DECLS
++
++#endif /* tcpd.h */
+diff -up /dev/null tcp_wrappers_7.6/weak_symbols.c
+--- /dev/null	2008-08-29 10:35:15.589003986 +0200
++++ tcp_wrappers_7.6/weak_symbols.c	2008-08-29 09:45:12.000000000 +0200
+@@ -0,0 +1,11 @@
++ /*
++  * @(#) weak_symbols.h 1.5 99/12/29 23:50
++  * 
++  * Author: Anthony Towns &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ajt at debian.org</A>&gt;
++  */
++
++#ifdef HAVE_WEAKSYMS
++#include &lt;syslog.h&gt;
++int deny_severity = LOG_WARNING;
++int allow_severity = SEVERITY; 
++#endif

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sig.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sig.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sig.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,40 @@
+diff -up tcp_wrappers_7.6/hosts_access.c.patch12 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch12	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -66,6 +66,7 @@ static char sep[] = &quot;, \t\r\n&quot;;
+ 
+ #define	YES		1
+ #define	NO		0
++#define ERR             -1
+ 
+  /*
+   * These variables are globally visible so that they can be redirected in
+@@ -106,7 +107,6 @@ int     hosts_access(request)
+ struct request_info *request;
+ {
+     int     verdict;
+-
+     /*
+      * If the (daemon, client) pair is matched by an entry in the file
+      * /etc/hosts.allow, access is granted. Otherwise, if the (daemon,
+@@ -129,9 +129,9 @@ struct request_info *request;
+ 	return (verdict == AC_PERMIT);
+     if (table_match(hosts_allow_table, request))
+ 	return (YES);
+-    if (table_match(hosts_deny_table, request))
+-	return (NO);
+-    return (YES);
++    if (table_match(hosts_deny_table, request) == NO)
++	return (YES);
++    return (NO);
+ }
+ 
+ /* table_match - match table entries with (daemon, client) pair */
+@@ -175,6 +175,7 @@ struct request_info *request;
+ 	(void) fclose(fp);
+     } else if (errno != ENOENT) {
+ 	tcpd_warn(&quot;cannot open %s: %m&quot;, table);
++	match = ERR;
+     }
+     if (match) {
+ 	if (hosts_access_verbose &gt; 1)

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sigchld.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sigchld.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-sigchld.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,88 @@
+diff -up tcp_wrappers_7.6/shell_cmd.c.patch20 tcp_wrappers_7.6/shell_cmd.c
+--- tcp_wrappers_7.6/shell_cmd.c.patch20	1994-12-28 17:42:44.000000000 +0100
++++ tcp_wrappers_7.6/shell_cmd.c	2008-08-29 09:45:12.000000000 +0200
+@@ -20,6 +20,11 @@ static char sccsid[] = &quot;@(#) shell_cmd.c
+ #include &lt;stdio.h&gt;
+ #include &lt;syslog.h&gt;
+ #include &lt;string.h&gt;
++#include &lt;errno.h&gt;
++#include &lt;unistd.h&gt;
++#include &lt;sys/wait.h&gt;
++#include &lt;sys/stat.h&gt;
++#include &lt;fcntl.h&gt;
+ 
+ extern void exit();
+ 
+@@ -31,13 +36,42 @@ extern void exit();
+ 
+ static void do_child();
+ 
++/*
++ * The sigchld handler. If there is a SIGCHLD caused by a child other than
++ * ours, we set a flag and raise the signal later.
++ */
++volatile static int foreign_sigchld;
++volatile static int our_child_pid;
++static void sigchld(int sig, siginfo_t *si, void *unused)
++{
++    if (si &amp;&amp; si-&gt;si_pid != our_child_pid)
++	foreign_sigchld = 1;
++}
++
+ /* shell_cmd - execute shell command */
+ 
+ void    shell_cmd(command)
+ char   *command;
+ {
+     int     child_pid;
+-    int     wait_pid;
++
++    struct sigaction new_action, old_action;
++    sigset_t new_mask, old_mask, empty_mask;
++
++    new_action.sa_sigaction = &amp;sigchld;
++    new_action.sa_flags = SA_SIGINFO;
++    sigemptyset(&amp;new_action.sa_mask);
++    sigemptyset(&amp;new_mask);
++    sigemptyset(&amp;empty_mask);
++    sigaddset(&amp;new_mask, SIGCHLD);
++
++    /*
++     * Set the variables for handler, set the handler and block the signal
++     * until we have the pid.
++     */
++    foreign_sigchld = 0; our_child_pid = 0;
++    sigprocmask(SIG_BLOCK, &amp;new_mask, &amp;old_mask);
++    sigaction(SIGCHLD, &amp;new_action, &amp;old_action);
+ 
+     /*
+      * Most of the work is done within the child process, to minimize the
+@@ -49,12 +83,26 @@ char   *command;
+ 	tcpd_warn(&quot;cannot fork: %m&quot;);
+ 	break;
+     case 00:					/* child */
++	/* Clear the blocked mask for the child not to be surprised. */
++	sigprocmask(SIG_SETMASK, &amp;empty_mask, 0);
+ 	do_child(command);
+ 	/* NOTREACHED */
+     default:					/* parent */
+-	while ((wait_pid = wait((int *) 0)) != -1 &amp;&amp; wait_pid != child_pid)
+-	     /* void */ ;
++	our_child_pid = child_pid;
++	sigprocmask(SIG_UNBLOCK, &amp;new_mask, 0);
++	while (waitpid(child_pid, (int *) 0, 0) == -1 &amp;&amp; errno == EINTR);
+     }
++
++    /*
++     * Revert the signal mask and the SIGCHLD handler.
++     */
++    sigprocmask(SIG_SETMASK, &amp;old_mask, 0);
++    sigaction(SIGCHLD, &amp;old_action, 0);
++
++    /* If there was a foreign SIGCHLD, raise it after we have restored the old
++     * mask and handler. */
++    if (foreign_sigchld)
++	raise(SIGCHLD);
+ }
+ 
+ /* do_child - exec command with { stdin, stdout, stderr } to /dev/null */

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-siglongjmp.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-siglongjmp.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-siglongjmp.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,30 @@
+diff -up tcp_wrappers_7.6/rfc931.c.patch19 tcp_wrappers_7.6/rfc931.c
+--- tcp_wrappers_7.6/rfc931.c.patch19	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/rfc931.c	2008-08-29 09:45:12.000000000 +0200
+@@ -33,7 +33,7 @@ static char sccsid[] = &quot;@(#) rfc931.c 1.
+ 
+ int     rfc931_timeout = RFC931_TIMEOUT;/* Global so it can be changed */
+ 
+-static jmp_buf timebuf;
++static sigjmp_buf timebuf;
+ 
+ /* fsocket - open stdio stream on top of socket */
+ 
+@@ -62,7 +62,7 @@ int     protocol;
+ static void timeout(sig)
+ int     sig;
+ {
+-    longjmp(timebuf, sig);
++    siglongjmp(timebuf, sig);
+ }
+ 
+ /* rfc931 - return remote user name, given socket structures */
+@@ -135,7 +135,7 @@ char   *dest;
+ 	 * Set up a timer so we won't get stuck while waiting for the server.
+ 	 */
+ 
+-	if (setjmp(timebuf) == 0) {
++	if (sigsetjmp(timebuf, 1) == 0) {
+ 	    /* Save SIGALRM timer and handler. Sudheer Abdul-Salam, SUN. */
+ 	    saved_timeout = alarm(0);
+ 	    nact.sa_handler = timeout;

Added: trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-strerror.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-strerror.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers-7.6-strerror.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,28 @@
+diff -up tcp_wrappers_7.6/percent_m.c.patch13 tcp_wrappers_7.6/percent_m.c
+--- tcp_wrappers_7.6/percent_m.c.patch13	1994-12-28 17:42:37.000000000 +0100
++++ tcp_wrappers_7.6/percent_m.c	2008-08-29 09:45:12.000000000 +0200
+@@ -13,7 +13,7 @@ static char sccsid[] = &quot;@(#) percent_m.c
+ #include &lt;string.h&gt;
+ 
+ extern int errno;
+-#ifndef SYS_ERRLIST_DEFINED
++#if !defined(SYS_ERRLIST_DEFINED) &amp;&amp; !defined(HAVE_STRERROR)
+ extern char *sys_errlist[];
+ extern int sys_nerr;
+ #endif
+@@ -29,11 +29,15 @@ char   *ibuf;
+ 
+     while (*bp = *cp)
+ 	if (*cp == '%' &amp;&amp; cp[1] == 'm') {
++#ifdef HAVE_STRERROR
++            strcpy(bp, strerror(errno));
++#else
+ 	    if (errno &lt; sys_nerr &amp;&amp; errno &gt; 0) {
+ 		strcpy(bp, sys_errlist[errno]);
+ 	    } else {
+ 		sprintf(bp, &quot;Unknown error %d&quot;, errno);
+ 	    }
++#endif
+ 	    bp += strlen(bp);
+ 	    cp += 2;
+ 	} else {

Added: trunk/rpms/tcp_wrappers/tcp_wrappers.spec
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers.spec	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers.spec	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,365 @@
+# $Id$
+# Authority: yury
+# Upstream: Wietse Venema &lt;wietse$wzv,win,tue,nl&gt;
+
+Summary: A security tool which acts as a wrapper for TCP daemons
+Name: tcp_wrappers
+Version: 7.6
+Release: 57%{?dist}
+
+%define LIB_MAJOR 0
+%define LIB_MINOR 7
+%define LIB_REL 6
+
+License: BSD
+Group: System Environment/Daemons
+Source: <A HREF="ftp://ftp.porcupine.org/pub/security/%{name">ftp://ftp.porcupine.org/pub/security/%{name</A>}_%{version}.tar.gz
+URL: <A HREF="ftp://ftp.porcupine.org/pub/security/index.html">ftp://ftp.porcupine.org/pub/security/index.html</A>
+Patch0: tcpw7.2-config.patch
+Patch1: tcpw7.2-setenv.patch
+Patch2: tcpw7.6-netgroup.patch
+Patch3: tcp_wrappers-7.6-bug11881.patch
+Patch4: tcp_wrappers-7.6-bug17795.patch
+Patch5: tcp_wrappers-7.6-bug17847.patch
+Patch6: tcp_wrappers-7.6-fixgethostbyname.patch
+Patch7: tcp_wrappers-7.6-docu.patch
+Patch9: tcp_wrappers.usagi-ipv6.patch
+Patch10: tcp_wrappers.ume-ipv6.patch
+Patch11: tcp_wrappers-7.6-shared.patch
+Patch12: tcp_wrappers-7.6-sig.patch
+Patch13: tcp_wrappers-7.6-strerror.patch
+Patch14: tcp_wrappers-7.6-ldflags.patch
+Patch15: tcp_wrappers-7.6-fix_sig-bug141110.patch
+Patch16: tcp_wrappers-7.6-162412.patch
+Patch17: tcp_wrappers-7.6-220015.patch
+Patch18: tcp_wrappers-7.6-restore_sigalarm.patch
+Patch19: tcp_wrappers-7.6-siglongjmp.patch
+Patch20: tcp_wrappers-7.6-sigchld.patch
+Patch21: tcp_wrappers-7.6-196326.patch
+Patch22: tcp_wrappers_7.6-249430.patch
+# required by sin_scope_id in ipv6 patch
+BuildRequires: glibc-devel &gt;= 2.2
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+Requires: tcp_wrappers-libs = %{version}-%{release}
+Obsoletes: tcp_wrappers &lt; 7.6-41
+
+%description
+The tcp_wrappers package provides small daemon programs which can
+monitor and filter incoming requests for systat, finger, FTP, telnet,
+rlogin, rsh, exec, tftp, talk and other network services.
+
+Install the tcp_wrappers program if you need a security tool for
+filtering incoming network services requests.
+
+This version also supports IPv6.
+
+%package libs
+Summary: tcp_wrappers libraries
+Group: System Environment/Libraries
+Obsoletes: tcp_wrappers &lt; 7.6-41
+
+%description libs
+tcp_wrappers-libs contains the libraries of the tcp_wrappers package.
+
+%package devel
+Summary: tcp_wrappers development libraries and headers
+Group: Development/Libraries
+Obsoletes: tcp_wrappers &lt; 7.6-41
+Requires: tcp_wrappers-libs = %{version}-%{release}
+
+%description devel
+tcp_wrappers-devel contains the libraries and header files needed to
+develop applications with tcp_wrappers support.
+
+%prep
+%setup -q -n %{name}_%{version}
+%patch0 -p1 -b .config
+%patch1 -p1 -b .setenv
+%patch2 -p1 -b .netgroup
+%patch3 -p1 -b .bug11881
+%patch4 -p1 -b .bug17795
+%patch5 -p1 -b .bug17847
+%patch6 -p1 -b .fixgethostbyname
+%patch7 -p1 -b .docu
+%patch9 -p1 -b .usagi-ipv6
+%patch10 -p1 -b .ume-ipv6
+%patch11 -p1 -b .shared
+%patch12 -p1 -b .sig
+%patch13 -p1 -b .strerror
+%patch14 -p1 -b .cflags
+%patch15 -p1 -b .fix_sig
+%patch16 -p1 -b .162412
+%patch17 -p1 -b .220015
+%patch18 -p1 -b .restore_sigalarm
+%patch19 -p1 -b .siglongjmp
+%patch20 -p1 -b .sigchld
+%patch21 -p1 -b .196326
+%patch22 -p1 -b .249430
+
+%build
+make RPM_OPT_FLAGS=&quot;$RPM_OPT_FLAGS -fPIC -DPIC -D_REENTRANT -DHAVE_STRERROR&quot; LDFLAGS=&quot;-pie&quot; MAJOR=%{LIB_MAJOR} MINOR=%{LIB_MINOR} REL=%{LIB_REL} linux
+
+
+%install
+rm -rf ${RPM_BUILD_ROOT}
+mkdir -p ${RPM_BUILD_ROOT}%{_includedir}
+mkdir -p ${RPM_BUILD_ROOT}/%{_lib}
+mkdir -p ${RPM_BUILD_ROOT}%{_mandir}/man{3,5,8}
+mkdir -p ${RPM_BUILD_ROOT}%{_sbindir}
+
+install -p -m644 hosts_access.3 ${RPM_BUILD_ROOT}%{_mandir}/man3
+install -p -m644 hosts_access.5 hosts_options.5 ${RPM_BUILD_ROOT}%{_mandir}/man5
+install -p -m644 tcpd.8 tcpdchk.8 tcpdmatch.8 ${RPM_BUILD_ROOT}%{_mandir}/man8
+ln -sf hosts_access.5 ${RPM_BUILD_ROOT}%{_mandir}/man5/hosts.allow.5
+ln -sf hosts_access.5 ${RPM_BUILD_ROOT}%{_mandir}/man5/hosts.deny.5
+#cp -a libwrap.a ${RPM_BUILD_ROOT}%{_libdir}
+cp -a libwrap.so* ${RPM_BUILD_ROOT}/%{_lib}
+install -p -m644 tcpd.h ${RPM_BUILD_ROOT}%{_includedir}
+install -m755 safe_finger ${RPM_BUILD_ROOT}%{_sbindir}
+install -m755 tcpd ${RPM_BUILD_ROOT}%{_sbindir}
+install -m755 try-from ${RPM_BUILD_ROOT}%{_sbindir}
+
+# XXX remove utilities that expect /etc/inetd.conf (#16059).
+#install -m755 tcpdchk ${RPM_BUILD_ROOT}%{_sbindir}
+#install -m755 tcpdmatch ${RPM_BUILD_ROOT}%{_sbindir}
+rm -f ${RPM_BUILD_ROOT}%{_mandir}/man8/tcpdmatch.*
+rm -f ${RPM_BUILD_ROOT}%{_mandir}/man8/tcpdchk.*
+
+%post libs -p /sbin/ldconfig
+
+%postun libs -p /sbin/ldconfig
+
+%clean
+rm -rf ${RPM_BUILD_ROOT}
+
+%files
+%defattr(-,root,root,-)
+%doc BLURB CHANGES README* DISCLAIMER Banners.Makefile
+%{_sbindir}/*
+%{_mandir}/man8/*
+
+%files libs
+%defattr(-,root,root,-)
+%doc BLURB CHANGES README* DISCLAIMER Banners.Makefile
+/%{_lib}/*.so.*
+%{_mandir}/man5/*
+
+%files devel
+%defattr(-,root,root,-)
+%{_includedir}/*
+#%{_libdir}/*.a
+/%{_lib}/*.so
+%{_mandir}/man3/*
+
+%changelog
+* Fri Dec 25 2009 Yury V. Zaytsev &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">yury at shurup.com</A>&gt; - 7.6-57
+- Ported over RPMForge with minor changes.
+
+* Sun Jul 26 2009 Fedora Release Engineering &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">rel-eng at lists.fedoraproject.org</A>&gt; - 7.6-56
+- Rebuilt for <A HREF="https://fedoraproject.org/wiki/Fedora_12_Mass_Rebuild">https://fedoraproject.org/wiki/Fedora_12_Mass_Rebuild</A>
+
+* Tue Apr 14 2009 Jan F. Chadima &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jchadima at redhat.com</A>&gt; - 7.6-55
+- resolving addr when name == &quot;&quot; (repair of patch #220015)
+
+* Wed Feb 25 2009 Fedora Release Engineering &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">rel-eng at lists.fedoraproject.org</A>&gt; - 7.6-54
+- Rebuilt for <A HREF="https://fedoraproject.org/wiki/Fedora_11_Mass_Rebuild">https://fedoraproject.org/wiki/Fedora_11_Mass_Rebuild</A>
+
+* Fri Aug 29 2008 Jan Safranek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jsafranek at redhat.com</A>&gt; - 7.6-53
+- rediff all patches to get rid of patch fuzz
+
+* Wed Feb 20 2008 Fedora Release Engineering &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">rel-eng at fedoraproject.org</A>&gt; - 7.6-52
+- Autorebuild for GCC 4.3
+
+* Tue Oct 16 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-51
+- review changes
+
+* Fri Aug 24 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-50
+- license tag update (and rebuild for BuildID, etc.)
+- include docs in the -libs subpackage, as it is the only one installed on most
+  systems (and to comply with the license text)
+
+* Wed Jul 25 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-49
+- fix for a.b.c.d/255.255.255.255 - fixes #249430
+
+* Thu Jun 28 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-48
+- dropped the hostname resolving patch
+- resolve the address given to hosts_ctl to hostname, if hostname not given
+- compare localhost and localhost.localdomain as the same
+- fixed a few compile warnings
+
+* Wed Jun 06 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-47
+- fix the hostname resolving patch for x86_64
+
+* Mon May 28 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-46
+- modified the fix for #112975 to fix #156373 as well
+
+* Fri May 25 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-45
+- unblock and catch SIGCHLD from spawned shell commands, fixes #112975
+
+* Mon Apr 16 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-44
+- added restore_sigalarm and siglongjmp patches from Debian, fixes #205129
+
+* Fri Mar 09 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-43
+- resolve hostnames in hosts.{allow,deny}, should fix a bunch of issues with
+  IPv4/6
+
+* Thu Mar 08 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-42.1
+- moved libwrap.so* to /lib
+- removed the static library libwrap.a
+
+* Mon Mar 05 2007 Tomas Janousek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">tjanouse at redhat.com</A>&gt; - 7.6-42
+- added Obsoletes field so that the upgrade goes cleanly
+- added dist tag
+
+* Mon Dec  4 2006 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 7.6-41
+- moved devel libraries, headers and man pages into devel sub package (#193188)
+- new libs sub package for libraries
+- using BuildRequires instead of BuildPreReq
+
+* Wed Jul 12 2006 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt; - 7.6-40.2.1
+- rebuild
+
+* Fri Feb 10 2006 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt; - 7.6-40.2
+- bump again for double-long bug on ppc(64)
+
+* Tue Feb 07 2006 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt; - 7.6-40.1
+- rebuilt for new gcc4.1 snapshot and glibc changes
+
+* Tue Jan 24 2006 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 7.6-40
+- fixed uninitialized fp in function inet_cfg (#162412)
+
+* Fri Dec 09 2005 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt;
+- rebuilt
+
+* Fri May  6 2005 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 7.6-39
+- fixed sig patch (#141110). Thanks to Nikita Shulga for the patch
+
+* Wed Feb  9 2005 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 7.6-38
+- rebuild
+
+* Thu Oct  7 2004 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 7.6-37.2
+- new URL and spec file cleanup, patch from Robert Scheck
+
+* Mon Oct  4 2004 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 7.6-37.1
+- rebuilt
+
+* Tue Jun 15 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Fri Mar  5 2004 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 7.6-36
+- pied tcpd
+
+* Tue Mar 02 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Fri Feb 13 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Wed Jun 04 2003 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Sun Feb 16 2003 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- use strerror  #84312
+
+* Tue Feb 11 2003 Harald Hoyer &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">harald at redhat.de</A>&gt; 7.6-33
+- revert Nalins weak version
+- link libwrap.so against libnsl, on which it depends
+
+* Mon Feb 10 2003 Nalin Dahyabhai &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">nalin at redhat.com</A>&gt; 7.6-32
+- link libwrap.so against libnsl, on which it depends
+- add default (weak) versions of allow_severity and deny_severity to the shared
+  library so that configure tests can find it correctly
+
+* Mon Feb 10 2003 Harald Hoyer &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">harald at redhat.de</A>&gt; 7.6-29
+- shared library generated and added #75494
+- added security patch tcp_wrappers-7.6-sig.patch
+- compile and link with -fPIC -DPIC
+
+* Wed Jan 22 2003 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- rebuilt
+
+* Tue Jan  7 2003 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt; 7.6-25
+- don't include -debuginfo files in package.
+
+* Tue Nov 19 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- rebuild on all arches
+
+* Fri Jun 21 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- automated rebuild
+
+* Tue Jun 11 2002 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- fix #61192
+- added Patch8 to fix #17847
+- update IPv6 patch
+
+* Thu May 23 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- automated rebuild
+
+* Wed Jan 09 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- automated rebuild
+
+* Sun Mar 11 2001 Pekka Savola &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pekkas at netcore.fi</A>&gt;
+- Add IPv6 patch from USAGI, enable it.
+
+* Mon Feb  5 2001 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt;
+- fix gethostbyname to work better with dot &quot;.&quot; notation (#16949)
+
+* Sat Dec 30 2000 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- permit hosts.{allow,deny} to be assembled from included components (#17795).
+- permit '*' and '?' wildcard matches on hostnames (#17847).
+
+* Sun Nov 19 2000 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- ia64 needs -fPIC too
+
+* Mon Aug 14 2000 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- remove utilities that expect /etc/inetd.conf (#16059).
+
+* Thu Jul 27 2000 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- security hardening (#11881).
+
+* Wed Jul 12 2000 Prospector &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bugzilla at redhat.com</A>&gt;
+- automatic rebuild
+
+* Tue Jun  6 2000 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- FHS packaging.
+
+* Tue May 16 2000 Chris Evans &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">chris at ferret.lmh.ox.ac.uk</A>&gt;
+- Make tcpd mode -rwx--x--x as a security hardening measure
+
+* Mon Feb  7 2000 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- compress man pages.
+
+* Mon Aug 23 1999 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- add netgroup support (#3940).
+
+* Wed May 26 1999 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- compile on sparc with -fPIC.
+
+* Sun Mar 21 1999 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt; 
+- auto rebuild in the new build environment (release 7)
+
+* Wed Dec 30 1998 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt;
+- build for glibc 2.1
+
+* Sat Aug 22 1998 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- close setenv bug (problem #690)
+- spec file cleanup
+
+* Thu Jun 25 1998 Alan Cox &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">alan at redhat.com</A>&gt;
+- Erp where did the Dec 05 patch escape to
+
+* Thu May 07 1998 Prospector System &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bugs at redhat.com</A>&gt;
+- translations modified for de, fr, tr
+
+* Fri Dec 05 1997 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- don't build setenv.o module -- it just breaks things
+
+* Wed Oct 29 1997 Marc Ewing &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">marc at redhat.com</A>&gt;
+- upgrade to 7.6
+
+* Thu Jul 17 1997 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- built against glibc
+
+* Mon Mar 03 1997 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- Upgraded to version 7.5
+- Uses a build root


Property changes on: trunk/rpms/tcp_wrappers/tcp_wrappers.spec
___________________________________________________________________
Name: svn:keywords
   + Id
Name: svn:eol-style
   + native

Added: trunk/rpms/tcp_wrappers/tcp_wrappers.ume-ipv6.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers.ume-ipv6.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers.ume-ipv6.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,45 @@
+diff -up tcp_wrappers_7.6/hosts_access.c.patch10 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch10	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -443,6 +443,15 @@ char   *string;
+     int len, mask_len, i = 0;
+     char ch;
+ 
++    /*
++     * Behavior of getaddrinfo() against IPv4-mapped IPv6 address is
++     * different between KAME and Solaris8.  While KAME returns
++     * AF_INET6, Solaris8 returns AF_INET.  So, we avoid this here.
++     */
++    if (STRN_EQ(string, &quot;::ffff:&quot;, 7)
++	&amp;&amp; dot_quad_addr(string + 7) != INADDR_NONE)
++	return (masked_match4(net_tok, mask_tok, string + 7));
++
+     memset(&amp;hints, 0, sizeof(hints));
+     hints.ai_family = AF_INET6;
+     hints.ai_socktype = SOCK_STREAM;
+@@ -452,13 +461,6 @@ char   *string;
+     memcpy(&amp;addr, res-&gt;ai_addr, sizeof(addr));
+     freeaddrinfo(res);
+ 
+-    if (IN6_IS_ADDR_V4MAPPED(&amp;addr.sin6_addr)) {
+-	if ((*(u_int32_t *)&amp;net.sin6_addr.s6_addr[12] = dot_quad_addr(net_tok)) == INADDR_NONE
+-	 || (mask = dot_quad_addr(mask_tok)) == INADDR_NONE)
+-	    return (NO);
+-	return ((*(u_int32_t *)&amp;addr.sin6_addr.s6_addr[12] &amp; mask) == *(u_int32_t *)&amp;net.sin6_addr.s6_addr[12]);
+-    }
+-
+     /* match IPv6 address against netnumber/prefixlen */
+     len = strlen(net_tok);
+     if (*net_tok != '[' || net_tok[len - 1] != ']')
+diff -up tcp_wrappers_7.6/socket.c.patch10 tcp_wrappers_7.6/socket.c
+--- tcp_wrappers_7.6/socket.c.patch10	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/socket.c	2008-08-29 09:45:12.000000000 +0200
+@@ -228,7 +228,7 @@ struct host_info *host;
+ 	hints.ai_family = sin-&gt;sa_family;
+ 	hints.ai_socktype = SOCK_STREAM;
+ 	hints.ai_flags = AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST;
+-	if ((err = getaddrinfo(host-&gt;name, NULL, &amp;hints, &amp;res0) == 0)) {
++	if ((err = getaddrinfo(host-&gt;name, NULL, &amp;hints, &amp;res0)) == 0) {
+ 	    freeaddrinfo(res0);
+ 	    res0 = NULL;
+ 	    tcpd_warn(&quot;host name/name mismatch: &quot;

Added: trunk/rpms/tcp_wrappers/tcp_wrappers.usagi-ipv6.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers.usagi-ipv6.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers.usagi-ipv6.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,1291 @@
+diff -up tcp_wrappers_7.6/fix_options.c.patch9 tcp_wrappers_7.6/fix_options.c
+--- tcp_wrappers_7.6/fix_options.c.patch9	1997-04-08 02:29:19.000000000 +0200
++++ tcp_wrappers_7.6/fix_options.c	2008-08-29 09:45:12.000000000 +0200
+@@ -11,6 +11,9 @@ static char sccsid[] = &quot;@(#) fix_options
+ 
+ #include &lt;sys/types.h&gt;
+ #include &lt;sys/param.h&gt;
++#ifdef INET6
++#include &lt;sys/socket.h&gt;
++#endif
+ #include &lt;netinet/in.h&gt;
+ #include &lt;netinet/in_systm.h&gt;
+ #include &lt;netinet/ip.h&gt;
+@@ -41,6 +44,22 @@ struct request_info *request;
+     unsigned int opt;
+     int     optlen;
+     struct in_addr dummy;
++#ifdef INET6
++    struct sockaddr_storage ss;
++    int sslen;
++
++    /*
++     * check if this is AF_INET socket
++     * XXX IPv6 support?
++     */
++    sslen = sizeof(ss);
++    if (getsockname(fd, (struct sockaddr *)&amp;ss, &amp;sslen) &lt; 0) {
++	syslog(LOG_ERR, &quot;getpeername: %m&quot;);
++	clean_exit(request);
++    }
++    if (ss.ss_family != AF_INET)
++	return;
++#endif
+ 
+     if ((ip = getprotobyname(&quot;ip&quot;)) != 0)
+ 	ipproto = ip-&gt;p_proto;
+diff -up tcp_wrappers_7.6/hosts_access.5.patch9 tcp_wrappers_7.6/hosts_access.5
+--- tcp_wrappers_7.6/hosts_access.5.patch9	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.5	2008-08-29 09:45:12.000000000 +0200
+@@ -85,11 +85,18 @@ member of the specified netgroup. Netgro
+ for daemon process names or for client user names.
+ .IP \(bu
+ An expression of the form `n.n.n.n/m.m.m.m\' is interpreted as a
+-`net/mask\' pair. A host address is matched if `net\' is equal to the
++`net/mask\' pair. An IPv4 host address is matched if `net\' is equal to the
+ bitwise AND of the address and the `mask\'. For example, the net/mask
+ pattern `131.155.72.0/255.255.254.0\' matches every address in the
+ range `131.155.72.0\' through `131.155.73.255\'.
+ .IP \(bu
++An expression of the form `[n:n:n:n:n:n:n:n]/m\' is interpreted as a
++`[net]/prefixlen\' pair. An IPv6 host address is matched if
++`prefixlen\' bits of `net\' is equal to the `prefixlen\' bits of the
++address. For example, the [net]/prefixlen pattern
++`[3ffe:505:2:1::]/64\' matches every address in the range
++`3ffe:505:2:1::\' through `3ffe:505:2:1:ffff:ffff:ffff:ffff\'.
++.IP \(bu
+ A string that begins with a `/\' character is treated as a file
+ name. A host name or address is matched if it matches any host name
+ or address pattern listed in the named file. The file format is
+diff -up tcp_wrappers_7.6/hosts_access.c.patch9 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch9	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -24,7 +24,13 @@ static char sccsid[] = &quot;@(#) hosts_acces
+ /* System libraries. */
+ 
+ #include &lt;sys/types.h&gt;
++#ifdef INT32_T
++    typedef uint32_t u_int32_t;
++#endif
+ #include &lt;sys/param.h&gt;
++#ifdef INET6
++#include &lt;sys/socket.h&gt;
++#endif
+ #include &lt;netinet/in.h&gt;
+ #include &lt;arpa/inet.h&gt;
+ #include &lt;stdio.h&gt;
+@@ -33,6 +39,9 @@ static char sccsid[] = &quot;@(#) hosts_acces
+ #include &lt;errno.h&gt;
+ #include &lt;setjmp.h&gt;
+ #include &lt;string.h&gt;
++#ifdef INET6
++#include &lt;netdb.h&gt;
++#endif
+ 
+ extern char *fgets();
+ extern int errno;
+@@ -82,6 +91,10 @@ static int client_match();
+ static int host_match();
+ static int string_match();
+ static int masked_match();
++#ifdef INET6
++static int masked_match4();
++static int masked_match6();
++#endif
+ 
+ /* Size of logical line buffer. */
+ 
+@@ -311,6 +324,13 @@ char   *string;
+ {
+     int     n;
+ 
++#ifdef INET6
++    /* convert IPv4 mapped IPv6 address to IPv4 address */
++    if (STRN_EQ(string, &quot;::ffff:&quot;, 7)
++      &amp;&amp; dot_quad_addr(string + 7) != INADDR_NONE) {
++      string += 7;
++    }
++#endif    
+ #ifndef DISABLE_WILDCARD_MATCHING
+     if (strchr(tok, '*') || strchr(tok,'?')) {  /* contains '*' or '?' */
+         return (match_pattern_ylo(string,tok)); 	       
+@@ -326,20 +346,72 @@ char   *string;
+     } else if (tok[(n = strlen(tok)) - 1] == '.') {	/* prefix */
+ 	return (STRN_EQ(tok, string, n));
+     } else {					/* exact match */
++#ifdef INET6
++	struct addrinfo hints, *res;
++	struct sockaddr_in6 pat, addr;
++	int len, ret;
++	char ch;
++
++	len = strlen(tok);
++	if (*tok == '[' &amp;&amp; tok[len - 1] == ']') {
++	    ch = tok[len - 1];
++	    tok[len - 1] = '\0';
++	    memset(&amp;hints, 0, sizeof(hints));
++	    hints.ai_family = AF_INET6;
++	    hints.ai_socktype = SOCK_STREAM;
++	    hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;
++	    if ((ret = getaddrinfo(tok + 1, NULL, &amp;hints, &amp;res)) == 0) {
++		memcpy(&amp;pat, res-&gt;ai_addr, sizeof(pat));
++		freeaddrinfo(res);
++	    }
++	    tok[len - 1] = ch;
++	    if (ret != 0 || getaddrinfo(string, NULL, &amp;hints, &amp;res) != 0)
++		return NO;
++	    memcpy(&amp;addr, res-&gt;ai_addr, sizeof(addr));
++	    freeaddrinfo(res);
++#ifdef NI_WITHSCOPEID
++	    if (pat.sin6_scope_id != 0 &amp;&amp;
++		addr.sin6_scope_id != pat.sin6_scope_id)
++		return NO;
++#endif
++	    return (!memcmp(&amp;pat.sin6_addr, &amp;addr.sin6_addr,
++			    sizeof(struct in6_addr)));
++	    return (ret);
++	}
++#endif
+ 	return (STR_EQ(tok, string));
+     }
+ }
+ 
+ /* masked_match - match address against netnumber/netmask */
+ 
++#ifdef INET6
+ static int masked_match(net_tok, mask_tok, string)
+ char   *net_tok;
+ char   *mask_tok;
+ char   *string;
+ {
++    return (masked_match4(net_tok, mask_tok, string) ||
++	    masked_match6(net_tok, mask_tok, string));
++}
++
++static int masked_match4(net_tok, mask_tok, string)
++#else
++static int masked_match(net_tok, mask_tok, string)
++#endif
++char   *net_tok;
++char   *mask_tok;
++char   *string;
++{
++#ifdef INET6
++    u_int32_t net;
++    u_int32_t mask;
++    u_int32_t addr;
++#else
+     unsigned long net;
+     unsigned long mask;
+     unsigned long addr;
++#endif
+ 
+     /*
+      * Disallow forms other than dotted quad: the treatment that inet_addr()
+@@ -351,12 +423,78 @@ char   *string;
+ 	return (NO);
+     if ((net = dot_quad_addr(net_tok)) == INADDR_NONE
+ 	|| (mask = dot_quad_addr(mask_tok)) == INADDR_NONE) {
++#ifndef INET6
+ 	tcpd_warn(&quot;bad net/mask expression: %s/%s&quot;, net_tok, mask_tok);
++#endif
+ 	return (NO);				/* not tcpd_jump() */
+     }
+     return ((addr &amp; mask) == net);
+ }
+ 
++#ifdef INET6
++static int masked_match6(net_tok, mask_tok, string)
++char   *net_tok;
++char   *mask_tok;
++char   *string;
++{
++    struct addrinfo hints, *res;
++    struct sockaddr_in6 net, addr;
++    u_int32_t mask;
++    int len, mask_len, i = 0;
++    char ch;
++
++    memset(&amp;hints, 0, sizeof(hints));
++    hints.ai_family = AF_INET6;
++    hints.ai_socktype = SOCK_STREAM;
++    hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;
++    if (getaddrinfo(string, NULL, &amp;hints, &amp;res) != 0)
++	return NO;
++    memcpy(&amp;addr, res-&gt;ai_addr, sizeof(addr));
++    freeaddrinfo(res);
++
++    if (IN6_IS_ADDR_V4MAPPED(&amp;addr.sin6_addr)) {
++	if ((*(u_int32_t *)&amp;net.sin6_addr.s6_addr[12] = dot_quad_addr(net_tok)) == INADDR_NONE
++	 || (mask = dot_quad_addr(mask_tok)) == INADDR_NONE)
++	    return (NO);
++	return ((*(u_int32_t *)&amp;addr.sin6_addr.s6_addr[12] &amp; mask) == *(u_int32_t *)&amp;net.sin6_addr.s6_addr[12]);
++    }
++
++    /* match IPv6 address against netnumber/prefixlen */
++    len = strlen(net_tok);
++    if (*net_tok != '[' || net_tok[len - 1] != ']')
++	return NO;
++    ch = net_tok[len - 1];
++    net_tok[len - 1] = '\0';
++    if (getaddrinfo(net_tok + 1, NULL, &amp;hints, &amp;res) != 0) {
++	net_tok[len - 1] = ch;
++	return NO;
++    }
++    memcpy(&amp;net, res-&gt;ai_addr, sizeof(net));
++    freeaddrinfo(res);
++    net_tok[len - 1] = ch;
++    if ((mask_len = atoi(mask_tok)) &lt; 0 || mask_len &gt; 128)
++	return NO;
++
++#ifdef NI_WITHSCOPEID
++    if (net.sin6_scope_id != 0 &amp;&amp; addr.sin6_scope_id != net.sin6_scope_id)
++	return NO;
++#endif
++    while (mask_len &gt; 0) {
++	if (mask_len &lt; 32) {
++	    mask = htonl(~(0xffffffff &gt;&gt; mask_len));
++	    if ((*(u_int32_t *)&amp;addr.sin6_addr.s6_addr[i] &amp; mask) != (*(u_int32_t *)&amp;net.sin6_addr.s6_addr[i] &amp; mask))
++		return NO;
++	    break;
++	}
++	if (*(u_int32_t *)&amp;addr.sin6_addr.s6_addr[i] != *(u_int32_t *)&amp;net.sin6_addr.s6_addr[i])
++	    return NO;
++	i += 4;
++	mask_len -= 32;
++    }
++    return YES;
++}
++#endif /* INET6 */
++
+ #ifndef DISABLE_WILDCARD_MATCHING
+ /* Note: this feature has been adapted in a pretty straightforward way
+    from Tatu Ylonen's last SSH version under free license by 
+diff -up tcp_wrappers_7.6/inetcf.c.patch9 tcp_wrappers_7.6/inetcf.c
+--- tcp_wrappers_7.6/inetcf.c.patch9	1997-02-12 02:13:24.000000000 +0100
++++ tcp_wrappers_7.6/inetcf.c	2008-08-29 09:45:12.000000000 +0200
+@@ -26,6 +26,9 @@ extern void exit();
+   * guesses. Shorter names follow longer ones.
+   */
+ char   *inet_files[] = {
++#ifdef INET6
++    &quot;/usr/local/v6/etc/inet6d.conf&quot;,	/* KAME */
++#endif
+     &quot;/private/etc/inetd.conf&quot;,		/* NEXT */
+     &quot;/etc/inet/inetd.conf&quot;,		/* SYSV4 */
+     &quot;/usr/etc/inetd.conf&quot;,		/* IRIX?? */
+diff -up tcp_wrappers_7.6/Makefile.patch9 tcp_wrappers_7.6/Makefile
+--- tcp_wrappers_7.6/Makefile.patch9	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/Makefile	2008-08-29 09:45:12.000000000 +0200
+@@ -21,7 +21,7 @@ what:
+ 	@echo &quot;	dynix epix esix freebsd hpux irix4 irix5 irix6 isc iunix&quot;
+ 	@echo &quot;	linux machten mips(untested) ncrsvr4 netbsd next osf power_unix_211&quot;
+ 	@echo &quot;	ptx-2.x ptx-generic pyramid sco sco-nis sco-od2 sco-os5 sinix sunos4&quot;
+-	@echo &quot;	sunos40 sunos5 sysv4 tandem ultrix unicos7 unicos8 unixware1 unixware2&quot;
++	@echo &quot;	sunos40 sunos5 solaris8 sysv4 tandem ultrix unicos7 unicos8 unixware1 unixware2&quot;
+ 	@echo &quot;	uts215 uxp&quot;
+ 	@echo
+ 	@echo &quot;If none of these match your environment, edit the system&quot;
+@@ -131,20 +131,33 @@ epix:
+ 	NETGROUP=-DNETGROUP TLI= SYSTYPE=&quot;-systype bsd43&quot; all
+ 
+ # Freebsd and linux by default have no NIS.
+-386bsd netbsd bsdos:
++386bsd bsdos:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+ 	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= NETGROUP= TLI= \
+ 	EXTRA_CFLAGS=-DSYS_ERRLIST_DEFINED VSYSLOG= all
+ 
+ freebsd:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
++	LIBS=&quot;-L/usr/local/v6/lib -linet6&quot; \
+ 	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= NETGROUP= TLI= \
+-	EXTRA_CFLAGS=-DSYS_ERRLIST_DEFINED VSYSLOG= all
++	EXTRA_CFLAGS=&quot;-DSYS_ERRLIST_DEFINED -DINET6 -Dss_family=__ss_family -Dss_len=__ss_len&quot; \
++	VSYSLOG= all
++
++netbsd:
++	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
++	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= NETGROUP= TLI= \
++	EXTRA_CFLAGS=&quot;-DSYS_ERRLIST_DEFINED -DINET6 -Dss_family=__ss_family -Dss_len=__ss_len&quot; VSYSLOG= all
+ 
+ linux:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+ 	LIBS=&quot;-lnsl&quot; RANLIB=ranlib ARFLAGS=rv AUX_OBJ= \
+-	NETGROUP=&quot;-DNETGROUP&quot; TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER&quot; all
++	NETGROUP=&quot;-DNETGROUP&quot; TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER -DINET6=1 -Dss_family=__ss_family -Dss_len=__ss_len&quot; all
++
++linux-old:
++	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
++	LIBS=&quot;/usr/inet6/lib/libinet6.a -lresolv&quot; \
++	RANLIB=ranlib ARFLAGS=rv AUX_OBJ=setenv.o NETGROUP= TLI= \
++	EXTRA_CFLAGS=&quot;-DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER -DINET6=1 -Dss_family=sin6_family -Dsockaddr_storage=sockaddr_in6 -I/usr/inet6/include&quot; all
+ 
+ # This is good for many SYSV+BSD hybrids with NIS, probably also for HP-UX 7.x.
+ hpux hpux8 hpux9 hpux10:
+@@ -196,6 +209,13 @@ sunos5:
+ 	NETGROUP=-DNETGROUP AUX_OBJ=setenv.o TLI=-DTLI \
+ 	BUGS=&quot;$(BUGS) -DSOLARIS_24_GETHOSTBYNAME_BUG&quot; all
+ 
++# SunOS 5.8 is another SYSV4 variant, but has IPv6 support
++solaris8:
++	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
++	LIBS=&quot;-lsocket -lnsl&quot; RANLIB=echo ARFLAGS=rv VSYSLOG= \
++	NETGROUP=-DNETGROUP AUX_OBJ=setenv.o TLI=-DTLI \
++	EXTRA_CFLAGS=&quot;-DINET6 -DNO_CLONE_DEVICE -DINT32_T&quot; all
++
+ # Generic SYSV40
+ esix sysv4:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+@@ -391,7 +411,7 @@ AR	= ar
+ # the ones provided with this source distribution. The environ.c module
+ # implements setenv(), getenv(), and putenv().
+ 
+-AUX_OBJ= setenv.o
++#AUX_OBJ= setenv.o
+ #AUX_OBJ= environ.o
+ #AUX_OBJ= environ.o strcasecmp.o
+ 
+@@ -454,7 +474,7 @@ AUX_OBJ= setenv.o
+ # host name aliases. Compile with -DSOLARIS_24_GETHOSTBYNAME_BUG to work
+ # around this. The workaround does no harm on other Solaris versions.
+ 
+-BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DLIBC_CALLS_STRTOK
++#BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DLIBC_CALLS_STRTOK
+ #BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DINET_ADDR_BUG
+ #BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS -DSOLARIS_24_GETHOSTBYNAME_BUG
+ 
+@@ -472,7 +492,7 @@ BUGS = -DGETPEERNAME_BUG -DBROKEN_FGETS 
+ # If your system supports vsyslog(), comment out the following definition.
+ # If in doubt leave it in, it won't harm.
+ 
+-VSYSLOG	= -Dvsyslog=myvsyslog
++#VSYSLOG	= -Dvsyslog=myvsyslog
+ 
+ # End of the system dependencies.
+ #################################
+diff -up tcp_wrappers_7.6/misc.c.patch9 tcp_wrappers_7.6/misc.c
+--- tcp_wrappers_7.6/misc.c.patch9	1996-02-11 17:01:30.000000000 +0100
++++ tcp_wrappers_7.6/misc.c	2008-08-29 09:45:12.000000000 +0200
+@@ -58,9 +58,31 @@ int     delimiter;
+ {
+     char   *cp;
+ 
++#ifdef INET6
++    int bracket = 0;
++
++    for (cp = string; cp &amp;&amp; *cp; cp++) {
++	switch (*cp) {
++	case '[':
++	    bracket++;
++	    break;
++	case ']':
++	    bracket--;
++	    break;
++	default:
++	    if (bracket == 0 &amp;&amp; *cp == delimiter) {
++		*cp++ = 0;
++		return cp;
++	    }
++	    break;
++	}
++    }
++    return (NULL);
++#else
+     if ((cp = strchr(string, delimiter)) != 0)
+ 	*cp++ = 0;
+     return (cp);
++#endif
+ }
+ 
+ /* dot_quad_addr - convert dotted quad to internal form */
+diff -up tcp_wrappers_7.6/refuse.c.patch9 tcp_wrappers_7.6/refuse.c
+--- tcp_wrappers_7.6/refuse.c.patch9	1994-12-28 17:42:40.000000000 +0100
++++ tcp_wrappers_7.6/refuse.c	2008-08-29 09:45:12.000000000 +0200
+@@ -25,7 +25,12 @@ static char sccsid[] = &quot;@(#) refuse.c 1.
+ void    refuse(request)
+ struct request_info *request;
+ {
++#ifdef INET6
++    syslog(deny_severity, &quot;refused connect from %s (%s)&quot;,
++	   eval_client(request), eval_hostaddr(request-&gt;client));
++#else
+     syslog(deny_severity, &quot;refused connect from %s&quot;, eval_client(request));
++#endif
+     clean_exit(request);
+     /* NOTREACHED */
+ }
+diff -up tcp_wrappers_7.6/rfc931.c.patch9 tcp_wrappers_7.6/rfc931.c
+--- tcp_wrappers_7.6/rfc931.c.patch9	1995-01-02 16:11:34.000000000 +0100
++++ tcp_wrappers_7.6/rfc931.c	2008-08-29 09:45:12.000000000 +0200
+@@ -68,20 +68,50 @@ int     sig;
+ /* rfc931 - return remote user name, given socket structures */
+ 
+ void    rfc931(rmt_sin, our_sin, dest)
++#ifdef INET6
++struct sockaddr *rmt_sin;
++struct sockaddr *our_sin;
++#else
+ struct sockaddr_in *rmt_sin;
+ struct sockaddr_in *our_sin;
++#endif
+ char   *dest;
+ {
+     unsigned rmt_port;
+     unsigned our_port;
++#ifdef INET6
++    struct sockaddr_storage rmt_query_sin;
++    struct sockaddr_storage our_query_sin;
++    int alen;
++#else
+     struct sockaddr_in rmt_query_sin;
+     struct sockaddr_in our_query_sin;
++#endif
+     char    user[256];			/* XXX */
+     char    buffer[512];		/* XXX */
+     char   *cp;
+     char   *result = unknown;
+     FILE   *fp;
+ 
++#ifdef INET6
++    /* address family must be the same */
++    if (rmt_sin-&gt;sa_family != our_sin-&gt;sa_family) {
++	STRN_CPY(dest, result, STRING_LENGTH);
++	return;
++    }
++    switch (our_sin-&gt;sa_family) {
++    case AF_INET:
++	alen = sizeof(struct sockaddr_in);
++	break;
++    case AF_INET6:
++	alen = sizeof(struct sockaddr_in6);
++	break;
++    default:
++	STRN_CPY(dest, result, STRING_LENGTH);
++	return;
++    }
++#endif
++
+     /*
+      * Use one unbuffered stdio stream for writing to and for reading from
+      * the RFC931 etc. server. This is done because of a bug in the SunOS
+@@ -92,7 +122,11 @@ char   *dest;
+      * sockets.
+      */
+ 
++#ifdef INET6
++    if ((fp = fsocket(our_sin-&gt;sa_family, SOCK_STREAM, 0)) != 0) {
++#else
+     if ((fp = fsocket(AF_INET, SOCK_STREAM, 0)) != 0) {
++#endif
+ 	setbuf(fp, (char *) 0);
+ 
+ 	/*
+@@ -112,6 +146,25 @@ char   *dest;
+ 	     * addresses from the query socket.
+ 	     */
+ 
++#ifdef INET6
++	    memcpy(&amp;our_query_sin, our_sin, alen);
++	    memcpy(&amp;rmt_query_sin, rmt_sin, alen);
++	    switch (our_sin-&gt;sa_family) {
++	    case AF_INET:
++		((struct sockaddr_in *)&amp;our_query_sin)-&gt;sin_port = htons(ANY_PORT);
++		((struct sockaddr_in *)&amp;rmt_query_sin)-&gt;sin_port = htons(RFC931_PORT);
++		break;
++	    case AF_INET6:
++		((struct sockaddr_in6 *)&amp;our_query_sin)-&gt;sin6_port = htons(ANY_PORT);
++		((struct sockaddr_in6 *)&amp;rmt_query_sin)-&gt;sin6_port = htons(RFC931_PORT);
++		break;
++	    }
++
++	    if (bind(fileno(fp), (struct sockaddr *) &amp; our_query_sin,
++		     alen) &gt;= 0 &amp;&amp;
++		connect(fileno(fp), (struct sockaddr *) &amp; rmt_query_sin,
++			alen) &gt;= 0) {
++#else
+ 	    our_query_sin = *our_sin;
+ 	    our_query_sin.sin_port = htons(ANY_PORT);
+ 	    rmt_query_sin = *rmt_sin;
+@@ -121,6 +174,7 @@ char   *dest;
+ 		     sizeof(our_query_sin)) &gt;= 0 &amp;&amp;
+ 		connect(fileno(fp), (struct sockaddr *) &amp; rmt_query_sin,
+ 			sizeof(rmt_query_sin)) &gt;= 0) {
++#endif
+ 
+ 		/*
+ 		 * Send query to server. Neglect the risk that a 13-byte
+@@ -129,8 +183,13 @@ char   *dest;
+ 		 */
+ 
+ 		fprintf(fp, &quot;%u,%u\r\n&quot;,
++#ifdef INET6
++			ntohs(((struct sockaddr_in *)rmt_sin)-&gt;sin_port),
++			ntohs(((struct sockaddr_in *)our_sin)-&gt;sin_port));
++#else
+ 			ntohs(rmt_sin-&gt;sin_port),
+ 			ntohs(our_sin-&gt;sin_port));
++#endif
+ 		fflush(fp);
+ 
+ 		/*
+@@ -144,8 +203,13 @@ char   *dest;
+ 		    &amp;&amp; ferror(fp) == 0 &amp;&amp; feof(fp) == 0
+ 		    &amp;&amp; sscanf(buffer, &quot;%u , %u : USERID :%*[^:]:%255s&quot;,
+ 			      &amp;rmt_port, &amp;our_port, user) == 3
++#ifdef INET6
++		    &amp;&amp; ntohs(((struct sockaddr_in *)rmt_sin)-&gt;sin_port) == rmt_port
++		    &amp;&amp; ntohs(((struct sockaddr_in *)our_sin)-&gt;sin_port) == our_port) {
++#else
+ 		    &amp;&amp; ntohs(rmt_sin-&gt;sin_port) == rmt_port
+ 		    &amp;&amp; ntohs(our_sin-&gt;sin_port) == our_port) {
++#endif
+ 
+ 		    /*
+ 		     * Strip trailing carriage return. It is part of the
+diff -up tcp_wrappers_7.6/scaffold.c.patch9 tcp_wrappers_7.6/scaffold.c
+--- tcp_wrappers_7.6/scaffold.c.patch9	1997-03-21 19:27:24.000000000 +0100
++++ tcp_wrappers_7.6/scaffold.c	2008-08-29 09:45:12.000000000 +0200
+@@ -25,7 +25,9 @@ static char sccs_id[] = &quot;@(#) scaffold.c
+ #define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
+ #endif
+ 
++#ifndef INET6
+ extern char *malloc();
++#endif
+ 
+ /* Application-specific. */
+ 
+@@ -39,6 +41,7 @@ int     allow_severity = SEVERITY;
+ int     deny_severity = LOG_WARNING;
+ int     rfc931_timeout = RFC931_TIMEOUT;
+ 
++#ifndef INET6
+ /* dup_hostent - create hostent in one memory block */
+ 
+ static struct hostent *dup_hostent(hp)
+@@ -73,9 +76,46 @@ struct hostent *hp;
+     }
+     return (&amp;hb-&gt;host);
+ }
++#endif
+ 
+ /* find_inet_addr - find all addresses for this host, result to free() */
+ 
++#ifdef INET6
++struct addrinfo *find_inet_addr(host)
++char   *host;
++{
++    struct addrinfo hints, *res;
++
++    memset(&amp;hints, 0, sizeof(hints));
++    hints.ai_family = PF_UNSPEC;
++    hints.ai_socktype = SOCK_STREAM;
++    hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;
++    if (getaddrinfo(host, NULL, &amp;hints, &amp;res) == 0)
++	return (res);
++
++    memset(&amp;hints, 0, sizeof(hints));
++    hints.ai_family = PF_UNSPEC;
++    hints.ai_socktype = SOCK_STREAM;
++    hints.ai_flags = AI_PASSIVE | AI_CANONNAME;
++    if (getaddrinfo(host, NULL, &amp;hints, &amp;res) != 0) {
++	tcpd_warn(&quot;%s: host not found&quot;, host);
++	return (0);
++    }
++    if (res-&gt;ai_family != AF_INET6 &amp;&amp; res-&gt;ai_family != AF_INET) {
++	tcpd_warn(&quot;%d: not an internet host&quot;, res-&gt;ai_family);
++	freeaddrinfo(res);
++	return (0);
++    }
++    if (!res-&gt;ai_canonname) {
++	tcpd_warn(&quot;%s: hostname alias&quot;, host);
++	tcpd_warn(&quot;(cannot obtain official name)&quot;, res-&gt;ai_canonname);
++    } else if (STR_NE(host, res-&gt;ai_canonname)) {
++	tcpd_warn(&quot;%s: hostname alias&quot;, host);
++	tcpd_warn(&quot;(official name: %.*s)&quot;, STRING_LENGTH, res-&gt;ai_canonname);
++    }
++    return (res);
++}
++#else
+ struct hostent *find_inet_addr(host)
+ char   *host;
+ {
+@@ -118,6 +158,7 @@ char   *host;
+     }
+     return (dup_hostent(hp));
+ }
++#endif
+ 
+ /* check_dns - give each address thorough workout, return address count */
+ 
+@@ -125,8 +166,13 @@ int     check_dns(host)
+ char   *host;
+ {
+     struct request_info request;
++#ifdef INET6
++    struct sockaddr_storage sin;
++    struct addrinfo *hp, *res;
++#else
+     struct sockaddr_in sin;
+     struct hostent *hp;
++#endif
+     int     count;
+     char   *addr;
+ 
+@@ -134,11 +180,18 @@ char   *host;
+ 	return (0);
+     request_init(&amp;request, RQ_CLIENT_SIN, &amp;sin, 0);
+     sock_methods(&amp;request);
++#ifndef INET6
+     memset((char *) &amp;sin, 0, sizeof(sin));
+     sin.sin_family = AF_INET;
++#endif
+ 
++#ifdef INET6
++    for (res = hp, count = 0; res; res = res-&gt;ai_next, count++) {
++	memcpy(&amp;sin, res-&gt;ai_addr, res-&gt;ai_addrlen);
++#else
+     for (count = 0; (addr = hp-&gt;h_addr_list[count]) != 0; count++) {
+ 	memcpy((char *) &amp;sin.sin_addr, addr, sizeof(sin.sin_addr));
++#endif
+ 
+ 	/*
+ 	 * Force host name and address conversions. Use the request structure
+@@ -151,7 +204,11 @@ char   *host;
+ 	    tcpd_warn(&quot;host address %s-&gt;name lookup failed&quot;,
+ 		      eval_hostaddr(request.client));
+     }
++#ifdef INET6
++    freeaddrinfo(hp);
++#else
+     free((char *) hp);
++#endif
+     return (count);
+ }
+ 
+diff -up tcp_wrappers_7.6/scaffold.h.patch9 tcp_wrappers_7.6/scaffold.h
+--- tcp_wrappers_7.6/scaffold.h.patch9	1994-12-31 18:19:20.000000000 +0100
++++ tcp_wrappers_7.6/scaffold.h	2008-08-29 09:45:12.000000000 +0200
+@@ -4,6 +4,10 @@
+   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
+   */
+ 
++#ifdef INET6
++extern struct addrinfo *find_inet_addr();
++#else
+ extern struct hostent *find_inet_addr();
++#endif
+ extern int check_dns();
+ extern int check_path();
+diff -up tcp_wrappers_7.6/socket.c.patch9 tcp_wrappers_7.6/socket.c
+--- tcp_wrappers_7.6/socket.c.patch9	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/socket.c	2008-08-29 09:45:12.000000000 +0200
+@@ -24,13 +24,22 @@ static char sccsid[] = &quot;@(#) socket.c 1.
+ #include &lt;sys/types.h&gt;
+ #include &lt;sys/param.h&gt;
+ #include &lt;sys/socket.h&gt;
++#ifdef INT32_T
++typedef uint32_t u_int32_t;
++#endif
+ #include &lt;netinet/in.h&gt;
+ #include &lt;netdb.h&gt;
+ #include &lt;stdio.h&gt;
+ #include &lt;syslog.h&gt;
+ #include &lt;string.h&gt;
+ 
++#ifdef INET6
++#ifndef NI_WITHSCOPEID
++#define NI_WITHSCOPEID	0
++#endif
++#else
+ extern char *inet_ntoa();
++#endif
+ 
+ /* Local stuff. */
+ 
+@@ -79,8 +88,13 @@ char   *name;
+ void    sock_host(request)
+ struct request_info *request;
+ {
++#ifdef INET6
++    static struct sockaddr_storage client;
++    static struct sockaddr_storage server;
++#else
+     static struct sockaddr_in client;
+     static struct sockaddr_in server;
++#endif
+     int     len;
+     char    buf[BUFSIZ];
+     int     fd = request-&gt;fd;
+@@ -109,7 +123,11 @@ struct request_info *request;
+ 	memset(buf, 0 sizeof(buf));
+ #endif
+     }
++#ifdef INET6
++    request-&gt;client-&gt;sin = (struct sockaddr *)&amp;client;
++#else
+     request-&gt;client-&gt;sin = &amp;client;
++#endif
+ 
+     /*
+      * Determine the server binding. This is used for client username
+@@ -122,7 +140,11 @@ struct request_info *request;
+ 	tcpd_warn(&quot;getsockname: %m&quot;);
+ 	return;
+     }
++#ifdef INET6
++    request-&gt;server-&gt;sin = (struct sockaddr *)&amp;server;
++#else
+     request-&gt;server-&gt;sin = &amp;server;
++#endif
+ }
+ 
+ /* sock_hostaddr - map endpoint address to printable form */
+@@ -130,10 +152,26 @@ struct request_info *request;
+ void    sock_hostaddr(host)
+ struct host_info *host;
+ {
++#ifdef INET6
++    struct sockaddr *sin = host-&gt;sin;
++    int salen;
++
++    if (!sin)
++	return;
++#ifdef SIN6_LEN
++    salen = sin-&gt;sa_len;
++#else
++    salen = (sin-&gt;sa_family == AF_INET) ? sizeof(struct sockaddr_in)
++					: sizeof(struct sockaddr_in6);
++#endif
++    getnameinfo(sin, salen, host-&gt;addr, sizeof(host-&gt;addr),
++		NULL, 0, NI_NUMERICHOST | NI_WITHSCOPEID);
++#else
+     struct sockaddr_in *sin = host-&gt;sin;
+ 
+     if (sin != 0)
+ 	STRN_CPY(host-&gt;addr, inet_ntoa(sin-&gt;sin_addr), sizeof(host-&gt;addr));
++#endif
+ }
+ 
+ /* sock_hostname - map endpoint address to host name */
+@@ -141,6 +179,160 @@ struct host_info *host;
+ void    sock_hostname(host)
+ struct host_info *host;
+ {
++#ifdef INET6
++    struct sockaddr *sin = host-&gt;sin;
++    struct sockaddr_in sin4;
++    struct addrinfo hints, *res, *res0 = NULL;
++    int salen, alen, err = 1;
++    char *ap = NULL, *rap, hname[NI_MAXHOST];
++
++    if (sin != NULL) {
++	if (sin-&gt;sa_family == AF_INET6) {
++	    struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sin;
++
++	    if (IN6_IS_ADDR_V4MAPPED(&amp;sin6-&gt;sin6_addr)) {
++		memset(&amp;sin4, 0, sizeof(sin4));
++#ifdef SIN6_LEN
++		sin4.sin_len = sizeof(sin4);
++#endif
++		sin4.sin_family = AF_INET;
++		sin4.sin_port = sin6-&gt;sin6_port;
++		sin4.sin_addr.s_addr = *(u_int32_t *)&amp;sin6-&gt;sin6_addr.s6_addr[12];
++		sin = (struct sockaddr *)&amp;sin4;
++	    }
++	}
++	switch (sin-&gt;sa_family) {
++	case AF_INET:
++	    ap = (char *)&amp;((struct sockaddr_in *)sin)-&gt;sin_addr;
++	    alen = sizeof(struct in_addr);
++	    salen = sizeof(struct sockaddr_in);
++	    break;
++	case AF_INET6:
++	    ap = (char *)&amp;((struct sockaddr_in6 *)sin)-&gt;sin6_addr;
++	    alen = sizeof(struct in6_addr);
++	    salen = sizeof(struct sockaddr_in6);
++	    break;
++	default:
++	    break;
++	}
++	if (ap)
++	    err = getnameinfo(sin, salen, hname, sizeof(hname),
++			      NULL, 0, NI_WITHSCOPEID | NI_NAMEREQD);
++    }
++    if (!err) {
++
++	STRN_CPY(host-&gt;name, hname, sizeof(host-&gt;name));
++
++	/* reject numeric addresses */
++	memset(&amp;hints, 0, sizeof(hints));
++	hints.ai_family = sin-&gt;sa_family;
++	hints.ai_socktype = SOCK_STREAM;
++	hints.ai_flags = AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST;
++	if ((err = getaddrinfo(host-&gt;name, NULL, &amp;hints, &amp;res0) == 0)) {
++	    freeaddrinfo(res0);
++	    res0 = NULL;
++	    tcpd_warn(&quot;host name/name mismatch: &quot;
++		      &quot;reverse lookup results in non-FQDN %s&quot;,
++		      host-&gt;name);
++	    strcpy(host-&gt;name, paranoid);	/* name is bad, clobber it */
++	}
++	err = !err;
++    }
++    if (!err) {
++	/* we are now sure that this is non-numeric */
++
++	/*
++	 * Verify that the address is a member of the address list returned
++	 * by gethostbyname(hostname).
++	 * 
++	 * Verify also that gethostbyaddr() and gethostbyname() return the same
++	 * hostname, or rshd and rlogind may still end up being spoofed.
++	 * 
++	 * On some sites, gethostbyname(&quot;localhost&quot;) returns &quot;localhost.domain&quot;.
++	 * This is a DNS artefact. We treat it as a special case. When we
++	 * can't believe the address list from gethostbyname(&quot;localhost&quot;)
++	 * we're in big trouble anyway.
++	 */
++
++	memset(&amp;hints, 0, sizeof(hints));
++	hints.ai_family = sin-&gt;sa_family;
++	hints.ai_socktype = SOCK_STREAM;
++	hints.ai_flags = AI_PASSIVE | AI_CANONNAME;
++	if (getaddrinfo(host-&gt;name, NULL, &amp;hints, &amp;res0) != 0) {
++
++	    /*
++	     * Unable to verify that the host name matches the address. This
++	     * may be a transient problem or a botched name server setup.
++	     */
++
++	    tcpd_warn(&quot;can't verify hostname: getaddrinfo(%s, %s) failed&quot;,
++		      host-&gt;name,
++		      (sin-&gt;sa_family == AF_INET) ? &quot;AF_INET&quot; : &quot;AF_INET6&quot;);
++
++	} else if ((res0-&gt;ai_canonname == NULL
++		    || STR_NE(host-&gt;name, res0-&gt;ai_canonname))
++		   &amp;&amp; STR_NE(host-&gt;name, &quot;localhost&quot;)) {
++
++	    /*
++	     * The gethostbyaddr() and gethostbyname() calls did not return
++	     * the same hostname. This could be a nameserver configuration
++	     * problem. It could also be that someone is trying to spoof us.
++	     */
++
++	    tcpd_warn(&quot;host name/name mismatch: %s != %.*s&quot;,
++		      host-&gt;name, STRING_LENGTH,
++		      (res0-&gt;ai_canonname == NULL) ? &quot;&quot; : res0-&gt;ai_canonname);
++
++	} else {
++
++	    /*
++	     * The address should be a member of the address list returned by
++	     * gethostbyname(). We should first verify that the h_addrtype
++	     * field is AF_INET, but this program has already caused too much
++	     * grief on systems with broken library code.
++	     */
++
++	    for (res = res0; res; res = res-&gt;ai_next) {
++		if (res-&gt;ai_family != sin-&gt;sa_family)
++		    continue;
++		switch (res-&gt;ai_family) {
++		case AF_INET:
++		    rap = (char *)&amp;((struct sockaddr_in *)res-&gt;ai_addr)-&gt;sin_addr;
++		    break;
++		case AF_INET6:
++		    /* need to check scope_id */
++		    if (((struct sockaddr_in6 *)sin)-&gt;sin6_scope_id !=
++		        ((struct sockaddr_in6 *)res-&gt;ai_addr)-&gt;sin6_scope_id) {
++			continue;
++		    }
++		    rap = (char *)&amp;((struct sockaddr_in6 *)res-&gt;ai_addr)-&gt;sin6_addr;
++		    break;
++		default:
++		    continue;
++		}
++		if (memcmp(rap, ap, alen) == 0) {
++		    freeaddrinfo(res0);
++		    return;			/* name is good, keep it */
++		}
++	    }
++
++	    /*
++	     * The host name does not map to the initial address. Perhaps
++	     * someone has messed up. Perhaps someone compromised a name
++	     * server.
++	     */
++
++	    getnameinfo(sin, salen, hname, sizeof(hname),
++			NULL, 0, NI_NUMERICHOST | NI_WITHSCOPEID);
++	    tcpd_warn(&quot;host name/address mismatch: %s != %.*s&quot;,
++		      hname, STRING_LENGTH,
++		      (res0-&gt;ai_canonname == NULL) ? &quot;&quot; : res0-&gt;ai_canonname);
++	}
++	strcpy(host-&gt;name, paranoid);		/* name is bad, clobber it */
++	if (res0)
++	    freeaddrinfo(res0);
++    }
++#else /* INET6 */
+     struct sockaddr_in *sin = host-&gt;sin;
+     struct hostent *hp;
+     int     i;
+@@ -220,6 +412,7 @@ struct host_info *host;
+ 	}
+ 	strcpy(host-&gt;name, paranoid);		/* name is bad, clobber it */
+     }
++#endif /* INET6 */
+ }
+ 
+ /* sock_sink - absorb unreceived IP datagram */
+@@ -228,7 +421,11 @@ static void sock_sink(fd)
+ int     fd;
+ {
+     char    buf[BUFSIZ];
++#ifdef INET6
++    struct sockaddr_storage sin;
++#else
+     struct sockaddr_in sin;
++#endif
+     int     size = sizeof(sin);
+ 
+     /*
+diff -up tcp_wrappers_7.6/tcpdchk.c.patch9 tcp_wrappers_7.6/tcpdchk.c
+--- tcp_wrappers_7.6/tcpdchk.c.patch9	1997-02-12 02:13:25.000000000 +0100
++++ tcp_wrappers_7.6/tcpdchk.c	2008-08-29 09:45:12.000000000 +0200
+@@ -22,6 +22,9 @@ static char sccsid[] = &quot;@(#) tcpdchk.c 1
+ 
+ #include &lt;sys/types.h&gt;
+ #include &lt;sys/stat.h&gt;
++#ifdef INET6
++#include &lt;sys/socket.h&gt;
++#endif
+ #include &lt;netinet/in.h&gt;
+ #include &lt;arpa/inet.h&gt;
+ #include &lt;stdio.h&gt;
+@@ -397,6 +400,31 @@ char   *pat;
+     }
+ }
+ 
++#ifdef INET6
++static int is_inet6_addr(pat)
++    char *pat;
++{
++    struct addrinfo hints, *res;
++    int len, ret;
++    char ch;
++
++    if (*pat != '[')
++	return (0);
++    len = strlen(pat);
++    if ((ch = pat[len - 1]) != ']')
++	return (0);
++    pat[len - 1] = '\0';
++    memset(&amp;hints, 0, sizeof(hints));
++    hints.ai_family = AF_INET6;
++    hints.ai_socktype = SOCK_STREAM;
++    hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;
++    if ((ret = getaddrinfo(pat + 1, NULL, &amp;hints, &amp;res)) == 0)
++	freeaddrinfo(res);
++    pat[len - 1] = ch;
++    return (ret == 0);
++}
++#endif
++
+ /* check_host - criticize host pattern */
+ 
+ static int check_host(pat)
+@@ -423,14 +451,27 @@ char   *pat;
+ #endif
+ #endif
+     } else if (mask = split_at(pat, '/')) {	/* network/netmask */
++#ifdef INET6
++	int mask_len;
++
++	if ((dot_quad_addr(pat) == INADDR_NONE
++	    || dot_quad_addr(mask) == INADDR_NONE)
++	    &amp;&amp; (!is_inet6_addr(pat)
++		|| ((mask_len = atoi(mask)) &lt; 0 || mask_len &gt; 128)))
++#else
+ 	if (dot_quad_addr(pat) == INADDR_NONE
+ 	    || dot_quad_addr(mask) == INADDR_NONE)
++#endif
+ 	    tcpd_warn(&quot;%s/%s: bad net/mask pattern&quot;, pat, mask);
+     } else if (STR_EQ(pat, &quot;FAIL&quot;)) {		/* obsolete */
+ 	tcpd_warn(&quot;FAIL is no longer recognized&quot;);
+ 	tcpd_warn(&quot;(use EXCEPT or DENY instead)&quot;);
+     } else if (reserved_name(pat)) {		/* other reserved */
+ 	 /* void */ ;
++#ifdef INET6
++    } else if (is_inet6_addr(pat)) { /* IPv6 address */
++	addr_count = 1;
++#endif
+     } else if (NOT_INADDR(pat)) {		/* internet name */
+ 	if (pat[strlen(pat) - 1] == '.') {
+ 	    tcpd_warn(&quot;%s: domain or host name ends in dot&quot;, pat);
+diff -up tcp_wrappers_7.6/tcpd.c.patch9 tcp_wrappers_7.6/tcpd.c
+--- tcp_wrappers_7.6/tcpd.c.patch9	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/tcpd.c	2008-08-29 09:45:12.000000000 +0200
+@@ -120,7 +120,12 @@ char  **argv;
+ 
+     /* Report request and invoke the real daemon program. */
+ 
++#ifdef INET6
++    syslog(allow_severity, &quot;connect from %s (%s)&quot;,
++	   eval_client(&amp;request), eval_hostaddr(request.client));
++#else
+     syslog(allow_severity, &quot;connect from %s&quot;, eval_client(&amp;request));
++#endif
+     closelog();
+     (void) execv(path, argv);
+     syslog(LOG_ERR, &quot;error: cannot execute %s: %m&quot;, path);
+diff -up tcp_wrappers_7.6/tcpd.h.patch9 tcp_wrappers_7.6/tcpd.h
+--- tcp_wrappers_7.6/tcpd.h.patch9	1996-03-19 16:22:25.000000000 +0100
++++ tcp_wrappers_7.6/tcpd.h	2008-08-29 09:45:12.000000000 +0200
+@@ -11,7 +11,11 @@
+ struct host_info {
+     char    name[STRING_LENGTH];	/* access via eval_hostname(host) */
+     char    addr[STRING_LENGTH];	/* access via eval_hostaddr(host) */
++#ifdef INET6
++    struct sockaddr *sin;		/* socket address or 0 */
++#else
+     struct sockaddr_in *sin;		/* socket address or 0 */
++#endif
+     struct t_unitdata *unit;		/* TLI transport address or 0 */
+     struct request_info *request;	/* for shared information */
+ };
+diff -up tcp_wrappers_7.6/tcpdmatch.c.patch9 tcp_wrappers_7.6/tcpdmatch.c
+--- tcp_wrappers_7.6/tcpdmatch.c.patch9	1996-02-11 17:01:36.000000000 +0100
++++ tcp_wrappers_7.6/tcpdmatch.c	2008-08-29 09:45:12.000000000 +0200
+@@ -57,7 +57,11 @@ int     main(argc, argv)
+ int     argc;
+ char  **argv;
+ {
++#ifdef INET6
++    struct addrinfo hints, *hp, *res;
++#else
+     struct hostent *hp;
++#endif
+     char   *myname = argv[0];
+     char   *client;
+     char   *server;
+@@ -68,8 +72,13 @@ char  **argv;
+     int     ch;
+     char   *inetcf = 0;
+     int     count;
++#ifdef INET6
++    struct sockaddr_storage server_sin;
++    struct sockaddr_storage client_sin;
++#else
+     struct sockaddr_in server_sin;
+     struct sockaddr_in client_sin;
++#endif
+     struct stat st;
+ 
+     /*
+@@ -172,13 +181,20 @@ char  **argv;
+     if (NOT_INADDR(server) == 0 || HOSTNAME_KNOWN(server)) {
+ 	if ((hp = find_inet_addr(server)) == 0)
+ 	    exit(1);
++#ifndef INET6
+ 	memset((char *) &amp;server_sin, 0, sizeof(server_sin));
+ 	server_sin.sin_family = AF_INET;
++#endif
+ 	request_set(&amp;request, RQ_SERVER_SIN, &amp;server_sin, 0);
+ 
++#ifdef INET6
++	for (res = hp, count = 0; res; res = res-&gt;ai_next, count++) {
++	    memcpy(&amp;server_sin, res-&gt;ai_addr, res-&gt;ai_addrlen);
++#else
+ 	for (count = 0; (addr = hp-&gt;h_addr_list[count]) != 0; count++) {
+ 	    memcpy((char *) &amp;server_sin.sin_addr, addr,
+ 		   sizeof(server_sin.sin_addr));
++#endif
+ 
+ 	    /*
+ 	     * Force evaluation of server host name and address. Host name
+@@ -194,7 +210,11 @@ char  **argv;
+ 	    fprintf(stderr, &quot;Please specify an address instead\n&quot;);
+ 	    exit(1);
+ 	}
++#ifdef INET6
++	freeaddrinfo(hp);
++#else
+ 	free((char *) hp);
++#endif
+     } else {
+ 	request_set(&amp;request, RQ_SERVER_NAME, server, 0);
+     }
+@@ -208,6 +228,18 @@ char  **argv;
+ 	tcpdmatch(&amp;request);
+ 	exit(0);
+     }
++#ifdef INET6
++    memset(&amp;hints, 0, sizeof(hints));
++    hints.ai_family = AF_INET6;
++    hints.ai_socktype = SOCK_STREAM;
++    hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;
++    if (getaddrinfo(client, NULL, &amp;hints, &amp;res) == 0) {
++	freeaddrinfo(res);
++	request_set(&amp;request, RQ_CLIENT_ADDR, client, 0);
++	tcpdmatch(&amp;request);
++	exit(0);
++    }
++#endif
+ 
+     /*
+      * Perhaps they are testing special client hostname patterns that aren't
+@@ -229,6 +261,34 @@ char  **argv;
+      */
+     if ((hp = find_inet_addr(client)) == 0)
+ 	exit(1);
++#ifdef INET6
++    request_set(&amp;request, RQ_CLIENT_SIN, &amp;client_sin, 0);
++
++    for (res = hp, count = 0; res; res = res-&gt;ai_next, count++) {
++	memcpy(&amp;client_sin, res-&gt;ai_addr, res-&gt;ai_addrlen);
++
++	/*
++	 * getnameinfo() doesn't do reverse lookup against link-local
++	 * address.  So, we pass through host name evaluation against
++	 * such addresses.
++	 */
++	if (res-&gt;ai_family != AF_INET6 ||
++	    !IN6_IS_ADDR_LINKLOCAL(&amp;((struct sockaddr_in6 *)res-&gt;ai_addr)-&gt;sin6_addr)) {
++	    /*
++	     * Force evaluation of client host name and address. Host name
++	     * conflicts will be reported while eval_hostname() does its job.
++	     */
++	    request_set(&amp;request, RQ_CLIENT_NAME, &quot;&quot;, RQ_CLIENT_ADDR, &quot;&quot;, 0);
++	    if (STR_EQ(eval_hostname(request.client), unknown))
++		tcpd_warn(&quot;host address %s-&gt;name lookup failed&quot;,
++			  eval_hostaddr(request.client));
++	}
++	tcpdmatch(&amp;request);
++	if (res-&gt;ai_next)
++	    printf(&quot;\n&quot;);
++    }
++    freeaddrinfo(hp);
++#else
+     memset((char *) &amp;client_sin, 0, sizeof(client_sin));
+     client_sin.sin_family = AF_INET;
+     request_set(&amp;request, RQ_CLIENT_SIN, &amp;client_sin, 0);
+@@ -250,6 +310,7 @@ char  **argv;
+ 	    printf(&quot;\n&quot;);
+     }
+     free((char *) hp);
++#endif
+     exit(0);
+ }
+ 
+diff -up tcp_wrappers_7.6/tli.c.patch9 tcp_wrappers_7.6/tli.c
+--- tcp_wrappers_7.6/tli.c.patch9	1997-03-21 19:27:26.000000000 +0100
++++ tcp_wrappers_7.6/tli.c	2008-08-29 09:45:12.000000000 +0200
+@@ -65,8 +65,13 @@ static void tli_sink();
+ void    tli_host(request)
+ struct request_info *request;
+ {
++#ifdef INET6
++    static struct sockaddr_storage client;
++    static struct sockaddr_storage server;
++#else
+     static struct sockaddr_in client;
+     static struct sockaddr_in server;
++#endif
+ 
+     /*
+      * If we discover that we are using an IP transport, pretend we never
+@@ -76,14 +81,29 @@ struct request_info *request;
+ 
+     tli_endpoints(request);
+     if ((request-&gt;config = tli_transport(request-&gt;fd)) != 0
++#ifdef INET6
++	&amp;&amp; (STR_EQ(request-&gt;config-&gt;nc_protofmly, &quot;inet&quot;) ||
++	    STR_EQ(request-&gt;config-&gt;nc_protofmly, &quot;inet6&quot;))) {
++#else
+ 	&amp;&amp; STR_EQ(request-&gt;config-&gt;nc_protofmly, &quot;inet&quot;)) {
++#endif
+ 	if (request-&gt;client-&gt;unit != 0) {
++#ifdef INET6
++	    client = *(struct sockaddr_storage *) request-&gt;client-&gt;unit-&gt;addr.buf;
++	    request-&gt;client-&gt;sin = (struct sockaddr *) &amp;client;
++#else
+ 	    client = *(struct sockaddr_in *) request-&gt;client-&gt;unit-&gt;addr.buf;
+ 	    request-&gt;client-&gt;sin = &amp;client;
++#endif
+ 	}
+ 	if (request-&gt;server-&gt;unit != 0) {
++#ifdef INET6
++	    server = *(struct sockaddr_storage *) request-&gt;server-&gt;unit-&gt;addr.buf;
++	    request-&gt;server-&gt;sin = (struct sockaddr *) &amp;server;
++#else
+ 	    server = *(struct sockaddr_in *) request-&gt;server-&gt;unit-&gt;addr.buf;
+ 	    request-&gt;server-&gt;sin = &amp;server;
++#endif
+ 	}
+ 	tli_cleanup(request);
+ 	sock_methods(request);
+@@ -187,7 +207,15 @@ int     fd;
+     }
+     while (config = getnetconfig(handlep)) {
+ 	if (stat(config-&gt;nc_device, &amp;from_config) == 0) {
++#ifdef NO_CLONE_DEVICE
++	/*
++	 * If the network devices are not cloned (as is the case for
++	 * Solaris 8 Beta), we must compare the major device numbers.
++	 */
++	    if (major(from_config.st_rdev) == major(from_client.st_rdev))
++#else
+ 	    if (minor(from_config.st_rdev) == major(from_client.st_rdev))
++#endif
+ 		break;
+ 	}
+     }
+diff -up tcp_wrappers_7.6/update.c.patch9 tcp_wrappers_7.6/update.c
+--- tcp_wrappers_7.6/update.c.patch9	1994-12-28 17:42:56.000000000 +0100
++++ tcp_wrappers_7.6/update.c	2008-08-29 09:45:12.000000000 +0200
+@@ -46,10 +46,18 @@ va_list ap;
+ 	    request-&gt;fd = va_arg(ap, int);
+ 	    continue;
+ 	case RQ_CLIENT_SIN:
++#ifdef INET6
++	    request-&gt;client-&gt;sin = va_arg(ap, struct sockaddr *);
++#else
+ 	    request-&gt;client-&gt;sin = va_arg(ap, struct sockaddr_in *);
++#endif
+ 	    continue;
+ 	case RQ_SERVER_SIN:
++#ifdef INET6
++	    request-&gt;server-&gt;sin = va_arg(ap, struct sockaddr *);
++#else
+ 	    request-&gt;server-&gt;sin = va_arg(ap, struct sockaddr_in *);
++#endif
+ 	    continue;
+ 
+ 	    /*
+diff -up tcp_wrappers_7.6/workarounds.c.patch9 tcp_wrappers_7.6/workarounds.c
+--- tcp_wrappers_7.6/workarounds.c.patch9	1996-03-19 16:22:26.000000000 +0100
++++ tcp_wrappers_7.6/workarounds.c	2008-08-29 09:45:12.000000000 +0200
+@@ -166,11 +166,22 @@ struct sockaddr *sa;
+ int    *len;
+ {
+     int     ret;
++#ifdef INET6
++    struct sockaddr *sin = sa;
++#else
+     struct sockaddr_in *sin = (struct sockaddr_in *) sa;
++#endif
+ 
+     if ((ret = getpeername(sock, sa, len)) &gt;= 0
++#ifdef INET6
++	&amp;&amp; ((sin-&gt;su_si.si_family == AF_INET6
++	     &amp;&amp; IN6_IS_ADDR_UNSPECIFIED(&amp;sin-&gt;su_sin6.sin6_addr))
++	    || (sin-&gt;su_si.si_family == AF_INET
++		&amp;&amp; sin-&gt;su_sin.sin_addr.s_addr == 0))) {
++#else
+ 	&amp;&amp; sa-&gt;sa_family == AF_INET
+ 	&amp;&amp; sin-&gt;sin_addr.s_addr == 0) {
++#endif
+ 	errno = ENOTCONN;
+ 	return (-1);
+     } else {

Added: trunk/rpms/tcp_wrappers/tcp_wrappers_7.6-249430.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcp_wrappers_7.6-249430.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcp_wrappers_7.6-249430.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,14 @@
+diff -up tcp_wrappers_7.6/hosts_access.c.patch22 tcp_wrappers_7.6/hosts_access.c
+--- tcp_wrappers_7.6/hosts_access.c.patch22	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/hosts_access.c	2008-08-29 09:45:12.000000000 +0200
+@@ -426,7 +426,9 @@ char   *string;
+     if ((addr = dot_quad_addr(string)) == INADDR_NONE)
+ 	return (NO);
+     if ((net = dot_quad_addr(net_tok)) == INADDR_NONE
+-	|| (mask = dot_quad_addr(mask_tok)) == INADDR_NONE) {
++	|| ((mask = dot_quad_addr(mask_tok)) == INADDR_NONE
++	    &amp;&amp; strcmp(mask_tok, &quot;255.255.255.255&quot;))) {
++	/* 255.255.255.255 == INADDR_NONE, separate check needed. TJ. */
+ #ifndef INET6
+ 	tcpd_warn(&quot;bad net/mask expression: %s/%s&quot;, net_tok, mask_tok);
+ #endif

Added: trunk/rpms/tcp_wrappers/tcpw7.2-config.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcpw7.2-config.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcpw7.2-config.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,94 @@
+diff -up tcp_wrappers_7.6/Makefile.patch1 tcp_wrappers_7.6/Makefile
+--- tcp_wrappers_7.6/Makefile.patch1	1997-03-21 19:27:21.000000000 +0100
++++ tcp_wrappers_7.6/Makefile	2008-08-29 09:45:12.000000000 +0200
+@@ -44,7 +44,7 @@ what:
+ #REAL_DAEMON_DIR=/usr/etc
+ #
+ # SysV.4 Solaris 2.x OSF AIX
+-#REAL_DAEMON_DIR=/usr/sbin
++REAL_DAEMON_DIR=/usr/sbin
+ #
+ # BSD 4.4
+ #REAL_DAEMON_DIR=/usr/libexec
+@@ -144,7 +144,7 @@ freebsd:
+ linux:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+ 	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ=setenv.o \
+-	NETGROUP= TLI= EXTRA_CFLAGS=&quot;-DBROKEN_SO_LINGER&quot; all
++	NETGROUP= TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER&quot; all
+ 
+ # This is good for many SYSV+BSD hybrids with NIS, probably also for HP-UX 7.x.
+ hpux hpux8 hpux9 hpux10:
+@@ -491,7 +491,7 @@ VSYSLOG	= -Dvsyslog=myvsyslog
+ # Uncomment the next definition to turn on the language extensions
+ # (examples: allow, deny, banners, twist and spawn).
+ # 
+-#STYLE	= -DPROCESS_OPTIONS	# Enable language extensions.
++STYLE	= -DPROCESS_OPTIONS	# Enable language extensions.
+ 
+ ################################################################
+ # Optional: Changing the default disposition of logfile records
+@@ -514,7 +514,8 @@ VSYSLOG	= -Dvsyslog=myvsyslog
+ #
+ # The LOG_XXX names below are taken from the /usr/include/syslog.h file.
+ 
+-FACILITY= LOG_MAIL	# LOG_MAIL is what most sendmail daemons use
++#FACILITY= LOG_MAIL 	# LOG_MAIL is what most sendmail daemons use
++FACILITY= LOG_AUTHPRIV	# LOG_AUTHPRIV is more appropriate for RH 2.0
+ 
+ # The syslog priority at which successful connections are logged.
+ 
+@@ -531,7 +532,7 @@ SEVERITY= LOG_INFO	# LOG_INFO is normall
+ # and with Solaris &lt; 2.4. APPEND_DOT will not work with hostnames taken
+ # from /etc/hosts or from NIS maps. It does work with DNS through NIS.
+ #
+-# DOT= -DAPPEND_DOT
++DOT= -DAPPEND_DOT
+ 
+ ##################################################
+ # Optional: Always attempt remote username lookups
+@@ -551,7 +552,7 @@ SEVERITY= LOG_INFO	# LOG_INFO is normall
+ # still do selective username lookups as documented in the hosts_access.5
+ # and hosts_options.5 manual pages (`nroff -man' format).
+ #
+-#AUTH	= -DALWAYS_RFC931
++AUTH	= #-DALWAYS_RFC931
+ #
+ # The default username lookup timeout is 10 seconds. This may not be long
+ # enough for slow hosts or networks, but is enough to irritate PC users.
+@@ -610,7 +611,7 @@ TABLES	= -DHOSTS_DENY=\&quot;/etc/hosts.deny\
+ # Paranoid mode implies hostname lookup. In order to disable hostname
+ # lookups altogether, see the next section.
+ 
+-PARANOID= -DPARANOID
++PARANOID= #-DPARANOID
+ 
+ ########################################
+ # Optional: turning off hostname lookups
+@@ -623,7 +624,7 @@ PARANOID= -DPARANOID
+ # In order to perform selective hostname lookups, disable paranoid
+ # mode (see previous section) and comment out the following definition.
+ 
+-HOSTNAME= -DALWAYS_HOSTNAME
++HOSTNAME= #-DALWAYS_HOSTNAME
+ 
+ #############################################
+ # Optional: Turning on host ADDRESS checking
+@@ -649,7 +650,7 @@ HOSTNAME= -DALWAYS_HOSTNAME
+ # source-routed traffic in the kernel. Examples: 4.4BSD derivatives,
+ # Solaris 2.x, and Linux. See your system documentation for details.
+ #
+-# KILL_OPT= -DKILL_IP_OPTIONS
++KILL_OPT= -DKILL_IP_OPTIONS
+ 
+ ## End configuration options
+ ############################
+@@ -659,7 +660,7 @@ HOSTNAME= -DALWAYS_HOSTNAME
+ SHELL	= /bin/sh
+ .c.o:;	$(CC) $(CFLAGS) -c $*.c
+ 
+-CFLAGS	= -O -DFACILITY=$(FACILITY) $(ACCESS) $(PARANOID) $(NETGROUP) \
++CFLAGS	= -DFACILITY=$(FACILITY) $(ACCESS) $(PARANOID) $(NETGROUP) \
+ 	$(BUGS) $(SYSTYPE) $(AUTH) $(UMASK) \
+ 	-DREAL_DAEMON_DIR=\&quot;$(REAL_DAEMON_DIR)\&quot; $(STYLE) $(KILL_OPT) \
+ 	-DSEVERITY=$(SEVERITY) -DRFC931_TIMEOUT=$(RFC931_TIMEOUT) \

Added: trunk/rpms/tcp_wrappers/tcpw7.2-setenv.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcpw7.2-setenv.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcpw7.2-setenv.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,12 @@
+diff -up tcp_wrappers_7.6/Makefile.patch2 tcp_wrappers_7.6/Makefile
+--- tcp_wrappers_7.6/Makefile.patch2	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/Makefile	2008-08-29 09:45:12.000000000 +0200
+@@ -143,7 +143,7 @@ freebsd:
+ 
+ linux:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+-	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ=setenv.o \
++	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= \
+ 	NETGROUP= TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER&quot; all
+ 
+ # This is good for many SYSV+BSD hybrids with NIS, probably also for HP-UX 7.x.

Added: trunk/rpms/tcp_wrappers/tcpw7.6-netgroup.patch
===================================================================
--- trunk/rpms/tcp_wrappers/tcpw7.6-netgroup.patch	                        (rev 0)
+++ trunk/rpms/tcp_wrappers/tcpw7.6-netgroup.patch	2009-12-25 14:36:16 UTC (rev 8232)
@@ -0,0 +1,14 @@
+diff -up tcp_wrappers_7.6/Makefile.patch3 tcp_wrappers_7.6/Makefile
+--- tcp_wrappers_7.6/Makefile.patch3	2008-08-29 09:45:12.000000000 +0200
++++ tcp_wrappers_7.6/Makefile	2008-08-29 09:45:12.000000000 +0200
+@@ -143,8 +143,8 @@ freebsd:
+ 
+ linux:
+ 	@make REAL_DAEMON_DIR=$(REAL_DAEMON_DIR) STYLE=$(STYLE) \
+-	LIBS= RANLIB=ranlib ARFLAGS=rv AUX_OBJ= \
+-	NETGROUP= TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER&quot; all
++	LIBS=&quot;-lnsl&quot; RANLIB=ranlib ARFLAGS=rv AUX_OBJ= \
++	NETGROUP=&quot;-DNETGROUP&quot; TLI= EXTRA_CFLAGS=&quot;$(RPM_OPT_FLAGS) -DSYS_ERRLIST_DEFINED -DBROKEN_SO_LINGER&quot; all
+ 
+ # This is good for many SYSV+BSD hybrids with NIS, probably also for HP-UX 7.x.
+ hpux hpux8 hpux9 hpux10:


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007026.html">[svn] r8231 - in trunk/rpms: . pnp4nagios
</A></li>
	<LI>Next message: <A HREF="007028.html">[svn] r8233 - in trunk/rpms: . powerman
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7027">[ date ]</a>
              <a href="thread.html#7027">[ thread ]</a>
              <a href="subject.html#7027">[ subject ]</a>
              <a href="author.html#7027">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
