<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r3163 - in trunk/tools/dstat: . examples stats
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r3163%20-%20in%20trunk/tools/dstat%3A%20.%20examples%20stats&In-Reply-To=%3C20050428142127.7C6C75C440F%40pooch.vmhosting.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001964.html">
   <LINK REL="Next"  HREF="001966.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r3163 - in trunk/tools/dstat: . examples stats</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r3163%20-%20in%20trunk/tools/dstat%3A%20.%20examples%20stats&In-Reply-To=%3C20050428142127.7C6C75C440F%40pooch.vmhosting.org%3E"
       TITLE="[svn] r3163 - in trunk/tools/dstat: . examples stats">packagers at lists.rpmforge.net
       </A><BR>
    <I>Thu Apr 28 16:21:27 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="001964.html">[svn] r3162 - in trunk/rpms: perl-Apache-AuthCookie perl-DBD-Chart	perl-DBIx-Recordset perl-Math-GMP perl-Net-RawIP	perl-News-Scan perl-Plucene perl-XML-SimpleObject
</A></li>
        <LI>Next message: <A HREF="001966.html">[svn] r3164 - trunk/tools/yam
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1965">[ date ]</a>
              <a href="thread.html#1965">[ thread ]</a>
              <a href="subject.html#1965">[ subject ]</a>
              <a href="author.html#1965">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2005-04-28 16:21:25 +0200 (Thu, 28 Apr 2005)
New Revision: 3163

Added:
   trunk/tools/dstat/README.examples
   trunk/tools/dstat/README.performance
   trunk/tools/dstat/README.stats
   trunk/tools/dstat/examples/
   trunk/tools/dstat/examples/curstest
   trunk/tools/dstat/examples/mstat.py
   trunk/tools/dstat/examples/read.py
   trunk/tools/dstat/stats/
   trunk/tools/dstat/stats/dstat.py
   trunk/tools/dstat/stats/dstat_battery.py
   trunk/tools/dstat/stats/dstat_cpufreq.py
   trunk/tools/dstat/stats/dstat_dbus.py
   trunk/tools/dstat/stats/dstat_qla2300.py
   trunk/tools/dstat/stats/dstat_thermal.py
   trunk/tools/dstat/stats/dstat_utmp.py
Modified:
   trunk/tools/dstat/ChangeLog
   trunk/tools/dstat/Makefile
   trunk/tools/dstat/README
   trunk/tools/dstat/README.screen
   trunk/tools/dstat/TODO
   trunk/tools/dstat/dstat
   trunk/tools/dstat/dstat.1
   trunk/tools/dstat/dstat.conf
   trunk/tools/dstat/dstat.spec
   trunk/tools/dstat/dstat15
Log:
Preparing release 0.6.0

Modified: trunk/tools/dstat/ChangeLog
===================================================================
--- trunk/tools/dstat/ChangeLog	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/ChangeLog	2005-04-28 14:21:25 UTC (rev 3163)
@@ -1,18 +1,44 @@
-* 0.5.10
-- Restore terminal for all exit situations (Modesto Alexandre)
-- Get ridding of duplicate 'too width' error message in dstat15
+* 0.6.0 - Bettiesbaai - released ../../2005
+- Removed keyboard input prevention patch. (Dbt 304673, Marc Lehmann)
+- Fixed bug with: dstat -tit -I 177
+- Added ipc stats (--ipc)
+- Added lock stats (--lock)
+- Added raw stats (--raw)
+- Added unix stats (--unix)
+- Improved udp stats
+- Reimplemented -I eth0,ide1 (Bert de Bruijn)
+- Smarter /proc handling, seek(0) instead of re-open()
+- Implemented dopen() as a wrapper hash for file descriptors
+- Small speedup improvements after profiling
+- Improvement in handling compatible stats (eg. disk, disk24, disk24old)
+- Added initial values (step=0) for disk, int, page, and sys stats
+- Allowed external tools to use the dstat classes
+- Added example scripts using the dstat classes (mstat.py and read.py)
+- Allowed external modules to be plugged in
+- Added external acpi modules (dstat_battery, dstat_cpufreq and dstat_thermal)
+- Added external modules (dstat_dbus and dstat_utmp)
+- Removed user stat (now in dstat_utmp module)
+- Smaller fixes and overall improvements
+- Improved help output and manpage
+- Added README.examples, README.performance and README.stats
+- Added profiling code (--debug)
+- Rewrote cprint/cprintlist logic
 
-* 0.5.9
+* 0.5.10 - released 08/04/2005
+- Small fix to restore terminal for all exit paths (Dbt 303526, Modesto Alexandre)
+- Get rid of duplicate 'screen width too small' error message in dstat15
+
+* 0.5.9 - released 28/03/2005
 - Make default list total lists (cpu, disk, net)
 - Fix clearline ANSI to work on older (Debian?) rxvt (Joshua Rodman)
-- Improved color/vt100 terminal capabilities logic (Charles Lepple)
+- Improved color/vt100 terminal capabilities logic (Dbt 300288, Charles Lepple)
 - Finally use curses for some of the terminal capabilities logic
 - Improvement to non-tty handling for intermediate updates
 - Small fix to handle the edge of the counters better
 - Prevent keyboard input/echo when running
 
-* 0.5.8
-- Added user stats using python-utmp
+* 0.5.8 - released 15/03/2005
+- Added user stats (-u), using python-utmp
 - Bail out if all requested stats fail
 - Replaced --noheader option by --noheaders option (like vmstat)
 - Added -V as short for --version
@@ -23,13 +49,13 @@
 - Replaced save and restore ANSI to save and restore VT100 (Olav Vitters)
 - Backported dstat to python 1.5 again
 
-* 0.5.7
+* 0.5.7 - released 31/12/2004
 - Change Makefile to not install when run without target (Kurt Roeckx)
 - Fixed another crash caused by /proc instability
 - Added --csv option to output Comma-Seperated-Value output
 - If output is not a tty, don't care about line-width
 
-* 0.5.6
+* 0.5.6 - released 20/12/2004
 - Made sys and int stats unit-aware (so 10000 int/sec -&gt; 10.0k) (Anton Blanchard)
 - Improve conv() function and stat show() functions
 - Improved the calculation of the cpu usage
@@ -49,18 +75,18 @@
 - Improvement in output, 10.0k or 5.0 will be displayed simply as 10k or 5
 - proc stats now show floats
 
-* 0.5.5
+* 0.5.5 - released 02/12/2004
 - In fact, round() was not the problem, use str() instead. (Anton Blanchard)
 - Abandoned the use of round() as it is limited to integers (Juergen Kreileder)
 
-* 0.5.4
+* 0.5.4 - released 25/10/2004
 - Added a python 1.5 version of dstat (Ville Herva)
 - Fixed a problem with count
 - Improved the logic for displaying repetitive headers
 - Now --nocolor implies --noupdate (since it implies no ANSI escape sequences)
 - Removed the 'Exiting on user request' message
 
-* 0.5.3
+* 0.5.3 - released 21/10/2004
 - Added -M or --mods option to allow modules
 - Added --full option to expand the -D, -I and -N discovery lists
 - Re-added the number of new processes (the --vmstat will no longer resemble vmstat)
@@ -72,17 +98,17 @@
 - Signal handling cleanup
 - Partitions are excluded from discovery on 2.4 kernels
 
-* 0.5.2
+* 0.5.2 - released 13/10/2004
 - Improved disk and net discovery functions (Ville Herva)
 - Fixed a bug with values when using --noupdate (Pasi Pirhonen)
 - Documented the internals a bit more, hoping people will contribute
 - Implemented a fix for when the output exceeds terminal columns
 
-* 0.5.1
+* 0.5.1 - released 11/10/2004
 - Fixed bug that caused counters to not be averages when delay &gt; 1
 - Added time stats (-t)
 
-* 0.5
+* 0.5 - released 11/10/2004
 - Changed some more int()'s into long()'s (Pasi Pirhonen)
 - Fixed the cpu out of index, /proc instability (Pasi Pirhonen)
 - Improved the rounding function
@@ -94,7 +120,7 @@
 - When counters roll over, show dash
 - Fixed 2 crash bugs caused by /proc instability
 
-* 0.4
+* 0.4 - released 26/10/2004
 - Added interrupt stats (-i)
 - Order of the stats adhere the order of the options
 - Interval more precise, using signals instead of sleep
@@ -122,6 +148,9 @@
 - Converted all values to bytes
 
 * 0.2
-- Added disk io (-d)
+- Added disk io stats (-d)
 - Added proc stats (-p)
 - Important layout changes
+
+* 0.1
+- Initial release

Modified: trunk/tools/dstat/Makefile
===================================================================
--- trunk/tools/dstat/Makefile	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/Makefile	2005-04-28 14:21:25 UTC (rev 3163)
@@ -11,6 +11,34 @@
 #	-[ ! -f $(DESTDIR)$(sysconfdir)/dstat.conf ] &amp;&amp; install -D -m0644 dstat.conf $(DESTDIR)$(sysconfdir)/dstat.conf
 	install -Dp -m0755 dstat $(DESTDIR)$(bindir)/dstat
 	install -Dp -m0644 dstat.1 $(DESTDIR)$(mandir)/man1/dstat.1
+	install -d -m0755 $(DESTDIR)$(datadir)/dstat/
+	install -Dp -m0755 stats/*.py $(DESTDIR)$(datadir)/dstat/
+#	install -d -m0755 $(DESTDIR)$(datadir)/dstat/examples/
+#	install -Dp -m0755 examples/*.py $(DESTDIR)$(datadir)/dstat/examples/
 
 clean:
-	@echo &quot;No clean phase.&quot;
+	rm -f dstat15.tr examples/*.pyc
+
+#### Imperfect translation to dstat15
+tr:
+	@cat dstat | perl -p -e ' \
+			next if (s|(\S+)\.center\((.+)\)\.replace\((.+), (.+)\)|string.replace(string.center($$1, $$2), $$3, $$4)|g); \
+			next if (s|(.[-?] .)\.rjust\((\S+)\)|string.rjust\($$1, $$2\)|g); \
+			next if (s|(. .)\.join\(l\[cpunr\+2:\]\)\.split\((.,.)\)|string.split(string.join(l[cpunr+2:], $$1), $$2)|g); \
+			next if (s|self\.intmap\[(\S+)\.strip\(\)\.lower\(\)\]|self.intmap[string.strip(string.lower($$1))]|g); \
+			next if (s|\((.0.) \+ (. .) \* len\((\S+)\)\)\.rjust\((\S+)\)|string.rjust($$1 + $$2 * len($$3), $$4)|g); \
+			next if (s|(\S+)\.replace\((.:.), (. .)\)\.split\(\)|string.split(string.replace($$1, $$2, $$3))|g); \
+			s|(\S+)\.replace\((.+), (.+)\)|string.replace($$1, $$2, $$3)|g; \
+			s|(\S+)\.rjust\((.+)\)|string.rjust($$1, $$2)|g; \
+			s|(\S+)\.center\((.+)\)|string.center($$1, $$2)|g; \
+			s|(\S+)\.strip\((.+)\)|string.strip($$1, $$2)|g; \
+			s|(\S+)\.split\((.+)\)|string.split($$1, $$2)|g; \
+			s|(\S+)\.rjust\(\)|string.rjust($$1)|g; \
+			s|(\S+)\.center\(\)|string.center($$1)|g; \
+			s|(\S+)\.strip\(\)|string.strip($$1)|g; \
+			s|(\S+)\.split\(\)|string.split($$1)|g; \
+			s|(\w+)\.lower\(\)|string.lower($$1)|g; \
+			s|long\(round\(var\)|int\(round\(var\)|g; \
+			s|, time$$|, time, string|g; \
+		' &gt;dstat15.tr
+	@chmod a+x dstat15.tr

Modified: trunk/tools/dstat/README
===================================================================
--- trunk/tools/dstat/README	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/README	2005-04-28 14:21:25 UTC (rev 3163)
@@ -8,16 +8,20 @@
 
 Dstat also cleverly gives you the most detailed information in
 columns and clearly indicates in what magnitude and unit the output
-is displayed. Less confusion, less mistakes.
+is displayed. Less confusion, less mistakes, more efficient.
 
-Dstat is also unique in letting you aggregate block device throughput
-for a certain diskset or network bandwidth for a group of interfaces,
-ie. you can see the throughput for all the block devices that make up
-a single filesystem or storage system.
+Dstat is unique in letting you aggregate block device throughput for
+a certain diskset or network bandwidth for a group of interfaces, ie.
+you can see the throughput for all the block devices that make up a
+single filesystem or storage system.
 
-You can customize your dstat output from /etc/dstat.conf and you can
-write your own dstat modules to plug into the dstat output.
+Dstat allows its data to be directly written to a CSV file to be
+imported and used by OpenOffice, Gnumeric or Excelto create graphs.
 
-Dstat's output, in its current form, is not very useful to be post-
-processed by other tools. It's mostly meant for allowing humans to
-interprete real-time data as easy as possible.
+Since it's practically impossible to test dstat on every possible
+permutation of kernel , python or distribution version, I need your
+help and your feedback to fix the remaining problems.
+
+If you have improvements or bugreports, please send them to:
+
+	&lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;

Added: trunk/tools/dstat/README.examples
===================================================================
--- trunk/tools/dstat/README.examples	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/README.examples	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,16 @@
+Dstat examples
+&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
+I've written a few examples that make use of the dstat classes.
+
+The following examples currently exist:
+
+	read.py	- shows how to access dstat data
+	mstat.py - small sub-second ministat tool
+
+Please send other examples or tools that make use of dstat classes
+or changes to extend the current infrastructure.
+
+I'm not particularly happy with how to interface with dstat from
+the outside, so any hints on how to improve it are welcome.
+
+Please send feedback to: &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;

Added: trunk/tools/dstat/README.performance
===================================================================
--- trunk/tools/dstat/README.performance	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/README.performance	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,17 @@
+Dstat performance
+&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
+Since dstat is written in python, it's not optimized for performance.
+
+When doing performance analysis, it's important to verify that the
+monitoring tool is not messing with the performance numbers.
+
+Depending on the stats being used and the load on the server itself
+the impact Dstat has on the system you're monitoring might be
+considerable.
+
+Before performing any tests please verify for yourself what impact
+Dstat has on your test results and keep that in mind when analysing
+the results afterwards.
+
+In case the impact is higher than expected, reduce the number of stats
+and remove expensive stats.

Modified: trunk/tools/dstat/README.screen
===================================================================
--- trunk/tools/dstat/README.screen	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/README.screen	2005-04-28 14:21:25 UTC (rev 3163)
@@ -1,9 +1,10 @@
 Configuring screen to display multiple dstat for different systems
 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
-It saved me a lot of work after I discovered the split screen functionality
-and how it worked exactly. Here is an example of how I would monitor 5 nodes
-in a cluster with a minimum of effort:
+Here is an example of how I monitor 5 nodes in a cluster with a minimum
+of effort using screen:
 
+Put the following content in a file called screenrc-5nodes:
+
 	startup_message off
 	defwrap off
 	split
@@ -20,8 +21,8 @@
 	focus down
 	screen -t node05 5 ssh -t 172.17.0.215 'dstat -cdnyp --tcp --udp -l -D lores,hires -N bond0,eth0,eth2,eth3 10'
 
-Put this in a file named screenrc-5nodes and then set the environment
-variable to tell screen to use this config-file for the next screen.
+Then set the environment variable to tell screen to use this config-file
+for the next screen.
 
 	SCREENRC='screenrc-5nodes' screen
 
@@ -35,3 +36,5 @@
 	ctrl-c
 
 5 times.
+
+If you have other tips or hints, please send them to: &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;

Added: trunk/tools/dstat/README.stats
===================================================================
--- trunk/tools/dstat/README.stats	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/README.stats	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,36 @@
+External dstat modules
+&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
+The core functionality of dstat is self-contained inside the dstat script,
+but it is possible to add your own dstat modules. Currently only the
+following external modules exist:
+
+	dstat_battery
+	dstat_cpufreq
+	dstat_dbus
+	dstat_thermal
+	dstat_utmp
+
+You can enable one of these stats by using the -M options:
+
+	dstat -a -M dbus,utmp
+
+Currently I foresee that all stats that depend on something else than
+just the kernel or the stock python modules are implemented as external
+modules. Also experimental modules or modules that are expensive should
+be external.
+
+Future possible external modules:
+
+	dstat_amavisd
+	dstat_apache
+	dstat_bind
+	dstat_dhcpd
+	dstat_dnsmasq
+	dstat_gfs
+	dstat_gpfs (needs a fast /proc interface)
+	dstat_nfs
+	dstat_postfix
+	dstat_qla2300
+	dstat_samba (needs a python tdb implementation)
+	dstat_sendmail
+	dstat_squid

Modified: trunk/tools/dstat/TODO
===================================================================
--- trunk/tools/dstat/TODO	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/TODO	2005-04-28 14:21:25 UTC (rev 3163)
@@ -1,23 +1,21 @@
 ### Usability
-+ Add --config option and use /etc/dstat.conf to influence output
-+ Allow to force to given magnitude
++ Add --config option and use /etc/dstat.conf and ~/.dstat to influence output (see example dstat.conf)
++ Allow to force to given magnitude (--unit=kilo)
 + Look at possibilities to show deviation (on second line ?)
-+ Find a way to use curses without the flickering and tty clearing in screen
-+ Detect terminal capabilities (colors, ANSI) using curses (?)
-+ Re-implement -I eth0,eth1
 
 ### Export/Graph
-+ Interface with rrdtool
++ Interface with rrdtool (python-rrd ?)
 + Allow for different types of export modules (only CSV now)
 
 ### Extending statistics (help welcome!)
-+ Add all stats to seperate modules and allow people to plugin their own modules
++ Add slab stats (see /proc/slabinfo and slabtop)
++ Add xorg stats (xdpyinfo, xrestop)
 + Add icmp, nfs, ntp stats ?
-+ Add user stats (number of users logged on)
 + Add application stats (-a or -A pid,cmd)
++ Add user stats (number of users logged on, utmp is not that useful, /proc/key-users)
 + Look into interfacing with apps (bind, sendmail, postfix, squid, amavisd, laus, samba)
 + Look into interfacing with specific HW counters in /proc
-+ Look at /proc/slabinfo, /proc/meminfo, /proc/locks, /proc/mdstat, /proc/vmstat
++ Look at /proc/meminfo, /proc/mdstat, /proc/netstat, /proc/snmp, /proc/vmstat
 + Allow for SNMP counters to be added
 
 ### Documentation (help welcome!)
@@ -28,14 +26,15 @@
   (explaining the different uses of tools like dstat, iostat, pmap, strace, tcpdump)
 
 ### General bugs
-+ Timer is not accurate on 2.6 kernel, every second there's a 1ms deviation (every 17mins -&gt; 1sec)
++ Timer is not accurate on 2.6 kernel, every 1 seconds there's a 0.8ms deviation (every 21mins -&gt; 1sec)
 + Python 1.5 prints 'L' for long, crashes when int()
 + If number of lines on terminal &lt;= 1, division by zero
 
 ### Stat bugs
-+ tcp stat is very slow and generates lots of softirqs (on some systems)
 + Implement better (?) protection against counter rollovers
-+ Fix bug with: ./dstat -tit -I 177
++ tcp stat is very slow and generates lots of softirqs (on some systems), to be confirmed
++ proc stats (run, blk and new) does not work on 2.4.30 (possibly 2.4.x), to be confirmed
++ proc stats seem to be off-by-one (some of the time)
 
 ### Redesign (v2.0)
 + Create modules that can contain samples of different units
@@ -48,4 +47,4 @@
 	tps (int)
 	blk_read/sec, blk_wrtn/sec (kB/sec)
 
-+ Design proper object model
++ Design proper object model and namespace for _all_ possible stats

Modified: trunk/tools/dstat/dstat
===================================================================
--- trunk/tools/dstat/dstat	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/dstat	2005-04-28 14:21:25 UTC (rev 3163)
@@ -12,29 +12,60 @@
 ### You should have received a copy of the GNU Library General Public License
 ### along with this program; if not, write to the Free Software
 ### Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-### Copyright 2004 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;
+### Copyright 2004, 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;
 
 from __future__ import generators
 
-import sys
+try:
+	import sys, signal, os, re, time
+	import types, curses, signal, resource
+	sys.path.insert(0, '/usr/share/dstat/')
+except KeyboardInterrupt, e:
+	pass
 
 if sys.version_info &lt; (2, 2):
 	sys.exit('error: Python 2.2 or later required, try dstat15 instead')
 
-import os, re, getopt, time, types
-import ConfigParser, urlparse, signal, resource
-import curses, termios
+### Workaround for python &lt; 2.3
+if not callable(enumerate):
+	if sys.version_info &lt; (2, 3) and sys.version_info &gt;= (2, 2):
+		def enumerate(sequence):
+			index = 0
+			for item in sequence:
+				yield index, item
+				index = index + 1
+	elif sys.version_info &lt; (2, 2):
+		def enumerate(sequence):
+			index = 0
+			list = []
+			for item in sequence:
+				list.append((index, item))
+				index = index + 1
+			return list
 
-VERSION = '0.5.10'
+### Workaround for python &lt; 2.3
+if not callable(sum):
+	def sum(sequence):
+		ret = 0
+		for i in sequence:
+			ret = ret + i
+		return ret
 
-enable = ('yes', 'on', 'true', '1')
-disable = ('no', 'off', 'false', '0')
+### Workaround for python &lt;= 2.2.1
+try:
+	True, False
+except NameError:
+	True = 1
+	False = 0
 
+VERSION = '0.6.0'
+
 class Options:
 	def __init__(self, args):
 		self.args = args
 		self.count = -1
 		self.cpulist = None
+		self.debug = False
 		self.delay = 1
 		self.disklist = None
 		self.full = False
@@ -47,11 +78,19 @@
 		self.header = True
 		self.output = False
 
+		### Temporary hardcoded for my own project
+		self.diskset = {
+			'local': ('sda', 'hd[a-d]'),
+			'lores': ('sd[b-k]', 'sd[v-z]', 'sda[a-e]'),
+			'hires': ('sd[l-u]', 'sda[f-o]'),
+		}
+
 		try:
-			opts, args = getopt.getopt (args, 'acdfghilmnopstuvyC:D:I:M:N:V',
-				['all', 'cpu', 'disk', 'help', 'int', 'load', 'mem', 'net', 'page', 'proc',
-				'swap', 'sys', 'tcp', 'time', 'udp', 'user', 'version', 'vmstat',
-				'full', 'integer', 'mods', 'modules', 'nocolor', 'noheaders', 'noupdate', 'output='])
+			import getopt
+			opts, args = getopt.getopt (args, 'acdfghilmno:pstvyC:D:I:M:N:V',
+				['all', 'cpu', 'disk', 'help', 'int', 'ipc', 'load', 'lock', 'mem', 'net', 'page',
+				'proc', 'raw', 'swap', 'sys', 'tcp', 'time', 'udp', 'unix', 'version', 'vmstat',
+				'debug', 'full', 'integer', 'mods', 'modules', 'nocolor', 'noheaders', 'noupdate', 'output='])
 		except getopt.error, exc:
 			print 'dstat: %s, try dstat -h for a list of all the options' % str(exc)
 			exit(1)
@@ -67,45 +106,53 @@
 				self.modlist.append('disk')
 			elif opt in ['-D']:
 				self.disklist = arg.split(',')
+			elif opt in ['--debug']:
+				self.debug = True
+			elif opt in ['-g', '--page']:
+				self.modlist.append('page')
 			elif opt in ['-i', '--int']:
 				self.modlist.append('int')
-			elif opt in ['-g', '--page']:
-				self.modlist.append('page')
 			elif opt in ['-I']:
 				self.intlist = arg.split(',')
+			elif opt in ['--ipc']:
+				self.modlist.append('ipc')
+			elif opt in ['-l', '--load']:
+				self.modlist.append('load')
+			elif opt in ['--lock']:
+				self.modlist.append('lock')
 			elif opt in ['-m', '--mem']:
 				self.modlist.append('mem')
 			elif opt in ['-M', '--mods', '--modules']:
 				self.modlist = self.modlist + arg.split(',')
-			elif opt in ['-l', '--load']:
-				self.modlist.append('load')
 			elif opt in ['-n', '--net']:
 				self.modlist.append('net')
 			elif opt in ['-N']:
 				self.netlist = arg.split(',')
 			elif opt in ['-p', '--proc']:
 				self.modlist.append('proc')
+			elif opt in ['--raw']:
+				self.modlist.append('raw')
 			elif opt in ['-s', '--swap']:
 				self.modlist.append('swap')
 			elif opt in ['--tcp']:
 				self.modlist.append('tcp')
 			elif opt in ['-t', '--time']:
 				self.modlist.append('time')
-			elif opt in ['-u', '--user']:
-				self.modlist.append('user')
 			elif opt in ['--udp']:
 				self.modlist.append('udp')
+			elif opt in ['--unix']:
+				self.modlist.append('unix')
 			elif opt in ['-y', '--sys']:
 				self.modlist.append('sys')
 
 			elif opt in ['-a', '--all']:
-				self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys', 'load' ]
+				self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys' ]
 			elif opt in ['-v', '--vmstat']:
 				self.modlist = self.modlist + [ 'proc', 'mem', 'page', 'disk', 'sys', 'cpu' ]
 				self.disklist = ('total',)
-
 			elif opt in ['-f', '--full']:
 				self.full = True
+
 			elif opt in ['--integer']:
 				self.integer = True
 			elif opt in ['--nocolor']:
@@ -153,99 +200,97 @@
 		print 'Clock ticks per secs: %d' % os.sysconf('SC_CLK_TCK')
 
 	def usage(self):
-		print 'usage: dstat [-afv] [-cdgilmnpsty] [-D..] [-I..] [-N..] [delay [count]]'
+		print 'Usage: dstat [-afv] [-cdgilmnpsty] [-C..] [-D..] [-I..] [-N..] [delay [count]]'
 
 	def help(self):
 		print '''Versatile tool for generating system resource statistics
 
 Dstat options:
-  -c, --cpu                enable cpu stats
-     -C 0,3,                  include cpu0, cpu3 and total
-  -d, --disk               enable disk stats
-     -D total,hda             include hda and total
-  -g, --page               enable page stats
-  -i, --int                enable interrupt stats
-     -I 5,eth2                include int5 and interrupt used by eth2
-  -l, --load               enable load stats
-  -m, --mem                enable memory stats
-  -n, --net                enable network stats
-     -N eth1,total            include eth1 and total
-  -p, --proc               enable process stats
-  -s, --swap               enable swap stats
-  -t, --time               enable time counter
-  -u, --user               enable user stats
-  -y, --sys                enable system stats
+  -c, --cpu              enable cpu stats
+     -C 0,3,                include cpu0, cpu3 and total
+  -d, --disk             enable disk stats
+     -D total,hda           include hda and total
+  -g, --page             enable page stats
+  -i, --int              enable interrupt stats
+     -I 5,eth2              include int5 and interrupt used by eth2
+  -l, --load             enable load stats
+  -m, --mem              enable memory stats
+  -n, --net              enable network stats
+     -N eth1,total          include eth1 and total
+  -p, --proc             enable process stats
+  -s, --swap             enable swap stats
+  -t, --time             enable time counter
+  -y, --sys              enable system stats
+  --ipc                  enable ipc stats
+  --lock                 enable lock stats
+  --raw                  enable raw stats
+  --tcp                  enable tcp stats
+  --udp                  enable udp stats
+  --unix                 enable unix stats
 
-  -M stat1,stat2           enable specific stats
+  -M stat1,stat2         enable external stats
      --mods stat1,stat2
 
-    Possible stats are:
-      cpu, disk, page, int, load, mem, net, proc,
-      swap, sys, tcp, time, udp, user
+  -a, --all              equals -cdngy (default)
+  -f, --full             expand -D, -I and -N discovery lists
+  -v, --vmstat           equals -pmgdsc -D total
 
-  -a, --all          equals -cdngyl
-  -v, --vmstat       equals -pmgdsc -D total
-  -f, --full         expand -D, -I and -N discovery lists
+  --integer              show integer values
+  --nocolor              disable colors (implies --noupdate)
+  --noheaders            disable repetitive headers
+  --noupdate             disable intermediate updates
+  --output file          write CSV output to file
 
-  --integer          show integer values
-  --nocolor          disable colors (implies --noupdate)
-  --noheaders        disable repetitive headers
-  --noupdate         disable intermediate updates when delay &gt; 1
-  --output file      write CSV output to file
-
   delay is the delay in seconds between each update
   count is the number of updates to display before exiting
-  The default delay is zero and count is one
+  The default delay is 1 and count is unspecified (unlimited)
 '''
 
-class Config:
-	def __init__(self):
-		self.configfile = op.configfile
-		self.cfg = ConfigParser.ConfigParser()
+### START STATS DEFINITIONS ###
 
-		(s,b,p,q,f,o) = urlparse.urlparse(self.configfile)
-		if s in ('http', 'ftp', 'file'):
-			configfh = urllib.urlopen(self.configfile)
-			try:
-				self.cfg.readfp(configfh)
-			except ConfigParser.MissingSectionHeaderError, e:
-				die(6, 'Error accessing URL: %s' % self.configfile)
-		else:
-			if os.access(self.configfile, os.R_OK):
-				try:
-					self.cfg.read(self.configfile)
-				except:
-					die(7, 'Syntax error reading file: %s' % self.configfile)
+class dstat:
+	### Initialise default variables
+	def init(self, vars=(), len=0):
+		if vars:
+			self.val = {}; self.cn1 = {}; self.cn2 = {}
+			for name in vars:
+				if len &lt;= 1:
+					self.val[name] = self.cn1[name] = self.cn2[name] = 0
+				else:
+					self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
+					for i in range(len):
+						self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
+
+	def __repr__(self):
+		&quot;Display stat results&quot;
+		line = ''
+		for i, name in enumerate(self.vars):
+			if isinstance(self.val[name], types.TupleType) or isinstance(self.val[name], types.ListType):
+				line = line + cprintlist(self.val[name], self.format)
+				sep = ansi['default'] + char['colon']
 			else:
-				die(6, 'Error accessing file: %s' % self.configfile)
+				line = line + cprint(self.val[name], self.format)
+				sep = ' '
+			if i + 1 != len(self.vars):
+				line = line + sep
+		return line
 
-	def getoption(self, section, option, var):
-		&quot;Get an option from a section from configfile&quot;
-		try:
-			var = self.cfg.get(section, option)
-			info(3, 'Setting option %s in section [%s] to: %s' % (option, section, var))
-		except ConfigParser.NoSectionError, e:
-			info(4, 'Failed to find section [%s] in %s' % (section, op.configfile))
-		except ConfigParser.NoOptionError, e:
-#			info(4, 'Failed to find option %s in [%s], set to default: %s' % (option, section, var))
-			info(4, 'Setting option %s in section [%s] to: %s (default)' % (option, section, var))
-		return var
+	def open(self, file):
+		&quot;Open stat file descriptor&quot;
+		self.file = file
+		self.fd = dopen(file)
 
-class dstat:
-	def init(self):
-		### Initialise default variables
-		self.val = {}; self.cn1 = {}; self.cn2 = {}
-		for i in self.vars: self.val[i] = self.cn1[i] = self.cn2[i] = 0
-
-	def varwidth(self):
+	def statwidth(self):
+		&quot;Return complete stat width&quot;
 		return len(self.vars) * self.width() + len(self.vars) - 1
 
 	def width(self):
+		&quot;Return column width&quot;
 		if isinstance(self.name, types.StringType):
-			return self.len
+			return self.format[1]
 		else:
 			for name in self.cn2.keys():
-				return len(self.cn2[name]) * self.len + len(self.cn2[name]) - 1
+				return len(self.cn2[name]) * self.format[1] + len(self.cn2[name]) - 1
 			return 0
 
 	def title(self, nr):
@@ -256,7 +301,7 @@
 
 	def title1(self):
 		if isinstance(self.name, types.StringType):
-			max = self.varwidth()
+			max = self.statwidth()
 			return ansi['darkblue'] + self.name[0:max].center(max).replace(' ', '-') + ansi['default']
 		ret = ''
 		for i, name in enumerate(self.name):
@@ -269,14 +314,14 @@
 		if isinstance(self.name, types.StringType):
 			ret = ''
 			for i, nick in enumerate(self.nick):
-				ret = ret + nick.center(self.len).replace(' ', '_')
+				ret = ret + nick.center(self.format[1]).replace(' ', '_')
 				if i + 1 != len(self.nick): ret = ret + ' '
 			return ansi['blue'] + ret
 		else:
 			ret = ''
 			for i, name in enumerate(self.name):
 				for j, nick in enumerate(self.nick):
-					ret = ret + ansi['blue'] + nick.center(self.len).replace(' ', '_')
+					ret = ret + ansi['blue'] + nick.center(self.format[1]).replace(' ', '_')
 					if j + 1 != len(self.nick): ret = ret + ' '
 				if i + 1 != len(self.name): ret = ret + ' '
 			return ansi['blue'] + ret
@@ -314,6 +359,11 @@
 			return ret
 
 	def check(self):
+		&quot;Check if stat is applicable&quot;
+		if not self.vars:
+			return False
+		if hasattr(self, 'fd') and not self.fd:
+			return False
 		if self.discover() and self.width():
 			return True
 		return False
@@ -321,67 +371,43 @@
 	def discover(self):
 		return True
 
-	def stats(self):
-		pass
-
-	def show(self):
-		sep = ' '
-		for i, name in enumerate(self.vars):
-			if self.format in ('%s', '%bs'):
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 1024))
-			elif self.format == '%ds':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 1000))
-			elif self.format == '%ps':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 100))
-			elif self.format == '%is':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 10))
-			elif self.format == '%f':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 1))
-			elif self.format in ('%s %s', '%s:%s', '%s-%s'):
-				sys.stdout.write(self.format % convlist(self.len, self.val[name]))
-				sep = ansi['default'] + char['colon']
-			elif self.format in ('%s %s %s', '%s %s %s %s %s %s'):
-				sys.stdout.write(self.format % convlist(self.len, self.val[name], 100))
-				sep = ansi['default'] + char['colon']
-			else:
-				sys.stdout.write(self.format % self.val[name])
-			if i + 1 != len(self.vars):
-				sys.stdout.write(sep)
-
 	def showend(self, totlist, vislist):
 		if self is not vislist[-1]:
-			sys.stdout.write(ansi['default'] + char['pipe'])
-		elif self is not totlist[-1]:
-			sys.stdout.write(ansi['default'] + char['gt'])
+			return ansi['default'] + char['pipe']
+		elif totlist != vislist:
+			return ansi['default'] + char['gt']
+		return ''
 
 	def showcsv(self):
 		def printcsv(var):
 			if var != round(var):
-				outputfile.write('%.2f' % var)
-			else:
-				outputfile.write('%d' % round(var))
+				return '%.3f' % var
+			return '%s' % round(var)
 
+		line = ''
 		for i, name in enumerate(self.vars):
 			if isinstance(self.val[name], types.ListType) or isinstance(self.val[name], types.TupleType):
 				for j, val in enumerate(self.val[name]):
-					printcsv(val)
+					line = line + printcsv(val)
 					if j + 1 != len(self.val[name]):
-						outputfile.write(',')
+						line = line + ','
 			else:
-				printcsv(self.val[name])
+				line = line + printcsv(self.val[name])
 			if i + 1 != len(self.vars):
-				outputfile.write(',')
+				line = line + ','
+		return line
 
 	def showcsvend(self, totlist, vislist):
 		if self is not vislist[-1]:
-			outputfile.write(',')
+			return ','
 		elif self is not totlist[-1]:
-			outputfile.write(',')
+			return ','
+		return ''
 
 class dstat_cpu(dstat):
 	def __init__(self):
-		self.len = 3
-		self.format = '%s %s %s %s %s %s'
+		self.format = ('p', 3, 34)
+		self.open('/proc/stat')
 		self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
 		self.vars = self.vars()
 		self.name = []
@@ -390,194 +416,194 @@
 				self.name.append('cpu' + name + ' usage')
 			else:
 				self.name.append('total cpu usage')
-		self.init()
-		for name in self.vars: self.cn1[name] = (0, 0, 0, 0, 0, 0); self.cn1[''] = (0, 0, 0, 0, 0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0, 0, 0, 0, 0); self.cn2[''] = (0, 0, 0, 0, 0, 0)
-		for name in self.vars: self.val[name] = [0, 0, 0, 0, 0, 0]; self.val[''] = [0, 0, 0, 0, 0, 0]
+		self.init(self.vars + ['',], 6)
 
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/stat'):
-			for line in open('/proc/stat', 'r').readlines():
-				l = line.split()
-				if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
-				ret.append(l[0][3:])
-			ret.sort()
-			for item in list: ret.append(item)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
+			ret.append(l[0][3:])
+		ret.sort()
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
 		ret = []
 		if op.cpulist:
 			list = op.cpulist
+		elif not op.full:
+			list = ('', )
 		else:
-			if not op.full:
-				list = ('', )
-			else:
-				list = []
-				cpu = 0
-				while cpu &lt; cpunr:
-					list.append(str(cpu))
-					cpu = cpu + 1
-				if len(list) &gt; 2: list = list[0:2]
+			list = []
+			cpu = 0
+			while cpu &lt; cpunr:
+				list.append(str(cpu))
+				cpu = cpu + 1
+			if len(list) &gt; 2: list = list[0:2]
 		for name in list:
 			if name in self.discover(''):
 				ret.append(name)
 		return ret
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
+			if len(l) &lt; 8: continue
 			for name in self.vars:
-				if len(l) &lt; 8 or l[0] != 'cpu' + name: continue
+				if l[0] != 'cpu' + name: continue
 				self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
 		for name in self.vars:
-			for i in (0, 1, 2, 3, 4, 5):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (total(self.cn2[name]) - total(self.cn1[name]))
+			for i in range(6):
+				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_cpu24(dstat):
 	def __init__(self):
-		self.len = 3
-		self.format = '%s %s %s'
+		self.format = ('p', 3, 34)
+		self.open('/proc/stat')
 		self.nick = ( 'usr', 'sys', 'idl')
 		self.vars = self.vars()
-		self.name = []
+		self.name = self.name()
+		self.init(self.vars + ['',], 3)
+
+	def name(self):
+		ret = []
 		for name in self.vars:
 			if name:
-				self.name.append('cpu' + name)
+				ret.append('cpu' + name)
 			else:
-				self.name.append('cpu total')
-		self.init()
-		for name in self.vars: self.cn1[name] = (0, 0, 0); self.cn1[''] = (0, 0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0, 0); self.cn2[''] = (0, 0, 0)
-		for name in self.vars: self.val[name] = [0, 0, 0]; self.val[''] = [0, 0, 0]
+				ret.append('cpu total')
+		return ret
 
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/stat'):
-			for line in open('/proc/stat', 'r').readlines():
-				l = line.split()
-				if len(l) != 5 or l[0][0:3] != 'cpu': continue
-				ret.append(l[0][3:])
-			ret.sort()
-			for item in list: ret.append(item)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if len(l) != 5 or l[0][0:3] != 'cpu': continue
+			ret.append(l[0][3:])
+		ret.sort()
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
 		ret = []
 		if op.cpulist:
 			list = op.cpulist
+		elif not op.full:
+			list = ('', )
 		else:
-			if not op.full:
-				list = ('', )
-			else:
-				list = []
-				cpu = 0
-				while cpu &lt; cpunr:
-					list.append(str(cpu))
-					cpu = cpu + 1
-				if len(list) &gt; 2: list = list[0:2]
+			list = []
+			cpu = 0
+			while cpu &lt; cpunr:
+				list.append(str(cpu))
+				cpu = cpu + 1
+			if len(list) &gt; 2: list = list[0:2]
 		for name in list:
 			if name in self.discover(''):
 				ret.append(name)
 		return ret
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			for name in self.vars:
 				if len(l) &lt; 5 or l[0] != 'cpu' + name: continue
 				self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
 		for name in self.vars:
-			for i in (0, 1, 2):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (total(self.cn2[name]) - total(self.cn1[name]))
+			for i in range(3):
+				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_disk(dstat):
 	def __init__(self):
-		self.format = '%s %s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
+		self.open('/proc/diskstats')
+		self.regexp = re.compile('^(ram\d+|loop\d+)$')
 		self.nick = ('read', 'write')
-		### Temporary hardcoded for my own project
-		self.diskset = {
-			'local': ('sda', 'hda', 'hdc'), 
-			'lores': ('sdb', 'sdc', 'sdd', 'sde', 'sdf', 'sdg', 'sdh', 'sdi', 'sdj', 'sdk', 'sdv', 'sdw', 'sdx', 'sdy', 'sdz', 'sdaa', 'sdab', 'sdac', 'sdad', 'sdae'),
-			'hires': ('sdl', 'sdm', 'sdn', 'sdo', 'sdp', 'sdq', 'sdr', 'sds', 'sdt', 'sdu', 'sdaf', 'sdag', 'sdah', 'sdai', 'sdaj', 'sdak', 'sdal', 'sdam', 'sdan', 'sdao'),
-		}
 		self.vars = self.vars()
-		self.name = []
-		for name in self.vars:
-			self.name.append('disk/' + name)
-		self.init()
+		self.name = ['disk/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
 
-		for name in self.vars: self.cn1[name] = (0, 0); self.cn1['total'] = (0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0); self.cn2['total'] = (0, 0)
-		for name in self.vars: self.val[name] = [0, 0]; self.val['total'] = [0, 0]
-
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/diskstats'):
-			for line in open('/proc/diskstats', 'r').readlines():
-				l = line.split()
-				if len(l) &lt; 13 or l[3] == '0': continue
-				name = l[2]
-				if not re.match('^(ram\d+|loop\d+)$', name):
-					ret.append(name)
-#			ret.sort()
-			for item in list: ret.append(item)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if len(l) &lt; 13 or l[3] == '0': continue
+			name = l[2]
+			if not self.regexp.match(name):
+				ret.append(name)
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
 		ret = []
 		if op.disklist:
 			list = op.disklist
+		elif not op.full:
+			list = ('total', )
 		else:
-			if not op.full:
-				list = ('total', )
-			else:
-				list = self.discover()
-				if len(list) &gt; 2: list = list[0:2]
-				list.sort()
+			list = self.discover()
+			if len(list) &gt; 2: list = list[0:2]
+			list.sort()
 		for name in list:
-			if name in self.discover('total') + self.diskset.keys():
+			if name in self.discover('total') + op.diskset.keys():
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in open('/proc/diskstats', 'r').readlines():
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 13: continue
+			if l[5] == '0' and l[9] == '0': continue
 			name = l[2]
+			if self.regexp.match(name): continue
+			self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
 			if name in self.vars:
 				self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
 			for set in self.vars:
-				if set in self.diskset.keys() and name in self.diskset[set]:
-					self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
-			self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / step,
-				)
+				if set in op.diskset.keys():
+					for disk in op.diskset[set]:
+						if re.match('^'+disk+'$', name):
+							self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
+		for name in self.cn2.keys():
+			self.val[name] = ( 
+				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+			)
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
-class dstat_disk24(dstat_disk):
+class dstat_disk24(dstat):
+	def __init__(self):
+		self.format = ('f', 5, 1024)
+		self.len = 5
+		self.open('/proc/partitions')
+		self.nick = ('read', 'write')
+		self.vars = self.vars()
+		self.name = ['disk/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
+		self.regexp = re.compile('^(ram\d+|loop\d+|name)$')
+
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
-			for line in open('/proc/partitions', 'r').readlines():
+		if not os.path.exists('/proc/diskstats'):
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = line.split()
 				if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
 				name = l[3]
-				if not re.match('^(ram\d+|loop\d+|name)$', name):
+				if not self.regexp.match(name):
 					ret.append(name)	
-#			ret.sort()
 			for item in list: ret.append(item)
 		return ret
 
@@ -585,50 +611,62 @@
 		ret = []
 		if op.disklist:
 			list = op.disklist
+		elif not op.full:
+			list = ('total', )
 		else:
-			if not op.full:
-				list = ('total', )
-			else:
-				list = self.discover()
-				if len(list) &gt; 2: list = list[0:2]
-				list.sort()
+			list = self.discover()
+			if len(list) &gt; 2: list = list[0:2]
+			list.sort()
 		for name in list:
-			if name in self.discover('total') + self.diskset.keys():
+			if name in self.discover('total') + op.diskset.keys():
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in open('/proc/partitions', 'r').readlines():
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 15: continue
+			if l[6] == '0' and l[10] == '0': continue
 			name = l[3]
 			if name == 'name': continue
+			if self.regexp.match(name): continue
+			self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]))
 			if name in self.vars:
 				self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
 			for set in self.vars:
-				if set in self.diskset.keys() and name in self.diskset[set]:
-					self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
-			self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]))
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / step,
-				)
+				if set in op.diskset.keys():
+					for disk in op.diskset[set]:
+						if re.match('^'+disk+'$', name):
+							self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
+		for name in self.cn2.keys():
+			self.val[name] = ( 
+				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+			)
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 ### FIXME: Needs rework, does anyone care ?
-class dstat_disk24old(dstat_disk24):
+class dstat_disk24old(dstat):
+	def __init__(self):
+		self.format = ('f', 5, 1024)
+		self.open('/proc/stat')
+		self.nick = ('read', 'write')
+		self.vars = self.vars()
+		self.name = ['disk/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
+		self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
+
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/stat') and not os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
-			for line in open('/proc/stat', 'r').readlines():
+		if not os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = line.split()
 				if len(l) &lt; 15: continue
 				ret.append(l[3])
-#			ret.sort()
 			for item in list: ret.append(item)
 		return ret
 
@@ -636,60 +674,86 @@
 		ret = []
 		if op.disklist:
 			list = op.disklist
+		elif not op.full:
+			list = ('total', )
 		else:
 			list = self.discover()
-			if not op.full and len(list) &gt; 2: list = list[0:2]
+			if len(list) &gt; 2: list = list[0:2]
 			list.sort()
 		for name in list:
-			if name in self.discover('total') + self.diskset.keys():
+			if name in self.discover('total') + op.diskset.keys():
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in open('/proc/stat', 'r').readlines():
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split(':')
 			if len(l) &lt; 3: continue
 			name = l[0]
 			if name == 'disk_io':
 				for pair in line.split()[1:]:
-					m = re.match('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$', pair)
+					m = self.regexp.match(pair)
 					if m:
 						l = m.groups()
+						if len(l) &lt; 4: continue
 						name = dev(int(l[0]), int(l[1]))
 						self.cn2[name] = ( long(l[2]), long(l[3]) )
+						self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
 						for set in self.vars:
-							if set in self.diskset.keys() and name in self.diskset[set]:
-								self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
-						self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = (
-					(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / step,
-				)
+							if set in op.diskset.keys():
+								for disk in op.diskset[set]:
+									if re.match('^'+disk+'$', name):
+										self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
+		for name in self.cn2.keys():
+			self.val[name] = (
+				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+			)
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_int(dstat):
 	def __init__(self):
-		self.len = 5
-		self.format = '%ds'
 		self.name = 'interrupts'
+		self.format = ('d', 5, 1000)
+		self.open('/proc/stat')
+		self.intmap = self.intmap()
 		self.vars = self.vars()
 		self.nick = self.vars
-		self.init()
+		self.init(self.vars, 1)
 
+	def intmap(self):
+		ret = {}
+		for line in dopen('/proc/interrupts').readlines():
+			l = line.split()
+			if len(l) &lt;= cpunr: continue
+			l1 = l[0].split(':')[0]
+			l2 = ' '.join(l[cpunr+2:]).split(',')
+			ret[l1] = l1
+			for name in l2:
+				ret[name.strip().lower()] = l1
+
 	def discover(self):
 		ret = []
-		if os.path.exists('/proc/stat'):
-			for line in open('/proc/stat', 'r').readlines():
-				l = line.split()
-				if l[0] != 'intr': continue
-				for name, i in enumerate(l[2:]):
-					if long(i) &gt; 10: ret.append(str(name))
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if l[0] != 'intr': continue
+			for name, i in enumerate(l[2:]):
+				if long(i) &gt; 10: ret.append(str(name))
 		return ret
 
+#	def check(self):
+#		if self.fd and self.vars:
+#			self.fd.seek(0)
+#			for line in self.fd.readlines():
+#				l = line.split()
+#				if l[0] != 'intr': continue
+#				return True
+#		return False
+
 	def vars(self):
 		ret = []
 		if op.intlist:
@@ -703,47 +767,62 @@
 		for name in list:
 			if name in self.discover():
 				ret.append(name)
+			elif name.lower() in self.intmap.keys():
+				ret.append(self.intmap[name.lower()])
 		return ret
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if l[0] != 'intr': continue
 			for name in self.vars:
 				self.cn2[name] = long(l[int(name) + 2])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_int24(dstat):
 	def __init__(self):
-		self.len = 5
-		self.format = '%ds'
 		self.name = 'interrupts'
+		self.format = ('f', 5, 1000)
+		self.open('/proc/interrupts')
 		self.vars = self.vars()
 		self.nick = self.vars
-		self.init()
+		self.init(self.vars, 1)
 
+	def intmap(self):
+		ret = {}
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if len(l) &lt;= cpunr: continue
+			l1 = l[0].split(':')[0]
+			l2 = ' '.join(l[cpunr+2:]).split(',')
+			ret[l1] = l1
+			for name in l2:
+				ret[name.strip().lower()] = l1
+
 	def discover(self):
 		ret = []
-		if os.path.exists('/proc/interrupts'):
-			for line in open('/proc/interrupts', 'r').readlines():
-				l = line.split()
-				if len(l) &lt; cpunr+1: continue
-				name = l[0].split(':')[0]
-				if long(l[1]) &gt; 10:
-					ret.append(name)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if len(l) &lt; cpunr+1: continue
+			name = l[0].split(':')[0]
+			if long(l[1]) &gt; 10:
+				ret.append(name)
 		return ret
 
-	def check(self):
-		for line in open('/proc/stat', 'r').readlines():
-			l = line.split()
-			if l[0] != 'intr' or len(l) &gt; 2: continue
-			if self.discover():
-				return True
-		return False
+#	def check(self):
+#		if self.fd and self.discover():
+#			self.fd.seek(0)
+#			for line in self.fd.readlines():
+#				l = line.split()
+#				if l[0] != 'intr' or len(l) &gt; 2: continue
+#				return True
+#		return False
 
 	def vars(self):
 		ret = []
@@ -758,10 +837,13 @@
 		for name in list:
 			if name in self.discover():
 				ret.append(name)
+			elif name.lower() in self.intmap.keys():
+				ret.append(self.intmap[name.lower()])
 		return ret
 
-	def stats(self):
-		for line in open('/proc/interrupts', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; cpunr+1: continue
 			name = l[0].split(':')[0]
@@ -773,50 +855,77 @@
 #				for hw in self.vars:
 #					for mod in l[2+cpunr:]:
 #						self.cn2[mod] = long(l[1])
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / step
+		for name in self.cn2.keys():
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
+class dstat_ipc(dstat):
+	def __init__(self):
+		self.name = 'sysv ipc'
+		self.format = ('d', 3, 10)
+		self.vars = ('msg', 'sem', 'shm')
+		self.nick = self.vars
+		self.init(self.vars, 1)
+
+	def extract(self):
+		for name in self.vars:
+			self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
+
 class dstat_load(dstat):
 	def __init__(self):
-		self.len = 4
-		self.format = '%f'
 		self.name = 'load avg'
+		self.format = ('f', 4, 10)
+		self.open('/proc/loadavg')
+		self.nick = ('1m', '5m', '15m')
 		self.vars = ('load1', 'load5', 'load15')
-		self.nick = ('1m', '5m', '15m')
-		self.init()
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/loadavg'):
-			return True
-		return False
-
-	def stats(self):
-		for line in open('/proc/loadavg', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 3: continue
 			self.val['load1'] = float(l[0])
 			self.val['load5'] = float(l[1])
 			self.val['load15'] = float(l[2])
 
+class dstat_lock(dstat):
+	def __init__(self):
+		self.name = 'file locks'
+		self.format = ('f', 3, 10)
+		self.open('/proc/locks')
+		self.nick = ('pos', 'lck', 'rea', 'wri')
+		self.vars = ('posix', 'flock', 'read', 'write')
+		self.init(self.vars, 1)
+
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if len(l) &lt; 4: continue
+			if l[1] == 'POSIX':
+				self.val['posix'] = self.val['posix'] + 1
+			elif l[1] == 'FLOCK':
+				self.val['flock'] = self.val['flock'] + 1
+			if l[3] == 'READ':
+				self.val['read'] = self.val['read'] + 1
+			elif l[3] == 'WRITE':
+				self.val['write'] = self.val['write'] + 1
+
 class dstat_mem(dstat):
 	def __init__(self):
 		self.name = 'memory usage'
-		self.len = 5
-		self.format = '%s'
+		self.format = ('f', 5, 1024)
+		self.open('/proc/meminfo')
+		self.nick = ('used', 'buff', 'cach', 'free')
 		self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
-		self.nick = ('used', 'buff', 'cach', 'free')
-		self.init()
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/meminfo'):
-			return True
-		return False
-
-	def stats(self):
-		for line in open('/proc/meminfo', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 2: continue
 			name = l[0].split(':')[0]
@@ -826,71 +935,59 @@
 
 class dstat_net(dstat):
 	def __init__(self):
-		self.len = 5
-		self.format = '%s %s'
+		self.format = ('f', 5, 1024)
+		self.open('/proc/net/dev')
+		self.nick = ('recv', 'send')
 		self.vars = self.vars()
-		self.name = []
-		for name in self.vars:
-			self.name.append('net/' + name)
-		self.nick = ('recv', 'send')
-		self.init()
+		self.name = ['net/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
 
-		for name in self.vars: self.cn1[name] = (0, 0); self.cn1['total'] = (0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0); self.cn2['total'] = (0, 0)
-		for name in self.vars: self.val[name] = [0, 0]; self.val['total'] = [0, 0]
-
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/net/dev'):
-			for line in open('/proc/net/dev', 'r').readlines():
-				l = line.split()
-				if len(l) &lt; 2: continue
-				name = l[0].split(':')[0]
-				if l[1] == '0': continue
-				if not re.match('^(Inter-\||face|lo)$', name):
-					ret.append(name)
-			ret.sort()
-			for item in list: ret.append(item)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.replace(':', ' ').split()
+			if len(l) &lt; 17: continue
+			if l[2] == '0' and l[10] == '0': continue
+			name = l[0]
+			if name not in ('lo', 'face'):
+				ret.append(name)
+		ret.sort()
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
 		ret = []
 		if op.netlist:
 			list = op.netlist
+		elif not op.full:
+			list = ('total', )
 		else:
-			if not op.full:
-				list = ('total', )
-			else:
-				list = self.discover()
-				if len(list) &gt; 2: list = list[0:2]
-				list.sort()
+			list = self.discover()
+			if len(list) &gt; 2: list = list[0:2]
+			list.sort()
 		for name in list:
-			if name in self.discover('total'):
+			if name in self.discover('total', 'lo'):
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		self.cn2['total'] = [0, 0]
-		for line in open('/proc/net/dev', 'r').readlines():
-			l = line.split()
-			if len(l) &lt; 1: continue
-			l2 = l[0].split(':')
-			if len(l2) &lt; 1: continue
-			name = l2[0]
-			if len(l2) &gt; 1 and l2[1].strip():
-				l = l2[1:] + l[1:]
-			else:
-				l = l[1:]
-			if len(l) &lt; 9: continue
-			if name in (self.vars) :
-				self.cn2[name] = ( long(l[0]), long(l[8]) )
-			if not re.match('^(Inter-\||face|lo)$', name):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[0]), self.cn2['total'][1] + long(l[8]))
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.replace(':', ' ').split()
+			if len(l) &lt; 17: continue
+			if l[2] == '0' and l[10] == '0': continue
+			name = l[0]
+			if name in self.vars :
+				self.cn2[name] = ( long(l[2]), long(l[10]) )
+			if name not in ('lo','face'):
+				self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[10]))
 		if update:
 			for name in self.cn2.keys():
 				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 1.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 1.0 / step,
+					(self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
+					(self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
 				 )
 		if step == op.delay:
 			self.cn1.update(self.cn2)
@@ -898,68 +995,65 @@
 class dstat_page(dstat):
 	def __init__(self):
 		self.name = 'paging'
-		self.format = '%s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
+		self.open('/proc/vmstat')
+		self.nick = ('in', 'out')
 		self.vars = ('pswpin', 'pswpout')
-		self.nick = ('in', 'out')
-		self.init()
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/vmstat'):
-			return True
-		return False
-
-	def stats(self):
-		for line in open('/proc/vmstat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 2: continue
 			name = l[0]
 			if name in self.vars:
 				self.cn2[name] = long(l[1])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
-class dstat_page24(dstat_page):
-	def check(self):
-		if os.path.exists('/proc/stat') and not os.path.exists('/proc/vmstat'):
-			return True
-		return False
+class dstat_page24(dstat):
+	def __init__(self):
+		self.name = 'paging'
+		self.format = ('f', 5, 1024)
+		self.open('/proc/stat')
+		self.nick = ('in', 'out')
+		self.vars = ('pswpin', 'pswpout')
+		self.init(self.vars, 1)
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+#	def check(self):
+#		if self.fd and not os.path.exists('/proc/vmstat'):
+#			return True
+#		return False
+
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 3: continue
 			name = l[0]
 			if name == 'swap':
 				self.cn2['pswpin'] = long(l[1])
 				self.cn2['pswpout'] = long(l[2])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_proc(dstat):
 	def __init__(self):
 		self.name = 'procs'
-		self.format = '%is'
-		self.len = 3
+		self.format = ('f', 3, 10)
+		self.open('/proc/stat')
+		self.nick = ('run', 'blk', 'new')
 		self.vars = ('procs_running', 'procs_blocked', 'processes')
-#		self.vars = ('procs_running', 'procs_blocked')
-		self.nick = ('run', 'blk', 'new')
-#		self.nick = ('ru', 'bl')
-		self.init()
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/stat'):
-			return True
-		return False
-
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 2: continue
 			name = l[0]
@@ -970,31 +1064,39 @@
 				self.cn2[name] = self.cn2[name] + long(l[1]) - 1
 			elif name == 'procs_blocked':
 				self.cn2[name] = self.cn2[name] + long(l[1])
-		if update:
-			self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / step
-			for name in ('procs_running', 'procs_blocked'):
-				self.val[name] = self.cn2[name] * 1.0 / step
+		self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
+		for name in ('procs_running', 'procs_blocked'):
+			self.val[name] = self.cn2[name] * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 			for name in ('procs_running', 'procs_blocked'):
 				self.cn2[name] = 0
 
+class dstat_raw(dstat):
+	def __init__(self):
+		self.name = 'raw'
+		self.format = ('f', 3, 10)
+		self.open('/proc/net/raw')
+		self.nick = ('soc',)
+		self.vars = ('sockets',)
+		self.init(self.vars, 1)
+
+	def extract(self):
+		self.fd.seek(0)
+		self.val['sockets'] = len(self.fd.readlines()) - 1
+
 class dstat_swap(dstat):
 	def __init__(self):
 		self.name = 'swap'
-		self.len = 5
-		self.format = '%s'
+		self.format = ('f', 5, 1024)
+		self.open('/proc/meminfo')
+		self.nick = ('used', 'free')
 		self.vars = ('SwapUsed', 'SwapFree')
-		self.nick = ('used', 'free')
-		self.init()
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/meminfo'):
-			return True
-		return False
-
-	def stats(self):
-		for line in open('/proc/meminfo', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 2: continue
 			name = l[0].split(':')[0]
@@ -1005,47 +1107,38 @@
 class dstat_sys(dstat):
 	def __init__(self):
 		self.name = 'system'
-		self.format = '%ds'
-		self.len = 5
+		self.format = ('d', 5, 1000)
+		self.open('/proc/stat')
+		self.nick = ('int', 'csw')
 		self.vars = ('intr', 'ctxt')
-		self.nick = ('int', 'csw')
-		self.init()
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/stat'):
-			return True
-		return False
-
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 2: continue
 			name = l[0]
 			if name in self.vars:
 				self.cn2[name] = long(l[1])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_tcp(dstat):
 	def __init__(self):
-		self.name = 'tcp'
-		self.format = '%is'
-		self.len = 3
+		self.name = 'tcp sockets'
+		self.format = ('f', 3, 1024)
+		self.open('/proc/net/tcp')
+		self.nick = ('lis', 'act', 'syn', 'tim')
 		self.vars = ('listen', 'established', 'syn_sent', 'time_wait')
-		self.nick = ('lis', 'act', 'syn', 'tim')
-		self.init()
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/net/tcp'):
-			return True
-		return False
-
-	def stats(self):
-		self.val['listen'] = self.val['established'] = self.val['syn_sent'] = self.val['time_wait'] = 0
-		for line in open('/proc/net/tcp', 'r').readlines():
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
 			if len(l) &lt; 12: continue
 			if l[3] == '0A': self.val['listen'] = self.val['listen'] + 1
@@ -1056,69 +1149,59 @@
 class dstat_time(dstat):
 	def __init__(self):
 		self.name = 'time'
-		self.format = '%10d'
-		self.len = 10
-		### Nice for debugging timer
-#		self.format = '%13.3f'
-#		self.len = 14
+		self.format = ('t', 10, 0)
+#		self.format = ('t', 15, 0)
 		self.nick = ('epoch',)
 		self.vars = ('epoch',)
-		self.init()
+		self.init(self.vars, 1)
 
-	def stats(self):
+	def extract(self):
 		self.val['epoch'] = time.time()
 
-	def show(self):
-		sys.stdout.write(self.format % self.val['epoch'])
+#	def __repr__(self):
+#		return ansi['reset'] + self.format % self.val['epoch']
 
 class dstat_udp(dstat):
 	def __init__(self):
 		self.name = 'udp'
-		self.format = '%is'
-		self.len = 3
-		self.nick = ('con', )
-		self.vars = ('connections', )
-		self.init()
+		self.format = ('f', 3, 50)
+		self.open('/proc/net/udp')
+		self.nick = ('lis', 'act')
+		self.vars = ('listen', 'established')
+		self.init(self.vars, 1)
 
-	def check(self):
-		if os.path.exists('/proc/net/udp'):
-			return True
-		return False
-
-	def stats(self):
-		self.val['connections'] = 0
-		for line in open('/proc/net/udp', 'r').readlines():
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = line.split()
-			if l[3] == '07': self.val['connections'] = self.val['connections'] + 1
+			if l[3] == '07': self.val['listen'] = self.val['listen'] + 1
+			elif l[3] == '01': self.val['established'] = self.val['established'] + 1
 
-class dstat_user(dstat):
+class dstat_unix(dstat):
 	def __init__(self):
-		self.name = 'users'
-		self.format = '%is'
-		self.len = 3
-		self.nick = ('usr', 'adm' )
-		self.vars = ('users', 'root')
-		self.init()
+		self.name = 'unix sockets'
+		self.format = ('d', 4, 100)
+		self.open('/proc/net/unix')
+		self.nick = ('dgrm', 'strm', 'lis', 'act')
+		self.vars = ('datagram', 'stream', 'listen', 'established')
+		self.init(self.vars, 1)
 
-	def check(self):
-		try:
-			import utmp
-			return True
-		except:
-			print 'The user stat needs the python-utmp module.'
-			return False
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = line.split()
+			if l[4] == '0002':
+				self.val['datagram'] = self.val['datagram'] + 1
+			elif l[4] == '0001':
+				self.val['stream'] = self.val['stream'] + 1
+				if l[5] == '01':
+					self.val['listen'] = self.val['listen'] + 1
+				elif l[5] == '03':
+					self.val['established'] = self.val['established'] + 1
 
-	def stats(self):
-		import utmp
-		u = utmp.UtmpRecord()
-		self.val['users'] = 0
-		self.val['root'] = 0
-		for i in u:
-			if i.ut_type == utmp.USER_PROCESS:
-				self.val['users'] = self.val['users'] + 1
-				if i.ut_user == 'root':
-					self.val['root'] = self.val['root'] + 1
-			
+### END STATS DEFINITIONS ###
 
 ansi = {
 	'black': '\033[0;30m',
@@ -1173,81 +1256,146 @@
 	'space': ' ',
 }
 
-def total(list):
-	ret = 0
-	for i in list:
-		ret = ret + i
-	return ret
+def ticks():
+	try:
+		for line in open('/proc/uptime', 'r', 0).readlines():
+			l = line.split()
+			if len(l) &lt; 2: continue
+			return float(l[0])
+	except:
+		for line in dopen('/proc/stat').readlines():
+			l = line.split()
+			if len(l) &lt; 2: continue
+			if l[0] == 'btime':
+				return time.time() - long(l[1])
 
-def convlist(max, list, base = 1024):
-#	max = max / len(list)
-	retlist = ()
-	for var in list:
-		retlist = retlist + (conv(max, var, base), )
-	return retlist
-
-#def convlist(max, list):
-#	return map(conv, list)
-
-### Use capabilities like: float=true, base=nr, color=true
-def conv(max, var, base = 1024):
-	if var &lt; 0:
-		return ansi['default'] + '- '.rjust(max)
-
-	if step == op.delay:
-		color = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
+def dopen(file):
+	global fds
+	if not os.path.exists(file): return None
+	if not 'fds' in globals(): fds = {}
+	if not file in fds:
+		fds[file] = open(file, 'r', 0)
 	else:
-		color = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
+		fds[file].seek(0)
+	return fds[file]
 
-	if base in (0, 1, 10):
-		unit = ('', '', '', '', '', '', '', '', '', '', '')
-	elif base == 100:
-		if round(var) == 0:
-			return ansi['default'] + '0'.rjust(max)
-		else:
-			return ansi[color[long(round(var)/34)]] + str(long(round(var))).rjust(max)
-	elif base == 1000:
-		unit = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
-	elif base == 1024:
-		### lowercase (b) is better for the eyes than uppercase
-		unit = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
-	else:
-		return ansi['default'] + '? '.rjust(max)
+def dclose(file):
+	global fds
+	if not 'fds' in globals(): fds = {}
+	if file in fds:
+		fds[file].close()
+		del(fds[file])
 
+def dchg(var, max, base):
 	c = 0
 	while True:
-		repr = str(long(round(var))) + unit[c]
-		if len(repr) &lt;= max:
-			if not op.integer and (base != 1000 or c &gt; 0):
-				if var != round(var) and len('%1.2f' % var + unit[c]) &lt;= max:
-					repr = '%1.2f' % var + unit[c]
-				elif var != round(var) and len('%1.1f' % var + unit[c]) &lt;= max:
-					repr = '%1.1f' % var + unit[c]
+		ret = str(long(round(var)))
+		if len(ret) &lt;= max:
+			break
+		var = var / base
+		c = c + 1
+	return ret, c
+
+def fchg(var, max, base):
+	c = 0
+	while True:
+		ret = str(long(round(var)))
+		if len(ret) &lt;= max:
+			i = max - len(ret)
+			while i &gt; 0:
+				fmt = '%.'+str(i)+'f'
+				ret = fmt % var
+				if var != round(var) and len(ret) &lt;= max:
+					break
+				i = i - 1
 			else:
-				var = long(round(var))
+				ret = str(long(round(var)))
 			break
 		var = var / base
 		c = c + 1
+	return ret, c
 
-	if var == 0:
-		return ansi['default'] + ('0' + ' ' * len(unit[0])).rjust(max)
-	return ansi[color[c]] + repr.rjust(max)
+def cprintlist(list, format):
+	ret = sep = ''
+	for var in list:
+		ret = ret + sep + cprint(var, format)
+		sep = ' '
+	return ret
 
+def cprint(var, format = ('f', 4, 1000)):
+	c = 0
+	type = format[0]
+	max = format[1]
+	mp = format[2]
+
+	base = 1000
+	if mp == 1024:
+		base = 1024
+
+	unit = False
+	if mp in (1000, 1024) and max &gt;= len(str(base)):
+		unit = True
+		max = max - 1
+
+	if var &lt; 0:
+		if unit:
+			return ansi['default'] + '- '.rjust(max)
+		else:
+			return ansi['default'] + '-'.rjust(max)
+
+	units = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+	if base == 1024:
+		units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+
+	colors = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
+	if step != op.delay:
+		colors = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
+
+	if op.integer and type in ('d', 'p', 'f'):
+		ret, c = dchg(var, max, base)
+	elif type in ('d', 'p'):
+		ret, c = dchg(var, max, base)
+	elif type in ('f', 't'):
+		ret, c = fchg(var, max, base)
+	else:
+		ret = str(var)
+
+	if ret == '0':
+		color = 'default'
+	elif type in ('d', 'p'):
+		color = colors[int(var/mp)%len(colors)]
+	elif type in ('f'):
+		color = colors[c%len(colors)]
+	else:
+		color = 'default'
+
+	ret = ansi[color] + ret.rjust(max)
+
+	if unit:
+		if c:
+			ret = ret + units[c]
+		else:
+			ret = ret + ' '
+
+	return ret
+
 def showtitle(nr, totlist, vislist, midchar, endchar):
+	line = ''
 	for o in vislist:
-		sys.stdout.write(o.title(nr))
+		line = line + o.title(nr)
 		if o is not vislist[-1]:
-			sys.stdout.write(midchar)
+			line = line + midchar
 		elif totlist != vislist:
-			sys.stdout.write(endchar)
-	sys.stdout.write('\n')
+			line = line + endchar
+	sys.stdout.write(line + '\n')
 
 def showcsvtitle(nr, totlist):
+	line = ''
 	for o in totlist:
-		outputfile.write(o.titlecsv(nr))
+		line = line + o.titlecsv(nr)
 		if o is not totlist[-1]:
-			outputfile.write(',')
-	outputfile.write('\n')
+			line = line + ','
+	outputfile.write(line + '\n')
 
 def info(level, str):
 	&quot;Output info message&quot;
@@ -1279,7 +1427,7 @@
 
 def getcpunr():
 	cpunr = -1
-	for line in open('/proc/stat', 'r').readlines():
+	for line in dopen('/proc/stat').readlines():
 		if line[0:3] == 'cpu':
 			cpunr = cpunr + 1
 	return cpunr
@@ -1303,7 +1451,7 @@
 
 #def mountpoint(dev):
 #	&quot;Return the mountpoint of a mounted device/file&quot;
-#	for entry in open('/etc/mtab', 'r').readlines():
+#	for entry in dopen('/etc/mtab').readlines():
 #		if entry:
 #			list = entry.split()
 #			if dev == list[0]:
@@ -1314,52 +1462,36 @@
 
 def exit(ret):
 	sys.stdout.write(ansi['reset'])
-	signal.signal(signal.SIGALRM, signal.SIG_DFL)
-	termios.tcsetattr(fd, termios.TCSADRAIN, old)
+	if 'signal' in sys.modules:
+		signal.signal(signal.SIGALRM, signal.SIG_DFL)
+#	termios.tcsetattr(fd, termios.TCSADRAIN, old)
 	sys.exit(ret)
 
 def main():
-	global update, loop, step, pagesize, cpunr, ansi, interval, outputfile
+	global update, loop, step, pagesize, cpunr, ansi, interval, outputfile, tick
 
 	loop = update = 0
 	step = op.delay
+	tick = ticks()
 	pagesize = resource.getpagesize()
 	cpunr = getcpunr()
 #	hz = os.sysconf('SC_CLK_TCK')
 	interval = 1
 
 	if op.output:
-		outputfile = open(op.output, 'a', 0)
-
-	### Build list of requested modules
-	totlist = []
-	for mod in op.modlist:
-		if mod == 'cpu':
-			totlist.append(dstat_cpu())
-			totlist.append(dstat_cpu24())
-		elif mod == 'disk':
-			totlist.append(dstat_disk())
-			totlist.append(dstat_disk24())
-			totlist.append(dstat_disk24old())
-		elif mod == 'int':
-			totlist.append(dstat_int())
-			totlist.append(dstat_int24())
-		elif mod == 'load':	totlist.append(dstat_load())
-		elif mod == 'mem':	totlist.append(dstat_mem())
-		elif mod == 'net':	totlist.append(dstat_net())
-		elif mod == 'page':
-			totlist.append(dstat_page())
-			totlist.append(dstat_page24())
-		elif mod == 'proc':	totlist.append(dstat_proc())
-		elif mod == 'swap':	totlist.append(dstat_swap())
-		elif mod == 'sys':	totlist.append(dstat_sys())
-		elif mod == 'tcp':	totlist.append(dstat_tcp())
-		elif mod == 'time':	totlist.append(dstat_time())
-		elif mod == 'udp':	totlist.append(dstat_udp())
-		elif mod == 'user':	totlist.append(dstat_user())
+		if os.path.exists(op.output):
+			outputfile = open(op.output, 'a', 0)
+			outputfile.write('\n\n')
 		else:
-			info(1, 'Module \'%s\' does not exist or failed to load.' % mod)
+			outputfile = open(op.output, 'w', 0)
+			outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
+			outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
 
+		### FIXME: Get rid of socket()
+		import socket
+		outputfile.write('&quot;Host:&quot;,&quot;%s&quot;\n' % (socket.gethostbyaddr(socket.gethostname())[0]))
+		outputfile.write('&quot;Cmdline:&quot;,&quot;dstat %s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n\n' % (' '.join(op.args), time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
+
 	### Check terminal capabilities
 	if sys.stdout.isatty():
 		if curses.tigetnum('colors') &lt; 0:
@@ -1380,55 +1512,68 @@
 	if not op.update:
 		interval = op.delay
 
-	### Remove defect objects and calculate line length
+	### Build list of requested modules
 	linewidth = 0
-	for o in totlist + []:
-		if o.check():
-			linewidth = linewidth + o.varwidth() + 1
+	oldvislist = []
+	totlist = []
+	for mod in op.modlist:
+		if mod == 'cpu':    objs = ( dstat_cpu(), dstat_cpu24() )
+		elif mod == 'disk': objs = ( dstat_disk(), dstat_disk24(), dstat_disk24old() )
+		elif mod == 'int':  objs = ( dstat_int(), dstat_int24() )
+		elif mod == 'page': objs = ( dstat_page(), dstat_page24() )
+		elif 'dstat_'+mod in globals():
+			exec(compile('objs = ( dstat_%s(), )' % mod, '&lt;string&gt;', 'exec'))
 		else:
-			totlist.remove(o)
+			try:
+				exec(compile('import dstat_%s\nobjs = ( dstat_%s.dstat_%s(), )' % (mod, mod, mod), '&lt;string&gt;', 'exec'))
+			except Exception, e:
+				info(1, 'Module \'dstat_%s\' does not exist or failed to load. (%s)' % (mod, e))
+				continue
 
+		### Remove defect stat objects and calculate line length
+		for o in objs:
+			if o.check():
+				linewidth = linewidth + o.statwidth() + 1
+				totlist.append(o)
+				break
+
 	if not totlist:
 		die(8, 'None of the stats you selected are available.')
 
-	### FIXME: Get rid of socket()
 	if op.output:
-		import socket
-		outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
-		outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
-		outputfile.write('&quot;Host:&quot;,&quot;%s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n' % (socket.gethostbyaddr(socket.gethostname())[0], time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
-		outputfile.write('&quot;Cmd:&quot;,&quot;dstat %s&quot;\n\n' % ' '.join(op.args))
+		showcsvtitle(1, totlist)
+		showcsvtitle(2, totlist)
 
-		if op.output:
-			showcsvtitle(1, totlist)
-			showcsvtitle(2, totlist)
-	oldvislist = []
-
 	### Increase precision if we're root (does not seem to have effect)
 #	if os.geteuid() == 0:
 #		os.nice(-20)
 #	sys.setcheckinterval(op.delay / 10000)
 
+	### Always show header the first time
+	showheader = True
+
 	signal.signal(signal.SIGALRM, signaler)
 	signal.alarm(interval)
 
-	### Always show header the first time
-	showheader = True
+	tt = 0
 
 	### Let the games begin
 	while update &lt;= op.delay * op.count or op.count == -1:
 
+		if op.debug and step == 1: tt = 0
+		if op.debug: t1 = time.time()
+
 		### Trim object list to what is visible on screen
-		(rows, cols) = getwinsize()
+		rows, cols = getwinsize()
 		vislist = []
 		curwidth = 0
 		for o in totlist:
-			if curwidth + o.varwidth() + 1 &lt;= cols:
+			if curwidth + o.statwidth() + 1 &lt;= cols:
 				vislist.append(o)
-				curwidth = curwidth + o.varwidth() + 1
-			elif vislist == totlist[:-1] and curwidth + o.varwidth() &lt;= cols:
+				curwidth = curwidth + o.statwidth() + 1
+			elif vislist == totlist[:-1] and curwidth + o.statwidth() &lt;= cols:
 				vislist.append(o)
-				curwidth = curwidth + o.varwidth() + 1
+				curwidth = curwidth + o.statwidth() + 1
 
 		### Check when to display the header
 		if op.header:
@@ -1439,7 +1584,7 @@
 
 		if showheader:
 			if loop == 0 and totlist != vislist:
-				print 'Screen width too small, trimming output.'
+				info(1, 'Screen width too small, trimming output.')
 			showheader = False
 			showtitle(1, totlist, vislist, ansi['darkblue'] + char['space'], ansi['darkblue'] + char['gt'])
 			showtitle(2, totlist, vislist, ansi['silver'] + char['pipe'], ansi['darkblue'] + char['gt'])
@@ -1451,24 +1596,29 @@
 			ansi['default'] = ansi['reset']
 		else:
 			ansi['default'] = ansi['gray']
-		sys.stdout.write(ansi['default'])
+		line = ansi['default']
 
-		### Debugging info
-#		sys.stdout.write('[%d:%d:%d] ' % (loop, step, update))
-
-		### Show the stats, calculate all objects (visible, invisible)
+		### Calculate all objects (visible, invisible)
+		oline = ''
 		for o in totlist:
-			o.stats()
+			o.extract()
 			if o in vislist:
-				o.show()
-				o.showend(totlist, vislist)
+				line = line + repr(o) + o.showend(totlist, vislist)
 			if op.output and step == op.delay:
-				o.showcsv()
-				o.showcsvend(totlist, vislist)
-		sys.stdout.write(ansi['default'])
+				oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
+
+		### Print stats
+		sys.stdout.write(line + ansi['default'])
 		if op.output and step == op.delay:
-			outputfile.write('\n')
+			outputfile.write(oline + '\n')
 
+		### Print debugging output
+		if op.debug: t2 = time.time(); tt = tt + (t2 - t1) * 1000
+		if op.debug:
+			if loop == 0: tt = tt * step
+			sys.stdout.write(' %3.3f' % (tt / step))
+			sys.stdout.write(' [%d:%d:%d] ' % (loop, update, step))
+
 		### If intermediate results, update increases with 1 sec (=interval)
 		update = update + interval
 
@@ -1484,44 +1634,35 @@
 
 		loop = (update + op.delay - 1) / op.delay
 		step = ((update - 1) % op.delay) + 1
+		tick = step
 
-### Unbuffered sys.stdout
-sys.stdout = os.fdopen(1, 'w', 0)
+### Main entrance
+if __name__ == '__main__':
+	try:
+		### Unbuffered sys.stdout
+		sys.stdout = os.fdopen(1, 'w', 0)
 
-curses.setupterm()
+		curses.setupterm()
 
-### Prevent keyboard input
-fd = sys.stdin.fileno()
-old = termios.tcgetattr(fd)
-new = termios.tcgetattr(fd)
-new[3] = new[3] &amp; ~termios.ECHO
-termios.tcsetattr(fd, termios.TCSADRAIN, new)
+		### Prevent keyboard input
+#		fd = sys.stdin.fileno()
+#		old = termios.tcgetattr(fd)
+#		new = termios.tcgetattr(fd)
+#		new[3] = new[3] &amp; ~termios.ECHO
+#		termios.tcsetattr(fd, termios.TCSADRAIN, new)
 
-### Workaround for python &gt; 2.1 and &lt; 2.3
-def enumerate(sequence):
-    index = 0
-    for item in sequence:
-        yield index, item
-        index = index + 1
-
-### Main entrance
-if __name__ == '__main__':
-	op=Options(sys.argv[1:])
-#	cf=Config()
-	try:
+		op = Options(sys.argv[1:])
 		main()
 	except KeyboardInterrupt, e:
 		print
 	except OSError, e:
-#		print e.errno
 		print
 		print 'OSError: %s' % e
 		exit(7)
-#	except Exception, e:
-#		signal.signal(signal.SIGALRM, signal.SIG_DFL)
-#		termios.tcsetattr(fd, termios.TCSADRAIN, old)
-#		raise e
+	exit(0)
+else:
+	op = Options('')
+	step = 1
+	tick = ticks()
 
-exit(0)
-
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/dstat.1
===================================================================
--- trunk/tools/dstat/dstat.1	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/dstat.1	2005-04-28 14:21:25 UTC (rev 3163)
@@ -1,15 +1,26 @@
 .\&quot; DO NOT MODIFY THIS FILE!  It was generated by help2man 1.33.
-.TH DSTAT &quot;1&quot; &quot;November 2004&quot; &quot;dstat 0.5.8&quot; &quot;User Commands&quot;
+.TH DSTAT &quot;1&quot; &quot;April 2005&quot; &quot;dstat 0.6.0&quot; &quot;User Commands&quot;
+
 .SH NAME
 Dstat \- Versatile tool for generating system resource statistics
+
 .SH SYNOPSIS
-dstat [-afv] [-cdgilmnpstuy] [-D..] [-I..] [-N..] [delay [count]]
+dstat [-afv] [-cdgilmnpsty] [-D..] [-I..] [-N..] [delay [count]]
+
 .SH DESCRIPTION
 Dstat is a versatile replacement for vmstat, iostat and ifstat. Dstat overcomes some of the limitations and adds some extra features.
 
-For Debian users of Sleuthkit, /usr/bin/dstat has been renamed to /usr/bin/datastat to avoid a name conflict. See bug #283709 for more information.
+Dstat allows you to view all of your system resources instantly, you can eg. compare disk usage in combination with interrupts from your IDE controller, or compare the network bandwidth numbers directly with the disk throughput (in the same interval).
 
-Dstat allows you to view all of your system resources instantly, you can eg. compare disk usage in combination with interrupts from your IDE controller, or compare the network bandwidth numbers directly with the disk throughput (in the same interval).
+Dstat also cleverly gives you the most detailed information in columns and clearly indicates in what magnitude and unit the output is displayed. Less confusion, less mistakes, more efficient.
+
+Dstat is unique in letting you aggregate block device throughput for a certain diskset or network bandwidth for a group of interfaces, ie.  you can see the throughput for all the block devices that make up a single filesystem or storage system.
+
+Dstat allows its data to be directly written to a CSV file to be imported and used by OpenOffice, Gnumeric or Excel to create graphs.
+
+Users of Sleuthkit might find Sleuthkit's dstat being renamed to datastat to avoid a name conflict. See Debian bug #283709 for more information.
+
+.SH OPTIONS
 .TP
 \fB\-c\fR, \fB\-\-cpu\fR
 enable cpu stats
@@ -59,22 +70,42 @@
 \fB\-y\fR, \fB\-\-sys\fR
 enable system stats
 .TP
+\fB\-\-ipc\fR
+enable ipc stats
+.TP
+\fB\-\-lock\fR
+enable lock stats
+.TP
+\fB\-\-raw\fR
+enable raw stats
+.TP
+\fB\-\-tcp\fR
+enable tcp stats
+.TP
+\fB\-\-udp\fR
+enable udp stats
+.TP
+\fB\-\-unix\fR
+enable unix stats
+.TP
 \fB\-M\fR stat1,stat2
-enable specific stats
+enable internal and external stats
 
-Possible stats are:
-  cpu, disk, page, int, load, mem, net, proc,
-  swap, sys, tcp, time, udp, user
+Possible internal stats are:
+  cpu, disk, int, ipc, load, lock, mem, net, page,
+  proc, raw, swap, sys, tcp, time, udp, unix
+
+Also see /usr/share/dstat/ for external stats
 .TP
 \fB\-a\fR, \fB\-\-all\fR
-equals \fB\-cdngyl\fR
+equals \fB\-cdngy\fR (default)
 .TP
+\fB\-f\fR, \fB\-\-full\fR
+expand -D, -I and -N discovery lists
+.TP
 \fB\-v\fR, \fB\-\-vmstat\fR
 equals \fB\-pmgdsc\fR \fB\-D\fR total
 .TP
-\fB\-f\fR, \fB\-\-full\fR
-expand -D, -I and -N discovery lists
-.TP
 \fB\-\-integer\fR
 show integer values
 .TP
@@ -89,10 +120,53 @@
 .TP
 \fB\-\-output\fR file
 write CSV output to file
+
+.SH ARGUMENTS
+\fBdelay\fR is the delay in seconds between each update
+
+\fBcount\fR is the number of updates to display before exiting
+
+The default delay is 1 and count is unspecified (unlimited)
+
+.SH INTERMEDIATE UPDATES
+When invoking dstat with a \fBdelay\fR greater than 1 and without the \fB--noupdate\fR option, it will show intermediate updates, ie. the first time a 1 sec average, the second update a 2 second average, etc. until the delay has been reached.
+
+.SH BUGS
+Since it's practically impossible to test dstat on every possible permutation of kernel , python or distribution version, I need your help and your feedback to fix the remaining problems. If you have improvements or bugreports, please send them to: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>
+
+Please see the TODO file for known bugs and future plans.
+
+.SH SEE ALSO
+.SS Performance tools
+ifstat(1), iftop(8), iostat(1), mpstat(1), netstat(1), vmstat(1), xosview(1)
+
+.SS Debugging tools
+htop, lslk(1), lsof(8), top(1)
+
+.SS Process tracing
+ltrace(1), pmap(1), ps(1), pstack(1), strace(1)
+
+.SS Binary debugging
+ldd(1), file(1), nm(1), objdump(1), readelf(1)
+
+.SS Memory usage tools
+free(1), memusage, memusagestat, slabtop(1)
+
+.SS Accounting tools
+dump-acct, dump-utmp, sa(8)
+
+.SS Hardware debugging tools
+dmidecode, ifinfo(1), lsdev(1), lshal(1), lshw(1), lsmod(8), lspci(8), lsusb(8), smartctl(8), x86info(1)
+
+.SS Xorg related tools
+xdpyinfo(1), xrestop(1)
+
+.SS Other useful info
+proc(5)
+
 .SH AUTHOR
 Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;
 
 Homepage at <A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>
 
-This manpage was written by Andrew Pollock &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">apollock at debian.org</A>&gt; for the
-Debian GNU/Linux system, but may be used by others.
+This manpage was initially written by Andrew Pollock &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">apollock at debian.org</A>&gt; for the Debian GNU/Linux system, and updated by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;

Modified: trunk/tools/dstat/dstat.conf
===================================================================
--- trunk/tools/dstat/dstat.conf	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/dstat.conf	2005-04-28 14:21:25 UTC (rev 3163)
@@ -1,12 +1,23 @@
 ### Dstat configuration file
+
+### BEWARE: This file is not yet functional, it's a prototype
+### to experiment and find the best syntax for a future dstat
+
 [main]
 interval = 5
 diff = 1
 colors = true
 abs = false
-noheader = false
-show = cpu disk net sys
+noheader = true
+noupdate = true
+default-options = -cdns
+unit = k
 
+[colors]
+default = red yellow green blue magenta cyan white darkred darkgreen
+dark = darkred darkyellow darkgreen darkblue darkmagenta darkcyan silver red green
+percentage = red yellow green
+
 [cpu]
 show = user sys idle wait
 
@@ -15,6 +26,8 @@
 
 [disk]
 show = hda hdc lores hires total
+
+[diskset]
 lores = sd[b-t]
 hires = sd[u-z] sda[a-d]
 total = sd[b-z] sda[a-d]
@@ -37,3 +50,13 @@
 
 [sys]
 show = int int
+
+[custom]
+load1 = <A HREF="file:///proc/loadavg,">file:///proc/loadavg,</A> line 1, column 1, format %4f
+load5 = <A HREF="file:///proc/loadavg,">file:///proc/loadavg,</A> line 1, column 2, format %4f
+load15 = <A HREF="file:///proc/loadavg,">file:///proc/loadavg,</A> line 1, column 3, format %4f
+int11 = <A HREF="file:///proc/stat,">file:///proc/stat,</A> re &quot;^intr &quot;, column 5, format %4d
+lo-in = <A HREF="file:///proc/net/dev,">file:///proc/net/dev,</A> re &quot;^lo: &quot;, column 3, format %4d
+lo-out = <A HREF="file:///proc/net/dev,">file:///proc/net/dev,</A> re &quot;^lo: &quot;, column 10, format %4d
+eth1 = <A HREF="file:///proc/net/dev,">file:///proc/net/dev,</A> re &quot;^eth1: \d+ (\d+) \d+ \d+ \d+ \d+ \d+ \d+ (\d+)&quot;, format %4d
+switch = <A HREF="snmp://127.0.0.1/net.tcp,">snmp://127.0.0.1/net.tcp,</A> format %4d

Modified: trunk/tools/dstat/dstat.spec
===================================================================
--- trunk/tools/dstat/dstat.spec	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/dstat.spec	2005-04-28 14:21:25 UTC (rev 3163)
@@ -9,7 +9,7 @@
 
 Summary: Versatile vmstat, iostat and ifstat replacement
 Name: dstat
-Version: 0.5.9
+Version: 0.6.0
 Release: 1
 License: GPL
 Group: System Environment/Base
@@ -65,13 +65,16 @@
 
 %files
 %defattr(-, root, root, 0755)
-%doc AUTHORS ChangeLog COPYING README* TESTS TODO
-#%doc *.conf
+%doc AUTHORS ChangeLog COPYING README* TODO examples/ *.conf
 %doc %{_mandir}/man1/dstat.1*
 #%config(noreplace) %{_sysconfdir}/dstat.conf
 %{_bindir}/dstat
+%{_datadir}/dstat/
 
 %changelog
+* Sun Apr 24 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.6.0-1
+- Updated to release 0.6.0.
+
 * Fri Apr 08 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.5.10-1
 - Updated to release 0.5.10.
 

Modified: trunk/tools/dstat/dstat15
===================================================================
--- trunk/tools/dstat/dstat15	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/dstat15	2005-04-28 14:21:25 UTC (rev 3163)
@@ -12,23 +12,54 @@
 ### You should have received a copy of the GNU Library General Public License
 ### along with this program; if not, write to the Free Software
 ### Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-### Copyright 2004 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;
+### Copyright 2004, 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;
 
-import sys
+#from __future__ import generators
 
+try:
+	import sys, signal, os, re, time, string
+	import types, curses, signal, resource
+	sys.path.insert(0, '/usr/share/dstat/')
+except KeyboardInterrupt, e:
+	pass
+
 #if sys.version_info &lt; (1, 5):
 #	sys.exit('error: Python 1.5 or later required')
 
-#from __future__ import generators
-import os, re, getopt, time, types, string
-import ConfigParser, urlparse, signal, resource
-import curses, termios
+### Workaround for python &lt; 2.3 (FIXME: check for sys.version_info existence)
+if not callable(enumerate):
+	if sys.version_info &lt; (2, 3) and sys.version_info &gt;= (2, 2):
+		def enumerate(sequence):
+			index = 0
+			for item in sequence:
+				yield index, item
+				index = index + 1
+	elif sys.version_info &lt; (2, 2):
+		def enumerate(sequence):
+			index = 0
+			list = []
+			for item in sequence:
+				list.append((index, item))
+				index = index + 1
+			return list
 
-VERSION = '0.5.10'
+### Workaround for python &lt; 2.3
+if not callable(sum):
+	def sum(sequence):
+		ret = 0
+		for i in sequence:
+			ret = ret + i
+		return ret
 
-enable = ('yes', 'on', 'true', '1')
-disable = ('no', 'off', 'false', '0')
+### Workaround for python &lt;= 2.2.1
+try:
+	True, False
+except NameError:
+	True = 1
+	False = 0
 
+VERSION = '0.6.0'
+
 class Options:
 	def __init__(self, args):
 		self.args = args
@@ -46,10 +77,18 @@
 		self.header = True
 		self.output = False
 
+		### Temporary hardcoded for my own project
+		self.diskset = {
+			'local': ('sda', 'hd[a-d]'),
+			'lores': ('sd[b-k]', 'sd[v-z]', 'sda[a-e]'),
+			'hires': ('sd[l-u]', 'sda[f-o]'),
+		}
+
 		try:
-			opts, args = getopt.getopt (args, 'acdfghilmnopstuvyC:D:I:M:N:V',
-				['all', 'cpu', 'disk', 'help', 'int', 'load', 'mem', 'net', 'page', 'proc',
-				'swap', 'sys', 'tcp', 'time', 'udp', 'user', 'version', 'vmstat',
+			import getopt
+			opts, args = getopt.getopt (args, 'acdfghilmno:pstvyC:D:I:M:N:V',
+				['all', 'cpu', 'disk', 'help', 'int', 'ipc', 'load', 'lock', 'mem', 'net', 'page',
+				'proc', 'raw', 'swap', 'sys', 'tcp', 'time', 'udp', 'unix', 'version', 'vmstat',
 				'full', 'integer', 'mods', 'modules', 'nocolor', 'noheaders', 'noupdate', 'output='])
 		except getopt.error, exc:
 			print 'dstat: %s, try dstat -h for a list of all the options' % str(exc)
@@ -66,45 +105,51 @@
 				self.modlist.append('disk')
 			elif opt in ['-D']:
 				self.disklist = string.split(arg, ',')
+			elif opt in ['-g', '--page']:
+				self.modlist.append('page')
 			elif opt in ['-i', '--int']:
 				self.modlist.append('int')
-			elif opt in ['-g', '--page']:
-				self.modlist.append('page')
 			elif opt in ['-I']:
 				self.intlist = string.split(arg, ',')
+			elif opt in ['--ipc']:
+				self.modlist.append('ipc')
+			elif opt in ['-l', '--load']:
+				self.modlist.append('load')
+			elif opt in ['--lock']:
+				self.modlist.append('lock')
 			elif opt in ['-m', '--mem']:
 				self.modlist.append('mem')
 			elif opt in ['-M', '--mods', '--modules']:
 				self.modlist = self.modlist + string.split(arg, ',')
-			elif opt in ['-l', '--load']:
-				self.modlist.append('load')
 			elif opt in ['-n', '--net']:
 				self.modlist.append('net')
 			elif opt in ['-N']:
 				self.netlist = string.split(arg, ',')
 			elif opt in ['-p', '--proc']:
 				self.modlist.append('proc')
+			elif opt in ['--raw']:
+				self.modlist.append('raw')
 			elif opt in ['-s', '--swap']:
 				self.modlist.append('swap')
 			elif opt in ['--tcp']:
 				self.modlist.append('tcp')
 			elif opt in ['-t', '--time']:
 				self.modlist.append('time')
-			elif opt in ['-u', '--user']:
-				self.modlist.append('user')
 			elif opt in ['--udp']:
 				self.modlist.append('udp')
+			elif opt in ['--unix']:
+				self.modlist.append('unix')
 			elif opt in ['-y', '--sys']:
 				self.modlist.append('sys')
 
 			elif opt in ['-a', '--all']:
-				self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys', 'load' ]
+				self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys' ]
 			elif opt in ['-v', '--vmstat']:
 				self.modlist = self.modlist + [ 'proc', 'mem', 'page', 'disk', 'sys', 'cpu' ]
 				self.disklist = ('total',)
-
 			elif opt in ['-f', '--full']:
 				self.full = True
+
 			elif opt in ['--integer']:
 				self.integer = True
 			elif opt in ['--nocolor']:
@@ -152,93 +197,80 @@
 		print 'Clock ticks per secs: %d' % os.sysconf('SC_CLK_TCK')
 
 	def usage(self):
-		print 'usage: dstat [-afv] [-cdgilmnpsty] [-D..] [-I..] [-N..] [delay [count]]'
+		print 'Usage: dstat [-afv] [-cdgilmnpsty] [-C..] [-D..] [-I..] [-N..] [delay [count]]'
 
 	def help(self):
 		print '''Versatile tool for generating system resource statistics
 
 Dstat options:
-  -c, --cpu                enable cpu stats
-     -C 0,3,                  include cpu0, cpu3 and total
-  -d, --disk               enable disk stats
-     -D total,hda             include hda and total
-  -g, --page               enable page stats
-  -i, --int                enable interrupt stats
-     -I 5,eth2                include int5 and interrupt used by eth2
-  -l, --load               enable load stats
-  -m, --mem                enable memory stats
-  -n, --net                enable network stats
-     -N eth1,total            include eth1 and total
-  -p, --proc               enable process stats
-  -s, --swap               enable swap stats
-  -t, --time               enable time counter
-  -u, --user               enable user stats
-  -y, --sys                enable system stats
+  -c, --cpu              enable cpu stats
+     -C 0,3,                include cpu0, cpu3 and total
+  -d, --disk             enable disk stats
+     -D total,hda           include hda and total
+  -g, --page             enable page stats
+  -i, --int              enable interrupt stats
+     -I 5,eth2              include int5 and interrupt used by eth2
+  -l, --load             enable load stats
+  -m, --mem              enable memory stats
+  -n, --net              enable network stats
+     -N eth1,total          include eth1 and total
+  -p, --proc             enable process stats
+  -s, --swap             enable swap stats
+  -t, --time             enable time counter
+  -y, --sys              enable system stats
+  --ipc                  enable ipc stats
+  --lock                 enable lock stats
+  --raw                  enable raw stats
+  --tcp                  enable tcp stats
+  --udp                  enable udp stats
+  --unix                 enable unix stats
 
-  -M stat1,stat2           enable specific stats
+  -M stat1,stat2         enable external stats
      --mods stat1,stat2
 
-    Possible stats are:
-      cpu, disk, page, int, load, mem, net, proc,
-      swap, sys, tcp, time, udp, user
+  -a, --all              equals -cdngy (default)
+  -f, --full             expand -D, -I and -N discovery lists
+  -v, --vmstat           equals -pmgdsc -D total
 
-  -a, --all          equals -cdngyl
-  -v, --vmstat       equals -pmgdsc -D total
-  -f, --full         expand -D, -I and -N discovery lists
+  --integer              show integer values
+  --nocolor              disable colors (implies --noupdate)
+  --noheaders            disable repetitive headers
+  --noupdate             disable intermediate updates
+  --output file          write CSV output to file
 
-  --integer          show integer values
-  --nocolor          disable colors (implies --noupdate)
-  --noheaders        disable repetitive headers
-  --noupdate         disable intermediate updates when delay &gt; 1
-  --output file      write CSV output to file
-
   delay is the delay in seconds between each update
   count is the number of updates to display before exiting
-  The default delay is zero and count is one
+  The default delay is 1 and count is unspecified (unlimited)
 '''
 
-class Config:
-	def __init__(self):
-		self.configfile = op.configfile
-		self.cfg = ConfigParser.ConfigParser()
+### START STATS DEFINITIONS ###
 
-		(s,b,p,q,f,o) = urlparse.urlparse(self.configfile)
-		if s in ('http', 'ftp', 'file'):
-			configfh = urllib.urlopen(self.configfile)
-			try:
-				self.cfg.readfp(configfh)
-			except ConfigParser.MissingSectionHeaderError, e:
-				die(6, 'Error accessing URL: %s' % self.configfile)
+class dstat:
+	### Initialise default variables
+	def init(self, vars=(), len=0):
+		if vars:
+			self.val = {}; self.cn1 = {}; self.cn2 = {}
+			for name in vars:
+				if len &lt;= 1:
+					self.val[name] = self.cn1[name] = self.cn2[name] = 0
+				else:
+					self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
+					for i in range(len):
+						self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
+
+	### Open stat file descriptor
+	def open(self, file):
+		self.file = file
+		if os.path.exists(file):
+			self.fd = dopen(file)
 		else:
-			if os.access(self.configfile, os.R_OK):
-				try:
-					self.cfg.read(self.configfile)
-				except:
-					die(7, 'Syntax error reading file: %s' % self.configfile)
-			else:
-				die(6, 'Error accessing file: %s' % self.configfile)
+			self.fd = None
 
-	def getoption(self, section, option, var):
-		&quot;Get an option from a section from configfile&quot;
-		try:
-			var = self.cfg.get(section, option)
-			info(3, 'Setting option %s in section [%s] to: %s' % (option, section, var))
-		except ConfigParser.NoSectionError, e:
-			info(4, 'Failed to find section [%s] in %s' % (section, op.configfile))
-		except ConfigParser.NoOptionError, e:
-#			info(4, 'Failed to find option %s in [%s], set to default: %s' % (option, section, var))
-			info(4, 'Setting option %s in section [%s] to: %s (default)' % (option, section, var))
-		return var
-
-class dstat:
-	def init(self):
-		### Initialise default variables
-		self.val = {}; self.cn1 = {}; self.cn2 = {}
-		for i in self.vars: self.val[i] = self.cn1[i] = self.cn2[i] = 0
-
+	### Return var width
 	def varwidth(self):
 		return len(self.vars) * self.width() + len(self.vars) - 1
 
+	### Return column width
 	def width(self):
 		if isinstance(self.name, types.StringType):
 			return self.len
@@ -260,7 +292,7 @@
 		ret = ''
 		for i, name in enumerate(self.name):
 			max = self.width()
-			ret = ret + string.replace(string.center(name[0:max], max),' ', '-')
+			ret = ret + string.replace(string.center(name[0:max], max), ' ', '-')
 			if i + 1 != len(self.name): ret = ret + '-'
 		return ansi['darkblue'] + ret
 
@@ -313,6 +345,8 @@
 			return ret
 
 	def check(self):
+		if hasattr(self, 'fd') and not self.fd:
+			return False
 		if self.discover() and self.width():
 			return True
 		return False
@@ -320,67 +354,73 @@
 	def discover(self):
 		return True
 
-	def stats(self):
+	def extract(self):
 		pass
 
-	def show(self):
+	def results(self):
 		sep = ' '
+		line = ''
 		for i, name in enumerate(self.vars):
 			if self.format in ('%s', '%bs'):
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 1024))
+				line = line + '%s' % conv(self.len, self.val[name], 1024)
 			elif self.format == '%ds':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 1000))
+				line = line + '%s' % conv(self.len, self.val[name], 1000)
 			elif self.format == '%ps':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 100))
+				line = line + '%s' % conv(self.len, self.val[name], 100)
 			elif self.format == '%is':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 10))
+				line = line + '%s' % conv(self.len, self.val[name], 10)
 			elif self.format == '%f':
-				sys.stdout.write('%s' % conv(self.len, self.val[name], 1))
+				line = line + '%s' % conv(self.len, self.val[name], 1)
 			elif self.format in ('%s %s', '%s:%s', '%s-%s'):
-				sys.stdout.write(self.format % convlist(self.len, self.val[name]))
+				line = line + self.format % convlist(self.len, self.val[name])
 				sep = ansi['default'] + char['colon']
 			elif self.format in ('%s %s %s', '%s %s %s %s %s %s'):
-				sys.stdout.write(self.format % convlist(self.len, self.val[name], 100))
+				line = line + self.format % convlist(self.len, self.val[name], 100)
 				sep = ansi['default'] + char['colon']
 			else:
-				sys.stdout.write(self.format % self.val[name])
+				line = line + self.format % self.val[name]
 			if i + 1 != len(self.vars):
-				sys.stdout.write(sep)
+				line = line + sep
+		return line
 
 	def showend(self, totlist, vislist):
 		if self is not vislist[-1]:
-			sys.stdout.write(ansi['default'] + char['pipe'])
-		elif self is not totlist[-1]:
-			sys.stdout.write(ansi['default'] + char['gt'])
+			return ansi['default'] + char['pipe']
+		elif totlist != vislist:
+			return ansi['default'] + char['gt']
+		return ''
 
 	def showcsv(self):
 		def printcsv(var):
 			if var != round(var):
-				outputfile.write('%.2f' % var)
-			else:
-				outputfile.write('%d' % round(var))
+				return '%.2f' % var
+			return '%s' % round(var)
 
+		line = ''
 		for i, name in enumerate(self.vars):
 			if isinstance(self.val[name], types.ListType) or isinstance(self.val[name], types.TupleType):
 				for j, val in enumerate(self.val[name]):
-					printcsv(val)
+					line = line + printcsv(val)
 					if j + 1 != len(self.val[name]):
-						outputfile.write(',')
+						line = line + ','
 			else:
-				printcsv(self.val[name])
+				line = line + printcsv(self.val[name])
 			if i + 1 != len(self.vars):
-				outputfile.write(',')
+				line = line + ','
+		return line
 
 	def showcsvend(self, totlist, vislist):
 		if self is not vislist[-1]:
-			outputfile.write(',')
+			return ','
 		elif self is not totlist[-1]:
-			outputfile.write(',')
+			return ','
+		return ''
 
 class dstat_cpu(dstat):
 	def __init__(self):
+		self.format = '%s %s %s %s %s %s'
 		self.len = 3
-		self.format = '%s %s %s %s %s %s'
+		self.open('/proc/stat')
 		self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
 		self.vars = self.vars()
 		self.name = []
@@ -389,15 +429,13 @@
 				self.name.append('cpu' + name + ' usage')
 			else:
 				self.name.append('total cpu usage')
-		self.init()
-		for name in self.vars: self.cn1[name] = (0, 0, 0, 0, 0, 0); self.cn1[''] = (0, 0, 0, 0, 0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0, 0, 0, 0, 0); self.cn2[''] = (0, 0, 0, 0, 0, 0)
-		for name in self.vars: self.val[name] = [0, 0, 0, 0, 0, 0]; self.val[''] = [0, 0, 0, 0, 0, 0]
+		self.init( self.vars + ['',], 6)
 
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/stat'):
-			for line in open('/proc/stat', 'r').readlines():
+		if self.fd:
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
 				ret.append(l[0][3:])
@@ -409,37 +447,38 @@
 		ret = []
 		if op.cpulist:
 			list = op.cpulist
+		elif not op.full:
+			list = ('', )
 		else:
-			if not op.full:
-				list = ('', )
-			else:
-				list = []
-				cpu = 0
-				while cpu &lt; cpunr:
-					list.append(str(cpu))
-					cpu = cpu + 1
-				if len(list) &gt; 2: list = list[0:2]
+			list = []
+			cpu = 0
+			while cpu &lt; cpunr:
+				list.append(str(cpu))
+				cpu = cpu + 1
+			if len(list) &gt; 2: list = list[0:2]
 		for name in list:
 			if name in self.discover(''):
 				ret.append(name)
 		return ret
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			for name in self.vars:
 				if len(l) &lt; 8 or l[0] != 'cpu' + name: continue
 				self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
 		for name in self.vars:
-			for i in (0, 1, 2, 3, 4, 5):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (total(self.cn2[name]) - total(self.cn1[name]))
+			for i in range(6):
+				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_cpu24(dstat):
 	def __init__(self):
+		self.format = '%s %s %s'
 		self.len = 3
-		self.format = '%s %s %s'
+		self.open('/proc/stat')
 		self.nick = ( 'usr', 'sys', 'idl')
 		self.vars = self.vars()
 		self.name = []
@@ -448,15 +487,13 @@
 				self.name.append('cpu' + name)
 			else:
 				self.name.append('cpu total')
-		self.init()
-		for name in self.vars: self.cn1[name] = (0, 0, 0); self.cn1[''] = (0, 0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0, 0); self.cn2[''] = (0, 0, 0)
-		for name in self.vars: self.val[name] = [0, 0, 0]; self.val[''] = [0, 0, 0]
+		self.init(self.vars + ['',], 3)
 
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/stat'):
-			for line in open('/proc/stat', 'r').readlines():
+		if self.fd:
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) != 5 or l[0][0:3] != 'cpu': continue
 				ret.append(l[0][3:])
@@ -468,30 +505,30 @@
 		ret = []
 		if op.cpulist:
 			list = op.cpulist
+		elif not op.full:
+			list = ('', )
 		else:
-			if not op.full:
-				list = ('', )
-			else:
-				list = []
-				cpu = 0
-				while cpu &lt; cpunr:
-					list.append(str(cpu))
-					cpu = cpu + 1
-				if len(list) &gt; 2: list = list[0:2]
+			list = []
+			cpu = 0
+			while cpu &lt; cpunr:
+				list.append(str(cpu))
+				cpu = cpu + 1
+			if len(list) &gt; 2: list = list[0:2]
 		for name in list:
 			if name in self.discover(''):
 				ret.append(name)
 		return ret
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			for name in self.vars:
 				if len(l) &lt; 5 or l[0] != 'cpu' + name: continue
 				self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
 		for name in self.vars:
-			for i in (0, 1, 2):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (total(self.cn2[name]) - total(self.cn1[name]))
+			for i in range(3):
+				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
@@ -499,33 +536,23 @@
 	def __init__(self):
 		self.format = '%s %s'
 		self.len = 5
+		self.open('/proc/diskstats')
 		self.nick = ('read', 'write')
-		### Temporary hardcoded for my own project
-		self.diskset = {
-			'local': ('sda', 'hda', 'hdc'), 
-			'lores': ('sdb', 'sdc', 'sdd', 'sde', 'sdf', 'sdg', 'sdh', 'sdi', 'sdj', 'sdk', 'sdv', 'sdw', 'sdx', 'sdy', 'sdz', 'sdaa', 'sdab', 'sdac', 'sdad', 'sdae'),
-			'hires': ('sdl', 'sdm', 'sdn', 'sdo', 'sdp', 'sdq', 'sdr', 'sds', 'sdt', 'sdu', 'sdaf', 'sdag', 'sdah', 'sdai', 'sdaj', 'sdak', 'sdal', 'sdam', 'sdan', 'sdao'),
-		}
 		self.vars = self.vars()
-		self.name = []
-		for name in self.vars:
-			self.name.append('disk/' + name)
-		self.init()
+		self.name = ['disk/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
 
-		for name in self.vars: self.cn1[name] = (0, 0); self.cn1['total'] = (0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0); self.cn2['total'] = (0, 0)
-		for name in self.vars: self.val[name] = [0, 0]; self.val['total'] = [0, 0]
-
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/diskstats'):
-			for line in open('/proc/diskstats', 'r').readlines():
+		if self.fd:
+			regexp = re.compile('^(ram\d+|loop\d+)$')
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) &lt; 13 or l[3] == '0': continue
 				name = l[2]
-				if not re.match('^(ram\d+|loop\d+)$', name):
+				if not regexp.match(name):
 					ret.append(name)
-#			ret.sort()
 			for item in list: ret.append(item)
 		return ret
 
@@ -533,50 +560,64 @@
 		ret = []
 		if op.disklist:
 			list = op.disklist
+		elif not op.full:
+			list = ('total', )
 		else:
-			if not op.full:
-				list = ('total', )
-			else:
-				list = self.discover()
-				if len(list) &gt; 2: list = list[0:2]
-				list.sort()
+			list = self.discover()
+			if len(list) &gt; 2: list = list[0:2]
+			list.sort()
 		for name in list:
-			if name in self.discover('total') + self.diskset.keys():
+			if name in self.discover('total') + op.diskset.keys():
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in open('/proc/diskstats', 'r').readlines():
+		regexp = re.compile('^(ram\d+|loop\d+)$')
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 13: continue
+			if l[5] == '0' and l[9] == '0': continue
 			name = l[2]
+			if regexp.match(name): continue
+			self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
 			if name in self.vars:
 				self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
 			for set in self.vars:
-				if set in self.diskset.keys() and name in self.diskset[set]:
-					self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
-			self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / step,
-				)
+				if set in op.diskset.keys():
+					for disk in op.diskset[set]:
+						if re.match('^'+disk+'$', name):
+							self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
+		for name in self.cn2.keys():
+			self.val[name] = ( 
+				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+			)
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
-class dstat_disk24(dstat_disk):
+class dstat_disk24(dstat):
+	def __init__(self):
+		self.format = '%s %s'
+		self.len = 5
+		self.open('/proc/partitions')
+		self.nick = ('read', 'write')
+		self.vars = self.vars()
+		self.name = ['disk/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
+
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
-			for line in open('/proc/partitions', 'r').readlines():
+		if self.fd and not os.path.exists('/proc/diskstats'):
+			regexp = re.compile('^(ram\d+|loop\d+|name)$')
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
 				name = l[3]
-				if not re.match('^(ram\d+|loop\d+|name)$', name):
+				if not regexp.match(name):
 					ret.append(name)	
-#			ret.sort()
 			for item in list: ret.append(item)
 		return ret
 
@@ -584,50 +625,63 @@
 		ret = []
 		if op.disklist:
 			list = op.disklist
+		elif not op.full:
+			list = ('total', )
 		else:
-			if not op.full:
-				list = ('total', )
-			else:
-				list = self.discover()
-				if len(list) &gt; 2: list = list[0:2]
-				list.sort()
+			list = self.discover()
+			if len(list) &gt; 2: list = list[0:2]
+			list.sort()
 		for name in list:
-			if name in self.discover('total') + self.diskset.keys():
+			if name in self.discover('total') + op.diskset.keys():
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in open('/proc/partitions', 'r').readlines():
+		regexp = re.compile('^(ram\d+|loop\d+|name)$')
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 15: continue
+			if l[6] == '0' and l[10] == '0': continue
 			name = l[3]
 			if name == 'name': continue
+			if regexp.match(name): continue
+			self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]))
 			if name in self.vars:
 				self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
 			for set in self.vars:
-				if set in self.diskset.keys() and name in self.diskset[set]:
-					self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
-			self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]))
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / step,
-				)
+				if set in op.diskset.keys():
+					for disk in op.diskset[set]:
+						if re.match('^'+disk+'$', name):
+							self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
+		for name in self.cn2.keys():
+			self.val[name] = ( 
+				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+			)
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 ### FIXME: Needs rework, does anyone care ?
-class dstat_disk24old(dstat_disk24):
+class dstat_disk24old(dstat):
+	def __init__(self):
+		self.format = '%s %s'
+		self.len = 5
+		self.open('/proc/stat')
+		self.nick = ('read', 'write')
+		self.vars = self.vars()
+		self.name = ['disk/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
+
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/stat') and not os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
-			for line in open('/proc/stat', 'r').readlines():
+		if self.fd and not os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) &lt; 15: continue
 				ret.append(l[3])
-#			ret.sort()
 			for item in list: ret.append(item)
 		return ret
 
@@ -635,60 +689,87 @@
 		ret = []
 		if op.disklist:
 			list = op.disklist
+		elif not op.full:
+			list = ('total', )
 		else:
 			list = self.discover()
-			if not op.full and len(list) &gt; 2: list = list[0:2]
+			if len(list) &gt; 2: list = list[0:2]
 			list.sort()
 		for name in list:
-			if name in self.discover('total') + self.diskset.keys():
+			if name in self.discover('total') + op.diskset.keys():
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in open('/proc/stat', 'r').readlines():
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line, ':')
 			if len(l) &lt; 3: continue
 			name = l[0]
 			if name == 'disk_io':
+				regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
 				for pair in string.split(line)[1:]:
-					m = re.match('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$', pair)
+					m = regexp.match(pair)
 					if m:
 						l = m.groups()
 						name = dev(int(l[0]), int(l[1]))
 						self.cn2[name] = ( long(l[2]), long(l[3]) )
+						self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
 						for set in self.vars:
-							if set in self.diskset.keys() and name in self.diskset[set]:
-								self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
-						self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = (
-					(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / step,
-				)
+							if set in op.diskset.keys():
+								for disk in op.diskset[set]:
+									if re.match('^'+disk+'$', name):
+										self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
+		for name in self.cn2.keys():
+			self.val[name] = (
+				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+			)
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_int(dstat):
 	def __init__(self):
+		self.name = 'interrupts'
+		self.format = '%ds'
 		self.len = 5
-		self.format = '%ds'
-		self.name = 'interrupts'
+		self.open('/proc/stat')
+
+		self.intmap = {}
+		for line in dopen('/proc/interrupts').readlines():
+			l = string.split(line)
+			if len(l) &lt;= cpunr: continue
+			l1 = string.split(l[0], ':')[0]
+			l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
+			self.intmap[l1] = l1
+			for name in l2:
+				self.intmap[string.strip(string.lower(name))] = l1
+
 		self.vars = self.vars()
 		self.nick = self.vars
-		self.init()
+		self.init(self.vars, 1)
 
 	def discover(self):
 		ret = []
-		if os.path.exists('/proc/stat'):
-			for line in open('/proc/stat', 'r').readlines():
+		if self.fd:
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = string.split(line)
 				if l[0] != 'intr': continue
 				for name, i in enumerate(l[2:]):
 					if long(i) &gt; 10: ret.append(str(name))
 		return ret
 
+	def check(self):
+		if self.fd and self.vars:
+			self.fd.seek(0)
+			for line in self.fd.readlines():
+				l = string.split(line)
+				if l[0] != 'intr': continue
+				return True
+		return False
+
 	def vars(self):
 		ret = []
 		if op.intlist:
@@ -702,33 +783,49 @@
 		for name in list:
 			if name in self.discover():
 				ret.append(name)
+			elif string.lower(name) in self.intmap.keys():
+				ret.append(self.intmap[string.lower(name)])
 		return ret
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if l[0] != 'intr': continue
 			for name in self.vars:
 				self.cn2[name] = long(l[int(name) + 2])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_int24(dstat):
 	def __init__(self):
+		self.name = 'interrupts'
+		self.format = '%ds'
 		self.len = 5
-		self.format = '%ds'
-		self.name = 'interrupts'
+		self.open('/proc/interrupts')
+
+		self.intmap = {}
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(line)
+			if len(l) &lt;= cpunr: continue
+			l1 = string.split(l[0], ':')[0]
+			l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
+			self.intmap[l1] = l1
+			for name in l2:
+				self.intmap[string.strip(string.lower(name))] = l1
+
 		self.vars = self.vars()
 		self.nick = self.vars
-		self.init()
+		self.init(self.vars, 1)
 
 	def discover(self):
 		ret = []
-		if os.path.exists('/proc/interrupts'):
-			for line in open('/proc/interrupts', 'r').readlines():
+		if self.fd:
+			self.fd.seek(0)
+			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) &lt; cpunr+1: continue
 				name = string.split(l[0], ':')[0]
@@ -737,10 +834,11 @@
 		return ret
 
 	def check(self):
-		for line in open('/proc/stat', 'r').readlines():
-			l = string.split(line)
-			if l[0] != 'intr' or len(l) &gt; 2: continue
-			if self.discover():
+		if self.fd and self.discover():
+			self.fd.seek(0)
+			for line in self.fd.readlines():
+				l = string.split(line)
+				if l[0] != 'intr' or len(l) &gt; 2: continue
 				return True
 		return False
 
@@ -757,10 +855,13 @@
 		for name in list:
 			if name in self.discover():
 				ret.append(name)
+			elif string.lower(name) in self.intmap.keys():
+				ret.append(self.intmap[string.lower(name)])
 		return ret
 
-	def stats(self):
-		for line in open('/proc/interrupts', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; cpunr+1: continue
 			name = string.split(l[0], ':')[0]
@@ -772,124 +873,162 @@
 #				for hw in self.vars:
 #					for mod in l[2+cpunr:]:
 #						self.cn2[mod] = long(l[1])
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / step
+		for name in self.cn2.keys():
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
+class dstat_ipc(dstat):
+	def __init__(self):
+		self.name = 'sysv ipc'
+		self.format = '%is'
+		self.len = 3
+		self.vars = ('msg', 'sem', 'shm')
+		self.nick = self.vars
+		self.init(self.vars, 1)
+
+	def check(self):
+		return True
+
+	def extract(self):
+		for name in self.vars:
+			self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
+
 class dstat_load(dstat):
 	def __init__(self):
+		self.name = 'load avg'
+		self.format = '%f'
 		self.len = 4
-		self.format = '%f'
-		self.name = 'load avg'
+		self.open('/proc/loadavg')
+		self.nick = ('1m', '5m', '15m')
 		self.vars = ('load1', 'load5', 'load15')
-		self.nick = ('1m', '5m', '15m')
-		self.init()
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/loadavg'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		for line in open('/proc/loadavg', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 3: continue
 			self.val['load1'] = float(l[0])
 			self.val['load5'] = float(l[1])
 			self.val['load15'] = float(l[2])
 
+class dstat_lock(dstat):
+	def __init__(self):
+		self.name = 'file locks'
+		self.format = '%is'
+		self.len = 3
+		self.open('/proc/locks')
+		self.nick = ('pos', 'lck', 'rea', 'wri')
+		self.vars = ('posix', 'flock', 'read', 'write')
+		self.init(self.vars, 1)
+
+	def check(self):
+		if self.fd:
+			return True
+		return False
+
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(line)
+			if len(l) &lt; 4: continue
+			if l[1] == 'POSIX':
+				self.val['posix'] = self.val['posix'] + 1
+			elif l[1] == 'FLOCK':
+				self.val['flock'] = self.val['flock'] + 1
+			if l[3] == 'READ':
+				self.val['read'] = self.val['read'] + 1
+			elif l[3] == 'WRITE':
+				self.val['write'] = self.val['write'] + 1
+
 class dstat_mem(dstat):
 	def __init__(self):
 		self.name = 'memory usage'
+		self.format = '%s'
 		self.len = 5
-		self.format = '%s'
+		self.open('/proc/meminfo')
+		self.nick = ('used', 'buff', 'cach', 'free')
 		self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
-		self.nick = ('used', 'buff', 'cach', 'free')
-		self.init()
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/meminfo'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		for line in open('/proc/meminfo', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 2: continue
-			name = string.split(l[0],':')[0]
+			name = string.split(l[0], ':')[0]
 			if name in self.vars + ('MemTotal',):
 				self.val[name] = long(l[1]) * 1024.0
 		self.val['MemUsed'] = self.val['MemTotal'] - self.val['MemFree'] - self.val['Buffers'] - self.val['Cached']
 
 class dstat_net(dstat):
 	def __init__(self):
+		self.format = '%s %s'
 		self.len = 5
-		self.format = '%s %s'
+		self.open('/proc/net/dev')
+		self.nick = ('recv', 'send')
 		self.vars = self.vars()
-		self.name = []
-		for name in self.vars:
-			self.name.append('net/' + name)
-		self.nick = ('recv', 'send')
-		self.init()
+		self.name = ['net/'+name for name in self.vars]
+		self.init(self.vars + ['total',], 2)
 
-		for name in self.vars: self.cn1[name] = (0, 0); self.cn1['total'] = (0, 0)
-		for name in self.vars: self.cn2[name] = (0, 0); self.cn2['total'] = (0, 0)
-		for name in self.vars: self.val[name] = [0, 0]; self.val['total'] = [0, 0]
-
 	def discover(self, *list):
 		ret = []
-		if os.path.exists('/proc/net/dev'):
-			for line in open('/proc/net/dev', 'r').readlines():
-				l = string.split(line)
-				if len(l) &lt; 2: continue
-				name = string.split(l[0], ':')[0]
-				if l[1] == '0': continue
-				if not re.match('^(Inter-\||face|lo)$', name):
-					ret.append(name)
-			ret.sort()
-			for item in list: ret.append(item)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(string.replace(line, ':', ' '))
+			if len(l) &lt; 17: continue
+			if l[2] == '0' and l[10] == '0': continue
+			name = l[0]
+			if name not in ('lo', 'face'):
+				ret.append(name)
+		ret.sort()
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
 		ret = []
 		if op.netlist:
 			list = op.netlist
+		elif not op.full:
+			list = ('total', )
 		else:
-			if not op.full:
-				list = ('total', )
-			else:
-				list = self.discover()
-				if len(list) &gt; 2: list = list[0:2]
-				list.sort()
+			list = self.discover()
+			if len(list) &gt; 2: list = list[0:2]
+			list.sort()
 		for name in list:
-			if name in self.discover('total'):
+			if name in self.discover('total', 'lo'):
 				ret.append(name)
 		return ret
 
-	def stats(self):
+	def extract(self):
 		self.cn2['total'] = [0, 0]
-		for line in open('/proc/net/dev', 'r').readlines():
-			l = string.split(line)
-			if len(l) &lt; 1: continue
-			l2 = string.split(l[0], ':')
-			if len(l2) &lt; 1: continue
-			name = l2[0]
-			if len(l2) &gt; 1 and string.strip(l2[1]):
-				l = l2[1:] + l[1:]
-			else:
-				l = l[1:]
-			if len(l) &lt; 9: continue
-			if name in (self.vars) :
-				self.cn2[name] = ( long(l[0]), long(l[8]) )
-			if not re.match('^(Inter-\||face|lo)$', name):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[0]), self.cn2['total'][1] + long(l[8]))
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(string.replace(line, ':', ' '))
+			if len(l) &lt; 17: continue
+			if l[2] == '0' and l[10] == '0': continue
+			name = l[0]
+			if name in self.vars :
+				self.cn2[name] = ( long(l[2]), long(l[10]) )
+			if name not in ('lo','face'):
+				self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[10]))
 		if update:
 			for name in self.cn2.keys():
 				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 1.0 / step,
-					(self.cn2[name][1] - self.cn1[name][1]) * 1.0 / step,
+					(self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
+					(self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
 				 )
 		if step == op.delay:
 			self.cn1.update(self.cn2)
@@ -899,45 +1038,55 @@
 		self.name = 'paging'
 		self.format = '%s'
 		self.len = 5
+		self.open('/proc/vmstat')
+		self.nick = ('in', 'out')
 		self.vars = ('pswpin', 'pswpout')
-		self.nick = ('in', 'out')
-		self.init()
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/vmstat'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		for line in open('/proc/vmstat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 2: continue
 			name = l[0]
 			if name in self.vars:
 				self.cn2[name] = long(l[1])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
-class dstat_page24(dstat_page):
+class dstat_page24(dstat):
+	def __init__(self):
+		self.name = 'paging'
+		self.format = '%s'
+		self.len = 5
+		self.open('/proc/stat')
+		self.nick = ('in', 'out')
+		self.vars = ('pswpin', 'pswpout')
+		self.init(self.vars, 1)
+
 	def check(self):
-		if os.path.exists('/proc/stat') and not os.path.exists('/proc/vmstat'):
+		if self.fd and not os.path.exists('/proc/vmstat'):
 			return True
 		return False
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 3: continue
 			name = l[0]
 			if name == 'swap':
 				self.cn2['pswpin'] = long(l[1])
 				self.cn2['pswpout'] = long(l[2])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
@@ -946,19 +1095,19 @@
 		self.name = 'procs'
 		self.format = '%is'
 		self.len = 3
+		self.open('/proc/stat')
+		self.nick = ('run', 'blk', 'new')
 		self.vars = ('procs_running', 'procs_blocked', 'processes')
-#		self.vars = ('procs_running', 'procs_blocked')
-		self.nick = ('run', 'blk', 'new')
-#		self.nick = ('ru', 'bl')
-		self.init()
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/stat'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 2: continue
 			name = l[0]
@@ -969,31 +1118,51 @@
 				self.cn2[name] = self.cn2[name] + long(l[1]) - 1
 			elif name == 'procs_blocked':
 				self.cn2[name] = self.cn2[name] + long(l[1])
-		if update:
-			self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / step
-			for name in ('procs_running', 'procs_blocked'):
-				self.val[name] = self.cn2[name] * 1.0 / step
+		self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
+		for name in ('procs_running', 'procs_blocked'):
+			self.val[name] = self.cn2[name] * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 			for name in ('procs_running', 'procs_blocked'):
 				self.cn2[name] = 0
 
+class dstat_raw(dstat):
+	def __init__(self):
+		self.name = 'raw'
+		self.format = '%is'
+		self.len = 3
+		self.open('/proc/net/raw')
+		self.nick = ('soc',)
+		self.vars = ('sockets',)
+		self.init(self.vars, 1)
+
+	def check(self):
+		if self.fd:
+			return True
+		return False
+
+	def extract(self):
+		self.fd.seek(0)
+		self.val['sockets'] = len(self.fd.readlines()) - 1
+
 class dstat_swap(dstat):
 	def __init__(self):
 		self.name = 'swap'
+		self.format = '%s'
 		self.len = 5
-		self.format = '%s'
+		self.open('/proc/meminfo')
+		self.nick = ('used', 'free')
 		self.vars = ('SwapUsed', 'SwapFree')
-		self.nick = ('used', 'free')
-		self.init()
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/meminfo'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		for line in open('/proc/meminfo', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 2: continue
 			name = string.split(l[0], ':')[0]
@@ -1006,45 +1175,48 @@
 		self.name = 'system'
 		self.format = '%ds'
 		self.len = 5
+		self.open('/proc/stat')
+		self.nick = ('int', 'csw')
 		self.vars = ('intr', 'ctxt')
-		self.nick = ('int', 'csw')
-		self.init()
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/stat'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		for line in open('/proc/stat', 'r').readlines():
+	def extract(self):
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 2: continue
 			name = l[0]
 			if name in self.vars:
 				self.cn2[name] = long(l[1])
-		if update:
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / step
+		for name in self.vars:
+			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
 		if step == op.delay:
 			self.cn1.update(self.cn2)
 
 class dstat_tcp(dstat):
 	def __init__(self):
-		self.name = 'tcp'
+		self.name = 'tcp sockets'
 		self.format = '%is'
 		self.len = 3
+		self.open('/proc/net/tcp')
+		self.nick = ('lis', 'act', 'syn', 'tim')
 		self.vars = ('listen', 'established', 'syn_sent', 'time_wait')
-		self.nick = ('lis', 'act', 'syn', 'tim')
-		self.init()
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/net/tcp'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		self.val['listen'] = self.val['established'] = self.val['syn_sent'] = self.val['time_wait'] = 0
-		for line in open('/proc/net/tcp', 'r').readlines():
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 12: continue
 			if l[3] == '0A': self.val['listen'] = self.val['listen'] + 1
@@ -1060,65 +1232,72 @@
 		### Nice for debugging timer
 #		self.format = '%13.3f'
 #		self.len = 14
+		self.format = '%13.4f'
+		self.len = 15
 		self.nick = ('epoch',)
 		self.vars = ('epoch',)
-		self.init()
+		self.init(self.vars, 1)
 
-	def stats(self):
+	def extract(self):
 		self.val['epoch'] = time.time()
 
-	def show(self):
-		sys.stdout.write(self.format % self.val['epoch'])
+	def results(self):
+		return ansi['reset'] + self.format % self.val['epoch']
 
 class dstat_udp(dstat):
 	def __init__(self):
 		self.name = 'udp'
 		self.format = '%is'
 		self.len = 3
-		self.nick = ('con', )
-		self.vars = ('connections', )
-		self.init()
+		self.open('/proc/net/udp')
+		self.nick = ('lis', 'act')
+		self.vars = ('listen', 'established')
+		self.init(self.vars, 1)
 
 	def check(self):
-		if os.path.exists('/proc/net/udp'):
+		if self.fd:
 			return True
 		return False
 
-	def stats(self):
-		self.val['connections'] = 0
-		for line in open('/proc/net/udp', 'r').readlines():
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
 			l = string.split(line)
-			if l[3] == '07': self.val['connections'] = self.val['connections'] + 1
+			if l[3] == '07': self.val['listen'] = self.val['listen'] + 1
+			elif l[3] == '01': self.val['established'] = self.val['established'] + 1
 
-class dstat_user(dstat):
+class dstat_unix(dstat):
 	def __init__(self):
-		self.name = 'users'
-		self.format = '%is'
-		self.len = 3
-		self.nick = ('usr', 'adm' )
-		self.vars = ('users', 'root')
-		self.init()
+		self.name = 'unix sockets'
+		self.format = '%ds'
+		self.len = 4
+		self.open('/proc/net/unix')
+		self.nick = ('dgrm', 'strm', 'lis', 'act')
+		self.vars = ('datagram', 'stream', 'listen', 'established')
+		self.init(self.vars, 1)
 
 	def check(self):
-		try:
-			import utmp
+		if self.fd:
 			return True
-		except:
-			print 'The user stat needs the python-utmp module.'
-			return False
+		return False
 
-	def stats(self):
-		import utmp
-		u = utmp.UtmpRecord()
-		self.val['users'] = 0
-		self.val['root'] = 0
-		for i in u:
-			if i.ut_type == utmp.USER_PROCESS:
-				self.val['users'] = self.val['users'] + 1
-				if i.ut_user == 'root':
-					self.val['root'] = self.val['root'] + 1
-			
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(line)
+			if l[4] == '0002':
+				self.val['datagram'] = self.val['datagram'] + 1
+			elif l[4] == '0001':
+				self.val['stream'] = self.val['stream'] + 1
+				if l[5] == '01':
+					self.val['listen'] = self.val['listen'] + 1
+				elif l[5] == '03':
+					self.val['established'] = self.val['established'] + 1
 
+### END STATS DEFINITIONS ###
+
 ansi = {
 	'black': '\033[0;30m',
 	'darkred': '\033[0;31m',
@@ -1172,12 +1351,35 @@
 	'space': ' ',
 }
 
-def total(list):
-	ret = 0
-	for i in list:
-		ret = ret + i
-	return ret
+def ticks():
+	try:
+		for line in open('/proc/uptime', 'r', 0).readlines():
+			l = string.split(line)
+			if len(l) &lt; 2: continue
+			return float(l[0])
+	except:
+		for line in dopen('/proc/stat').readlines():
+			l = string.split(line)
+			if len(l) &lt; 2: continue
+			if l[0] == 'btime':
+				return time.time() - long(l[1])
 
+def dopen(file):
+	global fds
+	if not 'fds' in globals(): fds = {}
+	if not file in fds:
+		fds[file] = open(file, 'r', 0)
+	else:
+		fds[file].seek(0)
+	return fds[file]
+
+def dclose(file):
+	global fds
+	if not 'fds' in globals(): fds = {}
+	if file in fds:
+		close(fds[file])
+		del(fds[file])
+
 def convlist(max, list, base = 1024):
 #	max = max / len(list)
 	retlist = ()
@@ -1233,20 +1435,22 @@
 	return ansi[color[c]] + string.rjust(repr, max)
 
 def showtitle(nr, totlist, vislist, midchar, endchar):
+	line = ''
 	for o in vislist:
-		sys.stdout.write(o.title(nr))
+		line = line + o.title(nr)
 		if o is not vislist[-1]:
-			sys.stdout.write(midchar)
+			line = line + midchar
 		elif totlist != vislist:
-			sys.stdout.write(endchar)
-	sys.stdout.write('\n')
+			line = line + endchar
+	sys.stdout.write(line + '\n')
 
 def showcsvtitle(nr, totlist):
+	line = ''
 	for o in totlist:
-		outputfile.write(o.titlecsv(nr))
+		line = line + o.titlecsv(nr)
 		if o is not totlist[-1]:
-			outputfile.write(',')
-	outputfile.write('\n')
+			line = line + ','
+	outputfile.write(line + '\n')
 
 def info(level, str):
 	&quot;Output info message&quot;
@@ -1256,7 +1460,7 @@
 def die(ret, str):
 	&quot;Print error and exit with errorcode&quot;
 	info(0, str)
-	sys.exit(ret)
+	exit(ret)
 
 def getwinsize():
 	if op.nolimit:
@@ -1278,7 +1482,7 @@
 
 def getcpunr():
 	cpunr = -1
-	for line in open('/proc/stat', 'r').readlines():
+	for line in dopen('/proc/stat').readlines():
 		if line[0:3] == 'cpu':
 			cpunr = cpunr + 1
 	return cpunr
@@ -1302,7 +1506,7 @@
 
 #def mountpoint(dev):
 #	&quot;Return the mountpoint of a mounted device/file&quot;
-#	for entry in open('/etc/mtab', 'r').readlines():
+#	for entry in dopen('/etc/mtab').readlines():
 #		if entry:
 #			list = string.split(entry)
 #			if dev == list[0]:
@@ -1313,55 +1517,39 @@
 
 def exit(ret):
 	sys.stdout.write(ansi['reset'])
-	signal.signal(signal.SIGALRM, signal.SIG_DFL)
+	if 'signal' in sys.modules:
+		signal.signal(signal.SIGALRM, signal.SIG_DFL)
+#	termios.tcsetattr(fd, termios.TCSADRAIN, old)
 	sys.exit(ret)
 
 def main():
-	global update, loop, step, pagesize, cpunr, ansi, interval, outputfile
+	global update, loop, step, pagesize, cpunr, ansi, interval, outputfile, tick
 
 	loop = update = 0
 	step = op.delay
+	tick = ticks()
 	pagesize = resource.getpagesize()
 	cpunr = getcpunr()
 #	hz = os.sysconf('SC_CLK_TCK')
 	interval = 1
 
 	if op.output:
-		outputfile = open(op.output, 'a', 0)
-
-	### Build list of requested modules
-	totlist = []
-	for mod in op.modlist:
-		if mod == 'cpu':
-			totlist.append(dstat_cpu())
-			totlist.append(dstat_cpu24())
-		elif mod == 'disk':
-			totlist.append(dstat_disk())
-			totlist.append(dstat_disk24())
-			totlist.append(dstat_disk24old())
-		elif mod == 'int':
-			totlist.append(dstat_int())
-			totlist.append(dstat_int24())
-		elif mod == 'load':	totlist.append(dstat_load())
-		elif mod == 'mem':	totlist.append(dstat_mem())
-		elif mod == 'net':	totlist.append(dstat_net())
-		elif mod == 'page':
-			totlist.append(dstat_page())
-			totlist.append(dstat_page24())
-		elif mod == 'proc':	totlist.append(dstat_proc())
-		elif mod == 'swap':	totlist.append(dstat_swap())
-		elif mod == 'sys':	totlist.append(dstat_sys())
-		elif mod == 'tcp':	totlist.append(dstat_tcp())
-		elif mod == 'time':	totlist.append(dstat_time())
-		elif mod == 'udp':	totlist.append(dstat_udp())
-		elif mod == 'user':	totlist.append(dstat_user())
+		if os.path.exists(op.output):
+			outputfile = open(op.output, 'a', 0)
+			outputfile.write('\n\n')
 		else:
-			info(1, 'Module \'%s\' does not exist or failed to load.' % mod)
+			outputfile = open(op.output, 'w', 0)
+			outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
+			outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
 
+		### FIXME: Get rid of socket()
+		import socket
+		outputfile.write('&quot;Host:&quot;,&quot;%s&quot;\n' % (socket.gethostbyaddr(socket.gethostname())[0]))
+		outputfile.write('&quot;Cmdline:&quot;,&quot;dstat %s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n\n' % (' '.join(op.args), time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
+
 	### Check terminal capabilities
 	if sys.stdout.isatty():
-#		if curses.tigetnum('colors') &lt; 0:
-		if os.environ.get('TERM', None) not in ('ansi', 'gnome', 'linux', 'rxvt', 'screen', 'screen-w', 'xterm', 'xterm-color'):
+		if curses.tigetnum('colors') &lt; 0:
 			op.color = False
 	else:
 		op.color = False
@@ -1379,46 +1567,54 @@
 	if not op.update:
 		interval = op.delay
 
-	### Remove defect objects and calculate line length
+	### Build list of requested modules
 	linewidth = 0
-	for o in totlist + []:
-		if o.check():
-			linewidth = linewidth + o.varwidth() + 1
+	oldvislist = []
+	totlist = []
+	for mod in op.modlist:
+		if mod == 'cpu':    objs = ( dstat_cpu(), dstat_cpu24() )
+		elif mod == 'disk': objs = ( dstat_disk(), dstat_disk24(), dstat_disk24old() )
+		elif mod == 'int':  objs = ( dstat_int(), dstat_int24() )
+		elif mod == 'page': objs = ( dstat_page(), dstat_page24() )
+		elif 'dstat_'+mod in globals():
+			exec(compile('objs = ( dstat_%s(), )' % mod, '&lt;string&gt;', 'exec'))
 		else:
-			totlist.remove(o)
+			try:
+				exec(compile('import dstat_%s\nobjs = ( dstat_%s.dstat_%s(), )' % (mod, mod, mod), '&lt;string&gt;', 'exec'))
+			except Exception, e:
+				info(1, 'Module \'dstat_%s\' does not exist or failed to load. (%s)' % (mod, e))
+				continue
 
+		### Remove defect stat objects and calculate line length
+		for o in objs:
+			if o.check():
+				linewidth = linewidth + o.varwidth() + 1
+				totlist.append(o)
+				break
+
 	if not totlist:
 		die(8, 'None of the stats you selected are available.')
 
-	### FIXME: Get rid of socket()
 	if op.output:
-		import socket
-		outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
-		outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
-		outputfile.write('&quot;Host:&quot;,&quot;%s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n' % (socket.gethostbyaddr(socket.gethostname())[0], time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
-		outputfile.write('&quot;Cmd:&quot;,&quot;dstat %s&quot;\n\n' % ' '.join(op.args))
+		showcsvtitle(1, totlist)
+		showcsvtitle(2, totlist)
 
-		if op.output:
-			showcsvtitle(1, totlist)
-			showcsvtitle(2, totlist)
-	oldvislist = []
-
 	### Increase precision if we're root (does not seem to have effect)
 #	if os.geteuid() == 0:
 #		os.nice(-20)
 #	sys.setcheckinterval(op.delay / 10000)
 
+	### Always show header the first time
+	showheader = True
+
 	signal.signal(signal.SIGALRM, signaler)
 	signal.alarm(interval)
 
-	### Always show header the first time
-	showheader = True
-
 	### Let the games begin
 	while update &lt;= op.delay * op.count or op.count == -1:
 
 		### Trim object list to what is visible on screen
-		(rows, cols) = getwinsize()
+		rows, cols = getwinsize()
 		vislist = []
 		curwidth = 0
 		for o in totlist:
@@ -1450,31 +1646,40 @@
 			ansi['default'] = ansi['reset']
 		else:
 			ansi['default'] = ansi['gray']
-		sys.stdout.write(ansi['default'])
+		line = ansi['default']
 
 		### Debugging info
-#		sys.stdout.write('[%d:%d:%d] ' % (loop, step, update))
+#		line = line + '[%d:%d:%d] ' % (loop, step, update)
 
-		### Show the stats, calculate all objects (visible, invisible)
+		### Calculate all objects (visible, invisible)
+		oline = ''
 		for o in totlist:
-			o.stats()
+			o.extract()
 			if o in vislist:
-				o.show()
-				o.showend(totlist, vislist)
+				line = line + o.results() + o.showend(totlist, vislist)
 			if op.output and step == op.delay:
-				o.showcsv()
-				o.showcsvend(totlist, vislist)
-		sys.stdout.write(ansi['default'])
+				oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
+
+		### Print stats
+		sys.stdout.write(line + ansi['default'])
 		if op.output and step == op.delay:
-			outputfile.write('\n')
+			outputfile.write(oline + '\n')
 
 		### If intermediate results, update increases with 1 sec (=interval)
 		update = update + interval
 
+		### Debugging/profiling
+#		global t1
+#		if not 't1' in globals(): t1 = tick
+#		sys.stdout.write(' [%4.4f' % (time.time() - t1))
+
 		### Do not pause when this is the final loop
 		if update &lt;= op.delay * op.count or op.count == -1:
 			signal.pause()
 
+		### Debuggine/profiling
+#		t1 = time.time()
+
 		### The last step in a loop is to show the definitive line on its own line
 		if step == op.delay:
 			sys.stdout.write('\n' + ansi['reset'] + ansi['clearline'] + ansi['save'])
@@ -1483,43 +1688,35 @@
 
 		loop = (update + op.delay - 1) / op.delay
 		step = ((update - 1) % op.delay) + 1
+		tick = step
 
-### Unbuffered sys.stdout
-sys.stdout = os.fdopen(1, 'w', 0)
+### Main entrance
+if __name__ == '__main__':
+	try:
+		### Unbuffered sys.stdout
+		sys.stdout = os.fdopen(1, 'w', 0)
 
-### Workaround for python &lt;= 2.2.1
-try:
-     True, False
-except NameError:
-     True = 1
-     False = 0
-Yes = yes = On = on = True
-No = no = Off = off = False
+		curses.setupterm()
 
-### Workaround for python &lt; 2.1
-def enumerate(sequence):
-    index = 0
-    list = []
-    for item in sequence:
-#        yield index, item
-        list.append((index, item))
-        index = index + 1
-    return list
+		### Prevent keyboard input
+#		fd = sys.stdin.fileno()
+#		old = termios.tcgetattr(fd)
+#		new = termios.tcgetattr(fd)
+#		new[3] = new[3] &amp; ~termios.ECHO
+#		termios.tcsetattr(fd, termios.TCSADRAIN, new)
 
-### Main entrance
-if __name__ == '__main__':
-	op=Options(sys.argv[1:])
-#	cf=Config()
-	try:
+		op = Options(sys.argv[1:])
 		main()
 	except KeyboardInterrupt, e:
 		print
 	except OSError, e:
-#		print e.errno
 		print
 		print 'OSError: %s' % e
 		exit(7)
+	exit(0)
+else:
+	op = Options('')
+	step = 1
+	tick = ticks()
 
-exit(0)
-
 # vim:ts=4:sw=4

Added: trunk/tools/dstat/examples/curstest
===================================================================
--- trunk/tools/dstat/examples/curstest	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/examples/curstest	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,23 @@
+#!/usr/bin/python
+import curses, sys
+
+#c = curses.wrapper(s)
+#w = curses.initscr()
+#curses.start_color()
+#print &quot;TERM is&quot;, curses.termname()
+#if curses.has_colors():
+#	print &quot;Has colors&quot;#
+#print curses.color_pair(curses.COLOR_RED), &quot;Red&quot;
+#curses.endwin()
+
+#curses.setupterm('xterm')
+curses.setupterm()
+
+if sys.stdout.isatty():
+	print &quot;Is a TTY&quot;
+
+print &quot;Size is %sx%s&quot; % (curses.tigetnum('lines'), curses.tigetnum('cols'))
+
+if curses.tigetnum('colors') &gt; 0:
+	print &quot;Has colors&quot;
+	print curses.tigetnum('colors')


Property changes on: trunk/tools/dstat/examples/curstest
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/tools/dstat/examples/mstat.py
===================================================================
--- trunk/tools/dstat/examples/mstat.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/examples/mstat.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,39 @@
+#!/usr/bin/python
+
+### Example2: simple sub-second monitor (ministat)
+
+### This is a quick example showing how to implement your own *stat utility
+### If you're interested in such functionality, contact me at <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>
+import sys
+sys.path.insert(0, '/usr/share/dstat/')
+import dstat, time
+
+### Allow arguments
+try: delay = float(sys.argv[1])
+except: delay = 0.2
+try: count = int(sys.argv[2])
+except: count = 10
+
+### Load stats
+stats = (dstat.dstat_time(), dstat.dstat_cpu(), dstat.dstat_mem(), dstat.dstat_load(), dstat.dstat_disk(), dstat.dstat_sys())
+
+### Make time stats sub-second
+stats[0].format = ('t', 13, 0)
+
+### Print headers
+title1 = title2 = ''
+for o in stats:
+	title1 = title1 + '  ' + o.title1()
+	title2 = title2 + '  ' + o.title2()
+print '\n' + title1 + '\n' + title2
+
+### Print stats
+for dstat.update in range(count):
+	line = ''
+	for o in stats:
+		o.extract()
+		line = line + '  ' + repr(o)
+	print line
+	if dstat.update != count-1: time.sleep(delay)
+	dstat.tick = 1
+print dstat.ansi['reset']


Property changes on: trunk/tools/dstat/examples/mstat.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/tools/dstat/examples/read.py
===================================================================
--- trunk/tools/dstat/examples/read.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/examples/read.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,39 @@
+#!/usr/bin/python
+
+### Example 1: Direct accessing stats
+### This is a quick example showing how you can access dstat data
+### If you're interested in this functionality, contact me at <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>
+import sys
+sys.path.insert(0, '/usr/share/dstat/')
+import dstat
+
+clear = dstat.ansi['reset']
+
+c = dstat.dstat_cpu()
+print c.title1() + '\n' + c.title2()
+c.extract()
+print c, clear
+print 'Percentage:', c.val['']
+print 'Raw:', c.cn2['']
+print
+
+m = dstat.dstat_mem()
+print m.title1() + '\n' + m.title2()
+m.extract()
+print m, clear
+print 'Raw:', m.val
+print
+
+l = dstat.dstat_load()
+print l.title1() + '\n' + l.title2()
+l.extract()
+print l, clear
+print 'Raw:', l.val
+print
+
+d = dstat.dstat_disk()
+print d.title1() + '\n' + d.title2()
+d.extract()
+print d, clear
+print 'Raw:', d.val['total']
+print


Property changes on: trunk/tools/dstat/examples/read.py
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/tools/dstat/stats/dstat.py
===================================================================
--- trunk/tools/dstat/stats/dstat.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/stats/dstat.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1 @@
+link ../dstat
\ No newline at end of file


Property changes on: trunk/tools/dstat/stats/dstat.py
___________________________________________________________________
Name: svn:special
   + *

Added: trunk/tools/dstat/stats/dstat_battery.py
===================================================================
--- trunk/tools/dstat/stats/dstat_battery.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/stats/dstat_battery.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,25 @@
+import dstat, string, os
+
+class dstat_battery(dstat.dstat):
+	def __init__(self):
+		self.name = 'battery'
+		self.format = ('f', 4, 34)
+		self.vars = os.listdir('/proc/acpi/battery/')
+		self.nick = [string.lower(name) for name in self.vars]
+		self.init(self.vars, 1)
+
+	def extract(self):
+		for battery in self.vars:
+			for line in dstat.dopen('/proc/acpi/battery/'+battery+'/info').readlines():
+				l = string.split(line)
+				if len(l) &lt; 4: continue
+				if l[0] == 'last':
+					full = int(l[3])
+			for line in dstat.dopen('/proc/acpi/battery/'+battery+'/state').readlines():
+				l = string.split(line)
+				if len(l) &lt; 3: continue
+				if l[0] == 'remaining':
+					current = int(l[2])
+			self.val[battery] = current * 100.0 / full
+
+# vim:ts=4:sw=4

Added: trunk/tools/dstat/stats/dstat_cpufreq.py
===================================================================
--- trunk/tools/dstat/stats/dstat_cpufreq.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/stats/dstat_cpufreq.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,32 @@
+import dstat, string, os
+
+class dstat_cpufreq(dstat.dstat):
+	def __init__(self):
+		self.name = 'frequency'
+		self.format = ('p', 4, 34)
+		self.vars = os.listdir('/sys/devices/system/cpu/')
+		self.nick = [string.lower(name) for name in self.vars]
+		self.init(self.vars, 1)
+
+	def check(self): 
+		if self.vars:
+			for cpu in self.vars:
+				if not os.access('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq', os.R_OK):
+					dstat.info(1, 'cpufreq: Cannot access acpi cpu frequency information.')
+					return False
+			return True
+		return false
+
+	def extract(self):
+		for cpu in self.vars:
+			for line in dstat.dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_max_freq').readlines():
+				l = string.split(line)
+				max = int(l[0])
+			for line in dstat.dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq').readlines():
+				l = string.split(line)
+				cur = int(l[0])
+			### Need to close becausee of bug in sysfs (?)
+			dstat.dclose('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq')
+			self.val[cpu] = cur * 100.0 / max
+
+# vim:ts=4:sw=4

Added: trunk/tools/dstat/stats/dstat_dbus.py
===================================================================
--- trunk/tools/dstat/stats/dstat_dbus.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/stats/dstat_dbus.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,40 @@
+import dstat
+
+class dstat_dbus(dstat.dstat):
+	def __init__(self):
+		self.name = 'dbus'
+		self.format = ('d', 3, 100)
+		self.nick = ('sys', 'ses')
+		self.vars = ('system', 'session')
+		self.init(self.vars, 1)
+
+	def check(self): 
+#		dstat.info(1, 'The dbus module is an EXPERIMENTAL module.')
+		try:
+			global dbus
+			import dbus
+			try:
+				self.sysbus = dbus.Bus(dbus.Bus.TYPE_SYSTEM).get_service('org.freedesktop.DBus').get_object('/org/freedesktop/DBus', 'org.freedesktop.DBus')
+				try:
+					self.sesbus = dbus.Bus(dbus.Bus.TYPE_SESSION).get_service('org.freedesktop.DBus').get_object('/org/freedesktop/DBus', 'org.freedesktop.DBus')
+				except:
+					self.sesbus = None
+			except:
+				info(1, 'dbus: Unable to connect to dbus message bus.')
+				return False
+			return True
+		except:
+			info(1, 'dbus: The dbus stat needs the python-dbus module.')
+			return False
+
+	def extract(self):
+		self.val['system'] = len(self.sysbus.ListServices()) - 1
+		try:
+			self.val['session'] = len(self.sesbus.ListServices()) - 1
+		except:
+			self.val['session'] = -1
+#		print dir(b); print dir(s); print dir(d); print d.ListServices()
+#		print dir(d)
+#		print d.ListServices()
+
+# vim:ts=4:sw=4

Added: trunk/tools/dstat/stats/dstat_qla2300.py
===================================================================

Added: trunk/tools/dstat/stats/dstat_thermal.py
===================================================================
--- trunk/tools/dstat/stats/dstat_thermal.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/stats/dstat_thermal.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,17 @@
+import dstat, string, os
+
+class dstat_thermal(dstat.dstat):
+	def __init__(self):
+		self.name = 'thermal'
+		self.format = ('d', 4, 20)
+		self.vars = os.listdir('/proc/acpi/thermal_zone/')
+		self.nick = [string.lower(name) for name in self.vars]
+		self.init(self.vars, 1)
+
+	def extract(self):
+		for zone in self.vars:
+			for line in dstat.dopen('/proc/acpi/thermal_zone/'+zone+'/temperature').readlines():
+				l = string.split(line)
+				self.val[zone] = int(l[1])
+
+# vim:ts=4:sw=4

Added: trunk/tools/dstat/stats/dstat_utmp.py
===================================================================
--- trunk/tools/dstat/stats/dstat_utmp.py	2005-04-26 20:44:24 UTC (rev 3162)
+++ trunk/tools/dstat/stats/dstat_utmp.py	2005-04-28 14:21:25 UTC (rev 3163)
@@ -0,0 +1,30 @@
+import dstat
+
+class dstat_utmp(dstat.dstat):
+	def __init__(self):
+		self.name = 'utmp'
+		self.format = ('d', 3, 10)
+		self.nick = ('ses', 'usr', 'adm' )
+		self.vars = ('sessions', 'users', 'root')
+		self.init(self.vars, 1)
+
+	def check(self): 
+		try:
+			global utmp
+			import utmp
+			return True
+		except:
+			info(1, 'utmp: The utmp stat needs the python-utmp module.')
+			return False
+
+	def extract(self):
+		for name in self.vars: self.val[name] = 0
+		for u in utmp.UtmpRecord():
+#			print '# type:%s pid:%s line:%s id:%s user:%s host:%s session:%s' % (i.ut_type, i.ut_pid, i.ut_line, i.ut_id, i.ut_user, i.ut_host, i.ut_session)
+			if u.ut_type == utmp.USER_PROCESS:
+				self.val['users'] = self.val['users'] + 1
+				if u.ut_user == 'root':
+					self.val['root'] = self.val['root'] + 1
+			self.val['sessions'] = self.val['sessions'] + 1
+
+# vim:ts=4:sw=4


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001964.html">[svn] r3162 - in trunk/rpms: perl-Apache-AuthCookie perl-DBD-Chart	perl-DBIx-Recordset perl-Math-GMP perl-Net-RawIP	perl-News-Scan perl-Plucene perl-XML-SimpleObject
</A></li>
	<LI>Next message: <A HREF="001966.html">[svn] r3164 - trunk/tools/yam
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1965">[ date ]</a>
              <a href="thread.html#1965">[ thread ]</a>
              <a href="subject.html#1965">[ subject ]</a>
              <a href="author.html#1965">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
