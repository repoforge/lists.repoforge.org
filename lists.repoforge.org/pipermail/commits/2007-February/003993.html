<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r5194 - in trunk/rpms: . splitvt tcpshow tcpstat
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5194%20-%20in%20trunk/rpms%3A%20.%20splitvt%20tcpshow%20tcpstat&In-Reply-To=%3C20070222223312.3497995CDE6%40pooch.vmhosting.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003992.html">
   <LINK REL="Next"  HREF="003994.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r5194 - in trunk/rpms: . splitvt tcpshow tcpstat</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5194%20-%20in%20trunk/rpms%3A%20.%20splitvt%20tcpshow%20tcpstat&In-Reply-To=%3C20070222223312.3497995CDE6%40pooch.vmhosting.org%3E"
       TITLE="[svn] r5194 - in trunk/rpms: . splitvt tcpshow tcpstat">packagers at lists.rpmforge.net
       </A><BR>
    <I>Thu Feb 22 23:33:12 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003992.html">[svn] r5193 - in trunk/rpms: . perl-X11-GUITest watchdog
</A></li>
        <LI>Next message: <A HREF="003994.html">[svn] r5195 - in trunk/rpms: . exdump morse mpack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3993">[ date ]</a>
              <a href="thread.html#3993">[ thread ]</a>
              <a href="subject.html#3993">[ subject ]</a>
              <a href="author.html#3993">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2007-02-22 23:33:11 +0100 (Thu, 22 Feb 2007)
New Revision: 5194

Added:
   trunk/rpms/splitvt/
   trunk/rpms/splitvt/splitvt-1.6.5-config.patch
   trunk/rpms/splitvt/splitvt.spec
   trunk/rpms/tcpshow/
   trunk/rpms/tcpshow/tcpshow.1
   trunk/rpms/tcpshow/tcpshow.c
   trunk/rpms/tcpshow/tcpshow.patch
   trunk/rpms/tcpshow/tcpshow.spec
   trunk/rpms/tcpstat/
   trunk/rpms/tcpstat/tcpstat.spec
Log:
Updates

Added: trunk/rpms/splitvt/splitvt-1.6.5-config.patch
===================================================================
--- trunk/rpms/splitvt/splitvt-1.6.5-config.patch	                        (rev 0)
+++ trunk/rpms/splitvt/splitvt-1.6.5-config.patch	2007-02-22 22:33:11 UTC (rev 5194)
@@ -0,0 +1,38 @@
+--- config.c.orig	2003-05-03 22:48:04.000000000 +0200
++++ config.c	2007-02-22 23:34:45.598421000 +0100
+@@ -213,7 +213,12 @@
+ 	fprintf(makefile, 
+ &quot;# Shareware copyright 1993, by Sam Lantinga\n\n&quot;);
+ #ifdef linux
+-	fprintf(makefile, &quot;\nCC = gcc\n&quot;);
++	fprintf(makefile, &quot;DESTDIR = \n&quot;);
++	fprintf(makefile, &quot;prefix = /usr\n&quot;);
++	fprintf(makefile, &quot;bindir = $(prefix)/bin\n&quot;);
++	fprintf(makefile, &quot;datadir = $(prefix)/share\n&quot;);
++	fprintf(makefile, &quot;mandir = $(datadir)/man\n&quot;);
++	fprintf(makefile, &quot;CC = gcc\n&quot;);
+ #endif
+ 	fclose(makefile);
+ 	system(&quot;sh scanpty &gt;&gt;Makefile&quot;);
+@@ -231,17 +236,17 @@
+ 	fprintf(makefile, &quot;       parserc.o lock.o cut-paste.o\n\n&quot;);
+ 	fprintf(makefile, &quot;splitvt: $(OBJS)\n&quot;);
+ #if defined(linux) &amp;&amp; !defined(DEBUG)
+-	fprintf(makefile, &quot;\t$(CC) -s -o $@ $(OBJS) $(LIBS)\n&quot;);
++	fprintf(makefile, &quot;\t$(CC) -s $(CFLAGS) -o $@ $(OBJS) $(LIBS)\n&quot;);
+ #else
+ 	fprintf(makefile, &quot;\t$(CC) -o $@ $(OBJS) $(LIBS)\n&quot;);
+ #endif
+ 	fprintf(makefile, &quot;\nclean: \n\trm -f *.o core \n&quot;);
+ 	fprintf(makefile, &quot;\ndistclean: clean\n\trm -f splitvt Makefile\n&quot;);
+ 	fprintf(makefile, &quot;\ninstall: install-man\n&quot;);
+-	fprintf(makefile, &quot;\tmv splitvt /usr/local/bin/splitvt\n&quot;);
+-	fprintf(makefile, &quot;\tmv examples/xsplitvt /usr/local/bin/xsplitvt\n&quot;);
++	fprintf(makefile, &quot;\tinstall -Dp -m0755 splitvt $(DESTDIR)$(bindir)/splitvt\n&quot;);
++	fprintf(makefile, &quot;\tinstall -Dp -m0755 examples/xsplitvt $(DESTDIR)$(bindir)/xsplitvt\n&quot;);
+ 	fprintf(makefile, &quot;\ninstall-man:\n&quot;);
+-	fprintf(makefile, &quot;\tcp splitvt.man /usr/local/man/man1/splitvt.1\n&quot;);
++	fprintf(makefile, &quot;\tinstall -Dp -m0644 splitvt.man $(DESTDIR)$(mandir)/man1/splitvt.1\n&quot;);
+ 
+ 	fclose(makefile);
+ 	exit(0);

Added: trunk/rpms/splitvt/splitvt.spec
===================================================================
--- trunk/rpms/splitvt/splitvt.spec	                        (rev 0)
+++ trunk/rpms/splitvt/splitvt.spec	2007-02-22 22:33:11 UTC (rev 5194)
@@ -0,0 +1,52 @@
+# $Id$
+# Authority: dag
+
+Summary: Splits any VT100 terminal window into two shell window
+Name: splitvt
+Version: 1.6.5
+Release: 1
+License: GPL
+Group: System Environment/Console
+URL: <A HREF="http://www.devolution.com/~slouken/projects/splitvt/">http://www.devolution.com/~slouken/projects/splitvt/</A>
+
+Source: <A HREF="http://www.devolution.com/~slouken/projects/splitvt/splitvt-%{version">http://www.devolution.com/~slouken/projects/splitvt/splitvt-%{version</A>}.tar.gz
+Patch: splitvt-1.6.5-config.patch
+Buildroot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+%description
+This program takes any VT100 terminal window and splits it into two shell
+windows, one on top and one on bottom. It allows you to watch two terminal
+sessions at once, which can be very useful whenever you want more screen
+real-estate without messing with windows. 
+
+%prep
+%setup
+%patch -p0 -b .orig
+%{__rm} -f Makefile
+
+%build
+./configure -q
+%{__make} %{?_smp_mflags}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+#%{__install} -Dp -m0755 splitvt.1 %{buildroot}%{_mandir}/man1/splitvt.1
+
+%post -p /sbin/ldconfig
+%postun -p /sbin/ldconfig
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%doc ANNOUNCE BLURB COPYING README TODO splitvt-1.6.5.lsm
+%doc escapes/* examples/*
+%doc %{_mandir}/man1/splitvt.1*
+%{_bindir}/splitvt
+%{_bindir}/xsplitvt
+
+%changelog
+* Thu Feb 22 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 1.6.5-1
+- Initial package. (using DAR)


Property changes on: trunk/rpms/splitvt/splitvt.spec
___________________________________________________________________
Name: svn:keywords
   + Id Revision
Name: svn:eol-style
   + native

Added: trunk/rpms/tcpshow/tcpshow.1
===================================================================
--- trunk/rpms/tcpshow/tcpshow.1	                        (rev 0)
+++ trunk/rpms/tcpshow/tcpshow.1	2007-02-22 22:33:11 UTC (rev 5194)
@@ -0,0 +1,292 @@
+.\&quot; @(#) $Id: tcpshow.1,v 1.0 1996/07/03 20:17:25 mike Exp $
+.\&quot;
+.\&quot; #if !defined(MAY_NOT_MODIFY)
+.\&quot;
+.\&quot; Copyright (c) 1996 I.T. NetworX Ltd.  All rights reserved.
+.\&quot;
+.\&quot; The conditions applying to the use of this manual page are the same as
+.\&quot; those conditions applying to the file &quot;tcpshow.c&quot;.  See that file for
+.\&quot; the conditions.
+.\&quot;
+.\&quot; #endif
+.TH TCPSHOW 1  &quot;03 July 1996&quot;
+.SH NAME
+tcpshow \- decode a \fBtcpdump\fP savefile
+.SH SYNOPSIS
+.na
+.B tcpshow
+[
+.B \-b
+] [
+.B \-sb
+] [
+.B \-w
+.I width
+] [
+.B \-nolink
+] [
+.B \-noip
+]
+.br
+.ti +8
+[
+.B \-nodata
+] [
+.B \-data
+] [
+.B \-track
+] [
+.B \-terse
+]
+.br
+.ti +8
+[
+.B \-cooked
+] [
+.B \-pp
+] [
+.B \-s
+] [
+.B \-h
+]
+.br
+.ti +8
+[
+.B expression
+]
+.br
+.ad
+.SH DESCRIPTION
+.LP
+\fBtcpshow\fP reads a \fBtcpdump\fP(1) savefile and provides a
+reasonably complete decode
+of Ethernet, IP, ICMP, UDP and TCP headers, in packets that match the
+boolean \fIexpression\fP.  The data belonging to these packets is
+displayed in ASCII.
+.LP
+Currently, protocol data is not decoded.  This is not considered a
+serious problem for applications that use ASCII data streams.
+.LP
+Also, IP and TCP options are not decoded.
+.LP
+The input file must be in the format produced by
+\fItcpdump -enx\fP.  This file can be generated from
+.br
+1. a prior run of
+.B tcpdump -w
+.I file
+.br
+2. a live run of
+.B tcpdump
+(without -w)
+.br
+3. any other program that produces a correctly formatted
+.br
+   trace
+.br
+See under EXAMPLES for each of these different methods, plus a
+description of the format the input file needs to be in.
+.LP
+Except when \fI-cooked\fP is used, \fBtcpdump\fP(1) is required
+to be on your PATH, to process the raw savefile.
+.SH OPTIONS
+The following options can be used in just about any sane combination.
+.TP
+.B \-b
+break long lines so they don't wrap
+.IP
+This produces a neater, more readable display of the application
+data.  The default width is 60 columns.  See the \fI-w\fP flag for
+how to change this default.
+.TP
+.B \-sb
+show line breaks
+.IP
+When \fI-b\fP is used, it may be useful to see exactly where
+\fBtcpshow\fP wrapped each line, in its display of application data.
+This option causes the string ``&lt;break&gt;'' to be displayed at the
+end of each wrapped line.  (Lines which were not wrapped, but
+terminated before the page width, are not so marked.)
+.TP
+.B \-w \fIwidth\fP
+.br
+set pagewidth to \fIwidth\fP columns
+.IP
+This determines where \fBtcpshow\fP will fold long lines, when the
+\fI-b\fP switch is used.
+.TP
+.B \-nolink
+don't decode the link header
+.IP
+The data link header (Ethernet header) is not decoded and displayed.
+.TP
+.B \-noip
+don't decode the IP header
+.IP
+The IP header is not decoded and displayed.
+.TP
+.B \-nodata
+don't show the data
+.IP
+The protocol data is not displayed (a count of data bytes is shown).
+.TP
+.B \-data
+display only the data
+.IP
+The data, plus a minimal decode of the IP and transport/ICMP headers,
+is displayed.
+.TP
+.B \-track
+track TCP sequence numbers
+.IP
+An additional field is produced in the output which shows the TCP
+acknowledgement number which this side of the connection should
+receive once the current packet has been received by its peer.
+.TP
+.B \-terse
+show the header decode in compact format
+.IP
+Without this option, the display of the decoded header is verbose,
+occupying a lot of display-space real-estate.  With this option,
+the decoded header information is much more compact and terse.
+Once you're familiar with the meanings of the header fields, you'll
+probably always use this option.  (Maybe this should be the
+default, with a \fI-verbose\fP flag to get long-winded header decodes?)
+.TP
+.B \-cooked
+don't run \fBtcpdump\fP(1) to pre-process the input
+.IP
+If the input file is already in the expected format, this option
+must be used.  See EXAMPLES below of where this flag is appropriate.
+.TP
+.B \-pp
+point-to-point link
+.IP
+If the input file was collected from data travelling over a
+point-to-point link (one which doesn't make an Ethernet header available),
+this option needs to be used.
+.TP
+.B \-s
+also display a hex dump of spurious data at packet-end
+.IP
+For a reason unknown to the author, \fBtcpdump\fP(1) output sometimes
+contains data at the end of packets which don't belong to those packets.
+This spurious data is suppressed from the output, except when this
+option is used.
+.TP
+.B \-h
+display a help summary
+.IP
+This list of options is displayed, with one-liner descriptions.
+.TP
+.B expression
+filter the input file using a \fBtcpdump\fP(1) expression
+.IP
+If the \fI-cooked\fP option is not used, then \fBtcpdump\fP(1) is
+required to be on your PATH.  It is used to read the raw savefile,
+producing output in the format \fBtcpshow\fP expects.  The
+\fIexpression\fP should be a valid \fBtcpdump\fP(1) expression.
+It is not parsed or interpreted by \fBtcpshow\fP, but passed on
+to \fBtcpdump\fP(1) for its consumption.
+.SH EXAMPLES
+In the following examples, where \fBtcpdump\fP(1) is used, the
+flag \fI-s 1518\fP is used to be sure of saving the complete Ethernet
+frame.
+.LP
+Also, where \fBtcpdump\fP(1) expressions are used, these could equally
+have been given to \fBtcpdump\fP(1) directly, if it was known at this
+time what data you're interested in.
+.LP
+Capture a raw savefile and decode it later.
+.IP
+# tcpdump -s 1518 -w savefile
+.br
+# tcpshow &lt; savefile
+.LP
+Decode the data as quickly as \fBtcpdump\fP(1) gives it to us.
+.IP
+# tcpdump -s 1518 -lenx | tcpshow
+.LP
+Display headers only.
+.IP
+# tcpshow -nodata &lt; savefile
+.LP
+Display data only (minimal header decode).
+.IP
+# tcpshow -data
+.LP
+Display a decode of Telnet traffic only, omitting the link and IP headers.
+.IP
+# tcpdump -s 1518 -w savefile
+.br
+# tcpshow -nolink -noip tcp port telnet &lt; savefile
+.LP
+Give a compact display of the TCP headers, and a full display of
+the data, for all packets going into or coming from the host &quot;sam&quot;
+-- this host is on a LAN accessible through a PPP link.
+.IP
+# tcpdump -i ppp0 -s 1518 -w savefile
+.br
+# tcpshow -pp -terse host sam &lt; savefile
+.LP
+Show all SMTP mail transfers, omitting the headers and wrapping the
+message bodies to make it easy to read them (you're not supposed to
+do this).
+.IP
+# tcpdump -s 1518 -w savefile
+.br
+# tcpshow -b -w 40 -data port smtp &lt; savefile
+.LP
+To display a decode of data not captured via \fBtcpdump\fP(1), you
+would typically use the application that captured the trace to dump
+that trace into a file in ASCII-hex format.  You feed that file into
+a Perl/sh/awk script (that you write), which produces a file in the
+format \fBtcpshow\fP expects.  Such scripts are easy to write.  For
+example, if your application is &quot;capture&quot; and your script
+is &quot;convert&quot;, then \fBtcpshow\fP might be used as follows.
+.IP
+# capture -hexoutput | convert | tcpshow
+.LP
+A loose definition of the format \fBtcpshow\fP expects is: the 1st
+line of each packet must begin in column 1.  All other lines must
+begin with a TAB.  The hex bytes can be separated from each other by
+any amount of whitespace, including none.
+.br
+When using \fI-cooked\fP, the first field should be the time the
+packet was captured (or a string like &quot;no-time-recorded&quot; if the time
+isn't available).  The remaining fields should be the bytes of the
+IP datagram.
+.br
+When \fI-cooked\fP is not used, the first field should be as above,
+with the next three fields being the Ethernet source address, the
+Ethernet destination address and the DIX Ethernet Type field.
+.SH FILES
+\fBtcpshow\fP reads from standard input and writes to standard
+output.
+.SH SEE ALSO
+tcpdump(1), nit(4P), bpf(4)
+.\&quot;
+.\&quot; #if !defined(MAY_NOT_MODIFY)
+.\&quot;
+.SH AUTHOR
+Mike Ryan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mike at NetworX.ie</A>&gt;
+.SH RESTRICTIONS
+This program and its source code are freely available.  See the
+Conditions governing their use in the source code.
+.\&quot;
+.\&quot; #endif
+.\&quot;
+.SH BUGS
+It should decode IP and TCP options.
+.LP
+It should decode data from application protocols that don't send their
+data in ASCII (e.g. DNS/BIND).
+.LP
+It should not depend on \fBtcpdump\fP(1) as much as it does.  It should
+be modified to use pcap(3) directly.
+.LP
+It doesn't bother mapping IP addresses into their host names.  The option
+to do this should be provided.
+.LP
+The \fI-terse\fP option should be a default, with \fI-verbose\fP avaiable
+to produce a verbose display of the headers.

Added: trunk/rpms/tcpshow/tcpshow.c
===================================================================
--- trunk/rpms/tcpshow/tcpshow.c	                        (rev 0)
+++ trunk/rpms/tcpshow/tcpshow.c	2007-02-22 22:33:11 UTC (rev 5194)
@@ -0,0 +1,1516 @@
+#if !defined(MAY_NOT_MODIFY)
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* tcpshow, v1.0                                                            */
+/*                                                                          */
+/* Quickie to decode a &quot;tcpdump&quot; savefile.                                  */
+/*                                                                          */
+/* The application data is displayed as ASCII -- application protocols are  */
+/* not decoded.                                                             */
+/*                                                                          */
+/* The data captured by &quot;tcpdump&quot; might be less than in the original        */
+/* packet.  We kludge a solution to this with setjmp()/longjmp().           */
+/*                                                                          */
+/* Although written to read tcpdump savefiles, with tcpdump itself as a     */
+/* front-end, it'll decode any hex dump that adheres to the format          */
+/* expected.  Some programs which capture network data offer an option to   */
+/* save the trace to a file in hex format -- this can often be massaged     */
+/* easily with Perl/awk/sh scripts to turn it into the format expected.     */
+/* As a special case, &quot;tcpdump -s 1518 -lenx | tcpshow -cooked&quot; works       */
+/* rather well, and &quot;tcpdump -s 1518 -lenx | tcpshow -cooked -data&quot; is nice */
+/* for watching the data traffic in real time.                              */
+/*                                                                          */
+/* ------------------------------------------------------------------------ */
+/*                                                                          */
+/* Copyright (c) 1996 I.T. NetworX Ltd.  All rights reserved.               */
+/*                                                                          */
+/* This source code is owned and copyrighted by I.T. NetworX Ltd.  This     */
+/* file and all files derived from it, directly or indirectly (such files   */
+/* collectively and separately being referred to henceforth as &quot;this file&quot;) */
+/* may be used, modified and redistributed subject to the following six     */
+/* Conditions.                                                              */
+/*                                                                          */
+/* Condition 1 of 6:                                                        */
+/* That all text (code/comments, etc.) in this file surrounded by the macro */
+/* block &quot;#if !defined(MAY_NOT_MODIFY) ... #endif&quot;, including the macro     */
+/* statements themselves, may not be modified in any way, or deleted.  In   */
+/* particular, this comment block and the printf() statements identifying   */
+/* I.T. NetworX as being the copyright owner, in the function usage(), may  */
+/* not be modified or deleted.  The single, only, exception to this is that */
+/* the non-inclusion of C comments by a C compiler/linker, in the object    */
+/* and executable images it produces, is permitted.                         */
+/*                                                                          */
+/* Condition 2 of 6:                                                        */
+/* That no financial gain be made from using this file or modifying this    */
+/* file.  It is permitted to charge for redistributing this file.           */
+/*                                                                          */
+/* Condition 3 of 6:                                                        */
+/* That no conditions other than these six Conditions be applied to the     */
+/* use, modification or redistribution of this file.                        */
+/*                                                                          */
+/* Condition 4 of 6:                                                        */
+/* That all modifications to this file show prominently the name of the     */
+/* person that made the change and the date on which the change was made.   */
+/*                                                                          */
+/* Condition 5 of 6:                                                        */
+/* That I.T. NetworX, its employees, agents and everybody else in the world */
+/* dead, living and yet to be born, are hereby free from liability of all   */
+/* and every kind arising from the use of this file by anybody for any      */
+/* purpose.  This file comes &quot;as is&quot; and all warranties, express or         */
+/* implied, are disclaimed.  As the manual page for chat(1) says, &quot;if it    */
+/* breaks, then you get to keep both pieces&quot;.                               */
+/*                                                                          */
+/* Condition 6 of 6:                                                        */
+/* That I.T. NetworX reserves the right to alter these Conditions at any    */
+/* time without giving prior notice, such alterations to apply only to the  */
+/* version current at the time of issue of the alterations and all later    */
+/* versions, and such alterations to apply only to versions produced        */
+/* exclusively by I.T. NetworX or its agents.                               */
+/*                                                                          */
+/* Addendum to Copyright:                                                   */
+/* I'm not a legal eagle and I worded the above notice off the top of my    */
+/* head, so it may be full of holes, but the spirit of my intentions are    */
+/* clear from reading it.  Please respect these intentions.                 */
+/*                                                                          */
+/* Me too:                                                                  */
+/* If anybody makes significant improvements to this file, such as adding   */
+/* decode support for DNS traffic or IP and TCP options, I would appreciate */
+/* it if they sent me a copy of their work (<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mike at NetworX.ie</A>).  Thanks.      */
+/*                                                                          */
+/* ------------------------------------------------------------------------ */
+/*                                                                          */
+/* File layout is as follows:                                               */
+/* system includes                                                          */
+/* local includes                                                           */
+/* #define macros                                                           */
+/* typedefs                                                                 */
+/* declarations of extern variables                                         */
+/* declarations of extern functions                                         */
+/* declarations of global variables                                         */
+/* declarations of global functions                                         */
+/* declarations of static variables                                         */
+/* declarations of static functions                                         */
+/* definitions of functions                                                 */
+/* (all functions and variables are declared/defined in alphabetical order) */
+/*                                                                          */
+/* ------------------------------------------------------------------------ */
+/*                                                                          */
+/* Compiles as follows:                                                     */
+/* cc -s -O -o tcpshow tcpshow.c                                            */
+/*                                                                          */
+/* ------------------------------------------------------------------------ */
+/*                                                                          */
+/* Who and when:                                                            */
+/* MikeRyan, 11apr96.                                                       */
+/*                                                                          */
+/* I.T. NetworX,                                                            */
+/* 67 Merrion Square,                                                       */
+/* Dublin 2,                                                                */
+/* Ireland.                                                                 */
+/* Phone: +353-1-676-8866                                                   */
+/* Fax:   +353-1-676-8868                                                   */
+/* Email: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mike at NetworX.ie</A>                                                   */
+/*                                                                          */
+/* ------------------------------------------------------------------------ */
+/*                                                                          */
+/* Modification History                                                     */
+/* MikeRyan, 14may96: Allow &quot;tcpdump&quot; expressions to be passed in.          */
+/* MikeRyan, 15may96: Added UDP decode logic.                               */
+/* MikeRyan, 16may96: Added ICMP decode logic.                              */
+/* MikeRyan, 16may96: Added -b switch to break long lines                   */
+/*                          -w option to specify the width of the page      */
+/*                          -h flag to give help on usage.                  */
+/* MikeRyan, 28may96: Added -nolink                                         */
+/*                          -nodata                                         */
+/*                          -noip                                           */
+/*                          -track                                          */
+/*                          -terse                                          */
+/*                          -sb                                             */
+/*                          -s                                              */
+/* MikeRyan, 25jun96: Incorporated my &quot;general.h&quot; typedef's, so that the    */
+/* present source file doesn't depend on any non-standard header files.     */
+/* This allows it to be distributed as a single file.  Also included the    */
+/* copyright notice, as I'm making the program freely available.            */
+/*                                                                          */
+/* MikeRyan, 26jun96: Added -cooked                                         */
+/*                          -pp                                             */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+#endif
+
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;netdb.h&gt;
+#include &lt;setjmp.h&gt;
+
+
+/* Some general defines.                                                    */
+#if defined(FALSE)
+#undef FALSE
+#endif
+#if defined(TRUE)
+#undef TRUE
+#endif
+#define FALSE        (boolean)0
+#define TRUE         (boolean)1
+#define elif            else if
+#if !defined(reg)
+#define reg            register        /* For debugging purposes            */
+#endif
+
+
+#define VERSION             1.0        /* Please change when appropriate    */
+#define COOKER        &quot;tcpdump&quot;
+#define MAXCOOKARGS         100        /* Max tcpdump expression words      */
+
+#define MAXPKT            10240        /* Should be 1518 for Ethernet       */
+#define NCOLS                60
+
+/* IP header elements.                                                      */
+#define IPHDRLEN             20
+#define FRAGOFF          0x1FFF
+#define MF               0x2000
+#define DF               0x4000
+
+/* TCP header elements.                                                     */
+#define TCPHDRLEN            20
+#define URG              0x0020
+#define ACK              0x0010
+#define PSH              0x0008
+#define RST              0x0004
+#define SYN              0x0002
+#define FIN              0x0001
+
+/* UDP header elements.                                                     */
+#define UDPHDRLEN             8
+
+/* ICMP header elements.                                                    */
+#define ICMPHDRLEN            4
+
+/* IP protocol types.                                                       */
+#define IP                    0
+#define ICMP                  1
+#define IGMP                  2
+#define GGP                   3
+#define IPENCAP               4
+#define ST                    5
+#define TCP                   6
+#define EGP                   8
+#define PUP                  12
+#define UDP                  17
+#define HMP                  20
+#define XNSIDP               22
+#define RDP                  27
+#define ISOTP4               29
+#define XTP                  36
+#define IDPRCMTP             39
+#define RSVP                 46
+#define VMTP                 81
+#define OSPF                 89
+#define IPIP                 94
+#define ENCAP                98
+
+/* ICMP types.                                                              */
+#define ECHO_REPLY            0
+#define DST_UNREACH           3
+#define SRC_QUENCH            4
+#define REDIRECT              5
+#define ECHO_REQ              8
+#define ROUTER_AD             9
+#define ROUTER_SOL           10
+#define TIME_EXCEED          11
+#define PARAM_PROB           12
+#define TIME_REQ             13
+#define TIME_REPLY           14
+#define INFO_REQ             15
+#define INFO_REPLY           16
+#define MASK_REQ             17
+#define MASK_REPLY           18
+
+/* ICMP codes for type == Destination Unreachable.                          */
+#define NET_UNREACH           0
+#define HOST_UNREACH          1
+#define PROTO_UNREACH         2
+#define PORT_UNREACH          3
+#define DF_SET                4
+#define SRCROUTE_FAILED       5
+#define DSTNET_UNKNOWN        6
+#define DSTHOST_UNKNOWN       7
+#define SRCHOST_ISOLATED      8
+#define DSTNET_PROHIB         9
+#define DSTHOST_PROHIB       10
+#define NET_UNREACH_TOS      11
+#define HOST_UNREACH_TOS     12
+#define COMM_PROHIB          13
+#define HOST_PREC_VIOL       14
+#define PREC_CUTOFF          15
+
+/* ICMP codes for type == Redirect.                                         */
+#define REDIR_FOR_NET         0
+#define REDIR_FOR_HOST        1
+#define REDIR_FOR_TOSNET      2
+#define REDIR_FOR_TOSHOST     3
+
+/* ICMP codes for type == Time Exceeded.                                    */
+#define TTL_ZERO              0
+#define REASS_TIMEOUT         1
+
+/* ICMP codes for type == Parameter Problem.                                */
+#define IP_HDR_BAD            0
+#define MISSING_OPT           1
+
+/* Skip remaining lines of current packet.  Note that this causes a         */
+/* longjmp(), so a succeeding &quot;return&quot; from a function isn't needed.        */
+#define nextpkt()   for ( ; ; ) (void)getpkt()
+/* Display a separator line between packet decodes.                         */
+#define prsep() \
+printf( \
+   &quot;-----------------------------------------------------------------\n&quot; \
+)
+
+
+/* My own preferred basic data types -- amend per target machine.           */
+typedef char boolean;
+typedef float float4;
+typedef double float8;
+typedef char int1;
+typedef short int2;
+typedef int int4;
+typedef unsigned char uint1;
+typedef unsigned short uint2;
+typedef unsigned int uint4;
+typedef unsigned char uchar;
+
+
+void main(int, char **);
+
+
+static boolean bflag = FALSE;
+static char *cookargs[MAXCOOKARGS+1];
+static boolean cookedflag = FALSE;
+static boolean dataflag = FALSE;
+static uint2 datalen = 0;
+static char *dflt_cookargs[] = {
+   COOKER, &quot;-enx&quot;, &quot;-s10240&quot;, &quot;-r-&quot;, (char *)NULL
+};
+static char dip[16];
+static boolean isip;
+static jmp_buf jmpbuf;
+static boolean nodataflag = FALSE;
+static boolean noipflag = FALSE;
+static boolean nolinkflag = FALSE;
+static int npkts_shown = 0;
+static char *off = &quot;off,&quot;;             /* &quot;off&quot; in middle of list           */
+static char *off_e = &quot;off&quot;;            /* &quot;off&quot; at end of list              */
+static char *on = &quot;on, &quot;;              /* &quot;on&quot; in middle of list            */
+static char *on_e = &quot;on&quot;;              /* &quot;on&quot; at end of list               */
+static int pagewidth = NCOLS;
+static char *pkt;
+static boolean ppflag = FALSE;
+static uint1 proto;
+static boolean sflag = FALSE;
+static boolean sbflag = FALSE;
+static char sip[16];
+static boolean terseflag = FALSE;
+static boolean trackflag = FALSE;
+static char *unknown = &quot;&lt;unknown&gt;&quot;;
+
+
+static void error(char *);
+static char *etheraddr(char *);
+static char *ether_proto(char *);
+static void fork_tcpdump(int, char **);
+static uint1 getbyte(char **);
+static uint4 getlongword(char **);
+static char *getpkt(void);
+static uint2 getword(char **);
+static char *icmpcode(uint1, uint1);
+static char *icmptype(uint1);
+static char *ipaddr(char **);
+static char *ip_proto(uint1);
+static char nextchar(char **);
+static char *rmwspace(char *);
+static char *showdata(char *);
+static char *showhdr(char *);
+static char *showicmp(char *);
+static char *showip(char *);
+static void showpkt(char *);
+static char *showtcp(char *);
+static char *showudp(char *);
+static char *skip(char *, uint2);
+static char *svcname(uint2, char *, boolean);
+static void usage(void);
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Print an error message and exit.                                         */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static void error (
+   char *msg
+) {
+
+   fprintf(stderr, &quot;***Error: %s\n&quot;, msg);
+   exit(1);
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Print a formatted Ethernet address.                                      */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *etheraddr (
+   char *eaddr
+) {
+
+   static char formatted[18];
+   int i;
+   int j;
+
+
+   for (i = j = 0; i &lt; 6; i++)
+      if (eaddr[1] == ':') {
+         formatted[j++] = '0';
+         formatted[j++] = toupper(eaddr[0]);
+         formatted[j++] = ':';
+         eaddr += 2;
+      }
+      else {
+         formatted[j++] = toupper(eaddr[0]);
+         formatted[j++] = toupper(eaddr[1]);
+         formatted[j++] = ':';
+         eaddr += 3;
+      }
+   formatted[j-1] = '\0';
+
+   return formatted;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Print the type of protocol encapsulated in the Ethernet frame.           */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *ether_proto (
+   char *type
+) {
+
+   if (strcmp(type, &quot;0800&quot;) == 0)
+      return &quot;IP&quot;;
+   elif (strcmp(type, &quot;0806&quot;) == 0)
+      return &quot;ARP&quot;;
+   elif (strcmp(type, &quot;8035&quot;) == 0)
+      return &quot;RARP&quot;;
+   else
+      return type;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Run tcpdump to pre-process the trace file.                               */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static void fork_tcpdump (
+   int argc,
+   char **argv
+) {
+
+   int fd[2];
+   int i;
+   pid_t pid;
+
+
+   /* Required &quot;tcpdump&quot; flags.                                             */
+   i = 0;
+   while (dflt_cookargs[i]) {
+      cookargs[i] = dflt_cookargs[i];
+      i++;
+   }
+   while (argc-- &gt; 0) {
+      if (i &gt;= MAXCOOKARGS) error(&quot;Too many expressions&quot;);
+      cookargs[i++] = *argv++;
+   }
+   cookargs[i] = (char *)NULL;
+
+   /* Fork tcpdump to cook our input.                                       */
+   if (pipe(fd)) error(&quot;pipe() failed&quot;);
+   if ((pid=fork()) &lt; 0) error(&quot;fork() failed&quot;);
+   if (pid == 0) {
+      (void)close(1);
+      if (dup(fd[1]) != 1) error(&quot;dup() failed&quot;);
+      (void)close(fd[0]);
+      (void)close(fd[1]);
+      execvp(COOKER, cookargs);
+      error(&quot;execvp() failed&quot;);
+   }
+
+   (void)close(0);
+   if (dup(fd[0]) != 0) error(&quot;dup() failed&quot;);
+   (void)close(fd[0]);
+   (void)close(fd[1]);
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Return the byte value and increment the pointer by sizeof(byte).         */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static uint1 getbyte (
+   char **pkt
+) {
+
+   char byte[1*2+1];                   /* ASCII representation of a byte    */
+   unsigned int val;
+
+
+   byte[0] = nextchar(pkt);
+   byte[1] = nextchar(pkt);
+   byte[2] = '\0';
+
+   (void)sscanf(byte, &quot;%x&quot;, &amp;val);
+
+   return (uint1)val;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Return the longword value and increment the pointer by sizeof(longword). */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static uint4 getlongword (
+   char **pkt
+) {
+
+   char longword[4*2+1];              /* ASCII representation of a longword */
+   unsigned long val;
+
+
+   longword[0] = nextchar(pkt);
+   longword[1] = nextchar(pkt);
+   longword[2] = nextchar(pkt);
+   longword[3] = nextchar(pkt);
+   longword[4] = nextchar(pkt);
+   longword[5] = nextchar(pkt);
+   longword[6] = nextchar(pkt);
+   longword[7] = nextchar(pkt);
+   longword[8] = '\0';
+
+   (void)sscanf(longword, &quot;%lx&quot;, &amp;val);
+
+   return (uint4)val;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Read in the next line of packet data.                                    */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *getpkt (
+) {
+
+   static boolean been_here_already = FALSE;
+   static char pktbuf[MAXPKT+1];
+
+
+   if (fgets(pktbuf, MAXPKT+1, stdin) == (char *)NULL) exit(0);
+
+   /* Line without leading &lt;tab&gt; means start of new packet.                 */
+   if (*pktbuf == '\t')
+      return rmwspace(pktbuf);
+   elif (! been_here_already) {        /* setjmp() won't have been called   */
+      been_here_already = TRUE;        /*  before reading 1st packet        */
+      return pkt = pktbuf;
+   }
+   else {
+      if (datalen &gt; 0)
+         printf(&quot;\n\t&lt;*** Rest of data missing from packet dump ***&gt;\n&quot;);
+      pkt = pktbuf;
+      longjmp(jmpbuf, 1);
+   }
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Return the word value and increment the pointer by sizeof(word).         */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static uint2 getword (
+   char **pkt
+) {
+
+   char word[2*2+1];                   /* ASCII representation of a word    */
+   unsigned int val;
+
+
+   word[0] = nextchar(pkt);
+   word[1] = nextchar(pkt);
+   word[2] = nextchar(pkt);
+   word[3] = nextchar(pkt);
+   word[4] = '\0';
+
+   (void)sscanf(word, &quot;%x&quot;, &amp;val);
+
+   return (uint2)val;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Print the code relating to the ICMP type.                                */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *icmpcode (
+   uint1 type,
+   uint1 code
+) {
+
+   char *bad;
+   char *descr;
+
+
+   bad = &quot;&lt;*** CORRUPT ***&gt;&quot;;
+   descr = (char *)NULL;
+
+   switch (type) {
+    case ECHO_REPLY:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case DST_UNREACH:
+      switch (code) {
+       case NET_UNREACH:       descr = &quot;network-unreachable&quot;;           break;
+       case HOST_UNREACH:      descr = &quot;host-unreachable&quot;;              break;
+       case PROTO_UNREACH:     descr = &quot;protocol-unreachable&quot;;          break;
+       case PORT_UNREACH:      descr = &quot;port-unreachable&quot;;              break;
+       case DF_SET:            descr = &quot;frag-needed-but-DF-set&quot;;        break;
+       case SRCROUTE_FAILED:   descr = &quot;source-route-failed&quot;;           break;
+       case DSTNET_UNKNOWN:    descr = &quot;destination-network-unknown&quot;;   break;
+       case DSTHOST_UNKNOWN:   descr = &quot;destination-host-unknown&quot;;      break;
+       case SRCHOST_ISOLATED:  descr = &quot;source-host-isolated&quot;;          break;
+       case DSTNET_PROHIB:     descr = &quot;dest-net-admin-prohibited&quot;;     break;
+       case DSTHOST_PROHIB:    descr = &quot;dest-host-admin-prohibited&quot;;    break;
+       case NET_UNREACH_TOS:   descr = &quot;network-unreachable-for-TOS&quot;;   break;
+       case HOST_UNREACH_TOS:  descr = &quot;host-unreachable-for-TOS&quot;;      break;
+       case COMM_PROHIB:       descr = &quot;trafffic-prohibited-by-filter&quot;; break;
+       case HOST_PREC_VIOL:    descr = &quot;host-precedence-violation&quot;;     break;
+       case PREC_CUTOFF:       descr = &quot;precedence-cutoff-in-effect&quot;;   break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case SRC_QUENCH:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case REDIRECT:
+      switch (code) {
+       case REDIR_FOR_NET:     descr = &quot;route-wrong-for-network&quot;;       break;
+       case REDIR_FOR_HOST:    descr = &quot;route-wrong-for-host&quot;;          break;
+       case REDIR_FOR_TOSNET:  descr = &quot;route-wrong-for-TOS-and-net&quot;;   break;
+       case REDIR_FOR_TOSHOST: descr = &quot;route-wrong-for-TOS-and-host&quot;;  break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case ECHO_REQ:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case ROUTER_AD:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case ROUTER_SOL:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case TIME_EXCEED:
+      switch (code) {
+       case TTL_ZERO:          descr = &quot;TTL-reached-zero&quot;;              break;
+       case REASS_TIMEOUT:     descr = &quot;reassembly-timer-expired&quot;;      break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case PARAM_PROB:
+      switch (code) {
+       case IP_HDR_BAD:        descr = &quot;IP-header-bad&quot;;                 break;
+       case MISSING_OPT:       descr = &quot;required-option-is-missing&quot;;    break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case TIME_REQ:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case TIME_REPLY:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case INFO_REQ:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case INFO_REPLY:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case MASK_REQ:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    case MASK_REPLY:
+      switch (code) {
+       case 0:                                                          break;
+       default:                descr = bad;                             break;
+      }
+      break;
+    default:
+      break;
+   }
+
+   return descr;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Print the type of ICMP packet.                                           */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *icmptype (
+   uint1 type
+) {
+
+   char *descr;
+
+
+   switch (type) {
+    case ECHO_REPLY:  descr = &quot;echo-reply&quot;;              break;
+    case DST_UNREACH: descr = &quot;destination-unreachable&quot;; break;
+    case SRC_QUENCH:  descr = &quot;source-quench&quot;;           break;
+    case REDIRECT:    descr = &quot;redirect&quot;;                break;
+    case ECHO_REQ:    descr = &quot;echo-request&quot;;            break;
+    case ROUTER_AD:   descr = &quot;router-advertisement&quot;;    break;
+    case ROUTER_SOL:  descr = &quot;router-solicitation&quot;;     break;
+    case TIME_EXCEED: descr = &quot;time-exceeded&quot;;           break;
+    case PARAM_PROB:  descr = &quot;parameter-problem&quot;;       break;
+    case TIME_REQ:    descr = &quot;timestamp-request&quot;;       break;
+    case TIME_REPLY:  descr = &quot;timestamp-reply&quot;;         break;
+    case INFO_REQ:    descr = &quot;information-request&quot;;     break;
+    case INFO_REPLY:  descr = &quot;information-reply&quot;;       break;
+    case MASK_REQ:    descr = &quot;address-mask-request&quot;;    break;
+    case MASK_REPLY:  descr = &quot;address-mask-reply&quot;;      break;
+    default:          descr = unknown;                   break;
+   }
+
+   return descr;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Print the IP address in dotted-quad.                                     */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *ipaddr (
+   char **pkt
+) {
+
+   static char addr[16];
+   uint2 byte1;
+   uint2 byte2;
+   uint2 byte3;
+   uint2 byte4;
+
+
+   /* We don't use inet_ntoa() because it wants a socket structure.         */
+   byte1 = (uint2)getbyte(pkt);
+   byte2 = (uint2)getbyte(pkt);
+   byte3 = (uint2)getbyte(pkt);
+   byte4 = (uint2)getbyte(pkt);
+   (void)sprintf(addr, &quot;%d.%d.%d.%d&quot;, byte1, byte2, byte3, byte4);
+
+   return addr;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Print the type of protocol encapsulated in the IP datagram.              */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *ip_proto (
+   uint1 code
+) {
+
+   char *name;
+
+
+   /* A simple table won't do, as the codes aren't contiguous.               */
+   switch (code) {
+    case IP:
+       name = &quot;IP&quot;; break;
+    case ICMP:
+       name = &quot;ICMP&quot;; break;
+    case IGMP:
+       name = &quot;IGMP&quot;; break;
+    case GGP:
+       name = &quot;GGP&quot;; break;
+    case IPENCAP:
+       name = &quot;IPENCAP&quot;; break;
+    case ST:
+       name = &quot;ST&quot;; break;
+    case TCP:
+       name = &quot;TCP&quot;; break;
+    case EGP:
+       name = &quot;EGP&quot;; break;
+    case PUP:
+       name = &quot;PUP&quot;; break;
+    case UDP:
+       name = &quot;UDP&quot;; break;
+    case HMP:
+       name = &quot;HMP&quot;; break;
+    case XNSIDP:
+       name = &quot;XNSIDP&quot;; break;
+    case RDP:
+       name = &quot;RDP&quot;; break;
+    case ISOTP4:
+       name = &quot;ISOTP4&quot;; break;
+    case XTP:
+       name = &quot;XTP&quot;; break;
+    case IDPRCMTP:
+       name = &quot;IDPRCMTP&quot;; break;
+    case RSVP:
+       name = &quot;RSVP&quot;; break;
+    case VMTP:
+       name = &quot;VMTP&quot;; break;
+    case OSPF:
+       name = &quot;OSPF&quot;; break;
+    case IPIP:
+       name = &quot;IPIP&quot;; break;
+    case ENCAP:
+       name = &quot;ENCAP&quot;; break;
+    default:
+       name = unknown; break;
+   }
+
+   return name;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode a &quot;tcpdump&quot; savefile.                                             */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+void main (
+   int argc,
+   char **argv
+) {
+
+   /* Command line options.                                                 */
+   while (--argc &gt; 0 &amp;&amp; **++argv == '-')
+      if (strcmp(*argv, &quot;-data&quot;) == 0)
+	 dataflag = nolinkflag = noipflag = TRUE;
+      elif (strcmp(*argv, &quot;-s&quot;) == 0) sflag = TRUE;
+      elif (strcmp(*argv, &quot;-b&quot;) == 0) bflag = TRUE;
+      elif (strcmp(*argv, &quot;-sb&quot;) == 0) sbflag = TRUE;
+      elif (strcmp(*argv, &quot;-terse&quot;) == 0) terseflag = TRUE;
+      elif (strcmp(*argv, &quot;-track&quot;) == 0) trackflag = TRUE;
+      elif (strcmp(*argv, &quot;-nodata&quot;) == 0) nodataflag = TRUE;
+      elif (strcmp(*argv, &quot;-nolink&quot;) == 0) nolinkflag = TRUE;
+      elif (strcmp(*argv, &quot;-noip&quot;) == 0) noipflag = TRUE;
+      elif (strcmp(*argv, &quot;-cooked&quot;) == 0) cookedflag = TRUE;
+      elif (strcmp(*argv, &quot;-pp&quot;) == 0) ppflag = TRUE;
+      elif (strcmp(*argv, &quot;-h&quot;) == 0) usage();
+      elif (strcmp(*argv, &quot;-w&quot;) == 0) {
+         if (--argc &lt;= 0) error(&quot;-w needs a numeric argument&quot;);
+         if ((pagewidth=atoi(*++argv)) &lt; 1) error(&quot;-w value too small&quot;);
+      }
+      else error(&quot;Unknown command line flag&quot;);
+
+   if (! cookedflag)
+      fork_tcpdump(argc, argv);
+   elif (argc != 0)
+      fprintf(stderr, &quot;input is cooked -- ignoring tcpdump expressions\n&quot;);
+
+   pkt = getpkt();
+   for ( ; ; ) if (! setjmp(jmpbuf)) showpkt(pkt);
+
+   exit(0);
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Return the next character in the packet buffer.                          */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char nextchar (
+   char **pkt
+) {
+
+   if (! **pkt) *pkt = getpkt();
+
+   return *(*pkt)++;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Remove whitespace from the buffer.                                       */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *rmwspace (
+   reg char *pktbuf
+) {
+
+   static char cleanpkt[MAXPKT+1];
+   reg char *pkt;
+
+
+   pkt = cleanpkt;
+   while (*pktbuf) {
+      if (! isspace(*pktbuf)) *pkt++ = *pktbuf;
+      pktbuf++;
+   }
+   *pkt = '\0';
+
+   return cleanpkt;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode the TCP/UDP data.                                                 */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *showdata (
+   char *pkt
+) {
+
+   uint1 byte;
+   int col;
+   char *descr;
+
+
+   if (dataflag)
+      putchar('\t');
+   elif (terseflag)
+      printf(&quot;DATA:\t&quot;);
+   else {
+      switch (proto) {
+       case TCP:  descr = &quot;TCP&quot;;   break;
+       case UDP:  descr = &quot;UDP&quot;;   break;
+       case ICMP: descr = &quot;ICMP&quot;;  break;
+       default:   descr = unknown; break;
+      }
+      printf(&quot;%s Data\n\t&quot;, descr);
+   }
+   if (nodataflag) {
+      uint2 ndatabytes = datalen;
+      datalen = 0;
+      printf(&quot;%d bytes\n&quot;, ndatabytes);
+      return skip(pkt, ndatabytes);
+   }
+
+   if (datalen == 0) {
+      printf(&quot;&lt;No data&gt;\n&quot;);
+      return pkt;
+   }
+
+   switch (bflag) {
+    case TRUE:
+      for (col = 1; datalen &gt; 0; datalen--, col++) {
+         byte = getbyte(&amp;pkt);
+	 if (byte == '\n') {
+	    putchar('\n');
+	    byte = '\t';
+	    col = 0;
+         }
+	 elif (col &gt; pagewidth) {
+            printf(&quot;%s\n\t&quot;, sbflag? &quot;&lt;break&gt;&quot;: &quot;&quot;);
+	    col = 1;
+	 }
+         if (byte != '\t' &amp;&amp; byte != '\n' &amp;&amp; !isprint(byte)) byte = '.';
+         putchar(byte);
+      }
+      break;
+    case FALSE:
+      for ( ; datalen &gt; 0; datalen--) {
+         byte = getbyte(&amp;pkt);
+         if (byte == '\n') {
+	    putchar('\n');
+	    byte = '\t';
+         }
+         if (byte != '\t' &amp;&amp; byte != '\n' &amp;&amp; !isprint(byte)) byte = '.';
+         putchar(byte);
+      }
+      break;
+    default:
+      error(&quot;Tri-valued boolean!&quot;);
+   }
+   putchar('\n');
+
+   return pkt;
+   
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode the packet header.                                                */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *showhdr (
+   char *pkt
+) {
+
+   char efrom[18];                     /* Source Ethernet address           */
+   char eto[18];                       /* Destination Ethernet address      */
+   char time[16];                      /* Packet timestamp                  */
+   char etype[20];                     /* Ethernet type (decoded to ASCII)  */
+
+
+   if (ppflag) {
+      (void)sscanf(pkt, &quot;%s&quot;, time);
+      isip = TRUE;                     /* tcpdump doesn't supply link type  */
+      if (! nolinkflag)
+	 if (terseflag) printf(&quot;TIME:\t%s\n&quot;, time);
+	 else printf(&quot;\tTimestamp:\t\t\t%s\n&quot;, time);
+      return getpkt();
+   }
+
+   (void)sscanf(pkt, &quot;%s %s %s %s&quot;, time, efrom, eto, etype);
+
+   isip = (boolean)(strcmp(etype, &quot;0800&quot;) == 0);
+   (void)strcpy(efrom, etheraddr(efrom));
+   (void)strcpy(eto, etheraddr(eto));
+
+   if (! nolinkflag)
+      if (terseflag) {
+	 printf(&quot;TIME:\t%s\n&quot;, time);
+	 printf(&quot;LINK:\t%s -&gt; %s type=%s\n&quot;, efrom, eto, ether_proto(etype));
+      }
+      else {
+	 printf(&quot;\tTimestamp:\t\t\t%s\n&quot;, time);
+	 printf(&quot;\tSource Ethernet Address:\t%s\n&quot;, efrom);
+	 printf(&quot;\tDestination Ethernet Address:\t%s\n&quot;, eto);
+	 printf(&quot;\tEncapsulated Protocol:\t\t%s\n&quot;, ether_proto(etype));
+      }
+
+   return getpkt();
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode the ICMP header.                                                  */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *showicmp (
+   char *pkt
+) {
+
+   uint2 cksum;
+   uint1 code;
+   uint2 nskipped;
+   uint1 type;
+   char *why;
+
+
+   type = getbyte(&amp;pkt);  nskipped  = sizeof(type);
+   code = getbyte(&amp;pkt);  nskipped += sizeof(code);
+   cksum = getword(&amp;pkt); nskipped += sizeof(cksum);
+
+   /* The length of the ICMP packet isn't recorded in the packet itself.    */
+   /* Must calculate it from the size of the IP datagram - the IP header.   */
+   datalen -= ICMPHDRLEN;
+
+   why = icmpcode(type, code);
+   if (dataflag) {
+      printf(
+         &quot;%s -&gt; %s ICMP%s%s%s%s\n&quot;,
+         sip, dip,
+         why? &quot;\n&quot;: &quot; &quot;, icmptype(type), why? &quot; because &quot;: &quot;&quot;, why? why: &quot;&quot;
+      );
+      return pkt;                      /* Header is read; nothing to skip   */
+   }
+
+   if (terseflag)
+      printf(
+	 &quot;ICMP:\t%s%s%s cksum=%04X\n&quot;,
+	 icmptype(type), why? &quot; because &quot;: &quot;&quot;, why? why: &quot;&quot;, cksum
+      );
+   else {
+      printf(&quot;ICMP Header\n&quot;);
+      printf(
+	 &quot;\tType:\t\t\t\t%s%s%s\n&quot;,
+	 icmptype(type), why? &quot;\n\tBecause:\t\t\t&quot;: &quot;&quot;, why? why: &quot;&quot;
+      );
+      printf(&quot;\tChecksum:\t\t\t0x%04X\n&quot;, cksum);
+   }
+
+   return pkt;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode the IP header.                                                    */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *showip (
+   char *pkt
+) {
+
+   uint2 cksum;
+   uint2 dgramlen;
+   uint2 flags;
+   uint2 hlen;
+   uint2 id;
+   uint2 nskipped;
+   uint1 servtype;
+   uint1 ttl;
+   uint1 ver;
+
+
+   ver = getbyte(&amp;pkt);             nskipped  = sizeof(ver);
+   if ((ver &amp; 0xF0) != 0x40) {
+      if (terseflag) printf(&quot;IP:\tnot v4\n&quot;);
+      else
+	 printf(
+	    &quot;IP Header\n\t&lt;Not an IPv4 datagram (ver=%d)&gt;\n&quot;,
+	    (ver &amp; 0xF0) &gt;&gt; 4
+	 );
+      nextpkt();
+   }
+   servtype = getbyte(&amp;pkt);        nskipped += sizeof(servtype);
+   dgramlen = getword(&amp;pkt);        nskipped += sizeof(dgramlen);
+   id = getword(&amp;pkt);              nskipped += sizeof(id);
+   flags = getword(&amp;pkt);           nskipped += sizeof(flags);
+   ttl = getbyte(&amp;pkt);             nskipped += sizeof(ttl);
+   proto = getbyte(&amp;pkt);           nskipped += sizeof(proto);
+   cksum = getword(&amp;pkt);           nskipped += sizeof(cksum);
+   (void)strcpy(sip, ipaddr(&amp;pkt)); nskipped += 4;
+   (void)strcpy(dip, ipaddr(&amp;pkt)); nskipped += 4;
+   hlen = (ver &amp; 0x0F) * 4;
+   datalen = dgramlen - hlen;
+
+   if (noipflag) return skip(pkt, hlen - nskipped);
+
+   printf(&quot;%s&quot;, terseflag? &quot;  IP:\t&quot;: &quot;IP Header\n&quot;);
+
+   if (terseflag) {
+      printf(
+	 &quot;%s -&gt; %s hlen=%d TOS=%02X dgramlen=%d id=%04X\n&quot;,
+	 sip, dip, hlen, (uint2)servtype, dgramlen, id
+      );
+      printf(
+	 &quot;\tMF/DF=%s/%s frag=%d TTL=%d proto=%s cksum=%04X\n&quot;,
+	 (flags &amp; MF) == MF? &quot;1&quot;: &quot;0&quot;, (flags &amp; DF) == DF? &quot;1&quot;: &quot;0&quot;,
+	 flags &amp; FRAGOFF, ttl, ip_proto(proto), cksum
+      );
+   }
+
+   else {
+      printf(&quot;\tVersion:\t\t\t4\n\tHeader Length:\t\t\t%d bytes\n&quot;, hlen);
+      printf(&quot;\tService Type:\t\t\t0x%02X\n&quot;, (uint2)servtype);
+      printf(&quot;\tDatagram Length:\t\t%d bytes\n&quot;, dgramlen);
+      printf(&quot;\tIdentification:\t\t\t0x%04X\n&quot;, id);
+      printf(
+	 &quot;\tFlags:\t\t\t\tMF=%s DF=%s\n&quot;,
+	 (flags &amp; MF) == MF? on: off, (flags &amp; DF) == DF? on_e: off_e
+      );
+      printf(&quot;\tFragment Offset:\t\t%d\n&quot;, flags &amp; FRAGOFF);
+      printf(&quot;\tTTL:\t\t\t\t%d\n&quot;, ttl);
+      printf(&quot;\tEncapsulated Protocol:\t\t%s\n&quot;, ip_proto(proto));
+      printf(&quot;\tHeader Checksum:\t\t0x%04X\n&quot;, cksum);
+      printf(&quot;\tSource IP Address:\t\t%s\n&quot;, sip);
+      printf(&quot;\tDestination IP Address:\t\t%s\n&quot;, dip);
+   }
+
+   if (hlen &gt; IPHDRLEN) {
+      if (! terseflag) printf(&quot;\t&lt;Options not displayed&gt;\n&quot;);
+      pkt = skip(pkt, hlen - IPHDRLEN);
+   }
+
+   return pkt;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode the packet chunk in the buffer.                                   */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static void showpkt (
+   reg char *pkt
+) {
+
+   isip = FALSE;
+
+   if (++npkts_shown &gt; 1) prsep();
+   if (! dataflag) printf(&quot;Packet %d\n&quot;, npkts_shown);
+
+   pkt = showhdr(pkt);
+   if (! isip) {
+      if (! dataflag)
+         printf(&quot;\t&lt;*** No decode support for non-IP protocols ***&gt;\n&quot;);
+      nextpkt();                       /* Doesn't return                    */
+   }
+   pkt = showip(pkt);
+   switch (proto) {
+    case TCP:
+      pkt = showtcp(pkt);
+      pkt = showdata(pkt);
+      break;
+    case UDP:
+      pkt = showudp(pkt);
+      pkt = showdata(pkt);
+      break;
+    case ICMP:
+      pkt = showicmp(pkt);
+      pkt = showdata(pkt);
+      break;
+    default:
+      printf(&quot;\t&lt;*** No decode support for encapsulated protocol ***&gt;\n&quot;);
+      datalen = 0;
+      nextpkt();                       /* Doesn't return                    */
+   }
+   /* &quot;tcpdump&quot; sometimes displays data at the end of a packet which, given */
+   /* the recorded Datagram Length, don't belong to the packet.             */
+   if (*pkt &amp;&amp; sflag)
+      printf(&quot;\t&lt;*** Spurious data at end: \&quot;%s\&quot; ***&gt;\n&quot;, pkt);
+   (void)getpkt();                     /* Load start of next packet         */
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode the TCP header.                                                   */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *showtcp (
+   char *pkt
+) {
+
+   uint4 ack;
+   uint2 advert;
+   uint2 cksum;
+   uint2 dport;
+   uint4 expect;
+   uint2 flags;
+   uint2 hlen;
+   uint2 nskipped;
+   uint4 seq;
+   uint2 sport;
+   uint2 urgptr;
+
+
+   sport = getword(&amp;pkt);   nskipped  = sizeof(sport);
+   dport = getword(&amp;pkt);   nskipped += sizeof(dport);
+   seq = getlongword(&amp;pkt); nskipped += sizeof(seq);
+   ack = getlongword(&amp;pkt); nskipped += sizeof(ack);
+   flags = getword(&amp;pkt);   nskipped += sizeof(flags);
+   advert = getword(&amp;pkt);  nskipped += sizeof(advert);
+   cksum = getword(&amp;pkt);   nskipped += sizeof(cksum);
+   urgptr = getword(&amp;pkt);  nskipped += sizeof(urgptr);
+
+   hlen = (flags &gt;&gt; 12 &amp; 0x0F) * 4;
+   datalen -= hlen;
+
+   if (dataflag) {
+      char dname[20];
+      char sname[20];
+      (void)strcpy(sname, svcname(sport, &quot;tcp&quot;, TRUE));
+      (void)strcpy(dname, svcname(dport, &quot;tcp&quot;, TRUE));
+      printf(&quot;%s.%s -&gt; %s.%s over TCP\n&quot;, sip, sname, dip, dname);
+      return skip(pkt, hlen - nskipped);
+   }
+
+   if (trackflag) {
+      expect = seq + datalen;
+      if ((flags &amp; SYN) == SYN || (flags &amp; FIN) == FIN) expect++;
+   }
+
+   if (terseflag) {
+      printf(&quot; TCP:\tport %d -&gt; %d seq=%010lu&quot;, sport, dport, seq);
+      if (trackflag) printf(&quot; (expect=%010lu)&quot;, expect);
+      printf(&quot; ack=%010lu\n&quot;, ack);
+      printf(
+	 &quot;\thlen=%d (data=%u) UAPRSF=%s%s%s%s%s%s&quot;,
+	 hlen, datalen,
+	 (flags &amp; URG) == URG? &quot;1&quot;: &quot;0&quot;, (flags &amp; ACK) == ACK? &quot;1&quot;: &quot;0&quot;,
+	 (flags &amp; PSH) == PSH? &quot;1&quot;: &quot;0&quot;, (flags &amp; RST) == RST? &quot;1&quot;: &quot;0&quot;,
+	 (flags &amp; SYN) == SYN? &quot;1&quot;: &quot;0&quot;, (flags &amp; FIN) == FIN? &quot;1&quot;: &quot;0&quot;
+      );
+      printf(&quot; wnd=%d cksum=%04X urg=%d\n&quot;, advert, cksum, urgptr);
+   }
+
+   else {
+      printf(&quot;TCP Header\n&quot;);
+      printf(
+	 &quot;\tSource Port:\t\t\t%d (%s)\n&quot;,
+	 sport, svcname(sport, &quot;tcp&quot;, FALSE)
+      );
+      printf(
+	 &quot;\tDestination Port:\t\t%d (%s)\n&quot;,
+	 dport, svcname(dport, &quot;tcp&quot;, FALSE)
+      );
+      printf(&quot;\tSequence Number:\t\t%010lu\n&quot;, seq);
+      if (trackflag) printf(&quot;\tExpect peer ACK:\t\t%010lu\n&quot;, expect);
+      printf(&quot;\tAcknowledgement Number:\t\t%010lu\n&quot;, ack);
+      printf(&quot;\tHeader Length:\t\t\t%d bytes (data=%u)\n&quot;, hlen, datalen);
+      printf(
+	 &quot;\tFlags:%s%s%s%s%s%s\n%s%s%s%s%s%s\n&quot;,
+	 &quot;\t\t\t\tURG=&quot;,   (flags &amp; URG) == URG? on: off,
+	 &quot; ACK=&quot;,          (flags &amp; ACK) == ACK? on: off,
+	 &quot; PSH=&quot;,          (flags &amp; PSH) == PSH? on_e: off_e,
+	 &quot;\t\t\t\t\tRST=&quot;, (flags &amp; RST) == RST? on: off,
+	 &quot; SYN=&quot;,          (flags &amp; SYN) == SYN? on: off,
+	 &quot; FIN=&quot;,          (flags &amp; FIN) == FIN? on_e: off_e
+      );
+      printf(&quot;\tWindow Advertisement:\t\t%d bytes\n&quot;, advert);
+      printf(&quot;\tChecksum:\t\t\t0x%04X\n&quot;, cksum);
+      printf(&quot;\tUrgent Pointer:\t\t\t%d\n&quot;, urgptr);
+   }
+
+   if (hlen &gt; TCPHDRLEN) {
+      if (! terseflag) printf(&quot;\t&lt;Options not displayed&gt;\n&quot;);
+      pkt = skip(pkt, hlen - TCPHDRLEN);
+   }
+
+   return pkt;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Decode the UDP header.                                                   */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *showudp (
+   char *pkt
+) {
+
+   uint2 cksum;
+   uint2 dgramlen;
+   uint2 dport;
+   uint2 nskipped;
+   uint2 sport;
+
+
+   sport     = getword(&amp;pkt); nskipped  = sizeof(sport);
+   dport     = getword(&amp;pkt); nskipped += sizeof(dport);
+   dgramlen  = getword(&amp;pkt); nskipped += sizeof(dgramlen);
+   cksum     = getword(&amp;pkt); nskipped += sizeof(cksum);
+
+   /* The size of the IP data field should equal the UDP packet length.     */
+   if (datalen != dgramlen) {
+      printf(&quot;\t&lt;*** Packet length corrupt ***&gt;\n&quot;);
+      nextpkt();                       /* Doesn't return                    */
+   }
+   datalen -= UDPHDRLEN;
+
+   if (dataflag) {
+      char dname[20];
+      char sname[20];
+      (void)strcpy(sname, svcname(sport, &quot;udp&quot;, TRUE));
+      (void)strcpy(dname, svcname(dport, &quot;udp&quot;, TRUE));
+      printf(&quot;%s.%s -&gt; %s.%s over UDP\n&quot;, sip, sname, dip, dname);
+      return pkt;                      /* Header is read; nothing to skip   */
+   }
+
+   if (terseflag)
+      printf(
+	 &quot; UDP:\tport %d -&gt; %d hdr=%u data=%u\n&quot;,
+	 sport, dport, UDPHDRLEN, datalen
+      );
+   else {
+      printf(&quot;UDP Header\n&quot;);
+      printf(
+	 &quot;\tSource Port:\t\t\t%d (%s)\n&quot;,
+	 sport, svcname(sport, &quot;udp&quot;, FALSE)
+      );
+      printf(
+	 &quot;\tDestination Port:\t\t%d (%s)\n&quot;,
+	 dport, svcname(dport, &quot;udp&quot;, FALSE)
+      );
+      printf(
+	 &quot;\tDatagram Length:\t\t%u bytes (Header=%u, Data=%u)\n&quot;,
+	 dgramlen, UDPHDRLEN, datalen
+      );
+      printf(&quot;\tChecksum:\t\t\t0x%04X\n&quot;, cksum);
+   }
+
+   return pkt;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Skip over un-interesting bytes.                                          */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *skip (
+   char *pkt,
+   uint2 nbytes
+) {
+
+   for ( ; nbytes &gt; 0; nbytes--) (void)getbyte(&amp;pkt);
+   return pkt;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Return the WKS name for the given port.                                  */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static char *svcname (
+   uint2 port,
+   char *proto,
+   boolean want_number
+) {
+
+   char *name;
+   static char number[6];
+   struct servent *service;            /* Doesn't need to be static         */
+
+
+   /* The crappy manpage doesn't say the port must be in net byte order.    */
+   if (service = getservbyport((int)htons(port), proto))
+      name = service-&gt;s_name;
+   elif (! want_number)
+      name = unknown;
+   else {
+      sprintf(number, &quot;%u&quot;, port);
+      name = number;
+   }
+
+   return name;
+
+}
+
+
+/****==========------------------------------------------------==========****/
+/*                                                                          */
+/* Give a summary of usage.                                                 */
+/*                                                                          */
+/****==========------------------------------------------------==========****/
+
+static void usage (
+) {
+
+#if !defined(MAY_NOT_MODIFY)
+   printf(&quot;\nCopyright (c) 1996 I.T. NetworX Ltd.  All rights reserved.\n&quot;);
+   printf(&quot;mailto:<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mike at NetworX.ie</A>\n\n&quot;);
+#endif
+   printf(&quot;tcpshow -- decode a tcpdump(1) savefile, giving a verbose\n&quot;);
+   printf(&quot;           display of the headers and an ASCII display of\n&quot;);
+   printf(&quot;           ICMP, UDP and TCP data.\n\n&quot;);
+   printf(&quot;Version %3.1f\n\n&quot;, VERSION);
+   printf(&quot;Usage: tcpshow [ options ... ] [ expr ]\n&quot;);
+   printf(&quot;\nwhere options are as follows\n&quot;);
+   printf(&quot;\t-b\t\tbreak long lines so they don't wrap\n&quot;);
+   printf(&quot;\t-sb\t\tshow breaks (show where we broke a line)\n&quot;);
+   printf(&quot;\t-w width\tset pagewidth to \&quot;width\&quot; columns (used by -b)\n&quot;);
+   printf(&quot;\t-nolink\t\tdon't decode link header (Ethernet header)\n&quot;);
+   printf(&quot;\t-noip\t\tdon't decode IP header\n&quot;);
+   printf(&quot;\t-nodata\t\tdon't show data (show headers only)\n&quot;);
+   printf(&quot;\t-data\t\tdisplay data only; minimal header decode\n&quot;);
+   printf(&quot;\t-track\t\ttrack sequence numbers (show next-expected ACK)\n&quot;);
+   printf(&quot;\t-terse\t\tshow header decode in compact format\n&quot;);
+   printf(&quot;\t-cooked\t\tdon't run tcpdump to pre-process the input\n&quot;);
+   printf(&quot;\t-pp\t\tpoint-to-point link (no Ethernet header available)\n&quot;);
+   printf(&quot;\t-s\t\tdisplay hex dump of spurious data at packet-end\n&quot;);
+   printf(&quot;\t-h\t\tdisplay this help summary\n\n&quot;);
+   printf(&quot;expr is a tcpdump(1) expression, and is only valid when &quot;);
+   printf(&quot;the -cooked\noption is not used.\n\n&quot;);
+   printf(&quot;Input is from stdin, &quot;);
+   printf(&quot;which must be a raw tcpdump(1) data file (savefile),\n&quot;);
+   printf(&quot;unless the -cooked option is used, in which case stdin &quot;);
+   printf(&quot;must be in the\nformat produced by tcpdump -lenx.\n\n&quot;);
+   printf(&quot;Output is to stdout\n\n&quot;);
+   printf(&quot;tcpdump(1) must be on your PATH unless -cooked is used.\n\n&quot;);
+
+   exit(0);
+
+}

Added: trunk/rpms/tcpshow/tcpshow.patch
===================================================================
--- trunk/rpms/tcpshow/tcpshow.patch	                        (rev 0)
+++ trunk/rpms/tcpshow/tcpshow.patch	2007-02-22 22:33:11 UTC (rev 5194)
@@ -0,0 +1,20 @@
+--- tcpshow.c.cln	Sat Jan 16 11:32:43 1999
++++ tcpshow.c	Sat Jan 16 12:11:01 1999
+@@ -286,7 +286,7 @@
+ typedef unsigned char uchar;
+ 
+ 
+-void main(int, char **);
++int main(int, char **);
+ 
+ 
+ static boolean bflag = FALSE;
+@@ -858,7 +858,7 @@
+ /*                                                                          */
+ /****==========------------------------------------------------==========****/
+ 
+-void main (
++int main (
+    int argc,
+    char **argv
+ ) {

Added: trunk/rpms/tcpshow/tcpshow.spec
===================================================================
--- trunk/rpms/tcpshow/tcpshow.spec	                        (rev 0)
+++ trunk/rpms/tcpshow/tcpshow.spec	2007-02-22 22:33:11 UTC (rev 5194)
@@ -0,0 +1,46 @@
+# $Id$
+# Authority: dag
+
+Summary: Prints dump files created by tcpdump
+Name: tcpshow
+Version: 1.0
+Release: 1
+License: distributable; see tcpshow.c for details
+Group: Applications/Internet
+URL: <A HREF="http://www.cs.berkeley.edu/~daw/mike/">http://www.cs.berkeley.edu/~daw/mike/</A>
+
+Source0: <A HREF="http://www.cs.berkeley.edu/~daw/mike/tcpshow.c">http://www.cs.berkeley.edu/~daw/mike/tcpshow.c</A>
+Source1: <A HREF="http://www.cs.berkeley.edu/~daw/mike/tcpshow.1">http://www.cs.berkeley.edu/~daw/mike/tcpshow.1</A>
+Patch0: tcpshow.patch
+BuildRoot: %{_tmppath}/%{name}-%{release}-%{version}-root
+
+Requires: tcpdump
+
+%description
+Utility to print raw packet dumps from tcpdump(8).
+
+%prep
+%setup -c -T
+%{__cp} -av %{SOURCE0} %{SOURCE1} .
+%patch0 -p0
+
+%build
+#%{__cc} -static %{optflags} -o tcpshow tcpshow.c
+%{__cc} %{optflags} -o tcpshow tcpshow.c
+
+%install
+%{__rm} -rf %{buildroot}
+%{__install} -Dp -m0755 tcpshow %{buildroot}%{_sbindir}/tcpshow
+%{__install} -Dp -m0644 tcpshow.1 %{buildroot}%{_mandir}/man1/tcpshow.1
+
+%files
+%defattr(-, root, root, 0755)
+%doc %{_mandir}/man1/tcpshow.1*
+%{_sbindir}/tcpshow
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%changelog
+* Thu Feb 22 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 1.0-1
+- Initial package. (using DAR)


Property changes on: trunk/rpms/tcpshow/tcpshow.spec
___________________________________________________________________
Name: svn:keywords
   + Id Revision
Name: svn:eol-style
   + native

Added: trunk/rpms/tcpstat/tcpstat.spec
===================================================================
--- trunk/rpms/tcpstat/tcpstat.spec	                        (rev 0)
+++ trunk/rpms/tcpstat/tcpstat.spec	2007-02-22 22:33:11 UTC (rev 5194)
@@ -0,0 +1,45 @@
+# $Id$
+# Authority: dag
+
+Summary: Reports certain network interface statistics
+Name: tcpstat
+Version: 1.5
+Release: 1
+License: NSD
+Group: System Environment/Tools
+URL: <A HREF="http://www.frenchfries.net/paul/tcpstat/">http://www.frenchfries.net/paul/tcpstat/</A>
+
+Source: <A HREF="http://www.frenchfries.net/paul/tcpstat/tcpstat-%{version">http://www.frenchfries.net/paul/tcpstat/tcpstat-%{version</A>}.tar.gz
+Buildroot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+%description
+tcpstat reports certain network interface statistics much like vmstat does
+for system statistics.
+
+tcpstat gets its information by either monitoring a specific interface, or
+by reading previously saved tcpdump data from a file. 
+
+%prep
+%setup
+
+%build
+%configure 
+%{__make} %{?_smp_mflags}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+
+%files
+%defattr(-, root, root, 0755)
+%doc AUTHORS COPYING INSTALL LICENSE NEWS README doc/Tips_and_Tricks.txt
+%doc %{_mandir}/man1/tcpprof.1*
+%doc %{_mandir}/man1/tcpstat.1*
+%{_bindir}/tcpstat
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%changelog
+* Thu Feb 22 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 1.5-1
+- Initial package. (using DAR)


Property changes on: trunk/rpms/tcpstat/tcpstat.spec
___________________________________________________________________
Name: svn:keywords
   + Id Revision
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003992.html">[svn] r5193 - in trunk/rpms: . perl-X11-GUITest watchdog
</A></li>
	<LI>Next message: <A HREF="003994.html">[svn] r5195 - in trunk/rpms: . exdump morse mpack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3993">[ date ]</a>
              <a href="thread.html#3993">[ thread ]</a>
              <a href="subject.html#3993">[ subject ]</a>
              <a href="author.html#3993">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
