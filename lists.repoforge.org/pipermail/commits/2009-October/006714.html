<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r7918 - trunk/rpms/rabbitvcs
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r7918%20-%20trunk/rpms/rabbitvcs&In-Reply-To=%3C200910141940.n9EJexCU005944%40surya.karan.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006713.html">
   <LINK REL="Next"  HREF="006715.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r7918 - trunk/rpms/rabbitvcs</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r7918%20-%20trunk/rpms/rabbitvcs&In-Reply-To=%3C200910141940.n9EJexCU005944%40surya.karan.org%3E"
       TITLE="[svn] r7918 - trunk/rpms/rabbitvcs">packagers at lists.rpmforge.net
       </A><BR>
    <I>Wed Oct 14 21:40:59 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="006713.html">[svn] r7917 - trunk/rpms/rabbitvcs
</A></li>
        <LI>Next message: <A HREF="006715.html">[svn] r7919 - trunk/tools/mrepo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6714">[ date ]</a>
              <a href="thread.html#6714">[ thread ]</a>
              <a href="subject.html#6714">[ subject ]</a>
              <a href="author.html#6714">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: shuff
Date: 2009-10-14 20:40:59 +0100 (Wed, 14 Oct 2009)
New Revision: 7918

Added:
   trunk/rpms/rabbitvcs/rabbitvcs-0.12_nautilusold.patch
Log:
added the patch to put in the nautilusold version of RabbitVCS.py


Added: trunk/rpms/rabbitvcs/rabbitvcs-0.12_nautilusold.patch
===================================================================
--- trunk/rpms/rabbitvcs/rabbitvcs-0.12_nautilusold.patch	                        (rev 0)
+++ trunk/rpms/rabbitvcs/rabbitvcs-0.12_nautilusold.patch	2009-10-14 19:40:59 UTC (rev 7918)
@@ -0,0 +1,2147 @@
+diff -Naur rabbitvcs-0.12-orig/rabbitvcs/lib/extensions/nautilus/RabbitVCS.py rabbitvcs-0.12/rabbitvcs/lib/extensions/nautilus/RabbitVCS.py
+--- rabbitvcs-0.12-orig/rabbitvcs/lib/extensions/nautilus/RabbitVCS.py	2009-10-01 09:37:06.000000000 -0400
++++ rabbitvcs-0.12/rabbitvcs/lib/extensions/nautilus/RabbitVCS.py	2009-10-13 11:18:55.000000000 -0400
+@@ -21,1716 +21,494 @@
+ #
+ 
+ &quot;&quot;&quot;
+-
+-Our module for everything related to the Nautilus extension.
+-  
++TODO
++    1. Integrate translations
++    2. Add more of the v0.12 menu items
++    3.  or figure out a way to use the regular nautilus extension's menu items/logic
++    4.  or clean up the current menuitem logic in some other way
+ &quot;&quot;&quot;
+ 
+-from __future__ import with_statement
+-import copy
+-import os.path
+-from os.path import isdir, isfile, realpath, basename
+-import datetime
+-import threading
++__version__ = &quot;0.12&quot;
+ 
++import copy
++import glob
+ import gnomevfs
+-import nautilus
+-import pysvn
+ import gobject
+ import gtk
++import nautilus
++import os
++import pysvn
++import sys
+ 
+-from rabbitvcs.lib.vcs.svn import SVN
+-
+-from rabbitvcs.util.vcs import *
+-from rabbitvcs.lib.helper import launch_ui_window, launch_diff_tool
+-from rabbitvcs.lib.helper import get_file_extension, get_common_directory
+-from rabbitvcs.lib.helper import pretty_timedelta
+-from rabbitvcs.lib.decorators import timeit, disable
+-
+-from rabbitvcs.lib.log import Log, reload_log_settings
+-log = Log(&quot;rabbitvcs.lib.extensions.nautilus&quot;)
+-
+-from rabbitvcs import gettext
+-_ = gettext.gettext
+-
+-from rabbitvcs.lib.settings import SettingsManager
+-settings = SettingsManager()
+-
+-import rabbitvcs.dbus.service
+-from rabbitvcs.dbus.statuschecker import StatusCheckerStub as StatusChecker
+-
+-# Start up our DBus service if it's not already started, if this fails
+-# we can't really do anything.
+-rabbitvcs.dbus.service.start()
++# RabbitVCS is actually more than just this module so we need to add the entire
++# directory to the path to be able to find our other modules. Because on import
++# Python generates compiled (.pyc) versions of Python source code files we have
++# to strip the 'c' from the extension to find the actual file.
++sys.path.append(os.path.dirname(os.path.realpath(__file__.rstrip(&quot;c&quot;))))
++
++# FIXME: this (and other) should be moved into a rabbitvcs module to prevent 
++# collisions with other modules on the path.
++import rabbitvcs.lib.helper
++
++#============================================================================== 
++
++ENABLE_ATTRIBUTES = True
++RECURSIVE_STATUS = True
++ENABLE_EMBLEMS = True
+ 
+ class RabbitVCS(nautilus.InfoProvider, nautilus.MenuProvider, nautilus.ColumnProvider):
+-    &quot;&quot;&quot; 
+-    This is the main class that implements all of our awesome features.
+-    
++    &quot;&quot;&quot; This is the main class that implements all of our awesome features.
+     &quot;&quot;&quot;
+     
+     #: Maps statuses to emblems.
+     #: TODO: should probably be possible to create this dynamically
+     EMBLEMS = {
+-        &quot;added&quot; :       &quot;rabbitvcs-added&quot;,
+-        &quot;deleted&quot;:      &quot;rabbitvcs-deleted&quot;,
+-        &quot;removed&quot;:      &quot;rabbitvcs-deleted&quot;,
+-        &quot;modified&quot;:     &quot;rabbitvcs-modified&quot;,
+-        &quot;conflicted&quot;:   &quot;rabbitvcs-conflicted&quot;,
+-        &quot;missing&quot;:      &quot;rabbitvcs-conflicted&quot;,
+-        &quot;normal&quot;:       &quot;rabbitvcs-normal&quot;,
+-        &quot;clean&quot;:        &quot;rabbitvcs-normal&quot;,
+-        &quot;ignored&quot;:      &quot;rabbitvcs-ignored&quot;,
+-        &quot;locked&quot;:       &quot;rabbitvcs-locked&quot;,
+-        &quot;read_only&quot;:    &quot;rabbitvcs-read_only&quot;,
+-        &quot;obstructed&quot;:   &quot;rabbitvcs-obstructed&quot;,
+-        &quot;incomplete&quot;:   &quot;rabbitvcs-incomplete&quot;,
+-        &quot;unversioned&quot;:  &quot;rabbitvcs-unversioned&quot;,
+-        &quot;unknown&quot;:      &quot;rabbitvcs-unknown&quot;,
+-        &quot;calculating&quot;:  &quot;rabbitvcs-calculating&quot;,
+-        &quot;error&quot;:        &quot;rabbitvcs-error&quot;
++        pysvn.wc_status_kind.added :       &quot;rabbitvcs-added&quot;,
++        pysvn.wc_status_kind.deleted:      &quot;rabbitvcs-deleted&quot;,
++        pysvn.wc_status_kind.modified:     &quot;rabbitvcs-modified&quot;,
++        pysvn.wc_status_kind.conflicted:   &quot;rabbitvcs-conflicted&quot;,
++        pysvn.wc_status_kind.normal:       &quot;rabbitvcs-normal&quot;,
++        pysvn.wc_status_kind.ignored:      &quot;rabbitvcs-ignored&quot;,
++        pysvn.wc_status_kind.obstructed:   &quot;rabbitvcs-obstructed&quot;
+     }
+-    
+-    #: A list of statuses which count as modified (for a directory) in 
+-    #: TortoiseSVN emblem speak.
+-    MODIFIED_STATUSES = [
+-        SVN.STATUS[&quot;added&quot;],
+-        SVN.STATUS[&quot;deleted&quot;],
+-        SVN.STATUS[&quot;replaced&quot;],
+-        SVN.STATUS[&quot;modified&quot;],
+-        SVN.STATUS[&quot;missing&quot;]
+-    ]
+-    
+-    MODIFIED_TEXT_STATUSES = [
+-        &quot;added&quot;, 
+-        &quot;deleted&quot;,
+-        &quot;replaced&quot;,
+-        &quot;modified&quot;,
+-        &quot;missing&quot;
+-    ]
+-    
+-    #: This is our lookup table for C{NautilusVFSFile}s which we need for attaching
+-    #: emblems. This is mostly a workaround for not being able to turn a path/uri
+-    #: into a C{NautilusVFSFile}. It looks like:::
+-    #: 
+-    #:     nautilusVFSFile_table = {
+-    #:        &quot;/foo/bar/baz&quot;: &lt;NautilusVFSFile&gt;
+-    #:     
+-    #:     }
+-    #: 
+-    #: Keeping track of C{NautilusVFSFile}s is a little bit complicated because
+-    #: when an item is moved (renamed) C{update_file_info} doesn't get called. So
+-    #: we also add C{NautilusVFSFile}s to this table from C{get_file_items} etc.
+-    nautilusVFSFile_table = {}
+-    
+-    #: Without an actual status monitor it's not possible to just keep
+-    #: track of stuff that happens (e.g. a commit happens, files are added,
+-    #: such things). So at the moment we just add all interesting items
+-    #: to this list.
+-    monitored_files = []
+-    
+-    #: This is in case we want to permanently enable invalidation of the status
+-    #: checker info. We put a path here before we invalidate the item, so that
+-    #: we don't enter an endless loop when updating the status.
+-    #: The callback should acquire this lock when pushing the path to this.
+-    always_invalidate = True
+-    paths_from_callback = []
+-    #: It appears that the &quot;update_file_info&quot; call that is triggered by the
+-    #: &quot;invalidate_extension_info&quot; in the callback function happens
+-    #: synchronously (ie. in the same thread). However, given the nature of the
+-    #: python/nautilus extensions module, I'm not sure how reliable this is.
+-    #: It's certainly supported by debugging statements, but maybe it will
+-    #: change in the future? Who knows. This should work for both the current
+-    #: situation, and the possibility that they are asynchronous.
+-    callback_paths_lock = threading.RLock()
+-    
+-    #: A list of statuses that we want to keep track of for when a process
+-    #: might have done something.
+-    STATUSES_TO_MONITOR = copy.copy(MODIFIED_TEXT_STATUSES)
+-    STATUSES_TO_MONITOR.extend([
+-        &quot;unversioned&quot;,
+-        # When doing a checkout Nautilus will notice a directory being
+-        # added and call update_file_info, but at that stage the
+-        # checkout likely hasn't completed yet and the status will be:
+-        &quot;incomplete&quot;
+-    ])
+-    
++
++    #-------------------------------------------------------------------------- 
+     def __init__(self):
+-        threading.currentThread().setName(&quot;RabbitVCS extension thread&quot;)
+-        
+-        # Create a global client we can use to do VCS related stuff
+-        self.vcs_client = SVN()
+-        
+-        self.status_checker = StatusChecker(self.cb_status)
+-        
+-        
+-    def get_columns(self):
+-        &quot;&quot;&quot;
+-        Return all the columns we support.
+-        
+-        &quot;&quot;&quot;
+-        
+-        return (
+-            nautilus.Column(
+-                &quot;RabbitVCS::status_column&quot;,
+-                &quot;status&quot;,
+-                _(&quot;Status&quot;),
+-                &quot;&quot;
+-            ),
+-            nautilus.Column(
+-                &quot;RabbitVCS::revision_column&quot;,
+-                &quot;revision&quot;,
+-                _(&quot;Revision&quot;),
+-                &quot;&quot;
+-            ),
+-            nautilus.Column(
+-                &quot;RabbitVCS::url_column&quot;,
+-                &quot;url&quot;,
+-                _(&quot;URL&quot;),
+-                &quot;&quot;
+-            ),
+-            nautilus.Column(
+-                &quot;RabbitVCS::author_column&quot;,
+-                &quot;author&quot;,
+-                _(&quot;Author&quot;),
+-                &quot;&quot;
+-            ),
+-            nautilus.Column(
+-                &quot;RabbitVCS::age_column&quot;,
+-                &quot;age&quot;,
+-                _(&quot;Age&quot;),
+-                &quot;&quot;
+-            )
+-        )
+-    
+-    #~ @timeit
+-    def update_file_info(self, item):
++        &quot;&quot;&quot; Constructor - initialise our required storage
+         &quot;&quot;&quot;
+-        
+-        C{update_file_info} is called only when:
+-        
+-          - When you enter a directory (once for each item but only when the
+-            item was modified since the last time it was listed)
+-          - When you refresh (once for each item visible)
+-          - When an item viewable from the current window is created or modified
+-          
+-        This is insufficient for our purpose because:
+-        
+-          - You're not notified about items you don't see (which is needed to 
+-            keep the emblem for the directories above the item up-to-date)
+-        
+-        @type   item: NautilusVFSFile
+-        @param  item: 
+-        
++
++        # This list keeps track of any files we have come across that will
++        # need to be re-scanned if there is a commit/revert.
++        self.monitoredFiles = []
++
++        # This list keeps a record of all of the files we're planning to scan
++        # when we get some idle time
++        self.scanStack = []
++
++    #--------------------------------------------------------------------------
++    def OnIdle(self):
++        &quot;&quot;&quot; We use the idle handler to pop items from our scan stack and run a
++            status scan on them. We do this so that we don't hog the processor
++            each time a folder is opened.
+         &quot;&quot;&quot;
+-        
+-        if not self.valid_uri(item.get_uri()): return
+-        path = realpath(unicode(gnomevfs.get_local_path_from_uri(item.get_uri()), &quot;utf-8&quot;))
+-        
+-        # log.debug(&quot;update_file_info() called for %s&quot; % path)
+-        
+-        # Always replace the item in the table with the one we receive, because
+-        # for example if an item is deleted and recreated the NautilusVFSFile
+-        # we had before will be invalid (think pointers and such).
+-        self.nautilusVFSFile_table[path] = item
+-        
+-        # This check should be pretty obvious :-)
+-        # TODO: how come the statuses for a few directories are incorrect
+-        # when we remove this line (detected as working copies, even though
+-        # they are not)? That shouldn't happen.
+-        is_in_a_or_a_working_copy = self.vcs_client.is_in_a_or_a_working_copy(path)
+-        if not is_in_a_or_a_working_copy: return
+-        
+-        # Do our magic...
+-        
+-        # I have added extra logic in cb_status, using a list
+-        # (paths_from_callback) that should allow us to work around this for
+-        # now. But it'd be good to have an actual status monitor. 
+-        
+-        # Useful for figuring out order of calls. See &quot;cb_status&quot;.
+-        # log.debug(&quot;%s: In update_status&quot; % threading.currentThread())
+-        with self.callback_paths_lock:
+-            triggered_by_callback = path in self.paths_from_callback
+-            if triggered_by_callback:
+-                self.paths_from_callback.remove(path)
+-
+-        # log.debug(&quot;US Thread: %s&quot; % threading.currentThread())
+-        invalidate_now = self.always_invalidate and not triggered_by_callback
+-        statuses = self.status_checker.check_status(path, recurse=True, invalidate=invalidate_now)
+-
+-        # TODO: using pysvn directly because I don't like the current
+-        # SVN class.
+-        client = pysvn.Client()
+-        client_info = client.info(path)
++        if len(self.scanStack):
++            self.ScanFile(self.scanStack.pop())
++            return True
++        else:
++            return False
+ 
+-        assert statuses.has_key(path), &quot;Path not in status list!&quot;
++    #-------------------------------------------------------------------------- 
++    def get_columns(self):
++        &quot;&quot;&quot; This is the function called by Nautilus to find out what extra
++            columns we can supply to it.
++        &quot;&quot;&quot;
++        return (nautilus.Column(&quot;NautilusPython::revision_column&quot;,
++                               &quot;revision&quot;,
++                               &quot;Revision&quot;,
++                               &quot;The file revision&quot;),
++                nautilus.Column(&quot;NautilusPython::user_column&quot;,
++                               &quot;user&quot;,
++                               &quot;SVN User&quot;,
++                               &quot;The SVN user&quot;)
+ 
+-        if bool(int(settings.get(&quot;general&quot;, &quot;enable_attributes&quot;))): self.update_columns(item, path, statuses, client_info)
+-        if bool(int(settings.get(&quot;general&quot;, &quot;enable_emblems&quot;))): self.update_status(item, path, statuses, client_info)
++                )
+ 
+-        # Useful for figuring out order of calls. See &quot;cb_status&quot;.
+-        # log.debug(&quot;%s: Leaving update_status&quot; % threading.currentThread())
+-        
+-        
+-    def update_columns(self, item, path, statuses, client_info):
++    #-------------------------------------------------------------------------- 
++    def update_file_info (self, file):
++        &quot;&quot;&quot; Callback from Nautilus to get the file status.
+         &quot;&quot;&quot;
+-        Update the columns (attributes) for a given Nautilus item,
+-        filling them in with information from the version control
+-        server.
+-
+-        &quot;&quot;&quot;
+-        log.debug(&quot;update_colums called for %s&quot; % path)
+-
+-        values = {
+-            &quot;status&quot;: &quot;&quot;,
+-            &quot;revision&quot;: &quot;&quot;,
+-            &quot;url&quot;: &quot;&quot;,
+-            &quot;author&quot;: &quot;&quot;,
+-            &quot;age&quot;: &quot;&quot;
+-        }
+ 
++        if file.get_uri_scheme() != 'file':
++            return
++
++        path = gnomevfs.get_local_path_from_uri(file.get_uri())
++
++        c = pysvn.Client()
+         try:
+-            if client_info is None:
+-                # It IS possible to reach here: ignored files satisfy the &quot;is in
+-                # WC&quot; condition, but aren't themselves versioned!
+-                log.debug(&quot;Unversioned file in WC: %s&quot; % path)
+-                values[&quot;status&quot;] = SVN.STATUS_REVERSE[pysvn.wc_status_kind.unversioned]
++            entry = c.info(path)
++        except:
++            return
++
++        if not entry:
++            return
++
++        # We'll scan the files during idle time, so add it to our stack
++        self.scanStack.append(file)
++        if len(self.scanStack) == 1:
++            gobject.idle_add(self.OnIdle)
++
++    #--------------------------------------------------------------------------
++    def ScanFile(self, file):
++        &quot;&quot;&quot; This is where the magic happens! This function check the current
++            status of *file*, and updates the display with the relevant emblem.
++
++            file - A NautilusFileItem to check
++        &quot;&quot;&quot;
++
++        # Transform the URI to a path
++        path = gnomevfs.get_local_path_from_uri(file.get_uri())
++
++        # Get the SVN info about the path
++        c = pysvn.Client()
++        entry = c.info(path)
++
++        # Update the columns if we're supposed to
++        if ENABLE_ATTRIBUTES:
++            file.add_string_attribute('revision', str(entry.revision.number))
++            author = entry.commit_author
++            if not author:
++                author = &quot;&quot;
++            file.add_string_attribute('user', author)
++
++        # Update the display emblems if we're supposed to
++        if ENABLE_EMBLEMS:
++            if os.path.isdir(path):
++                # We're a folder
++                st = c.status(path, recurse=RECURSIVE_STATUS)
++
++                # Check if this folder had been added
++                for x in st:
++                    if x.path == path and x.text_status == pysvn.wc_status_kind.added:
++                        file.add_emblem(self.EMBLEMS[pysvn.wc_status_kind.added])
++                        return
++
++                # Check if any of the contents of the folder have been modified
++                t = set([    pysvn.wc_status_kind.modified,
++                            pysvn.wc_status_kind.added,
++                            pysvn.wc_status_kind.deleted])
++                statuses = set([s.text_status for s in st])
++
++                if len( t &amp; statuses ):
++                    file.add_emblem(self.EMBLEMS[pysvn.wc_status_kind.modified])
++                else:
++                    file.add_emblem(self.EMBLEMS[pysvn.wc_status_kind.normal])
+             else:
+-                info = client_info.data
+-                # FIXME: replace
+-                # status = client.status(path, recurse=False)[-1].data                
+-                status = statuses[path]
+-    
+-                values[&quot;status&quot;] = status[&quot;text_status&quot;]
++                # We're a file
+ 
+-                # If the text status shows it isn't modified, but the properties
+-                # DO, let them take priority.
+-                if status[&quot;text_status&quot;] not in RabbitVCS.MODIFIED_TEXT_STATUSES \
+-                  and status[&quot;prop_status&quot;] in RabbitVCS.MODIFIED_TEXT_STATUSES:
+-                    values[&quot;status&quot;] = status[&quot;prop_status&quot;]
+-
+-                values[&quot;revision&quot;] = str(info[&quot;commit_revision&quot;].number)
+-                values[&quot;url&quot;] = str(info[&quot;url&quot;])
+-                values[&quot;author&quot;] = str(info[&quot;commit_author&quot;])
+-                values[&quot;age&quot;] = str(
+-                    pretty_timedelta(
+-                        datetime.datetime.fromtimestamp(info[&quot;commit_time&quot;]),
+-                        datetime.datetime.now()
+-                    )
+-                )
+-        except:
+-            log.exception()
++                # Get our status
++                st = c.status(path, recurse=False)[0]
+ 
+-        for key, value in values.items():
+-            item.add_string_attribute(key, value)
++                # Display an emblem if we have a match for the status
++                if st.text_status in self.EMBLEMS:
++                    file.add_emblem(self.EMBLEMS[st.text_status])
++
++                # Keep a note of this file object in case we have commits etc.
++                t = [ pysvn.wc_status_kind.modified, 
++                      pysvn.wc_status_kind.added, 
++                      pysvn.wc_status_kind.deleted]
++                if st.text_status in t:
++                    if file not in self.monitoredFiles:
++                        self.monitoredFiles.append(file)
++                else:
++                    try:
++                        self.monitoredFiles.remove(file)
++                    except:
++                        pass
++
++    #-------------------------------------------------------------------------- 
++    def get_file_items(self, window, files):
++        &quot;&quot;&quot; Menu activated with files selected
++        &quot;&quot;&quot;
++
++        # At the moment we're only handling single files or folders
++        if len(files) &lt; 1:
++            return
++
++        file = files[0]
++        if file is None:
++            return
++
++        path = gnomevfs.get_local_path_from_uri(file.get_uri())
++
++        items = [ ('NautilusPython::svndelete_file_item', 'Delete' , 'Remove files from the repository.', self.OnDelete, &quot;rabbitvcs-delete&quot;),
++		          ('NautilusPython::svnrename_file_item', 'Rename' , 'Rename a file in the repository', self.OnRename, &quot;rabbitvcs-rename&quot;),
++                  ('NautilusPython::svnrefreshstatus_file_item', 'Refresh Status', 'Refresh the display status of the selected files.', self.OnRefreshStatus, &quot;rabbitvcs-refresh&quot;),
++        ]
++
++        if len( files ) == 1:
++            items += [    ('NautilusPython::svnlog_file_item', 'Log' , 'Log of %s' % file.get_name(), self.OnShowLog, &quot;rabbitvcs-show_log&quot;),
++                        ('NautilusPython::svnupdate_file_item', 'Update' , 'Get the latest code from the repository.', self.OnUpdate, &quot;rabbitvcs-update&quot;)
++            ]
++
++        # Check if this is a folder, and if so if it's under source control
++        if os.path.isdir(path):
++            # Check if this folder is versioned
++            if os.path.isdir(os.path.join(path, &quot;.svn&quot;)):
++                # Check if any of our children are modified.
++                c = pysvn.Client()
++                st = c.status(path, recurse=RECURSIVE_STATUS)
++                statuses = set([x.text_status for x in st])
++                t = set([    pysvn.wc_status_kind.modified,
++                            pysvn.wc_status_kind.added,
++                            pysvn.wc_status_kind.deleted])
++                if len( t &amp; statuses ):
++                    # If so, add some useful menu items
++                    items += [    ('NautilusPython::svnmkdiff_file_item', 'Patch', 'Create a patch of %s from the repository version'%file.get_name(), self.OnMkDiff, &quot;rabbitvcs-diff&quot;), 
++                                ('NautilusPython::svncommit_file_item', 'Commit' , 'Commit %s to the repository.' % file.get_name(), self.OnCommit, &quot;rabbitvcs-commit&quot;),
++                                ('NautilusPython::svnrevert_file_item', 'Revert' , 'Revert %s back to the repository version.'%file.get_name(), self.OnRevert, &quot;rabbitvcs-revert&quot;),]
++
++                items += [
++                    ('NautilusPython::svnproperties_file_item', 'Properties', 'File properties for %s.'%file.get_name(), self.OnProperties, &quot;rabbitvcs-properties&quot;)
++                ]
++
++            else:
++                # Check if the parent is under source control
++                if os.path.isdir(os.path.join(os.path.split(path)[0], &quot;.svn&quot;)):
++                    items = [('NautilusPython::svnadd_file_item', 'Add' , 'Add %s to the repository.'%file.get_name(), self.OnAdd, &quot;rabbitvcs-add&quot;)]
++                else:
++		            items = [('NautilusPython::svncheckout_file_item', 'Checkout' , 'Checkout code from an SVN repository', self.OnCheckout, &quot;rabbitvcs-checkout&quot;)]
+ 
+-    
+-    def update_status(self, item, path, statuses, client_info):
+-        # If we are able to set an emblem that means we have a local status
+-        # available. The StatusMonitor will keep us up-to-date through the 
+-        # C{cb_status} callback.
+-        # Warning! If you use invalidate=True here, it will set up an endless
+-        # loop:
+-        # 1. Update requests status (inv=True)
+-        # 2. Status checker returns &quot;calculating&quot;
+-        # 3. Status checker calculates status, calls callback
+-        # 4. Callback triggers update
+-                
+-        # Path == first index or last for old system?
+-        if statuses[path][&quot;text_status&quot;] == &quot;calculating&quot;:
+-            item.add_emblem(self.EMBLEMS[&quot;calculating&quot;])
+         else:
+-            summarized_status = get_summarized_status(path, statuses)
+-            if summarized_status in self.EMBLEMS:
+-                item.add_emblem(self.EMBLEMS[summarized_status])
+-        
+-    #~ @disable
+-    @timeit
+-    def get_file_items(self, window, items):
+-        &quot;&quot;&quot;
+-        Menu activated with items selected. Nautilus also calls this function
+-        when rendering submenus, even though this is not needed since the entire
+-        menu has already been returned.
+-        
+-        Note that calling C{nautilusVFSFile.invalidate_extension_info()} will 
+-        also cause get_file_items to be called.
+-        
+-        @type   window: NautilusNavigationWindow
+-        @param  window:
+-        
+-        @type   items:  list of NautilusVFSFile
+-        @param  items:
+-        
+-        @rtype:         list of MenuItems
+-        @return:        The context menu entries to add to the menu.
+-        
+-        &quot;&quot;&quot;
+-        
+-        paths = []
+-        for item in items:
+-            if self.valid_uri(item.get_uri()):
+-                path = realpath(unicode(gnomevfs.get_local_path_from_uri(item.get_uri()), &quot;utf-8&quot;))
+-                paths.append(path)
+-                self.nautilusVFSFile_table[path] = item
++            # We're a file, so lets check if we're in a versioned folder
++            if os.path.isdir(os.path.join(os.path.split(path)[0], &quot;.svn&quot;)):
++                # OK we're in a versioned folder - are we already in SVN?
++                c = pysvn.Client()
++                st = c.status(path)[0]
++                if not st.is_versioned:
++                    # If not, we can only offer to add the file.
++                    items = [('NautilusPython::svnadd_file_item', 'Add' , 'Add %s to the repository.'%file.get_name(), self.OnAdd, &quot;rabbitvcs-add&quot;)]
++
++                # Add the revert and diff items if we've changed from the repos version
++                if st.text_status in [pysvn.wc_status_kind.added, pysvn.wc_status_kind.modified]:
++                    items += [    ('NautilusPython::svnrevert_file_item', 'Revert' , 'Revert %s back to the repository version.'%file.get_name(), self.OnRevert, &quot;rabbitvcs-revert&quot;), ]
++
++                    if len(files) == 1:
++                        items += [    ('NautilusPython::svncommit_file_item', 'Commit' , 'Commit %s to the repository.' % file.get_name(), self.OnCommit, &quot;rabbitvcs-commit&quot;),
++                                    ('NautilusPython::svndiff_file_item', 'Diff' , 'Diff %s against the repository version' % file.get_name(), self.OnShowDiff, &quot;rabbitvcs-diff&quot;),
++                                    ('NautilusPython::svnmkdiff_file_item', 'Patch', 'Create a patch of %s from the repository version'%file.get_name(), self.OnMkDiff, &quot;rabbitvcs-createpatch&quot;), 
++	            ]
++
++                # Add the conflict resolution menu items
++                if st.text_status in [pysvn.wc_status_kind.conflicted]:
++                    items += [    ('NautilusPython::svnrevert_file_item', 'Revert' , 'Revert %s back to the repository version.'%file.get_name(), self.OnRevert, &quot;rabbitvcs-revert&quot;), ]
++
++                    if len(files) == 1:
++                        items += [  ('NautilusPython::svneditconflict_file_item', 'Edit Conflicts' , 'Edit the conflicts found when updating %s.'%file.get_name(), self.OnEditConflicts, None),
++                                    ('NautilusPython::svnresolveconflict_file_item', 'Resolved' , 'Mark %s as resolved.'%file.get_name(), self.OnResolveConflicts, &quot;rabbitvcs-resolve&quot;)]
+ 
+-        if len(paths) == 0: return []
+-        
+-        return MainContextMenu(window.get_data(&quot;base_dir&quot;), paths, self).construct_menu()
+-        
+-    
+-    #~ @disable
+-    @timeit
+-    def get_background_items(self, window, item):
+-        &quot;&quot;&quot;
+-        Menu activated on entering a directory. Builds context menu for File
+-        menu and for window background.
+-        
+-        @type   window: NautilusNavigationWindow
+-        @param  window:
+-        
+-        @type   item:   NautilusVFSFile
+-        @param  item:
+-        
+-        @rtype:         list of MenuItems
+-        @return:        The context menu entries to add to the menu.
+-        
+-        &quot;&quot;&quot;
+-        
+-        if not self.valid_uri(item.get_uri()): return
+-        path = realpath(unicode(gnomevfs.get_local_path_from_uri(item.get_uri()), &quot;utf-8&quot;))
+-        self.nautilusVFSFile_table[path] = item
+-        
+-        # log.debug(&quot;get_background_items() called&quot;)
+-        
+-        window.set_data(&quot;base_dir&quot;, path)
+-        
+-        return MainContextMenu(path, [path], self).construct_menu()
+-    
+-    #
+-    # Helper functions
+-    #
+-    
+-    def valid_uri(self, uri):
+-        &quot;&quot;&quot;
+-        Check whether or not it's a good idea to have RabbitVCS do
+-        its magic for this URI. Some examples of URI schemes:
+-        
+-        x-nautilus-<A HREF="desktop:///">desktop:///</A> # e.g. mounted devices on the desktop
+-        
+-        &quot;&quot;&quot;
+-        
+-        if not uri.startswith(&quot;<A HREF="file://">file://</A>&quot;): return False
+-        
+-        return True
+-    
+-    #
+-    # Some methods to help with keeping emblems up-to-date
+-    #
+-    
+-    def rescan_after_process_exit(self, proc, paths):
+-        &quot;&quot;&quot; 
+-        Rescans all of the items on our C{monitored_files} list after the
+-        process specified by C{proc} completes. Also checks the paths
+-        that were passed.
+-        
+-        TODO: the monitored_files list could grow quite large if somebody
+-        browses a lot of working copies. It probably won't affect anything
+-        (most importantly performance) all that negatively.
+-        
++                items += [
++                    ('NautilusPython::svnproperties_file_item', 'Properties', 'File properties for %s.'%file.get_name(), self.OnProperties, &quot;rabbitvcs-properties&quot;)
++                ]
++
++            else:
++                items = []
++
++        return self.create_menu(window, items, files)
++
++    #-------------------------------------------------------------------------- 
++    def get_background_items(self, window, file):
++        &quot;&quot;&quot; Menu activated on window background
+         &quot;&quot;&quot;
+-        
+-        def do_check():
+-            # We'll check the paths first (these were the paths that
+-            # were originally passed along to the context menu). 
+-            #
+-            # This is needed among other things for:
+-            #
+-            #   - When a directory is normal and you add files inside it
+-            #
+-            for path in paths:
+-                statuses = self.status_checker.check_status(path, recurse=True, invalidate=True)
+-            
+-        self.execute_after_process_exit(proc, do_check)
+-        
+-    def execute_after_process_exit(self, proc, func = None):
+ 
+-        def is_process_still_alive():
+-            log.debug(&quot;is_process_still_alive() for pid: %i&quot; % proc.pid)
+-            # First we need to see if the commit process is still running
++        if file.get_uri() == &quot;x-nautilus-<A HREF="desktop:///">desktop:///</A>&quot;:
++            return
+ 
+-            retval = proc.poll()
+-            
+-            log.debug(&quot;%s&quot; % retval)
+-            
+-            still_going = (retval is None)
++        path = gnomevfs.get_local_path_from_uri(file.get_uri())
+ 
+-            if not still_going and callable(func):
+-                func()
+-            
+-            return still_going
++        window.set_data(&quot;base_dir&quot;, os.path.realpath(unicode(path)))
+ 
+-        # Add our callback function on a 1 second timeout
+-        gobject.timeout_add_seconds(1, is_process_still_alive)
+-        
+-    # 
+-    # Some other methods
+-    # 
+-    
+-    def reload_settings(self, proc):
+-        &quot;&quot;&quot;
+-        Used to re-load settings after the settings dialog has been closed.
+-        
+-        FIXME: This probably doesn't belong here, ideally the settings manager
+-        does this itself and make sure everything is reloaded properly 
+-        after the settings dialogs saves.
+-        &quot;&quot;&quot;
+-    
+-        def do_reload_settings():
+-            globals()[&quot;settings&quot;] = SettingsManager()
+-            globals()[&quot;log&quot;] = reload_log_settings()(&quot;rabbitvcs.lib.extensions.nautilus&quot;)
+-            log.debug(&quot;Re-scanning settings&quot;)
+-            
+-        self.execute_after_process_exit(proc, do_reload_settings)
+-        
+-        
+-    # 
+-    # Callbacks
+-    # 
+-    
+-    def cb_status(self, path, statuses):
+-        &quot;&quot;&quot;
+-        This is the callback that C{StatusMonitor} calls. 
+-        
+-        @type   path:   string
+-        @param  path:   The path of the item something interesting happened to.
+-        
+-        @type   statuses: list of tuples of (path, status)
+-        @param  statuses: The statuses (we do nothing with this now)
+-        &quot;&quot;&quot;
+-        # log.debug(&quot;CB Thread: %s&quot; % threading.currentThread())
+-        if path in self.nautilusVFSFile_table:
+-            item = self.nautilusVFSFile_table[path]
+-            # We need to invalidate the extension info for only one reason:
+-            #
+-            # - Invalidating the extension info will cause Nautilus to remove all
+-            #   temporary emblems we applied so we don't have overlay problems
+-            #   (with ourselves, we'd still have some with other extensions).
+-            #
+-            # After invalidating C{update_file_info} applies the correct emblem.
+-            
+-            # Since invalidation triggers an &quot;update_file_info&quot; call, we can
+-            # tell it NOT to invalidate the status checker path.
+-            with self.callback_paths_lock:
+-                self.paths_from_callback.append(path)
+-                # These are useful to establish whether the &quot;update_status&quot; call
+-                # happens INSIDE this next call, or later, or in another thread. 
+-                # log.debug(&quot;%s: Invalidating...&quot; % threading.currentThread())
+-                item.invalidate_extension_info()
+-                # log.debug(&quot;%s: Done invalidate call.&quot; % threading.currentThread())
+-        
+-class MainContextMenu:
+-    &quot;&quot;&quot;
+-    
+-    A class that represents our context menu.
+-    
+-    See: <A HREF="http://code.google.com/p/rabbitvcs/wiki/ContextMenuStructure">http://code.google.com/p/rabbitvcs/wiki/ContextMenuStructure</A>
+-    
+-    FIXME: There's currently a problem with the order in which menu items 
+-    appear, even though a list such as C{[&lt;Update&gt;, &lt;Commit&gt;, &lt;RabbitVCS&gt;]} 
+-    would be returned it might end up as C{[&lt;RabbitVCS&gt;, &lt;Update&gt;, &lt;Commit&gt;]}.
+-    
+-    &quot;&quot;&quot;
+-    
+-    SEPARATOR = u'\u2015' * 10
+-    
+-    def __init__(self, base_dir, paths, rabbitvcs_extension):
+-        self.base_dir = base_dir
+-        self.paths = paths
+-        self.rabbitvcs_extension = rabbitvcs_extension
+-        self.vcs_client = SVN()
+-        
+-        self.status_checker = StatusChecker()
+-        
+-        self.statuses = {}
+-        for path in self.paths:
+-            self.statuses.update(self.status_checker.check_status(path, recurse=True, callback=False))
+-        self.text_statuses = [self.statuses[key][&quot;text_status&quot;] for key in self.statuses.keys()]
+-        self.prop_statuses = [self.statuses[key][&quot;prop_status&quot;] for key in self.statuses.keys()]
+-        
+-        self.path_dict = {}
+-        self.path_dict[&quot;length&quot;] = len(paths)
+-        
+-        checks = {
+-            &quot;is_dir&quot;                        : isdir,
+-            &quot;is_file&quot;                       : isfile,
+-            &quot;is_working_copy&quot;               : is_working_copy,
+-            &quot;is_in_a_or_a_working_copy&quot;     : is_in_a_or_a_working_copy,
+-            &quot;is_versioned&quot;                  : is_versioned,
+-            &quot;is_normal&quot;                     : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;normal&quot; and self.statuses[path][&quot;prop_status&quot;] == &quot;normal&quot;,
+-            &quot;is_added&quot;                      : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;added&quot;,
+-            &quot;is_modified&quot;                   : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;modified&quot; or self.statuses[path][&quot;prop_status&quot;] == &quot;modified&quot;,
+-            &quot;is_deleted&quot;                    : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;deleted&quot;,
+-            &quot;is_ignored&quot;                    : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;ignored&quot;,
+-            &quot;is_locked&quot;                     : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;locked&quot;,
+-            &quot;is_missing&quot;                    : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;missing&quot;,
+-            &quot;is_conflicted&quot;                 : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;conflicted&quot;,
+-            &quot;is_obstructed&quot;                 : lambda path: self.statuses[path][&quot;text_status&quot;] == &quot;obstructed&quot;,
+-            &quot;has_unversioned&quot;               : lambda path: &quot;unversioned&quot; in self.text_statuses,
+-            &quot;has_added&quot;                     : lambda path: &quot;added&quot; in self.text_statuses,
+-            &quot;has_modified&quot;                  : lambda path: &quot;modified&quot; in self.text_statuses or &quot;modified&quot; in self.prop_statuses,
+-            &quot;has_deleted&quot;                   : lambda path: &quot;deleted&quot; in self.text_statuses,
+-            &quot;has_ignored&quot;                   : lambda path: &quot;ignored&quot; in self.text_statuses,
+-            &quot;has_locked&quot;                    : lambda path: &quot;locked&quot; in self.text_statuses,
+-            &quot;has_missing&quot;                   : lambda path: &quot;missing&quot; in self.text_statuses,
+-            &quot;has_conflicted&quot;                : lambda path: &quot;conflicted&quot; in self.text_statuses,
+-            &quot;has_obstructed&quot;                : lambda path: &quot;obstructed&quot; in self.text_statuses
+-        }
+-
+-        # Each path gets tested for each check
+-        # If a check has returned True for any path, skip it for remaining paths
+-        for path in paths:
+-            for key, func in checks.items():
+-                if key not in self.path_dict or self.path_dict[key] is not True:
+-                    self.path_dict[key] = func(path)
+-        
+-    def construct_menu(self):
+-        &quot;&quot;&quot;
+-        
+-        This function is really only used to contain the menu defintion. The
+-        actual menu is build using C{create_menu_from_definition}.
+-        
+-        @rtype:     list of MenuItems
+-        @return:    A list of MenuItems representing the context menu.
+-        &quot;&quot;&quot;
+-        
+-        # The following dictionary defines the complete contextmenu
+-        menu_definition = [
+-            {
+-                &quot;identifier&quot;: &quot;RabbitVCS::Debug&quot;,
+-                &quot;label&quot;: _(&quot;Debug&quot;),
+-                &quot;tooltip&quot;: &quot;&quot;,
+-                &quot;icon&quot;: &quot;rabbitvcs-monkey&quot;,
+-                &quot;signals&quot;: {
+-                    &quot;activate&quot;: {
+-                        &quot;callback&quot;: None,
+-                        &quot;args&quot;: None
+-                    }
+-                },
+-                &quot;condition&quot;: (lambda: settings.get(&quot;general&quot;, &quot;show_debug&quot;)),
+-                &quot;submenus&quot;: [
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Bugs&quot;,
+-                        &quot;label&quot;: _(&quot;Bugs&quot;),
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: &quot;rabbitvcs-bug&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: None,
+-                                &quot;args&quot;: None
+-                            }
+-                        },
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Debug_Shell&quot;,
+-                        &quot;label&quot;: _(&quot;Open Shell&quot;),
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: &quot;gnome-terminal&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_debug_shell,
+-                                &quot;args&quot;: None
+-                            }
+-                        },
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Refresh_Status&quot;,
+-                        &quot;label&quot;: _(&quot;Refresh Status&quot;),
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: &quot;rabbitvcs-refresh&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_refresh_status,
+-                                &quot;args&quot;: None
+-                            }
+-                        },
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Debug_Revert&quot;,
+-                        &quot;label&quot;: _(&quot;Debug Revert&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Reverts everything it sees&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-revert&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_debug_revert,
+-                                &quot;args&quot;: None
+-                            }
+-                        },
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Debug_Invalidate&quot;,
+-                        &quot;label&quot;: _(&quot;Invalidate&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Force an invalidate_extension_info() call&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-clear&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_debug_invalidate,
+-                                &quot;args&quot;: None
+-                            }
+-                        },
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Debug_Add_Emblem&quot;,
+-                        &quot;label&quot;: _(&quot;Add Emblem&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Add an emblem&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-emblems&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_debug_add_emblem,
+-                                &quot;args&quot;: None
+-                            }
+-                        },
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                ]
+-            },
+-            {
+-                &quot;identifier&quot;: &quot;RabbitVCS::Checkout&quot;,
+-                &quot;label&quot;: _(&quot;Checkout&quot;),
+-                &quot;tooltip&quot;: _(&quot;Check out a working copy&quot;),
+-                &quot;icon&quot;: &quot;rabbitvcs-checkout&quot;,
+-                &quot;signals&quot;: {
+-                    &quot;activate&quot;: {
+-                        &quot;callback&quot;: self.callback_checkout,
+-                        &quot;args&quot;: None
+-                    }
+-                }, 
+-                &quot;condition&quot;: self.condition_checkout,
+-                &quot;submenus&quot;: [
+-                    
+-                ]
+-            },
+-            {
+-                &quot;identifier&quot;: &quot;RabbitVCS::Update&quot;,
+-                &quot;label&quot;: _(&quot;Update&quot;),
+-                &quot;tooltip&quot;: _(&quot;Update a working copy&quot;),
+-                &quot;icon&quot;: &quot;rabbitvcs-update&quot;,
+-                &quot;signals&quot;: {
+-                    &quot;activate&quot;: {
+-                        &quot;callback&quot;: self.callback_update,
+-                        &quot;args&quot;: None
+-                    }
+-                }, 
+-                &quot;condition&quot;: self.condition_update,
+-                &quot;submenus&quot;: [
+-                    
+-                ]
+-            },
+-            {
+-                &quot;identifier&quot;: &quot;RabbitVCS::Commit&quot;,
+-                &quot;label&quot;: _(&quot;Commit&quot;),
+-                &quot;tooltip&quot;: _(&quot;Commit modifications to the repository&quot;),
+-                &quot;icon&quot;: &quot;rabbitvcs-commit&quot;,
+-                &quot;signals&quot;: {
+-                    &quot;activate&quot;: {
+-                        &quot;callback&quot;: self.callback_commit,
+-                        &quot;args&quot;: None
+-                    }
+-                }, 
+-                &quot;condition&quot;: self.condition_commit,
+-                &quot;submenus&quot;: [
+-                    
+-                ]
+-            },
+-            {
+-                &quot;identifier&quot;: &quot;RabbitVCS::RabbitVCS&quot;,
+-                &quot;label&quot;: _(&quot;RabbitVCS&quot;),
+-                &quot;tooltip&quot;: &quot;&quot;,
+-                &quot;icon&quot;: &quot;rabbitvcs&quot;,
+-                &quot;signals&quot;: {
+-                    &quot;activate&quot;: {
+-                        &quot;callback&quot;: None,
+-                        &quot;args&quot;: None
+-                    }
+-                }, 
+-                &quot;condition&quot;: (lambda: True),
+-                &quot;submenus&quot;: [
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Diff&quot;,
+-                        &quot;label&quot;: _(&quot;View Diff&quot;),
+-                        &quot;tooltip&quot;: _(&quot;View the modifications made to a file&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-diff&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_diff,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_diff,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Show_Log&quot;,
+-                        &quot;label&quot;: _(&quot;Show Log&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Show a file's log information&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-show_log&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_show_log,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_show_log,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Separator1&quot;,
+-                        &quot;label&quot;: self.SEPARATOR,
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {}, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: []
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Add&quot;,
+-                        &quot;label&quot;: _(&quot;Add&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Schedule an item to be added to the repository&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-add&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_add,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_add,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::AddToIgnoreList&quot;,
+-                        &quot;label&quot;: _(&quot;Add to ignore list&quot;),
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {}, 
+-                        &quot;condition&quot;: self.condition_add_to_ignore_list,
+-                        &quot;submenus&quot;: [
+-                            {
+-                                &quot;identifier&quot;: &quot;RabbitVCS::AddToIgnoreFile&quot;,
+-                                &quot;label&quot;: basename(self.paths[0]),
+-                                &quot;tooltip&quot;: _(&quot;Ignore an item&quot;),
+-                                &quot;icon&quot;: None,
+-                                &quot;signals&quot;: {
+-                                    &quot;activate&quot;: {
+-                                        &quot;callback&quot;: self.callback_ignore_filename,
+-                                        &quot;args&quot;: None
+-                                    }
+-                                }, 
+-                                &quot;condition&quot;: (lambda: True),
+-                                &quot;submenus&quot;: [
+-                                ]
+-                            },
+-                            {
+-                                &quot;identifier&quot;: &quot;RabbitVCS::AddToIgnoreExt&quot;,
+-                                &quot;label&quot;: &quot;*%s&quot; % get_file_extension(self.paths[0]),
+-                                &quot;tooltip&quot;: _(&quot;Ignore all files with this extension&quot;),
+-                                &quot;icon&quot;: None,
+-                                &quot;signals&quot;: {
+-                                    &quot;activate&quot;: {
+-                                        &quot;callback&quot;: self.callback_ignore_ext,
+-                                        &quot;args&quot;: None
+-                                    }
+-                                }, 
+-                                &quot;condition&quot;: self.condition_ignore_ext,
+-                                &quot;submenus&quot;: [
+-                                ]
+-                            }
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::SeparatorAdd&quot;,
+-                        &quot;label&quot;: self.SEPARATOR,
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {}, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: []
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::UpdateToRevision&quot;,
+-                        &quot;label&quot;: _(&quot;Update to revision...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Update a file to a specific revision&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-update&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_updateto,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_update_to,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Rename&quot;,
+-                        &quot;label&quot;: _(&quot;Rename...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Schedule an item to be renamed on the repository&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-rename&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_rename,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_rename,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Delete&quot;,
+-                        &quot;label&quot;: _(&quot;Delete&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Schedule an item to be deleted from the repository&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-delete&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_delete,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_delete,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Revert&quot;,
+-                        &quot;label&quot;: _(&quot;Revert&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Revert an item to its unmodified state&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-revert&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_revert,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_revert,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Resolve&quot;,
+-                        &quot;label&quot;: _(&quot;Resolve&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Mark a conflicted item as resolved&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-resolve&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_resolve,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_resolve,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Relocate&quot;,
+-                        &quot;label&quot;: _(&quot;Relocate...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Relocate your working copy&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-relocate&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_relocate,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_relocate,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::GetLock&quot;,
+-                        &quot;label&quot;: _(&quot;Get Lock...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Locally lock items&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-lock&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_lock,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_lock,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Unlock&quot;,
+-                        &quot;label&quot;: _(&quot;Release Lock...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Release lock on an item&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-unlock&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_unlock,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_unlock,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Cleanup&quot;,
+-                        &quot;label&quot;: _(&quot;Cleanup&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Clean up working copy&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-cleanup&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_cleanup,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_cleanup,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Separator2&quot;,
+-                        &quot;label&quot;: self.SEPARATOR,
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {}, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: []
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Export&quot;,
+-                        &quot;label&quot;: _(&quot;Export&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Export a working copy or repository with no versioning information&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-export&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_export,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_export,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Create_Repository&quot;,
+-                        &quot;label&quot;: _(&quot;Create Repository here&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Create a repository in a folder&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-run&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_create_repository,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_create,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Import&quot;,
+-                        &quot;label&quot;: _(&quot;Import&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Import an item into a repository&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-import&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_import,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_import,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Separator3&quot;,
+-                        &quot;label&quot;: self.SEPARATOR,
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {}, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: []
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::BranchTag&quot;,
+-                        &quot;label&quot;: _(&quot;Branch/tag...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Copy an item to another location in the repository&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-branch&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_branch,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_branch,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Switch&quot;,
+-                        &quot;label&quot;: _(&quot;Switch...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Change the repository location of a working copy&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-switch&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_switch,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_switch,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Merge&quot;,
+-                        &quot;label&quot;: _(&quot;Merge...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;A wizard with steps for merging&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-merge&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_merge,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_merge,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Separator4&quot;,
+-                        &quot;label&quot;: self.SEPARATOR,
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {}, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: []
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Annotate&quot;,
+-                        &quot;label&quot;: _(&quot;Annotate...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Annotate a file&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-annotate&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_annotate,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_annotate,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Separator5&quot;,
+-                        &quot;label&quot;: self.SEPARATOR,
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {}, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: []
+-                    },
+-                   {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::CreatePatch&quot;,
+-                        &quot;label&quot;: _(&quot;Create Patch...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Creates a unified diff file with all changes you made&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-createpatch&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_createpatch,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_createpatch,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::ApplyPatch&quot;,
+-                        &quot;label&quot;: _(&quot;Apply Patch...&quot;),
+-                        &quot;tooltip&quot;: _(&quot;Applies a unified diff file to the working copy&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-applypatch&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_applypatch,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_applypatch,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Properties&quot;,
+-                        &quot;label&quot;: _(&quot;Properties&quot;),
+-                        &quot;tooltip&quot;: _(&quot;View the properties of an item&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-properties&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_properties,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: self.condition_properties,
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Separator6&quot;,
+-                        &quot;label&quot;: self.SEPARATOR,
+-                        &quot;tooltip&quot;: &quot;&quot;,
+-                        &quot;icon&quot;: None,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: None,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Help&quot;,
+-                        &quot;label&quot;: _(&quot;Help&quot;),
+-                        &quot;tooltip&quot;: _(&quot;View help&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-help&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: None,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: (lambda: False),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::Settings&quot;,
+-                        &quot;label&quot;: _(&quot;Settings&quot;),
+-                        &quot;tooltip&quot;: _(&quot;View or change RabbitVCS settings&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-settings&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_settings,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    },
+-                    {
+-                        &quot;identifier&quot;: &quot;RabbitVCS::About&quot;,
+-                        &quot;label&quot;: _(&quot;About&quot;),
+-                        &quot;tooltip&quot;: _(&quot;About RabbitVCS&quot;),
+-                        &quot;icon&quot;: &quot;rabbitvcs-about&quot;,
+-                        &quot;signals&quot;: {
+-                            &quot;activate&quot;: {
+-                                &quot;callback&quot;: self.callback_about,
+-                                &quot;args&quot;: None
+-                            }
+-                        }, 
+-                        &quot;condition&quot;: (lambda: True),
+-                        &quot;submenus&quot;: [
+-                            
+-                        ]
+-                    }
+-                ]
+-            },
+-        ]
+-        
+-        return self.create_menu_from_definition(menu_definition)
+-    
+-    def create_menu_from_definition(self, menu_definition):
+-        &quot;&quot;&quot;
+-        
+-        Create the actual menu from a menu definiton.
+-        
+-        A single menu item definition looks like::
+-        
+-            {
+-                &quot;identifier&quot;: &quot;RabbitVCS::Identifier&quot;,
+-                &quot;label&quot;: &quot;&quot;,
+-                &quot;tooltip&quot;: &quot;&quot;,
+-                &quot;icon&quot;: &quot;&quot;,
+-                &quot;signals&quot;: {
+-                    &quot;activate&quot;: {
+-                        &quot;callback&quot;: None,
+-                        &quot;args&quot;: None
+-                    }
+-                }, 
+-                &quot;condition&quot;: (lambda: True),
+-                &quot;submenus&quot;: [
+-                    
+-                ]
+-            }
+-        
+-        @type   menu_definition:  list
+-        @param  menu_definition:  A list of definition items.
+-        
+-        @rtype:     list of MenuItems
+-        @return:    A list of MenuItems representing the context menu.
+-        
++        if not os.path.isdir(os.path.join(path,&quot;.svn&quot;)):
++            items = [     ('NautilusPython::svncheckout_file_item', 'Checkout' , 'Checkout code from an SVN repository', self.OnCheckout, &quot;rabbitvcs-checkout&quot;)
++                    ]
++        else:
++            items = [     ('NautilusPython::svnlog_file_item', 'Log' , 'SVN Log of %s' % file.get_name(), self.OnShowLog, &quot;rabbitvcs-show_log&quot;),
++                        ('NautilusPython::svncommit_file_item', 'Commit' , 'Commit %s back to the repository.' % file.get_name(), self.OnCommit, &quot;rabbitvcs-commit&quot;),
++                        ('NautilusPython::svnupdate_file_item', 'Update' , 'Get the latest code from the repository.', self.OnUpdate, &quot;rabbitvcs-update&quot;),
++                        ('NautilusPython::svnrefreshstatus_file_item', 'Refresh', 'Refresh the display status of %s.'%file.get_name(), self.OnRefreshStatus, &quot;rabbitvcs-refresh&quot;),
++                        ('NautilusPython::svnmkdiffdir_file_item', 'Patch', 'Create a patch of %s from the repository version'%file.get_name(), self.OnMkDiffDir, &quot;rabbitvcs-diff&quot;),
++                ('NautilusPython::svnproperties_file_item', 'Properties', 'File properties for %s.'%file.get_name(), self.OnProperties, &quot;rabbitvcs-properties&quot;)
++            ]
++
++        return self.create_menu(window, items, [file])
++
++    def create_menu(self, window, items, paths):
++        &quot;&quot;&quot;
++        While I can add submenu items in nautilus-python 0.5.0, I can't get
++        the submenu item activate signal to connect to a callback method
++        
++        menuitem = nautilus.MenuItem('NautilusPython::Svn', 'RabbitVCS', '', &quot;rabbitvcs&quot;)
++        if hasattr(menuitem, &quot;set_submenu&quot;):
++            submenu = nautilus.Menu()
++            menuitem.set_submenu(submenu)
++            for item in items:
++                i = nautilus.MenuItem( item[0], item[1], item[2], item[4] )
++                i.connect('activate', item[3], window, paths)
++                submenu.append_item( i )
++
++            return menuitem,
++		&quot;&quot;&quot;
++		
++        menuitems = []
++        for item in items:
++            i = nautilus.MenuItem( item[0], item[1], item[2], item[4] )
++            i.connect('activate', item[3], window, paths)
++            menuitems.append(i)
++
++        return menuitems
++            
++    #--------------------------------------------------------------------------
++    def RescanFilesAfterProcess(self, pid):
++        &quot;&quot;&quot; Rescans all of the files on our *monitoredFiles* list after the
++            process specified by *pid* completes.
+         &quot;&quot;&quot;
+-        
+-        menu = []
+-        previous_label = None
+-        is_first = True
+-        index = 0
+-        length = len(menu_definition)
+-        
+-        for definition_item in menu_definition:
+-            is_last = (index + 1 == length)
+-            
+-            # Execute the condition associated with the definition_item
+-            # which will figure out whether or not to display this item.
+-            if not definition_item.has_key(&quot;condition&quot;) or definition_item[&quot;condition&quot;]():
+-                # If the item is a separator, don't show it if this is the first
+-                # or last item, or if the previous item was a separator.
+-                if (definition_item[&quot;label&quot;] == self.SEPARATOR and
+-                        (is_first or is_last or previous_label == self.SEPARATOR)):
+-                    index += 1
+-                    continue
+-            
+-                menu_item = nautilus.MenuItem(
+-                    definition_item[&quot;identifier&quot;],
+-                    definition_item[&quot;label&quot;],
+-                    definition_item[&quot;tooltip&quot;],
+-                    definition_item[&quot;icon&quot;]
+-                )
+-                
+-                # Making the seperator insensitive makes sure nobody
+-                # will click it accidently.
+-                if (definition_item[&quot;label&quot;] == self.SEPARATOR): 
+-                  menu_item.set_property(&quot;sensitive&quot;, False)
+-                
+-                # Make sure all the signals are connected.
+-                for signal, value in definition_item[&quot;signals&quot;].items():
+-                    if value[&quot;callback&quot;] != None:
+-                        # FIXME: the adding of arguments need to be done properly
+-                        if &quot;kwargs&quot; in value:
+-                            menu_item.connect(signal, value[&quot;callback&quot;], self.paths, value[&quot;kwargs&quot;])    
+-                        else:
+-                            menu_item.connect(signal, value[&quot;callback&quot;], self.paths)
+-                
+-                menu.append(menu_item)
+-                
+-                # The menu item above has just been added, so we can note that
+-                # we're no longer on the first menu item.  And we'll keep
+-                # track of this item so the next iteration can test if it should
+-                # show a separator or not
+-                is_first = False
+-                previous_label = definition_item[&quot;label&quot;]
+-                
+-                # Since we can't just call set_submenu and run the risk of not
+-                # having any submenu items later (which would result in the 
+-                # menu item not being displayed) we have to check first.
+-                if definition_item.has_key(&quot;submenus&quot;):
+-                    submenu = self.create_menu_from_definition(
+-                        definition_item[&quot;submenus&quot;]
+-                    )
+-                    
+-                    if len(submenu) &gt; 0:
+-                        nautilus_submenu = nautilus.Menu()
+-                        menu_item.set_submenu(nautilus_submenu)
+-                        
+-                        for submenu_item in submenu:
+-                            nautilus_submenu.append_item(submenu_item)
++        # We need a function that can check the file status once the process has completed.
++        def ThreadProc():
++            # First we need to see if the commit process is still running
++            if os.path.exists(&quot;/proc/&quot; + str(pid)):
++                # If so, check its status by reading the status file from /proc
++                f = open(&quot;/proc/%d/status&quot;%pid).readlines()
++                # if it's a zombie process, then we can waitpid() on it to end the process
++                if &quot;zombie&quot; in f[1]:
++                    os.waitpid(pid, 0)
+ 
+-            index += 1
+-            
+-        return menu
+-    
+-    #
+-    # Conditions
+-    #
+-    
+-    def condition_checkout(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                self.path_dict[&quot;is_dir&quot;] and
+-                not self.path_dict[&quot;is_working_copy&quot;])
+-                
+-    def condition_update(self):
+-        return (self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_versioned&quot;] and
+-                not self.path_dict[&quot;is_added&quot;])
+-                        
+-    def condition_commit(self):
+-        if self.path_dict[&quot;is_in_a_or_a_working_copy&quot;]:
+-            if (self.path_dict[&quot;is_added&quot;] or
+-                    self.path_dict[&quot;is_modified&quot;] or
+-                    self.path_dict[&quot;is_deleted&quot;] or
+-                    not self.path_dict[&quot;is_versioned&quot;]):
+-                return True
+-            elif (self.path_dict[&quot;is_dir&quot;]):
+-                return True
+-        return False
+-        
+-    def condition_diff(self):
+-        if self.path_dict[&quot;length&quot;] == 2:
+-            return True
+-        elif (self.path_dict[&quot;length&quot;] == 1 and
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_modified&quot;]):
+-            return True        
+-        return False
+-        
+-    def condition_show_log(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_versioned&quot;] and
+-                not self.path_dict[&quot;is_added&quot;])
+-        
+-    def condition_add(self):
+-        if (self.path_dict[&quot;is_dir&quot;] and
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;]):
+-            return True
+-        elif (not self.path_dict[&quot;is_dir&quot;] and
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                not self.path_dict[&quot;is_versioned&quot;]):
+-            return True
+-        return False
+-        
+-    def condition_add_to_ignore_list(self):
+-        return self.path_dict[&quot;is_versioned&quot;]
+-        
+-    def condition_rename(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_versioned&quot;] and
+-                not self.path_dict[&quot;is_added&quot;])
+-        
+-    def condition_delete(self):
+-        # FIXME: This should be False for the top-level WC folder
+-        return self.path_dict[&quot;is_versioned&quot;]
+-        
+-    def condition_revert(self):
+-        if self.path_dict[&quot;is_in_a_or_a_working_copy&quot;]:
+-            if (self.path_dict[&quot;is_added&quot;] or
+-                    self.path_dict[&quot;is_modified&quot;] or
+-                    self.path_dict[&quot;is_deleted&quot;]):
++                # Return true to get another callback after the next timeout
+                 return True
+             else:
+-                if (self.path_dict[&quot;is_dir&quot;] and
+-                        (self.path_dict[&quot;has_added&quot;] or
+-                        self.path_dict[&quot;has_modified&quot;] or
+-                        self.path_dict[&quot;has_deleted&quot;] or
+-                        self.path_dict[&quot;has_missing&quot;])):
+-                    return True
+-        return False
+-        
+-    def condition_annotate(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                not self.path_dict[&quot;is_dir&quot;] and
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_versioned&quot;] and
+-                not self.path_dict[&quot;is_added&quot;])
+-        
+-    def condition_properties(self):
+-        return (self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_versioned&quot;])
+-
+-    def condition_createpatch(self):
+-        if self.path_dict[&quot;is_in_a_or_a_working_copy&quot;]:
+-            if (self.path_dict[&quot;is_added&quot;] or
+-                    self.path_dict[&quot;is_modified&quot;] or
+-                    self.path_dict[&quot;is_deleted&quot;] or
+-                    not self.path_dict[&quot;is_versioned&quot;]):
+-                return True
+-            elif (self.path_dict[&quot;is_dir&quot;] and
+-                    (self.path_dict[&quot;has_added&quot;] or
+-                    self.path_dict[&quot;has_modified&quot;] or
+-                    self.path_dict[&quot;has_deleted&quot;] or
+-                    self.path_dict[&quot;has_unversioned&quot;] or
+-                    self.path_dict[&quot;has_missing&quot;])):
+-                return True
+-        return False
+-    
+-    def condition_applypatch(self):
+-        if self.path_dict[&quot;is_in_a_or_a_working_copy&quot;]:
+-            return True
+-        return False
+-    
+-    def condition_add_to_ignore_list(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and 
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                not self.path_dict[&quot;is_versioned&quot;])
+-    
+-    def condition_ignore_ext(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and self.path_dict[&quot;is_file&quot;])
++                # The process has completed, so we now want to rescan the 
++                # files we're monitoring to see if their status has changed. We
++                # need to make a copy of monitoredFiles as the rescanning process
++                # will affect it.
++                checkList = copy.copy(self.monitoredFiles)
++                while len(checkList):
++                    checkList.pop().invalidate_extension_info()
++                return False
+ 
+-    def condition_lock(self):
+-        return self.path_dict[&quot;is_versioned&quot;]
++        # Add our callback function on a 1 second timeout
++        gobject.timeout_add(1000, ThreadProc)
+ 
+-    def condition_branch(self):
+-        return self.path_dict[&quot;is_versioned&quot;]
+ 
+-    def condition_relocate(self):
+-        return self.path_dict[&quot;is_versioned&quot;]
+-
+-    def condition_switch(self):
+-        return self.path_dict[&quot;is_versioned&quot;]
+-
+-    def condition_merge(self):
+-        return self.path_dict[&quot;is_versioned&quot;]
+-
+-    def condition_import(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                not self.path_dict[&quot;is_in_a_or_a_working_copy&quot;])
+-
+-    def condition_export(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                not self.path_dict[&quot;is_in_a_or_a_working_copy&quot;])
+-   
+-    def condition_update_to(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                self.path_dict[&quot;is_in_a_or_a_working_copy&quot;])
+-    
+-    def condition_resolve(self):
+-        return (self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_versioned&quot;] and
+-                self.path_dict[&quot;is_conflicted&quot;])
+-            
+-    def condition_create(self):
+-        return (self.path_dict[&quot;length&quot;] == 1 and
+-                not self.path_dict[&quot;is_in_a_or_a_working_copy&quot;])
+-
+-    def condition_unlock(self):
+-        return (self.path_dict[&quot;is_in_a_or_a_working_copy&quot;] and
+-                self.path_dict[&quot;is_versioned&quot;] and
+-                self.path_dict[&quot;has_locked&quot;])
+-
+-    def condition_cleanup(self):
+-        return self.path_dict[&quot;is_versioned&quot;]
+-       
+-    def callback_debug_shell(self, menu_item, paths):
+-        &quot;&quot;&quot;
+-        
+-        Open up an IPython shell which shares the context of the extension.
+-        
+-        See: <A HREF="http://ipython.scipy.org/moin/Cookbook/EmbeddingInGTK">http://ipython.scipy.org/moin/Cookbook/EmbeddingInGTK</A>
+-        
+-        &quot;&quot;&quot;
+-        import gtk
+-        from rabbitvcs.debug.ipython_view import IPythonView
+-        
+-        window = gtk.Window()
+-        window.set_size_request(750,550)
+-        window.set_resizable(True)
+-        window.set_position(gtk.WIN_POS_CENTER)
+-        scrolled_window = gtk.ScrolledWindow()
+-        scrolled_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
+-        ipython_view = IPythonView()
+-        ipython_view.updateNamespace(locals())
+-        ipython_view.set_wrap_mode(gtk.WRAP_CHAR)
+-        ipython_view.show()
+-        scrolled_window.add(ipython_view)
+-        scrolled_window.show()
+-        window.add(scrolled_window)
+-        window.show()
+-    
+-    def callback_refresh_status(self, menu_item, paths):
++
++    #--------------------------------------------------------------------------
++    def OnEditConflicts(self, menuitem, window, files):
++        &quot;&quot;&quot; Edit Conflicts menu handler.
+         &quot;&quot;&quot;
+-        Refreshes an item status, which is actually just invalidate.
++        file = files[0]    
++
++        path = gnomevfs.get_local_path_from_uri(file.get_uri())
++        rabbitvcs.lib.helper.launch_diff_tool(path + &quot;.mine&quot;, path)
++
++    #-------------------------------------------------------------------------- 
++    def OnResolveConflicts(self, menuitem, window, files):
++        &quot;&quot;&quot; Resolve Conflicts menu handler.
+         &quot;&quot;&quot;
+-        
+-        self.callback_debug_invalidate(menu_item, paths)
+-    
+-    def callback_debug_revert(self, menu_item, paths):
+-        client = pysvn.Client()
+-        for path in paths:
+-            client.revert(path, recurse=True)
+-        
+-    def callback_debug_invalidate(self, menu_item, paths):
+-        rabbitvcs_extension = self.rabbitvcs_extension
+-        nautilusVFSFile_table = rabbitvcs_extension.nautilusVFSFile_table
+-        for path in paths:
+-            log.debug(&quot;callback_debug_invalidate() called for %s&quot; % path)
+-            if path in nautilusVFSFile_table:
+-                nautilusVFSFile_table[path].invalidate_extension_info()
+-    
+-    def callback_debug_add_emblem(self, menu_item, paths):
+-        def add_emblem_dialog():
+-            from subprocess import Popen, PIPE
+-            command = [&quot;zenity&quot;, &quot;--entry&quot;, &quot;--title=RabbitVCS&quot;, &quot;--text=Emblem to add:&quot;]
+-            emblem = Popen(command, stdout=PIPE).communicate()[0].replace(&quot;\n&quot;, &quot;&quot;)
+-            
+-            rabbitvcs_extension = self.rabbitvcs_extension
+-            nautilusVFSFile_table = rabbitvcs_extension.nautilusVFSFile_table
+-            for path in paths:
+-                if path in nautilusVFSFile_table:
+-                    nautilusVFSFile_table[path].add_emblem(emblem)
+-            return False
+-            
+-        gobject.idle_add(add_emblem_dialog)
+-    
+-    # End debugging callbacks
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;resolve&quot;, paths)
++        self.RescanFilesAfterProcess(pid)
+ 
+-    def callback_checkout(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;checkout&quot;, paths)
+-        self.rabbitvcs_extension.rescan_after_process_exit(proc, paths)
+-    
+-    def callback_update(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;update&quot;, paths)
+-        self.rabbitvcs_extension.rescan_after_process_exit(proc, paths)
+-
+-    def callback_commit(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;commit&quot;, [&quot;--base-dir=&quot; + self.base_dir] + paths)
+-        self.rabbitvcs_extension.rescan_after_process_exit(proc, paths)
+-
+-    def callback_add(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;add&quot;, paths)
+-        # self.rabbitvcs_extension.rescan_after_process_exit(proc, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #--------------------------------------------------------------------------
++    def OnRevert(self, menuitem, window, files):
++        &quot;&quot;&quot; Revert menu handler.
++        &quot;&quot;&quot;
+ 
+-    def callback_delete(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;delete&quot;, paths)
+-        self.rabbitvcs_extension.rescan_after_process_exit(proc, paths)
+-
+-    def callback_revert(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;revert&quot;, paths)
+-        self.rabbitvcs_extension.rescan_after_process_exit(proc, paths)
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;revert&quot;, paths)
++        self.RescanFilesAfterProcess(pid)
+ 
+-    def callback_diff(self, menu_item, paths):
+-        launch_diff_tool(*paths)
+-    
+-    def callback_show_log(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;log&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #--------------------------------------------------------------------------
++    def OnCheckout(self, menuitem, window, files):
++        &quot;&quot;&quot; Checkout menu handler.
++        &quot;&quot;&quot;
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;checkout&quot;, paths)
+ 
+-    def callback_rename(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;rename&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #--------------------------------------------------------------------------
++    def OnShowDiff(self, menuitem, window, files):
++        &quot;&quot;&quot; Diff menu handler.
++        &quot;&quot;&quot;
+ 
+-    def callback_createpatch(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;createpatch&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
+-    
+-    def callback_applypatch(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;applypatch&quot;, paths)
+-        self.rabbitvcs_extension.rescan_after_process_exit(proc, paths)
+-    
+-    def callback_properties(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;properties&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++        paths = self.get_paths_from_files(files)
++        rabbitvcs.lib.helper.launch_diff_tool(*paths)
+ 
+-    def callback_about(self, menu_item, paths):
+-        launch_ui_window(&quot;about&quot;)
++    #--------------------------------------------------------------------------
++    def OnShowLog(self, menuitem, window, files):
++        &quot;&quot;&quot; Show Log menu handler.
++        &quot;&quot;&quot;
+         
+-    def callback_settings(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;settings&quot;)
+-        self.rabbitvcs_extension.reload_settings(proc)
+-    
+-    def callback_ignore_filename(self, menu_item, paths):
+-        from rabbitvcs.ui.ignore import Ignore
+-        ignore = Ignore(paths[0], basename(paths[0]))
+-        ignore.start()
+-
+-    def callback_ignore_ext(self, menu_item, paths):
+-        from rabbitvcs.ui.ignore import Ignore
+-        ignore = Ignore(paths[0], &quot;*%s&quot; % get_file_extension(paths[0]), glob=True)
+-        ignore.start()
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;log&quot;, paths)
++        self.RescanFilesAfterProcess(pid)
+ 
+-    def callback_lock(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;lock&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #-------------------------------------------------------------------------- 
++    def OnCommit(self, menuitem, window, files):
++        &quot;&quot;&quot; Commit menu handler.
++        &quot;&quot;&quot;
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;commit&quot;, [&quot;--base-dir=&quot; + window.get_data(&quot;base_dir&quot;)] + paths)
++        self.RescanFilesAfterProcess(pid)
+ 
+-    def callback_branch(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;branch&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #--------------------------------------------------------------------------
++    def OnUpdate(self, menuitem, window, files):
++        &quot;&quot;&quot; Update menu handler.
++        &quot;&quot;&quot;
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;update&quot;, paths)
++        self.RescanFilesAfterProcess(pid)
+ 
+-    def callback_switch(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;switch&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #--------------------------------------------------------------------------
++    def OnAdd(self, menuitem, window, files):
++        &quot;&quot;&quot; Add menu handler.
++        &quot;&quot;&quot;
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;add&quot;, paths)
++        self.RescanFilesAfterProcess(pid)
+ 
+-    def callback_merge(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;merge&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #-------------------------------------------------------------------------- 
++    def OnDelete(self, menuitem, window, files):
++        &quot;&quot;&quot; Delete menu handler.
++        &quot;&quot;&quot;
+ 
+-    def callback_import(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;import&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;delete&quot;, paths)
++        self.RescanFilesAfterProcess(pid)
+ 
+-    def callback_export(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;export&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++    #-------------------------------------------------------------------------- 
++    def OnRename(self, menuitem, window, files):
++        &quot;&quot;&quot; Delete menu handler.
++        &quot;&quot;&quot;
+ 
+-    def callback_updateto(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;updateto&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
+-    
+-    def callback_resolve(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;resolve&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++        paths = self.get_paths_from_files(files)
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;rename&quot;, paths)
++        self.RescanFilesAfterProcess(pid)
+         
+-    def callback_annotate(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;annotate&quot;, paths)
++    #--------------------------------------------------------------------------
++    def OnRefreshStatus(self, menuitem, window, files):
++        &quot;&quot;&quot; Refresh status menu handler. Invalidates the status of all of the selected files.
++        &quot;&quot;&quot;
++        for file in files:
++            file.invalidate_extension_info()
++
++    #--------------------------------------------------------------------------
++    def OnProperties(self, menuitem, window, files):
++        &quot;&quot;&quot; Properties menu handler.
++        &quot;&quot;&quot;
++        file = files[0]
++        path = gnomevfs.get_local_path_from_uri(file.get_uri())
++        pid = rabbitvcs.lib.helper.launch_ui_window(&quot;properties&quot;, [path])
++        self.RescanFilesAfterProcess(pid)
++
++    #--------------------------------------------------------------------------
++    def OnMkDiff(self, menuitem, window, files):
++        &quot;&quot;&quot; MkDiff menu handler.
++        &quot;&quot;&quot;
++
++        paths = self.get_paths_from_files(files)	    
++        proc = launch_ui_window(&quot;createpatch&quot;, paths)
+         self.rabbitvcs_extension.execute_after_process_exit(proc)
+ 
+-    def callback_unlock(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;unlock&quot;, paths)
++    #--------------------------------------------------------------------------
++    def OnMkDiffDir(self, menuitem, window, files):
++        &quot;&quot;&quot; MkDiffDir menu handler.
++        &quot;&quot;&quot;
++
++        paths = self.get_paths_from_files(files)
++        proc = launch_ui_window(&quot;createpatch&quot;, paths)
+         self.rabbitvcs_extension.execute_after_process_exit(proc)
++
++    def get_paths_from_files(self, files):
++        paths = []
++        for file in files:
++            paths.append(gnomevfs.get_local_path_from_uri(file.get_uri()))
+         
+-    def callback_create_repository(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;create&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
+-    
+-    def callback_relocate(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;relocate&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++        return paths
+ 
+-    def callback_cleanup(self, menu_item, paths):
+-        proc = launch_ui_window(&quot;cleanup&quot;, paths)
+-        self.rabbitvcs_extension.execute_after_process_exit(proc)
++#============================================================================== 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006713.html">[svn] r7917 - trunk/rpms/rabbitvcs
</A></li>
	<LI>Next message: <A HREF="006715.html">[svn] r7919 - trunk/tools/mrepo
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6714">[ date ]</a>
              <a href="thread.html#6714">[ thread ]</a>
              <a href="subject.html#6714">[ subject ]</a>
              <a href="author.html#6714">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
