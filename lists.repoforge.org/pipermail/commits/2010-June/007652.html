<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r8857 - in /trunk/rpms: aio-stress/ aio-stress/aio-stress.c aio-stress/aio-stress.spec dbench/ dbench/dbench-4.0-datadir.patch dbench/dbench-4.0-destdir.patch dbench/dbench.spec ffsb/ ffsb/ffsb.spec mtr/mtr.spec sysbench/ sysbench/sysbench.spec
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r8857%20-%20in%20/trunk/rpms%3A%20aio-stress/%20aio-stress/aio-stress.c%0A%20aio-stress/aio-stress.spec%20dbench/%20dbench/dbench-4.0-datadir.patch%0A%20dbench/dbench-4.0-destdir.patch%20dbench/dbench.spec%20ffsb/%20ffsb/ffsb.spec%0A%20mtr/mtr.spec%20sysbench/%20sysbench/sysbench.spec&In-Reply-To=%3C201006091300.o59D0VKk018448%40surya.karan.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007651.html">
   <LINK REL="Next"  HREF="007653.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r8857 - in /trunk/rpms: aio-stress/ aio-stress/aio-stress.c aio-stress/aio-stress.spec dbench/ dbench/dbench-4.0-datadir.patch dbench/dbench-4.0-destdir.patch dbench/dbench.spec ffsb/ ffsb/ffsb.spec mtr/mtr.spec sysbench/ sysbench/sysbench.spec</H1>
    <B>Dag Wieers</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r8857%20-%20in%20/trunk/rpms%3A%20aio-stress/%20aio-stress/aio-stress.c%0A%20aio-stress/aio-stress.spec%20dbench/%20dbench/dbench-4.0-datadir.patch%0A%20dbench/dbench-4.0-destdir.patch%20dbench/dbench.spec%20ffsb/%20ffsb/ffsb.spec%0A%20mtr/mtr.spec%20sysbench/%20sysbench/sysbench.spec&In-Reply-To=%3C201006091300.o59D0VKk018448%40surya.karan.org%3E"
       TITLE="[svn] r8857 - in /trunk/rpms: aio-stress/ aio-stress/aio-stress.c aio-stress/aio-stress.spec dbench/ dbench/dbench-4.0-datadir.patch dbench/dbench-4.0-destdir.patch dbench/dbench.spec ffsb/ ffsb/ffsb.spec mtr/mtr.spec sysbench/ sysbench/sysbench.spec">dag at wieers.com
       </A><BR>
    <I>Wed Jun  9 15:00:31 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="007651.html">[svn] r8856 - in /trunk/rpms/lighttpd: lighttpd-1.4.26-defaultconf.patch lighttpd.spec
</A></li>
        <LI>Next message: <A HREF="007653.html">[svn] r8858 - /trunk/rpms/fio/fio.spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7652">[ date ]</a>
              <a href="thread.html#7652">[ thread ]</a>
              <a href="subject.html#7652">[ subject ]</a>
              <a href="author.html#7652">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: Wed Jun  9 14:00:30 2010
New Revision: 8857

URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge?rev=8857&amp;view=rev">http://svn.rpmforge.net/viewvc/rpmforge?rev=8857&amp;view=rev</A>
Log:
Updates

Added:
    trunk/rpms/aio-stress/
    trunk/rpms/aio-stress/aio-stress.c
    trunk/rpms/aio-stress/aio-stress.spec   (with props)
    trunk/rpms/dbench/
    trunk/rpms/dbench/dbench-4.0-datadir.patch
    trunk/rpms/dbench/dbench-4.0-destdir.patch
    trunk/rpms/dbench/dbench.spec   (with props)
    trunk/rpms/ffsb/
    trunk/rpms/ffsb/ffsb.spec   (with props)
    trunk/rpms/sysbench/
    trunk/rpms/sysbench/sysbench.spec   (with props)
Modified:
    trunk/rpms/mtr/mtr.spec

Added: trunk/rpms/aio-stress/aio-stress.c
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/aio-stress/aio-stress.c?rev=8857&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/aio-stress/aio-stress.c?rev=8857&amp;view=markup</A>
==============================================================================
--- trunk/rpms/aio-stress/aio-stress.c (added)
+++ trunk/rpms/aio-stress/aio-stress.c Wed Jun  9 14:00:30 2010
@@ -1,0 +1,1514 @@
+/*
+ * Copyright (c) 2004 SuSE, Inc.  All Rights Reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope that it would be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * 
+ * Further, this software is distributed without any warranty that it is
+ * free of the rightful claim of any third person regarding infringement
+ * or the like.  Any license provided herein, whether implied or
+ * otherwise, applies only to this software file.  Patent licenses, if
+ * any, provided herein do not apply to combinations of this program with
+ * other software, or any other product whatsoever.
+ * 
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ * 
+ * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,
+ * Mountain View, CA  94043, or:
+ * 
+ *
+ * aio-stress
+ *
+ * will open or create each file on the command line, and start a series
+ * of aio to it.  
+ *
+ * aio is done in a rotating loop.  first file1 gets 8 requests, then
+ * file2, then file3 etc.  As each file finishes writing, it is switched
+ * to reads
+ *
+ * io buffers are aligned in case you want to do raw io
+ *
+ * compile with gcc -Wall -laio -lpthread -o aio-stress aio-stress.c
+ *
+ * run aio-stress -h to see the options
+ *
+ * Please mail Chris Mason (<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mason at suse.com</A>) with bug reports or patches
+ */
+#define _FILE_OFFSET_BITS 64
+#define PROG_VERSION &quot;0.21&quot;
+#define NEW_GETEVENTS
+
+#include &lt;stdio.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/time.h&gt;
+#include &lt;libaio.h&gt;
+#include &lt;sys/ipc.h&gt;
+#include &lt;sys/shm.h&gt;
+#include &lt;sys/mman.h&gt;
+#include &lt;string.h&gt;
+#include &lt;pthread.h&gt;
+
+#define IO_FREE 0
+#define IO_PENDING 1
+#define RUN_FOREVER -1
+
+#ifndef O_DIRECT
+#define O_DIRECT         040000 /* direct disk access hint */
+#endif
+
+enum {
+    WRITE,
+    READ,
+    RWRITE,
+    RREAD,
+    LAST_STAGE,
+};
+
+#define USE_MALLOC 0
+#define USE_SHM 1
+#define USE_SHMFS 2
+
+/* 
+ * various globals, these are effectively read only by the time the threads
+ * are started
+ */
+long stages = 0;
+unsigned long page_size_mask;
+int o_direct = 0;
+int o_sync = 0;
+int latency_stats = 0;
+int completion_latency_stats = 0;
+int io_iter = 8;
+int iterations = RUN_FOREVER;
+int max_io_submit = 0;
+long rec_len = 64 * 1024;
+int depth = 64;
+int num_threads = 1;
+int num_contexts = 1;
+off_t context_offset = 2 * 1024 * 1024;
+int fsync_stages = 1;
+int use_shm = 0;
+int shm_id;
+char *unaligned_buffer = NULL;
+char *aligned_buffer = NULL;
+int padded_reclen = 0;
+int stonewall = 1;
+int verify = 0;
+char *verify_buf = NULL;
+int unlink_files = 0;
+
+struct io_unit;
+struct thread_info;
+
+/* pthread mutexes and other globals for keeping the threads in sync */
+pthread_cond_t stage_cond = PTHREAD_COND_INITIALIZER;
+pthread_mutex_t stage_mutex = PTHREAD_MUTEX_INITIALIZER;
+int threads_ending = 0;
+int threads_starting = 0;
+struct timeval global_stage_start_time;
+struct thread_info *global_thread_info;
+
+/* 
+ * latencies during io_submit are measured, these are the 
+ * granularities for deviations 
+ */
+#define DEVIATIONS 6
+int deviations[DEVIATIONS] = { 100, 250, 500, 1000, 5000, 10000 };
+struct io_latency {
+    double max;
+    double min;
+    double total_io;
+    double total_lat;
+    double deviations[DEVIATIONS]; 
+};
+
+/* container for a series of operations to a file */
+struct io_oper {
+    /* already open file descriptor, valid for whatever operation you want */
+    int fd;
+
+    /* starting byte of the operation */
+    off_t start;
+
+    /* ending byte of the operation */
+    off_t end;
+
+    /* size of the read/write buffer */
+    int reclen;
+
+    /* max number of pending requests before a wait is triggered */
+    int depth;
+
+    /* current number of pending requests */
+    int num_pending;
+
+    /* last error, zero if there were none */
+    int last_err;
+
+    /* total number of errors hit. */
+    int num_err;
+
+    /* read,write, random, etc */
+    int rw;
+
+    /* number of ios that will get sent to aio */
+    int total_ios;
+
+    /* number of ios we've already sent */
+    int started_ios;
+
+    /* last offset used in an io operation */
+    off_t last_offset;
+
+    /* stonewalled = 1 when we got cut off before submitting all our ios */
+    int stonewalled;
+
+    /* list management */
+    struct io_oper *next;
+    struct io_oper *prev;
+
+    struct timeval start_time;
+
+    char *file_name;
+};
+
+/* a single io, and all the tracking needed for it */
+struct io_unit {
+    /* note, iocb must go first! */
+    struct iocb iocb;
+
+    /* pointer to parent io operation struct */
+    struct io_oper *io_oper;
+
+    /* aligned buffer */
+    char *buf;
+
+    /* size of the aligned buffer (record size) */
+    int buf_size;
+
+    /* state of this io unit (free, pending, done) */
+    int busy;
+
+    /* result of last operation */
+    long res;
+
+    struct io_unit *next;
+
+    struct timeval io_start_time;		/* time of io_submit */
+};
+
+struct thread_info {
+    io_context_t io_ctx;
+    pthread_t tid;
+
+    /* allocated array of io_unit structs */
+    struct io_unit *ios;
+
+    /* list of io units available for io */
+    struct io_unit *free_ious;
+
+    /* number of io units in the ios array */
+    int num_global_ios;
+
+    /* number of io units in flight */
+    int num_global_pending;
+
+    /* preallocated array of iocb pointers, only used in run_active */
+    struct iocb **iocbs;
+
+    /* preallocated array of events */
+    struct io_event *events;
+
+    /* size of the events array */
+    int num_global_events;
+
+    /* latency stats for io_submit */
+    struct io_latency io_submit_latency;
+
+    /* list of operations still in progress, and of those finished */
+    struct io_oper *active_opers;
+    struct io_oper *finished_opers;
+
+    /* number of files this thread is doing io on */
+    int num_files;
+
+    /* how much io this thread did in the last stage */
+    double stage_mb_trans;
+
+    /* latency completion stats i/o time from io_submit until io_getevents */
+    struct io_latency io_completion_latency;
+};
+
+/*
+ * return seconds between start_tv and stop_tv in double precision
+ */
+static double time_since(struct timeval *start_tv, struct timeval *stop_tv)
+{
+    double sec, usec;
+    double ret;
+    sec = stop_tv-&gt;tv_sec - start_tv-&gt;tv_sec;
+    usec = stop_tv-&gt;tv_usec - start_tv-&gt;tv_usec;
+    if (sec &gt; 0 &amp;&amp; usec &lt; 0) {
+        sec--;
+	usec += 1000000;
+    } 
+    ret = sec + usec / (double)1000000;
+    if (ret &lt; 0)
+        ret = 0;
+    return ret;
+}
+
+/*
+ * return seconds between start_tv and now in double precision
+ */
+static double time_since_now(struct timeval *start_tv)
+{
+    struct timeval stop_time;
+    gettimeofday(&amp;stop_time, NULL);
+    return time_since(start_tv, &amp;stop_time);
+}
+
+/*
+ * Add latency info to latency struct 
+ */
+static void calc_latency(struct timeval *start_tv, struct timeval *stop_tv,
+			struct io_latency *lat)
+{
+    double delta;
+    int i;
+    delta = time_since(start_tv, stop_tv);
+    delta = delta * 1000;
+
+    if (delta &gt; lat-&gt;max)
+    	lat-&gt;max = delta;
+    if (!lat-&gt;min || delta &lt; lat-&gt;min)
+    	lat-&gt;min = delta;
+    lat-&gt;total_io++;
+    lat-&gt;total_lat += delta;
+    for (i = 0 ; i &lt; DEVIATIONS ; i++) {
+        if (delta &lt; deviations[i]) {
+	    lat-&gt;deviations[i]++;
+	    break;
+	}
+    }
+}
+
+static void oper_list_add(struct io_oper *oper, struct io_oper **list)
+{
+    if (!*list) {
+        *list = oper;
+	oper-&gt;prev = oper-&gt;next = oper;
+	return;
+    }
+    oper-&gt;prev = (*list)-&gt;prev;
+    oper-&gt;next = *list;
+    (*list)-&gt;prev-&gt;next = oper;
+    (*list)-&gt;prev = oper;
+    return;
+}
+
+static void oper_list_del(struct io_oper *oper, struct io_oper **list)
+{
+    if ((*list)-&gt;next == (*list)-&gt;prev &amp;&amp; *list == (*list)-&gt;next) {
+        *list = NULL;
+	return;
+    }
+    oper-&gt;prev-&gt;next = oper-&gt;next;
+    oper-&gt;next-&gt;prev = oper-&gt;prev;
+    if (*list == oper)
+        *list = oper-&gt;next;
+}
+
+/* worker func to check error fields in the io unit */
+static int check_finished_io(struct io_unit *io) {
+    int i;
+    if (io-&gt;res != io-&gt;buf_size) {
+
+  		 struct stat s;
+  		 fstat(io-&gt;io_oper-&gt;fd, &amp;s);
+  
+  		 /*
+  		  * If file size is large enough for the read, then this short
+  		  * read is an error.
+  		  */
+  		 if ((io-&gt;io_oper-&gt;rw == READ || io-&gt;io_oper-&gt;rw == RREAD) &amp;&amp;
+  		     s.st_size &gt; (io-&gt;iocb.u.c.offset + io-&gt;res)) {
+  
+  		 		 fprintf(stderr, &quot;io err %lu (%s) op %d, off %Lu size %d\n&quot;,
+  		 		 		 io-&gt;res, strerror(-io-&gt;res), io-&gt;iocb.aio_lio_opcode,
+  		 		 		 io-&gt;iocb.u.c.offset, io-&gt;buf_size);
+  		 		 io-&gt;io_oper-&gt;last_err = io-&gt;res;
+  		 		 io-&gt;io_oper-&gt;num_err++;
+  		 		 return -1;
+  		 }
+    }
+    if (verify &amp;&amp; io-&gt;io_oper-&gt;rw == READ) {
+        if (memcmp(io-&gt;buf, verify_buf, io-&gt;io_oper-&gt;reclen)) {
+	    fprintf(stderr, &quot;verify error, file %s offset %Lu contents (offset:bad:good):\n&quot;, 
+	            io-&gt;io_oper-&gt;file_name, io-&gt;iocb.u.c.offset);
+	    
+	    for (i = 0 ; i &lt; io-&gt;io_oper-&gt;reclen ; i++) {
+	        if (io-&gt;buf[i] != verify_buf[i]) {
+		    fprintf(stderr, &quot;%d:%c:%c &quot;, i, io-&gt;buf[i], verify_buf[i]);
+		}
+	    }
+	    fprintf(stderr, &quot;\n&quot;);
+	}
+
+    }
+    return 0;
+}
+
+/* worker func to check the busy bits and get an io unit ready for use */
+static int grab_iou(struct io_unit *io, struct io_oper *oper) {
+    if (io-&gt;busy == IO_PENDING)
+        return -1;
+
+    io-&gt;busy = IO_PENDING;
+    io-&gt;res = 0;
+    io-&gt;io_oper = oper;
+    return 0;
+}
+
+char *stage_name(int rw) {
+    switch(rw) {
+    case WRITE:
+        return &quot;write&quot;;
+    case READ:
+        return &quot;read&quot;;
+    case RWRITE:
+        return &quot;random write&quot;;
+    case RREAD:
+        return &quot;random read&quot;;
+    }
+    return &quot;unknown&quot;;
+}
+
+static inline double oper_mb_trans(struct io_oper *oper) {
+    return ((double)oper-&gt;started_ios * (double)oper-&gt;reclen) /
+                (double)(1024 * 1024);
+}
+
+static void print_time(struct io_oper *oper) {
+    double runtime;
+    double tput;
+    double mb;
+
+    runtime = time_since_now(&amp;oper-&gt;start_time); 
+    mb = oper_mb_trans(oper);
+    tput = mb / runtime;
+    fprintf(stderr, &quot;%s on %s (%.2f MB/s) %.2f MB in %.2fs\n&quot;, 
+	    stage_name(oper-&gt;rw), oper-&gt;file_name, tput, mb, runtime);
+}
+
+static void print_lat(char *str, struct io_latency *lat) {
+    double avg = lat-&gt;total_lat / lat-&gt;total_io;
+    int i;
+    double total_counted = 0;
+    fprintf(stderr, &quot;%s min %.2f avg %.2f max %.2f\n\t&quot;, 
+            str, lat-&gt;min, avg, lat-&gt;max);
+
+    for (i = 0 ; i &lt; DEVIATIONS ; i++) {
+	fprintf(stderr, &quot; %.0f &lt; %d&quot;, lat-&gt;deviations[i], deviations[i]);
+	total_counted += lat-&gt;deviations[i];
+    }
+    if (total_counted &amp;&amp; lat-&gt;total_io - total_counted)
+        fprintf(stderr, &quot; &lt; %.0f&quot;, lat-&gt;total_io - total_counted);
+    fprintf(stderr, &quot;\n&quot;);
+    memset(lat, 0, sizeof(*lat));
+}
+
+static void print_latency(struct thread_info *t)
+{
+    struct io_latency *lat = &amp;t-&gt;io_submit_latency;
+    print_lat(&quot;latency&quot;, lat);
+}
+
+static void print_completion_latency(struct thread_info *t)
+{
+    struct io_latency *lat = &amp;t-&gt;io_completion_latency;
+    print_lat(&quot;completion latency&quot;, lat);
+}
+
+/*
+ * updates the fields in the io operation struct that belongs to this
+ * io unit, and make the io unit reusable again
+ */
+void finish_io(struct thread_info *t, struct io_unit *io, long result,
+		struct timeval *tv_now) {
+    struct io_oper *oper = io-&gt;io_oper;
+
+    calc_latency(&amp;io-&gt;io_start_time, tv_now, &amp;t-&gt;io_completion_latency);
+    io-&gt;res = result;
+    io-&gt;busy = IO_FREE;
+    io-&gt;next = t-&gt;free_ious;
+    t-&gt;free_ious = io;
+    oper-&gt;num_pending--;
+    t-&gt;num_global_pending--;
+    check_finished_io(io);
+    if (oper-&gt;num_pending == 0 &amp;&amp; 
+       (oper-&gt;started_ios == oper-&gt;total_ios || oper-&gt;stonewalled)) 
+    {
+        print_time(oper);
+    } 
+}
+
+int read_some_events(struct thread_info *t) {
+    struct io_unit *event_io;
+    struct io_event *event;
+    int nr;
+    int i; 
+    int min_nr = io_iter;
+    struct timeval stop_time;
+
+    if (t-&gt;num_global_pending &lt; io_iter)
+        min_nr = t-&gt;num_global_pending;
+
+#ifdef NEW_GETEVENTS
+    nr = io_getevents(t-&gt;io_ctx, min_nr, t-&gt;num_global_events, t-&gt;events,NULL);
+#else
+    nr = io_getevents(t-&gt;io_ctx, t-&gt;num_global_events, t-&gt;events, NULL);
+#endif
+    if (nr &lt;= 0)
+        return nr;
+
+    gettimeofday(&amp;stop_time, NULL);
+    for (i = 0 ; i &lt; nr ; i++) {
+	event = t-&gt;events + i;
+	event_io = (struct io_unit *)((unsigned long)event-&gt;obj); 
+	finish_io(t, event_io, event-&gt;res, &amp;stop_time);
+    }
+    return nr;
+}
+
+/* 
+ * finds a free io unit, waiting for pending requests if required.  returns
+ * null if none could be found
+ */
+static struct io_unit *find_iou(struct thread_info *t, struct io_oper *oper)
+{
+    struct io_unit *event_io;
+    int nr;
+
+retry:
+    if (t-&gt;free_ious) {
+        event_io = t-&gt;free_ious;
+	t-&gt;free_ious = t-&gt;free_ious-&gt;next;
+	if (grab_iou(event_io, oper)) {
+	    fprintf(stderr, &quot;io unit on free list but not free\n&quot;);
+	    abort();
+	}
+	return event_io;
+    }
+    nr = read_some_events(t);
+    if (nr &gt; 0)
+    	goto retry;
+    else
+    	fprintf(stderr, &quot;no free ious after read_some_events\n&quot;);
+    return NULL;
+}
+
+/*
+ * wait for all pending requests for this io operation to finish
+ */
+static int io_oper_wait(struct thread_info *t, struct io_oper *oper) {
+    struct io_event event;
+    struct io_unit *event_io;
+
+    if (oper == NULL) {
+        return 0;
+    }
+
+    if (oper-&gt;num_pending == 0)
+        goto done;
+
+    /* this func is not speed sensitive, no need to go wild reading
+     * more than one event at a time
+     */
+#ifdef NEW_GETEVENTS
+    while(io_getevents(t-&gt;io_ctx, 1, 1, &amp;event, NULL) &gt; 0) {
+#else
+    while(io_getevents(t-&gt;io_ctx, 1, &amp;event, NULL) &gt; 0) {
+#endif
+	struct timeval tv_now;
+        event_io = (struct io_unit *)((unsigned long)event.obj); 
+
+	gettimeofday(&amp;tv_now, NULL);
+	finish_io(t, event_io, event.res, &amp;tv_now);
+
+	if (oper-&gt;num_pending == 0)
+	    break;
+    }
+done:
+    if (oper-&gt;num_err) {
+        fprintf(stderr, &quot;%u errors on oper, last %u\n&quot;, 
+	        oper-&gt;num_err, oper-&gt;last_err);
+    }
+    return 0;
+}
+
+off_t random_byte_offset(struct io_oper *oper) {
+    off_t num;
+    off_t rand_byte = oper-&gt;start;
+    off_t range;
+    off_t offset = 1;
+
+    range = (oper-&gt;end - oper-&gt;start) / (1024 * 1024);
+    if ((page_size_mask+1) &gt; (1024 * 1024))
+        offset = (page_size_mask+1) / (1024 * 1024);
+    if (range &lt; offset)
+        range = 0;
+    else
+        range -= offset;
+
+    /* find a random mb offset */
+    num = 1 + (int)((double)range * rand() / (RAND_MAX + 1.0 ));
+    rand_byte += num * 1024 * 1024;
+    
+    /* find a random byte offset */
+    num = 1 + (int)((double)(1024 * 1024) * rand() / (RAND_MAX + 1.0));
+
+    /* page align */
+    num = (num + page_size_mask) &amp; ~page_size_mask;
+    rand_byte += num;
+
+    if (rand_byte + oper-&gt;reclen &gt; oper-&gt;end) {
+	rand_byte -= oper-&gt;reclen;
+    }
+    return rand_byte;
+}
+
+/* 
+ * build an aio iocb for an operation, based on oper-&gt;rw and the
+ * last offset used.  This finds the struct io_unit that will be attached
+ * to the iocb, and things are ready for submission to aio after this
+ * is called.
+ *
+ * returns null on error
+ */
+static struct io_unit *build_iocb(struct thread_info *t, struct io_oper *oper)
+{
+    struct io_unit *io;
+    off_t rand_byte;
+
+    io = find_iou(t, oper);
+    if (!io) {
+        fprintf(stderr, &quot;unable to find io unit\n&quot;);
+	return NULL;
+    }
+
+    switch(oper-&gt;rw) {
+    case WRITE:
+        io_prep_pwrite(&amp;io-&gt;iocb,oper-&gt;fd, io-&gt;buf, oper-&gt;reclen, 
+	               oper-&gt;last_offset);
+	oper-&gt;last_offset += oper-&gt;reclen;
+	break;
+    case READ:
+        io_prep_pread(&amp;io-&gt;iocb,oper-&gt;fd, io-&gt;buf, oper-&gt;reclen, 
+	              oper-&gt;last_offset);
+	oper-&gt;last_offset += oper-&gt;reclen;
+	break;
+    case RREAD:
+	rand_byte = random_byte_offset(oper);
+	oper-&gt;last_offset = rand_byte;
+        io_prep_pread(&amp;io-&gt;iocb,oper-&gt;fd, io-&gt;buf, oper-&gt;reclen, 
+	              rand_byte);
+        break;
+    case RWRITE:
+	rand_byte = random_byte_offset(oper);
+	oper-&gt;last_offset = rand_byte;
+        io_prep_pwrite(&amp;io-&gt;iocb,oper-&gt;fd, io-&gt;buf, oper-&gt;reclen, 
+	              rand_byte);
+        
+        break;
+    }
+
+    return io;
+}
+
+/* 
+ * wait for any pending requests, and then free all ram associated with
+ * an operation.  returns the last error the operation hit (zero means none)
+ */
+static int
+finish_oper(struct thread_info *t, struct io_oper *oper)
+{
+    unsigned long last_err;
+
+    io_oper_wait(t, oper);
+    last_err = oper-&gt;last_err;
+    if (oper-&gt;num_pending &gt; 0) {
+        fprintf(stderr, &quot;oper num_pending is %d\n&quot;, oper-&gt;num_pending);
+    }
+    close(oper-&gt;fd);
+    free(oper);
+    return last_err;
+}
+
+/* 
+ * allocates an io operation and fills in all the fields.  returns
+ * null on error
+ */
+static struct io_oper * 
+create_oper(int fd, int rw, off_t start, off_t end, int reclen, int depth,
+            int iter, char *file_name)
+{
+    struct io_oper *oper;
+
+    oper = malloc (sizeof(*oper));
+    if (!oper) {
+	fprintf(stderr, &quot;unable to allocate io oper\n&quot;);
+	return NULL;
+    }
+    memset(oper, 0, sizeof(*oper));
+
+    oper-&gt;depth = depth;
+    oper-&gt;start = start;
+    oper-&gt;end = end;
+    oper-&gt;last_offset = oper-&gt;start;
+    oper-&gt;fd = fd;
+    oper-&gt;reclen = reclen;
+    oper-&gt;rw = rw;
+    oper-&gt;total_ios = (oper-&gt;end - oper-&gt;start) / oper-&gt;reclen;
+    oper-&gt;file_name = file_name;
+
+    return oper;
+}
+
+/*
+ * does setup on num_ios worth of iocbs, but does not actually
+ * start any io
+ */
+int build_oper(struct thread_info *t, struct io_oper *oper, int num_ios, 
+               struct iocb **my_iocbs) 
+{
+    int i;
+    struct io_unit *io;
+
+    if (oper-&gt;started_ios == 0)
+	gettimeofday(&amp;oper-&gt;start_time, NULL);
+
+    if (num_ios == 0)
+        num_ios = oper-&gt;total_ios;
+
+    if ((oper-&gt;started_ios + num_ios) &gt; oper-&gt;total_ios)
+        num_ios = oper-&gt;total_ios - oper-&gt;started_ios;   
+
+    for( i = 0 ; i &lt; num_ios ; i++) {
+	io = build_iocb(t, oper);
+	if (!io) {
+	    return -1;    
+	}
+	my_iocbs[i] = &amp;io-&gt;iocb;
+    }
+    return num_ios;
+}
+
+/*
+ * runs through the iocbs in the array provided and updates
+ * counters in the associated oper struct
+ */
+static void update_iou_counters(struct iocb **my_iocbs, int nr,
+	struct timeval *tv_now) 
+{
+    struct io_unit *io;
+    int i;
+    for (i = 0 ; i &lt; nr ; i++) {
+	io = (struct io_unit *)(my_iocbs[i]);
+	io-&gt;io_oper-&gt;num_pending++;
+	io-&gt;io_oper-&gt;started_ios++;
+	io-&gt;io_start_time = *tv_now;	/* set time of io_submit */
+    }
+}
+
+/* starts some io for a given file, returns zero if all went well */
+int run_built(struct thread_info *t, int num_ios, struct iocb **my_iocbs) 
+{
+    int ret;
+    struct timeval start_time;
+    struct timeval stop_time;
+
+resubmit:
+    gettimeofday(&amp;start_time, NULL);
+    ret = io_submit(t-&gt;io_ctx, num_ios, my_iocbs);
+    gettimeofday(&amp;stop_time, NULL);
+    calc_latency(&amp;start_time, &amp;stop_time, &amp;t-&gt;io_submit_latency);
+
+    if (ret != num_ios) {
+	/* some ios got through */
+	if (ret &gt; 0) {
+	    update_iou_counters(my_iocbs, ret, &amp;stop_time);
+	    my_iocbs += ret;
+	    t-&gt;num_global_pending += ret;
+	    num_ios -= ret;
+	}
+	/* 
+	 * we've used all the requests allocated in aio_init, wait and
+	 * retry
+	 */
+	if (ret &gt; 0 || ret == -EAGAIN) {
+	    int old_ret = ret;
+	    if ((ret = read_some_events(t) &gt; 0)) {
+		goto resubmit;
+	    } else {
+	    	fprintf(stderr, &quot;ret was %d and now is %d\n&quot;, ret, old_ret);
+		abort();
+	    }
+	}
+
+	fprintf(stderr, &quot;ret %d (%s) on io_submit\n&quot;, ret, strerror(-ret));
+	return -1;
+    }
+    update_iou_counters(my_iocbs, ret, &amp;stop_time);
+    t-&gt;num_global_pending += ret;
+    return 0;
+}
+
+/* 
+ * changes oper-&gt;rw to the next in a command sequence, or returns zero
+ * to say this operation is really, completely done for
+ */
+static int restart_oper(struct io_oper *oper) {
+    int new_rw  = 0;
+    if (oper-&gt;last_err)
+        return 0;
+
+    /* this switch falls through */
+    switch(oper-&gt;rw) {
+    case WRITE:
+	if (stages &amp; (1 &lt;&lt; READ))
+	    new_rw = READ;
+    case READ:
+	if (!new_rw &amp;&amp; stages &amp; (1 &lt;&lt; RWRITE))
+	    new_rw = RWRITE;
+    case RWRITE:
+	if (!new_rw &amp;&amp; stages &amp; (1 &lt;&lt; RREAD))
+	    new_rw = RREAD;
+    }
+
+    if (new_rw) {
+	oper-&gt;started_ios = 0;
+	oper-&gt;last_offset = oper-&gt;start;
+	oper-&gt;stonewalled = 0;
+
+	/* 
+	 * we're restarting an operation with pending requests, so the
+	 * timing info won't be printed by finish_io.  Printing it here
+	 */
+	if (oper-&gt;num_pending)
+	    print_time(oper);
+
+	oper-&gt;rw = new_rw;
+	return 1;
+    } 
+    return 0;
+}
+
+static int oper_runnable(struct io_oper *oper) {
+    struct stat buf;
+    int ret;
+
+    /* first context is always runnable, if started_ios &gt; 0, no need to
+     * redo the calculations
+     */
+    if (oper-&gt;started_ios || oper-&gt;start == 0)
+        return 1;
+    /*
+     * only the sequential phases force delays in starting */
+    if (oper-&gt;rw &gt;= RWRITE)
+        return 1;
+    ret = fstat(oper-&gt;fd, &amp;buf);
+    if (ret &lt; 0) {
+        perror(&quot;fstat&quot;);
+	exit(1);
+    }
+    if (S_ISREG(buf.st_mode) &amp;&amp; buf.st_size &lt; oper-&gt;start)
+        return 0;
+    return 1;
+}
+
+/*
+ * runs through all the io operations on the active list, and starts
+ * a chunk of io on each.  If any io operations are completely finished,
+ * it either switches them to the next stage or puts them on the 
+ * finished list.
+ *
+ * this function stops after max_io_submit iocbs are sent down the 
+ * pipe, even if it has not yet touched all the operations on the 
+ * active list.  Any operations that have finished are moved onto
+ * the finished_opers list.
+ */
+static int run_active_list(struct thread_info *t,
+			 int io_iter,
+			 int max_io_submit)
+{
+    struct io_oper *oper;
+    struct io_oper *built_opers = NULL;
+    struct iocb **my_iocbs = t-&gt;iocbs;
+    int ret = 0;
+    int num_built = 0;
+
+    oper = t-&gt;active_opers;
+    while(oper) {
+	if (!oper_runnable(oper)) {
+	    oper = oper-&gt;next;
+	    if (oper == t-&gt;active_opers)
+	        break;
+	    continue;
+	}
+	ret = build_oper(t, oper, io_iter, my_iocbs);
+	if (ret &gt;= 0) {
+	    my_iocbs += ret;
+	    num_built += ret;
+	    oper_list_del(oper, &amp;t-&gt;active_opers);
+	    oper_list_add(oper, &amp;built_opers);
+	    oper = t-&gt;active_opers;
+	    if (num_built + io_iter &gt; max_io_submit)
+	        break;
+	} else
+	    break;
+    }
+    if (num_built) {
+	ret = run_built(t, num_built, t-&gt;iocbs);
+	if (ret &lt; 0) {
+	    fprintf(stderr, &quot;error %d on run_built\n&quot;, ret);
+	    exit(1);
+	}
+	while(built_opers) {
+	    oper = built_opers;
+	    oper_list_del(oper, &amp;built_opers);
+	    oper_list_add(oper, &amp;t-&gt;active_opers);
+	    if (oper-&gt;started_ios == oper-&gt;total_ios) {
+		oper_list_del(oper, &amp;t-&gt;active_opers);
+		oper_list_add(oper, &amp;t-&gt;finished_opers);
+	    }
+	}
+    }
+    return 0;
+}
+
+void drop_shm() {
+    int ret;
+    struct shmid_ds ds;
+    if (use_shm != USE_SHM)
+        return;
+
+    ret = shmctl(shm_id, IPC_RMID, &amp;ds);
+    if (ret) {
+        perror(&quot;shmctl IPC_RMID&quot;);
+    }
+}
+
+void aio_setup(io_context_t *io_ctx, int n)
+{
+    int res = io_queue_init(n, io_ctx);
+    if (res != 0) {
+	fprintf(stderr, &quot;io_queue_setup(%d) returned %d (%s)\n&quot;,
+		n, res, strerror(-res));
+	exit(3);
+    }
+}
+
+/*
+ * allocate io operation and event arrays for a given thread
+ */
+int setup_ious(struct thread_info *t, 
+              int num_files, int depth, 
+	      int reclen, int max_io_submit) {
+    int i;
+    size_t bytes = num_files * depth * sizeof(*t-&gt;ios);
+
+    t-&gt;ios = malloc(bytes);
+    if (!t-&gt;ios) {
+	fprintf(stderr, &quot;unable to allocate io units\n&quot;);
+	return -1;
+    }
+    memset(t-&gt;ios, 0, bytes);
+
+    for (i = 0 ; i &lt; depth * num_files; i++) {
+	t-&gt;ios[i].buf = aligned_buffer;
+	aligned_buffer += padded_reclen;
+	t-&gt;ios[i].buf_size = reclen;
+	if (verify)
+	    memset(t-&gt;ios[i].buf, 'b', reclen);
+	else
+	    memset(t-&gt;ios[i].buf, 0, reclen);
+	t-&gt;ios[i].next = t-&gt;free_ious;
+	t-&gt;free_ious = t-&gt;ios + i;
+    }
+    if (verify) {
+        verify_buf = aligned_buffer;
+        memset(verify_buf, 'b', reclen);
+    }
+
+    t-&gt;iocbs = malloc(sizeof(struct iocb *) * max_io_submit);
+    if (!t-&gt;iocbs) {
+        fprintf(stderr, &quot;unable to allocate iocbs\n&quot;);
+	goto free_buffers;
+    }
+
+    memset(t-&gt;iocbs, 0, max_io_submit * sizeof(struct iocb *));
+
+    t-&gt;events = malloc(sizeof(struct io_event) * depth * num_files);
+    if (!t-&gt;events) {
+        fprintf(stderr, &quot;unable to allocate ram for events\n&quot;);
+	goto free_buffers;
+    }
+    memset(t-&gt;events, 0, num_files * sizeof(struct io_event)*depth);
+
+    t-&gt;num_global_ios = num_files * depth;
+    t-&gt;num_global_events = t-&gt;num_global_ios;
+    return 0;
+
+free_buffers:
+    if (t-&gt;ios)
+        free(t-&gt;ios);
+    if (t-&gt;iocbs)
+        free(t-&gt;iocbs);  
+    if (t-&gt;events)
+        free(t-&gt;events);
+    return -1;
+}
+
+/*
+ * The buffers used for file data are allocated as a single big
+ * malloc, and then each thread and operation takes a piece and uses
+ * that for file data.  This lets us do a large shm or bigpages alloc
+ * and without trying to find a special place in each thread to map the
+ * buffers to
+ */
+int setup_shared_mem(int num_threads, int num_files, int depth, 
+                     int reclen, int max_io_submit) 
+{
+    char *p = NULL;
+    size_t total_ram;
+    
+    padded_reclen = (reclen + page_size_mask) / (page_size_mask+1);
+    padded_reclen = padded_reclen * (page_size_mask+1);
+    total_ram = num_files * depth * padded_reclen + num_threads;
+    if (verify)
+    	total_ram += padded_reclen;
+
+    if (use_shm == USE_MALLOC) {
+	p = malloc(total_ram + page_size_mask);
+    } else if (use_shm == USE_SHM) {
+        shm_id = shmget(IPC_PRIVATE, total_ram, IPC_CREAT | 0700);
+	if (shm_id &lt; 0) {
+	    perror(&quot;shmget&quot;);
+	    drop_shm();
+	    goto free_buffers;
+	}
+	p = shmat(shm_id, (char *)0x50000000, 0);
+        if ((long)p == -1) {
+	    perror(&quot;shmat&quot;);
+	    goto free_buffers;
+	}
+	/* won't really be dropped until we shmdt */
+	drop_shm();
+    } else if (use_shm == USE_SHMFS) {
+        char mmap_name[16]; /* /dev/shm/ + null + XXXXXX */    
+	int fd;
+
+	strcpy(mmap_name, &quot;/dev/shm/XXXXXX&quot;);
+	fd = mkstemp(mmap_name);
+        if (fd &lt; 0) {
+	    perror(&quot;mkstemp&quot;);
+	    goto free_buffers;
+	}
+	unlink(mmap_name);
+	ftruncate(fd, total_ram);
+	shm_id = fd;
+	p = mmap((char *)0x50000000, total_ram,
+	         PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+
+        if (p == MAP_FAILED) {
+	    perror(&quot;mmap&quot;);
+	    goto free_buffers;
+	}
+    }
+    if (!p) {
+        fprintf(stderr, &quot;unable to allocate buffers\n&quot;);
+	goto free_buffers;
+    }
+    unaligned_buffer = p;
+    p = (char*)((intptr_t) (p + page_size_mask) &amp; ~page_size_mask);
+    aligned_buffer = p;
+    return 0;
+
+free_buffers:
+    drop_shm();
+    if (unaligned_buffer)
+        free(unaligned_buffer);
+    return -1;
+}
+
+/*
+ * runs through all the thread_info structs and calculates a combined
+ * throughput
+ */
+void global_thread_throughput(struct thread_info *t, char *this_stage) {
+    int i;
+    double runtime = time_since_now(&amp;global_stage_start_time);
+    double total_mb = 0;
+    double min_trans = 0;
+
+    for (i = 0 ; i &lt; num_threads ; i++) {
+        total_mb += global_thread_info[i].stage_mb_trans;
+	if (!min_trans || t-&gt;stage_mb_trans &lt; min_trans)
+	    min_trans = t-&gt;stage_mb_trans;
+    }
+    if (total_mb) {
+	fprintf(stderr, &quot;%s throughput (%.2f MB/s) &quot;, this_stage,
+	        total_mb / runtime);
+	fprintf(stderr, &quot;%.2f MB in %.2fs&quot;, total_mb, runtime);
+        if (stonewall)
+	    fprintf(stderr, &quot; min transfer %.2fMB&quot;, min_trans);
+        fprintf(stderr, &quot;\n&quot;);
+    }
+}
+
+
+/* this is the meat of the state machine.  There is a list of
+ * active operations structs, and as each one finishes the required
+ * io it is moved to a list of finished operations.  Once they have
+ * all finished whatever stage they were in, they are given the chance
+ * to restart and pick a different stage (read/write/random read etc)
+ *
+ * various timings are printed in between the stages, along with
+ * thread synchronization if there are more than one threads.
+ */
+int worker(struct thread_info *t)
+{
+    struct io_oper *oper;
+    char *this_stage = NULL;
+    struct timeval stage_time;
+    int status = 0;
+    int iteration = 0;
+    int cnt;
+
+    aio_setup(&amp;t-&gt;io_ctx, 512);
+
+restart:
+    if (num_threads &gt; 1) {
+        pthread_mutex_lock(&amp;stage_mutex);
+	threads_starting++;
+	if (threads_starting == num_threads) {
+	    threads_ending = 0;
+	    gettimeofday(&amp;global_stage_start_time, NULL);
+	    pthread_cond_broadcast(&amp;stage_cond);
+	}
+	while (threads_starting != num_threads)
+	    pthread_cond_wait(&amp;stage_cond, &amp;stage_mutex);
+        pthread_mutex_unlock(&amp;stage_mutex);
+    }
+    if (t-&gt;active_opers) {
+        this_stage = stage_name(t-&gt;active_opers-&gt;rw);
+	gettimeofday(&amp;stage_time, NULL);
+	t-&gt;stage_mb_trans = 0;
+    }
+
+    cnt = 0;
+    /* first we send everything through aio */
+    while(t-&gt;active_opers &amp;&amp; (cnt &lt; iterations || iterations == RUN_FOREVER)) {
+	if (stonewall &amp;&amp; threads_ending) {
+	    oper = t-&gt;active_opers;
+	    oper-&gt;stonewalled = 1;
+	    oper_list_del(oper, &amp;t-&gt;active_opers);
+	    oper_list_add(oper, &amp;t-&gt;finished_opers);
+	} else {
+	    run_active_list(t, io_iter,  max_io_submit);
+        }
+	cnt++;
+    }
+    if (latency_stats)
+        print_latency(t);
+
+    if (completion_latency_stats)
+	print_completion_latency(t);
+
+    /* then we wait for all the operations to finish */
+    oper = t-&gt;finished_opers;
+    do {
+	if (!oper)
+		break;
+	io_oper_wait(t, oper);
+	oper = oper-&gt;next;
+    } while(oper != t-&gt;finished_opers);
+
+    /* then we do an fsync to get the timing for any future operations
+     * right, and check to see if any of these need to get restarted
+     */
+    oper = t-&gt;finished_opers;
+    while(oper) {
+	if (fsync_stages)
+            fsync(oper-&gt;fd);
+	t-&gt;stage_mb_trans += oper_mb_trans(oper);
+	if (restart_oper(oper)) {
+	    oper_list_del(oper, &amp;t-&gt;finished_opers);
+	    oper_list_add(oper, &amp;t-&gt;active_opers);
+	    oper = t-&gt;finished_opers;
+	    continue;
+	}
+	oper = oper-&gt;next;
+	if (oper == t-&gt;finished_opers)
+	    break;
+    } 
+
+    if (t-&gt;stage_mb_trans &amp;&amp; t-&gt;num_files &gt; 0) {
+        double seconds = time_since_now(&amp;stage_time);
+	fprintf(stderr, &quot;thread %d %s totals (%.2f MB/s) %.2f MB in %.2fs\n&quot;, 
+	        t - global_thread_info, this_stage, t-&gt;stage_mb_trans/seconds, 
+		t-&gt;stage_mb_trans, seconds);
+    }
+
+    if (num_threads &gt; 1) {
+	pthread_mutex_lock(&amp;stage_mutex);
+	threads_ending++;
+	if (threads_ending == num_threads) {
+	    threads_starting = 0;
+	    pthread_cond_broadcast(&amp;stage_cond);
+	    global_thread_throughput(t, this_stage);
+	}
+	while(threads_ending != num_threads)
+	    pthread_cond_wait(&amp;stage_cond, &amp;stage_mutex);
+	pthread_mutex_unlock(&amp;stage_mutex);
+    }
+    
+    /* someone got restarted, go back to the beginning */
+    if (t-&gt;active_opers &amp;&amp; (cnt &lt; iterations || iterations == RUN_FOREVER)) {
+	iteration++;
+        goto restart;
+    }
+
+    /* finally, free all the ram */
+    while(t-&gt;finished_opers) {
+	oper = t-&gt;finished_opers;
+	oper_list_del(oper, &amp;t-&gt;finished_opers);
+	status = finish_oper(t, oper);
+    }
+
+    if (t-&gt;num_global_pending) {
+        fprintf(stderr, &quot;global num pending is %d\n&quot;, t-&gt;num_global_pending);
+    }
+    io_queue_release(t-&gt;io_ctx);
+    
+    return status;
+}
+
+typedef void * (*start_routine)(void *);
+int run_workers(struct thread_info *t, int num_threads)
+{
+    int ret;
+    int thread_ret;
+    int i;
+
+    for(i = 0 ; i &lt; num_threads ; i++) {
+        ret = pthread_create(&amp;t[i].tid, NULL, (start_routine)worker, t + i);
+	if (ret) {
+	    perror(&quot;pthread_create&quot;);
+	    exit(1);
+	}
+    }
+    for(i = 0 ; i &lt; num_threads ; i++) {
+        ret = pthread_join(t[i].tid, (void *)&amp;thread_ret);
+        if (ret) {
+	    perror(&quot;pthread_join&quot;);
+	    exit(1);
+	}
+    }
+    return 0;
+}
+
+off_t parse_size(char *size_arg, off_t mult) {
+    char c;
+    int num;
+    off_t ret;
+    c = size_arg[strlen(size_arg) - 1];
+    if (c &gt; '9') {
+        size_arg[strlen(size_arg) - 1] = '\0';
+    }
+    num = atoi(size_arg);
+    switch(c) {
+    case 'g':
+    case 'G':
+        mult = 1024 * 1024 * 1024;
+	break;
+    case 'm':
+    case 'M':
+        mult = 1024 * 1024;
+	break;
+    case 'k':
+    case 'K':
+        mult = 1024;
+	break;
+    case 'b':
+    case 'B':
+        mult = 1;
+	break;
+    }
+    ret = mult * num;
+    return ret;
+}
+
+void print_usage(void) {
+    printf(&quot;usage: aio-stress [-s size] [-r size] [-a size] [-d num] [-b num]\n&quot;);
+    printf(&quot;                  [-i num] [-t num] [-c num] [-C size] [-nxhOS ]\n&quot;);
+    printf(&quot;                  file1 [file2 ...]\n&quot;);
+    printf(&quot;\t-a size in KB at which to align buffers\n&quot;);
+    printf(&quot;\t-b max number of iocbs to give io_submit at once\n&quot;);
+    printf(&quot;\t-c number of io contexts per file\n&quot;);
+    printf(&quot;\t-C offset between contexts, default 2MB\n&quot;);
+    printf(&quot;\t-s size in MB of the test file(s), default 1024MB\n&quot;);
+    printf(&quot;\t-r record size in KB used for each io, default 64KB\n&quot;);
+    printf(&quot;\t-d number of pending aio requests for each file, default 64\n&quot;);
+    printf(&quot;\t-i number of ios per file sent before switching\n\t   to the next file, default 8\n&quot;);
+    printf(&quot;\t-I total number of ayncs IOs the program will run, default is run until Cntl-C\n&quot;);
+    printf(&quot;\t-O Use O_DIRECT (not available in 2.4 kernels),\n&quot;);
+    printf(&quot;\t-S Use O_SYNC for writes\n&quot;);
+    printf(&quot;\t-o add an operation to the list: write=0, read=1,\n&quot;); 
+    printf(&quot;\t   random write=2, random read=3.\n&quot;);
+    printf(&quot;\t   repeat -o to specify multiple ops: -o 0 -o 1 etc.\n&quot;);
+    printf(&quot;\t-m shm use ipc shared memory for io buffers instead of malloc\n&quot;);
+    printf(&quot;\t-m shmfs mmap a file in /dev/shm for io buffers\n&quot;);
+    printf(&quot;\t-n no fsyncs between write stage and read stage\n&quot;);
+    printf(&quot;\t-l print io_submit latencies after each stage\n&quot;);
+    printf(&quot;\t-L print io completion latencies after each stage\n&quot;);
+    printf(&quot;\t-t number of threads to run\n&quot;);
+    printf(&quot;\t-u unlink files after completion\n&quot;);
+    printf(&quot;\t-v verification of bytes written\n&quot;);
+    printf(&quot;\t-x turn off thread stonewalling\n&quot;);
+    printf(&quot;\t-h this message\n&quot;);
+    printf(&quot;\n\t   the size options (-a -s and -r) allow modifiers -s 400{k,m,g}\n&quot;);
+    printf(&quot;\t   translate to 400KB, 400MB and 400GB\n&quot;);
+    printf(&quot;version %s\n&quot;, PROG_VERSION);
+}
+
+int main(int ac, char **av) 
+{
+    int rwfd;
+    int i;
+    int j;
+    int c;
+
+    off_t file_size = 1 * 1024 * 1024 * 1024;
+    int first_stage = WRITE;
+    struct io_oper *oper;
+    int status = 0;
+    int num_files = 0;
+    int open_fds = 0;
+    struct thread_info *t;
+
+    page_size_mask = getpagesize() - 1;
+
+    while(1) {
+	c = getopt(ac, av, &quot;a:b:c:C:m:s:r:d:i:I:o:t:lLnhOSxvu&quot;);
+	if  (c &lt; 0)
+	    break;
+
+        switch(c) {
+	case 'a':
+	    page_size_mask = parse_size(optarg, 1024);
+	    page_size_mask--;
+	    break;
+	case 'c':
+	    num_contexts = atoi(optarg);
+	    break;
+	case 'C':
+	    context_offset = parse_size(optarg, 1024 * 1024);
+	case 'b':
+	    max_io_submit = atoi(optarg);
+	    break;
+	case 's':
+	    file_size = parse_size(optarg, 1024 * 1024);
+	    break;
+	case 'd':
+	    depth = atoi(optarg);
+	    break;
+	case 'r':
+	    rec_len = parse_size(optarg, 1024);
+	    break;
+	case 'i':
+	    io_iter = atoi(optarg);
+	    break;
+        case 'I':
+          iterations = atoi(optarg);
+        break;
+	case 'n':
+	    fsync_stages = 0;
+	    break;
+	case 'l':
+	    latency_stats = 1;
+	    break;
+	case 'L':
+	    completion_latency_stats = 1;
+	    break;
+	case 'm':
+	    if (!strcmp(optarg, &quot;shm&quot;)) {
+		fprintf(stderr, &quot;using ipc shm\n&quot;);
+	        use_shm = USE_SHM;
+	    } else if (!strcmp(optarg, &quot;shmfs&quot;)) {
+	        fprintf(stderr, &quot;using /dev/shm for buffers\n&quot;);
+		use_shm = USE_SHMFS;
+	    }
+	    break;
+	case 'o': 
+	    i = atoi(optarg);
+	    stages |= 1 &lt;&lt; i;
+	    fprintf(stderr, &quot;adding stage %s\n&quot;, stage_name(i));
+	    break;
+	case 'O':
+	    o_direct = O_DIRECT;
+	    break;
+	case 'S':
+	    o_sync = O_SYNC;
+	    break;
+	case 't':
+	    num_threads = atoi(optarg);
+	    break;
+	case 'x':
+	    stonewall = 0;
+	    break;
+	case 'u':
+	    unlink_files = 1;
+	    break;
+	case 'v':
+	    verify = 1;
+	    break;
+	case 'h':
+	default:
+	    print_usage();
+	    exit(1);
+	}
+    }
+
+    /* 
+     * make sure we don't try to submit more ios than we have allocated
+     * memory for
+     */
+    if (depth &lt; io_iter) {
+	io_iter = depth;
+        fprintf(stderr, &quot;dropping io_iter to %d\n&quot;, io_iter);
+    }
+
+    if (optind &gt;= ac) {
+	print_usage();
+	exit(1);
+    }
+
+    num_files = ac - optind;
+
+    if (num_threads &gt; (num_files * num_contexts)) {
+        num_threads = num_files * num_contexts;
+	fprintf(stderr, &quot;dropping thread count to the number of contexts %d\n&quot;, 
+	        num_threads);
+    }
+
+    t = malloc(num_threads * sizeof(*t));
+    if (!t) {
+        perror(&quot;malloc&quot;);
+	exit(1);
+    }
+    global_thread_info = t;
+
+    /* by default, allow a huge number of iocbs to be sent towards
+     * io_submit
+     */
+    if (!max_io_submit)
+        max_io_submit = num_files * io_iter * num_contexts;
+
+    /*
+     * make sure we don't try to submit more ios than max_io_submit allows 
+     */
+    if (max_io_submit &lt; io_iter) {
+        io_iter = max_io_submit;
+	fprintf(stderr, &quot;dropping io_iter to %d\n&quot;, io_iter);
+    }
+
+    if (!stages) {
+        stages = (1 &lt;&lt; WRITE) | (1 &lt;&lt; READ) | (1 &lt;&lt; RREAD) | (1 &lt;&lt; RWRITE);
+    } else {
+        for (i = 0 ; i &lt; LAST_STAGE; i++) {
+	    if (stages &amp; (1 &lt;&lt; i)) {
+	        first_stage = i;
+		fprintf(stderr, &quot;starting with %s\n&quot;, stage_name(i));
+		break;
+	    }
+	}
+    }
+
+    if (file_size &lt; num_contexts * context_offset) {
+        fprintf(stderr, &quot;file size %Lu too small for %d contexts\n&quot;, 
+	        file_size, num_contexts);
+	exit(1);
+    }
+
+    fprintf(stderr, &quot;file size %LuMB, record size %luKB, depth %d, ios per iteration %d\n&quot;, file_size / (1024 * 1024), rec_len / 1024, depth, io_iter);
+    fprintf(stderr, &quot;max io_submit %d, buffer alignment set to %luKB\n&quot;, 
+            max_io_submit, (page_size_mask + 1)/1024);
+    fprintf(stderr, &quot;threads %d files %d contexts %d context offset %LuMB verification %s\n&quot;, 
+            num_threads, num_files, num_contexts, 
+	    context_offset / (1024 * 1024), verify ? &quot;on&quot; : &quot;off&quot;);
+    /* open all the files and do any required setup for them */
+    for (i = optind ; i &lt; ac ; i++) {
+	int thread_index;
+	for (j = 0 ; j &lt; num_contexts ; j++) {
+	    thread_index = open_fds % num_threads;
+	    open_fds++;
+
+	    rwfd = open(av[i], O_CREAT | O_RDWR | o_direct | o_sync, 0600);
+	    assert(rwfd != -1);
+
+	    oper = create_oper(rwfd, first_stage, j * context_offset, 
+	                       file_size - j * context_offset, rec_len, 
+			       depth, io_iter, av[i]);
+	    if (!oper) {
+		fprintf(stderr, &quot;error in create_oper\n&quot;);
+		exit(-1);
+	    }
+	    oper_list_add(oper, &amp;t[thread_index].active_opers);
+	    t[thread_index].num_files++;
+	}
+    }
+    if (setup_shared_mem(num_threads, num_files * num_contexts, 
+                         depth, rec_len, max_io_submit))
+    {
+        exit(1);
+    }
+    for (i = 0 ; i &lt; num_threads ; i++) {
+	if (setup_ious(&amp;t[i], t[i].num_files, depth, rec_len, max_io_submit))
+		exit(1);
+    }
+    if (num_threads &gt; 1){
+        printf(&quot;Running multi thread version num_threads:%d\n&quot;, num_threads);
+        run_workers(t, num_threads);
+    } else {
+        printf(&quot;Running single thread version \n&quot;);
+	status = worker(t);
+    }
+    if (unlink_files) {
+	for (i = optind ; i &lt; ac ; i++) {
+	    printf(&quot;Cleaning up file %s \n&quot;, av[i]);
+	    unlink(av[i]);
+	}
+    }
+
+    if (status) {
+	exit(1);
+    }
+    return status;
+}
+

Added: trunk/rpms/aio-stress/aio-stress.spec
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/aio-stress/aio-stress.spec?rev=8857&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/aio-stress/aio-stress.spec?rev=8857&amp;view=markup</A>
==============================================================================
--- trunk/rpms/aio-stress/aio-stress.spec (added)
+++ trunk/rpms/aio-stress/aio-stress.spec Wed Jun  9 14:00:30 2010
@@ -1,0 +1,38 @@
+# $Id$
+# Authority: dag
+# Upstream: Chris Mason &lt;mason$suse,com&gt;
+
+Summary: AIO benchmark tool
+Name: aio-stress
+Version: 0.21
+Release: 1%{?dist}
+License: GPL
+Group: Applications/System
+URL: <A HREF="http://fsbench.filesystems.org/">http://fsbench.filesystems.org/</A>
+
+Source: <A HREF="http://fsbench.filesystems.org/bench/aio-stress.c">http://fsbench.filesystems.org/bench/aio-stress.c</A>
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+%description
+aio-stress is a AIO benchmark tool.
+
+%prep
+%{__cp} -v %{SOURCE0} aio-stress.c
+
+%build
+%{__cc} -Wall -laio -lpthread -o aio-stress aio-stress.c
+
+%install
+%{__rm} -rf %{buildroot}
+%{__install} -Dp -m0755 aio-stress %{buildroot}%{_bindir}/aio-stress
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%{_bindir}/aio-stress
+
+%changelog
+* Tue Jun 08 2010 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.21-1
+- Initial package. (using DAR)

Propchange: trunk/rpms/aio-stress/aio-stress.spec
------------------------------------------------------------------------------
    svn:eol-style = native

Propchange: trunk/rpms/aio-stress/aio-stress.spec
------------------------------------------------------------------------------
    svn:keywords = Id Revision

Added: trunk/rpms/dbench/dbench-4.0-datadir.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/dbench/dbench-4.0-datadir.patch?rev=8857&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/dbench/dbench-4.0-datadir.patch?rev=8857&amp;view=markup</A>
==============================================================================
--- trunk/rpms/dbench/dbench-4.0-datadir.patch (added)
+++ trunk/rpms/dbench/dbench-4.0-datadir.patch Wed Jun  9 14:00:30 2010
@@ -1,0 +1,26 @@
+--- dbench-4.0/Makefile.in.datadir	2007-07-11 15:26:53.000000000 -0400
++++ dbench-4.0/Makefile.in	2007-07-11 15:27:53.000000000 -0400
+@@ -32,9 +32,9 @@ tbench_srv: $(SRV_OBJS)
+ 
+ # Careful here: don't install client.txt over itself.
+ install: all
+-	${INSTALLCMD} -d $(DESTDIR)/$(bindir) $(DESTDIR)/$(datadir) $(DESTDIR)/$(mandir)
++	${INSTALLCMD} -d $(DESTDIR)/$(bindir) $(DESTDIR)/$(datadir)/dbench $(DESTDIR)/$(mandir)
+ 	${INSTALLCMD} dbench tbench tbench_srv $(DESTDIR)/$(bindir)
+-	${INSTALLCMD} client.txt $(DESTDIR)/$(datadir)
++	${INSTALLCMD} -m644 client.txt $(DESTDIR)/$(datadir)/dbench
+ 	${INSTALLCMD} -m644 dbench.1 $(DESTDIR)/$(mandir)
+ 	ln -sf dbench.1 $(DESTDIR)/$(mandir)/tbench.1
+ 	ln -sf dbench.1 $(DESTDIR)/$(mandir)/tbench_srv.1
+--- dbench-4.0/dbench.c.datadir	2008-04-14 09:10:00.000000000 +0530
++++ dbench-4.0/dbench.c	2008-04-14 09:10:22.000000000 +0530
+@@ -28,7 +28,7 @@
+ 
+ struct options options = {
+ 	.timelimit           = 600,
+-	.loadfile            = DATADIR &quot;/client.txt&quot;,
++	.loadfile            = DATADIR &quot;/dbench/client.txt&quot;,
+ 	.directory           = &quot;.&quot;,
+ 	.tcp_options         = TCP_OPTIONS,
+ 	.nprocs              = 10,
+ 

Added: trunk/rpms/dbench/dbench-4.0-destdir.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/dbench/dbench-4.0-destdir.patch?rev=8857&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/dbench/dbench-4.0-destdir.patch?rev=8857&amp;view=markup</A>
==============================================================================
--- trunk/rpms/dbench/dbench-4.0-destdir.patch (added)
+++ trunk/rpms/dbench/dbench-4.0-destdir.patch Wed Jun  9 14:00:30 2010
@@ -1,0 +1,21 @@
+--- dbench-4.0/Makefile.in.destdir	2007-06-20 16:42:46.000000000 -0400
++++ dbench-4.0/Makefile.in	2007-06-20 16:44:56.000000000 -0400
+@@ -32,12 +32,12 @@
+ 
+ # Careful here: don't install client.txt over itself.
+ install: all
+-	${INSTALLCMD} -d $(bindir) $(datadir) $(mandir)
+-	${INSTALLCMD} dbench tbench tbench_srv $(bindir)
+-	${INSTALLCMD} client.txt $(datadir)
+-	${INSTALLCMD} -m644 dbench.1 $(mandir)
+-	ln -sf dbench.1 $(mandir)/tbench.1
+-	ln -sf dbench.1 $(mandir)/tbench_srv.1
++	${INSTALLCMD} -d $(DESTDIR)/$(bindir) $(DESTDIR)/$(datadir) $(DESTDIR)/$(mandir)
++	${INSTALLCMD} dbench tbench tbench_srv $(DESTDIR)/$(bindir)
++	${INSTALLCMD} client.txt $(DESTDIR)/$(datadir)
++	${INSTALLCMD} -m644 dbench.1 $(DESTDIR)/$(mandir)
++	ln -sf dbench.1 $(DESTDIR)/$(mandir)/tbench.1
++	ln -sf dbench.1 $(DESTDIR)/$(mandir)/tbench_srv.1
+ 
+ clean:
+ 	rm -f *.o *~ dbench tbench tbench_srv

Added: trunk/rpms/dbench/dbench.spec
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/dbench/dbench.spec?rev=8857&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/dbench/dbench.spec?rev=8857&amp;view=markup</A>
==============================================================================
--- trunk/rpms/dbench/dbench.spec (added)
+++ trunk/rpms/dbench/dbench.spec Wed Jun  9 14:00:30 2010
@@ -1,0 +1,64 @@
+# $Id$
+# Authority: dag
+
+%{?el5:%define _without_poptdevel 1}
+%{?el4:%define _without_poptdevel 1}
+%{?el3:%define _without_poptdevel 1}
+
+Summary: Filesystem load benchmarking tool
+Name: dbench
+Version: 4.0
+Release: 1%{?dist}
+License: GPLv2+
+Group: System Environment/Base
+URL: <A HREF="http://samba.org/ftp/tridge/dbench/README">http://samba.org/ftp/tridge/dbench/README</A>
+
+Source: <A HREF="http://samba.org/ftp/tridge/dbench/dbench-%{version">http://samba.org/ftp/tridge/dbench/dbench-%{version</A>}.tar.gz 
+Patch0: dbench-4.0-destdir.patch
+Patch1: dbench-4.0-datadir.patch
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+BuildRequires: autoconf
+%{?_without_poptdevel:BuildRequires: popt}
+%{!?_without_poptdevel:BuildRequires: popt-devel}
+
+%description
+Dbench is a file system benchmark that generates load patterns similar
+to those of the commercial Netbench benchmark, but without requiring a
+lab of Windows load generators to run. It is now considered a de facto
+standard for generating load on the Linux VFS.
+
+%prep
+%setup
+%patch0 -p1 -b .destdir
+%patch1 -p1 -b .datadir
+
+%build
+./autogen.sh 
+%configure
+%{__make} %{?_smp_mflags}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot; \
+    mandir=&quot;%{_mandir}/man1&quot; \
+    INSTALLCMD=&quot;install -p&quot;
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%doc COPYING README
+%doc %{_mandir}/man1/dbench.1*
+%doc %{_mandir}/man1/tbench.1*
+%doc %{_mandir}/man1/tbench_srv.1*
+%{_bindir}/dbench
+%{_bindir}/tbench
+%{_bindir}/tbench_srv
+%dir %{_datadir}/dbench/
+%{_datadir}/dbench/client.txt
+
+%changelog
+* Wed Jun 09 2010 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 4.0-1
+- Initial package. (using DAR)

Propchange: trunk/rpms/dbench/dbench.spec
------------------------------------------------------------------------------
    svn:eol-style = native

Propchange: trunk/rpms/dbench/dbench.spec
------------------------------------------------------------------------------
    svn:keywords = Id Revision

Added: trunk/rpms/ffsb/ffsb.spec
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/ffsb/ffsb.spec?rev=8857&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/ffsb/ffsb.spec?rev=8857&amp;view=markup</A>
==============================================================================
--- trunk/rpms/ffsb/ffsb.spec (added)
+++ trunk/rpms/ffsb/ffsb.spec Wed Jun  9 14:00:30 2010
@@ -1,0 +1,45 @@
+# $Id$
+# Authority: dag
+
+Summary: The Flexible Filesystem Benchmark
+Name: ffsb
+Version: 5.2.1
+Release: 1%{?dist}
+License: GPLv2+
+Group: Applications/System
+URL: <A HREF="http://sourceforge.net/projects/ffsb/">http://sourceforge.net/projects/ffsb/</A>
+
+Source: <A HREF="http://dl.sf.net/ffsb/ffsb-%{version">http://dl.sf.net/ffsb/ffsb-%{version</A>}.tar.gz
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+%description
+The Flexible Filesystem Benchmark (FFSB) is a cross-platform filesystem
+performance measurement tool. It uses customizable profiles to measure
+of different workloads, and it supports multiple groups of threads
+across multiple filesystems.
+
+%prep
+%setup
+
+%build
+%configure
+%{__make} %{?_smp_mflags}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+
+### Remove leftover file in tarball
+%{__rm} -v examples/profile_smallfile_reads~
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%doc AUTHORS COPYING README USAGE examples/
+%{_bindir}/ffsb
+
+%changelog
+* Wed Jun 09 2010 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 5.2.1-1
+- Initial package. (using DAR)

Propchange: trunk/rpms/ffsb/ffsb.spec
------------------------------------------------------------------------------
    svn:eol-style = native

Propchange: trunk/rpms/ffsb/ffsb.spec
------------------------------------------------------------------------------
    svn:keywords = Id Revision

Modified: trunk/rpms/mtr/mtr.spec
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/mtr/mtr.spec?rev=8857&amp;r1=8856&amp;r2=8857&amp;view=diff">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/mtr/mtr.spec?rev=8857&amp;r1=8856&amp;r2=8857&amp;view=diff</A>
==============================================================================
--- trunk/rpms/mtr/mtr.spec (original)
+++ trunk/rpms/mtr/mtr.spec Wed Jun  9 14:00:30 2010
@@ -9,7 +9,7 @@
 
 Summary: Network diagnostic tool
 Name: mtr
-Version: 0.78
+Version: 0.79
 Release: 1%{?dist}
 Epoch: 2
 License: GPL
@@ -145,6 +145,9 @@
 %{_sbindir}/xmtr
 
 %changelog
+* Wed Jun 09 2010 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 2:0.79-1
+- Updated to release 0.79.
+
 * Tue Jun 08 2010 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 2:0.78-1
 - Updated to release 0.78.
 

Added: trunk/rpms/sysbench/sysbench.spec
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/sysbench/sysbench.spec?rev=8857&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/sysbench/sysbench.spec?rev=8857&amp;view=markup</A>
==============================================================================
--- trunk/rpms/sysbench/sysbench.spec (added)
+++ trunk/rpms/sysbench/sysbench.spec Wed Jun  9 14:00:30 2010
@@ -1,0 +1,66 @@
+# $Id$
+# Authority: dag
+
+%{?el4:%define _without_postgresql 1}
+%{?el3:%define _without_mysql 1}
+%{?el3:%define _without_postgresql 1}
+
+Summary: System performance benchmark
+Name: sysbench
+Version: 0.4.10
+Release: 1%{?dist}
+License: GPLv2+
+Group: Applications/System
+URL: <A HREF="http://sysbench.sourceforge.net/">http://sysbench.sourceforge.net/</A>
+
+Source: <A HREF="http://dl.sf.net/sysbench/sysbench-%{version">http://dl.sf.net/sysbench/sysbench-%{version</A>}.tar.gz
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+%{!?_without_mysql:BuildRequires: mysql-devel}
+%{!?_without_postgresql:BuildRequires: postgresql-devel}
+
+%description
+SysBench is a modular, cross-platform and multi-threaded benchmark
+tool for evaluating OS parameters that are important for a system
+running a database under intensive load.
+
+The idea of this benchmark suite is to quickly get an impression about
+system performance without setting up complex database benchmarks or
+even without installing a database at all. Current features allow to
+test the following system parameters:
+- file I/O performance
+- scheduler performance
+- memory allocation and transfer speed
+- POSIX threads implementation performance
+- database server performance (OLTP benchmark)
+
+Primarily written for MySQL server benchmarking, SysBench will be
+further extended to support multiple database backends, distributed
+benchmarks and third-party plug-in modules.
+
+%prep
+%setup
+
+%build
+%configure \
+%{!?_without_mysql:--with-mysql} \
+%{?_without_mysql:--without-mysql} \
+%{!?_without_postgresql:--with-pgsql}
+%{__make}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%doc ChangeLog COPYING INSTALL README
+%{_bindir}/sysbench
+%exclude %{_docdir}/sysbench/
+
+%changelog
+* Wed Jun 09 2010 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.4.10-1
+- Initial package. (using DAR)

Propchange: trunk/rpms/sysbench/sysbench.spec
------------------------------------------------------------------------------
    svn:eol-style = native

Propchange: trunk/rpms/sysbench/sysbench.spec
------------------------------------------------------------------------------
    svn:keywords = Id Revision


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007651.html">[svn] r8856 - in /trunk/rpms/lighttpd: lighttpd-1.4.26-defaultconf.patch lighttpd.spec
</A></li>
	<LI>Next message: <A HREF="007653.html">[svn] r8858 - /trunk/rpms/fio/fio.spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7652">[ date ]</a>
              <a href="thread.html#7652">[ thread ]</a>
              <a href="subject.html#7652">[ subject ]</a>
              <a href="author.html#7652">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
