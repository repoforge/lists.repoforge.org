<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r3209 - in trunk/tools/dstat: . stats
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r3209%20-%20in%20trunk/tools/dstat%3A%20.%20stats&In-Reply-To=%3C20050512214045.417F11D02A0%40lists.rpmforge.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002010.html">
   <LINK REL="Next"  HREF="002012.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r3209 - in trunk/tools/dstat: . stats</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r3209%20-%20in%20trunk/tools/dstat%3A%20.%20stats&In-Reply-To=%3C20050512214045.417F11D02A0%40lists.rpmforge.net%3E"
       TITLE="[svn] r3209 - in trunk/tools/dstat: . stats">packagers at lists.rpmforge.net
       </A><BR>
    <I>Thu May 12 23:40:45 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="002010.html">[svn] r3208 - trunk/rpms/gstreamer-plugins-extras
</A></li>
        <LI>Next message: <A HREF="002012.html">[svn] r3210 - in trunk/tools/dstat: . plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2011">[ date ]</a>
              <a href="thread.html#2011">[ thread ]</a>
              <a href="subject.html#2011">[ subject ]</a>
              <a href="author.html#2011">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2005-05-12 23:40:44 +0200 (Thu, 12 May 2005)
New Revision: 3209

Removed:
   trunk/tools/dstat/stats/dstat.py
Modified:
   trunk/tools/dstat/dstat
   trunk/tools/dstat/dstat15
   trunk/tools/dstat/stats/dstat_battery.py
   trunk/tools/dstat/stats/dstat_cpufreq.py
   trunk/tools/dstat/stats/dstat_dbus.py
   trunk/tools/dstat/stats/dstat_freespace.py
   trunk/tools/dstat/stats/dstat_postfix.py
   trunk/tools/dstat/stats/dstat_sendmail.py
   trunk/tools/dstat/stats/dstat_thermal.py
   trunk/tools/dstat/stats/dstat_utmp.py
Log:
Updates

Modified: trunk/tools/dstat/dstat
===================================================================
--- trunk/tools/dstat/dstat	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/dstat	2005-05-12 21:40:44 UTC (rev 3209)
@@ -68,7 +68,7 @@
 		self.args = args
 		self.count = -1
 		self.cpulist = None
-		self.debug = False
+		self.debug = 0
 		self.delay = 1
 		self.disklist = None
 		self.full = False
@@ -110,7 +110,7 @@
 			elif opt in ['-D']:
 				self.disklist = arg.split(',')
 			elif opt in ['--debug']:
-				self.debug = True
+				self.debug = self.debug + 1
 			elif opt in ['-g', '--page']:
 				self.modlist.append('page')
 			elif opt in ['-i', '--int']:
@@ -250,7 +250,6 @@
 '''
 
 ### START STATS DEFINITIONS ###
-
 class dstat:
 	### Initialise default variables
 	def init(self, vars=(), len=0):
@@ -591,7 +590,6 @@
 class dstat_disk24(dstat):
 	def __init__(self):
 		self.format = ('f', 5, 1024)
-		self.len = 5
 		self.open('/proc/partitions')
 		self.nick = ('read', 'write')
 		self.regexp = re.compile('^(ram\d+|loop\d+|name)$')
@@ -739,6 +737,7 @@
 			ret[l1] = l1
 			for name in l2:
 				ret[name.strip().lower()] = l1
+		return ret
 
 	def discover(self):
 		ret = []
@@ -808,6 +807,7 @@
 			ret[l1] = l1
 			for name in l2:
 				ret[name.strip().lower()] = l1
+		return ret
 
 	def discover(self):
 		ret = []
@@ -1307,13 +1307,17 @@
 def fchg(var, max, base):
 	c = 0
 	while True:
-		ret = str(long(round(var)))
+#		ret = repr(round(var))
+#		ret = repr(long(round(var,max)))
+		ret = str(long(round(var,max)))
+		if var == 0:
+			ret = str('0')
+			break
 		if len(ret) &lt;= max:
 			i = max - len(ret)
 			while i &gt; 0:
-				fmt = '%.'+str(i)+'f'
-				ret = fmt % var
-				if var != round(var) and len(ret) &lt;= max:
+				ret = ('%.'+str(i)+'f') % var
+				if len(ret) &lt;= max and ret != repr(round(var)):
 					break
 				i = i - 1
 			else:
@@ -1467,6 +1471,12 @@
 #			if dev == list[0]:
 #				return list[1]
 
+def readfile(file):
+	ret = ''
+	for line in open(file,'r').readlines():
+		ret = ret + line
+	return ret
+
 def signaler(signum, frame):
 	signal.alarm(interval)
 
@@ -1531,13 +1541,20 @@
 		elif mod == 'disk': objs = ( dstat_disk(), dstat_disk24(), dstat_disk24old() )
 		elif mod == 'int':  objs = ( dstat_int(), dstat_int24() )
 		elif mod == 'page': objs = ( dstat_page(), dstat_page24() )
-		elif 'dstat_'+mod in globals():
-			exec(compile('objs = ( dstat_%s(), )' % mod, '&lt;string&gt;', 'exec'))
 		else:
+			if 'dstat_'+mod not in globals():
+				try:
+#					exec(compile('from dstat_%s import *' % mod, '&lt;string&gt;', 'exec'))
+					import imp
+					file, pathname, description = imp.find_module('dstat_'+mod)
+					exec(compile(readfile(pathname), '&lt;string&gt;', 'exec'))
+				except Exception, e:
+					info(1, 'Module &quot;dstat_%s&quot; failed to load. (%s)' % (mod, e))
+					continue
 			try:
-				exec(compile('import dstat_%s\nobjs = ( dstat_%s.dstat_%s(), )' % (mod, mod, mod), '&lt;string&gt;', 'exec'))
+				exec(compile('objs = ( dstat_%s(), )' % mod, '&lt;string&gt;', 'exec'))
 			except Exception, e:
-				info(1, 'Module \'dstat_%s\' failed to load. (%s)' % (mod, e))
+				info(1, 'Class &quot;dstat_%s&quot; has problems. (%s)' % (mod, e))
 				continue
 
 		### Remove defect stat objects and calculate line length
@@ -1626,7 +1643,8 @@
 		if op.debug: t2 = time.time(); tt = tt + (t2 - t1) * 1000
 		if op.debug:
 			if loop == 0: tt = tt * step
-			sys.stdout.write(' %3.3f' % (tt / step))
+			sys.stdout.write(' %6.3f' % (tt / step))
+		if op.debug &gt; 1:
 			sys.stdout.write(' [%d:%d:%d] ' % (loop, update, step))
 
 		### If intermediate results, update increases with 1 sec (=interval)

Modified: trunk/tools/dstat/dstat15
===================================================================
--- trunk/tools/dstat/dstat15	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/dstat15	2005-05-12 21:40:44 UTC (rev 3209)
@@ -19,9 +19,10 @@
 try:
 	import sys, signal, os, re, time, string
 	import types, curses, signal, resource
-	sys.path.insert(0, '.')
-	sys.path.insert(0, './stats/')
+	pwd = os.path.dirname(sys.argv[0])
 	sys.path.insert(0, '/usr/share/dstat/')
+	sys.path.insert(0, pwd + '/stats/')
+	sys.path.insert(0, pwd)
 except KeyboardInterrupt, e:
 	pass
 
@@ -60,7 +61,7 @@
 		self.args = args
 		self.count = -1
 		self.cpulist = None
-		self.debug = False
+		self.debug = 0
 		self.delay = 1
 		self.disklist = None
 		self.full = False
@@ -102,7 +103,7 @@
 			elif opt in ['-D']:
 				self.disklist = string.split(arg, ',')
 			elif opt in ['--debug']:
-				self.debug = True
+				self.debug = self.debug + 1
 			elif opt in ['-g', '--page']:
 				self.modlist.append('page')
 			elif opt in ['-i', '--int']:
@@ -242,7 +243,6 @@
 '''
 
 ### START STATS DEFINITIONS ###
-
 class dstat:
 	### Initialise default variables
 	def init(self, vars=(), len=0):
@@ -256,25 +256,36 @@
 					for i in range(len):
 						self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
 
-	### Open stat file descriptor
+	def __repr__(self):
+		&quot;Display stat results&quot;
+		line = ''
+		for i, name in enumerate(self.vars):
+			if isinstance(self.val[name], types.TupleType) or isinstance(self.val[name], types.ListType):
+				line = line + cprintlist(self.val[name], self.format)
+				sep = ansi['default'] + char['colon']
+			else:
+				line = line + cprint(self.val[name], self.format)
+				sep = char['space']
+			if i + 1 != len(self.vars):
+				line = line + sep
+		return line
+
 	def open(self, file):
+		&quot;Open stat file descriptor&quot;
 		self.file = file
-		if os.path.exists(file):
-			self.fd = dopen(file)
-		else:
-			self.fd = None
+		self.fd = dopen(file)
 
-	### Return var width
-	def varwidth(self):
+	def statwidth(self):
+		&quot;Return complete stat width&quot;
 		return len(self.vars) * self.width() + len(self.vars) - 1
 
-	### Return column width
 	def width(self):
+		&quot;Return column width&quot;
 		if isinstance(self.name, types.StringType):
-			return self.len
+			return self.format[1]
 		else:
 			for name in self.cn2.keys():
-				return len(self.cn2[name]) * self.len + len(self.cn2[name]) - 1
+				return len(self.cn2[name]) * self.format[1] + len(self.cn2[name]) - 1
 			return 0
 
 	def title(self, nr):
@@ -285,29 +296,29 @@
 
 	def title1(self):
 		if isinstance(self.name, types.StringType):
-			max = self.varwidth()
+			max = self.statwidth()
 			return ansi['darkblue'] + string.replace(string.center(self.name[0:max], max), ' ', '-') + ansi['default']
 		ret = ''
 		for i, name in enumerate(self.name):
 			max = self.width()
 			ret = ret + string.replace(string.center(name[0:max], max), ' ', '-')
-			if i + 1 != len(self.name): ret = ret + '-'
+			if i + 1 != len(self.name): ret = ret + ansi['blue'] + char['dash'] + ansi['darkblue']
 		return ansi['darkblue'] + ret
 
 	def title2(self):
 		if isinstance(self.name, types.StringType):
 			ret = ''
 			for i, nick in enumerate(self.nick):
-				ret = ret + string.replace(string.center(nick, self.len), ' ', '_')
-				if i + 1 != len(self.nick): ret = ret + ' '
+				ret = ret + string.replace(string.center(nick, self.format[1]), ' ', '_')
+				if i + 1 != len(self.nick): ret = ret + char['space']
 			return ansi['blue'] + ret
 		else:
 			ret = ''
 			for i, name in enumerate(self.name):
 				for j, nick in enumerate(self.nick):
-					ret = ret + ansi['blue'] + string.replace(string.center(nick, self.len), ' ', '_')
-					if j + 1 != len(self.nick): ret = ret + ' '
-				if i + 1 != len(self.name): ret = ret + ' '
+					ret = ret + ansi['blue'] + string.replace(string.center(nick, self.format[1]), ' ', '_')
+					if j + 1 != len(self.nick): ret = ret + char['space']
+				if i + 1 != len(self.name): ret = ret + ansi['default'] + char['colon']
 			return ansi['blue'] + ret
 
 	def titlecsv(self, nr):
@@ -343,8 +354,11 @@
 			return ret
 
 	def check(self):
+		&quot;Check if stat is applicable&quot;
 		if hasattr(self, 'fd') and not self.fd:
 			return False
+		if not self.vars:
+			return False
 		if self.discover() and self.width():
 			return True
 		return False
@@ -352,35 +366,6 @@
 	def discover(self):
 		return True
 
-	def extract(self):
-		pass
-
-	def results(self):
-		sep = ' '
-		line = ''
-		for i, name in enumerate(self.vars):
-			if self.format in ('%s', '%bs'):
-				line = line + '%s' % conv(self.len, self.val[name], 1024)
-			elif self.format == '%ds':
-				line = line + '%s' % conv(self.len, self.val[name], 1000)
-			elif self.format == '%ps':
-				line = line + '%s' % conv(self.len, self.val[name], 100)
-			elif self.format == '%is':
-				line = line + '%s' % conv(self.len, self.val[name], 10)
-			elif self.format == '%f':
-				line = line + '%s' % conv(self.len, self.val[name], 1)
-			elif self.format in ('%s %s', '%s:%s', '%s-%s'):
-				line = line + self.format % convlist(self.len, self.val[name])
-				sep = ansi['default'] + char['colon']
-			elif self.format in ('%s %s %s', '%s %s %s %s %s %s'):
-				line = line + self.format % convlist(self.len, self.val[name], 100)
-				sep = ansi['default'] + char['colon']
-			else:
-				line = line + self.format % self.val[name]
-			if i + 1 != len(self.vars):
-				line = line + sep
-		return line
-
 	def showend(self, totlist, vislist):
 		if self is not vislist[-1]:
 			return ansi['default'] + char['pipe']
@@ -391,7 +376,7 @@
 	def showcsv(self):
 		def printcsv(var):
 			if var != round(var):
-				return '%.2f' % var
+				return '%.3f' % var
 			return '%s' % round(var)
 
 		line = ''
@@ -416,8 +401,7 @@
 
 class dstat_cpu(dstat):
 	def __init__(self):
-		self.format = '%s %s %s %s %s %s'
-		self.len = 3
+		self.format = ('p', 3, 34)
 		self.open('/proc/stat')
 		self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
 		self.vars = self.vars()
@@ -427,7 +411,7 @@
 				self.name.append('cpu' + name + ' usage')
 			else:
 				self.name.append('total cpu usage')
-		self.init( self.vars + ['',], 6)
+		self.init(self.vars + ['',], 6)
 
 	def discover(self, *list):
 		ret = []
@@ -438,7 +422,7 @@
 				if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
 				ret.append(l[0][3:])
 			ret.sort()
-			for item in list: ret.append(item)
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
@@ -463,8 +447,9 @@
 		self.fd.seek(0)
 		for line in self.fd.readlines():
 			l = string.split(line)
+			if len(l) &lt; 8: continue
 			for name in self.vars:
-				if len(l) &lt; 8 or l[0] != 'cpu' + name: continue
+				if l[0] != 'cpu' + name: continue
 				self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
 		for name in self.vars:
 			for i in range(6):
@@ -474,29 +459,31 @@
 
 class dstat_cpu24(dstat):
 	def __init__(self):
-		self.format = '%s %s %s'
-		self.len = 3
+		self.format = ('p', 3, 34)
 		self.open('/proc/stat')
 		self.nick = ( 'usr', 'sys', 'idl')
 		self.vars = self.vars()
-		self.name = []
+		self.name = self.name()
+		self.init(self.vars + ['',], 3)
+
+	def name(self):
+		ret = []
 		for name in self.vars:
 			if name:
-				self.name.append('cpu' + name)
+				ret.append('cpu' + name)
 			else:
-				self.name.append('cpu total')
-		self.init(self.vars + ['',], 3)
+				ret.append('cpu total')
+		return ret
 
 	def discover(self, *list):
 		ret = []
-		if self.fd:
-			self.fd.seek(0)
-			for line in self.fd.readlines():
-				l = string.split(line)
-				if len(l) != 5 or l[0][0:3] != 'cpu': continue
-				ret.append(l[0][3:])
-			ret.sort()
-			for item in list: ret.append(item)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(line)
+			if len(l) != 5 or l[0][0:3] != 'cpu': continue
+			ret.append(l[0][3:])
+		ret.sort()
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
@@ -532,9 +519,9 @@
 
 class dstat_disk(dstat):
 	def __init__(self):
-		self.format = '%s %s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/diskstats')
+		self.regexp = re.compile('^(ram\d+|loop\d+)$')
 		self.nick = ('read', 'write')
 		self.vars = self.vars()
 		self.name = ['disk/'+name for name in self.vars]
@@ -543,15 +530,14 @@
 	def discover(self, *list):
 		ret = []
 		if self.fd:
-			regexp = re.compile('^(ram\d+|loop\d+)$')
 			self.fd.seek(0)
 			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) &lt; 13 or l[3] == '0': continue
 				name = l[2]
-				if not regexp.match(name):
+				if not self.regexp.match(name):
 					ret.append(name)
-			for item in list: ret.append(item)
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
@@ -562,7 +548,7 @@
 			list = ('total', )
 		else:
 			list = self.discover()
-			if len(list) &gt; 2: list = list[0:2]
+#			if len(list) &gt; 2: list = list[0:2]
 			list.sort()
 		for name in list:
 			if name in self.discover('total') + op.diskset.keys():
@@ -571,14 +557,13 @@
 
 	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		regexp = re.compile('^(ram\d+|loop\d+)$')
 		self.fd.seek(0)
 		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt; 13: continue
 			if l[5] == '0' and l[9] == '0': continue
 			name = l[2]
-			if regexp.match(name): continue
+			if self.regexp.match(name): continue
 			self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
 			if name in self.vars:
 				self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
@@ -597,10 +582,10 @@
 
 class dstat_disk24(dstat):
 	def __init__(self):
-		self.format = '%s %s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/partitions')
 		self.nick = ('read', 'write')
+		self.regexp = re.compile('^(ram\d+|loop\d+|name)$')
 		self.vars = self.vars()
 		self.name = ['disk/'+name for name in self.vars]
 		self.init(self.vars + ['total',], 2)
@@ -608,15 +593,14 @@
 	def discover(self, *list):
 		ret = []
 		if self.fd and not os.path.exists('/proc/diskstats'):
-			regexp = re.compile('^(ram\d+|loop\d+|name)$')
 			self.fd.seek(0)
 			for line in self.fd.readlines():
 				l = string.split(line)
 				if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
 				name = l[3]
-				if not regexp.match(name):
+				if not self.regexp.match(name):
 					ret.append(name)	
-			for item in list: ret.append(item)
+		for item in list: ret.append(item)
 		return ret
 
 	def vars(self):
@@ -627,7 +611,7 @@
 			list = ('total', )
 		else:
 			list = self.discover()
-			if len(list) &gt; 2: list = list[0:2]
+#			if len(list) &gt; 2: list = list[0:2]
 			list.sort()
 		for name in list:
 			if name in self.discover('total') + op.diskset.keys():
@@ -636,7 +620,6 @@
 
 	def extract(self):
 		for name in self.vars: self.cn2[name] = (0, 0)
-		regexp = re.compile('^(ram\d+|loop\d+|name)$')
 		self.fd.seek(0)
 		for line in self.fd.readlines():
 			l = string.split(line)
@@ -644,7 +627,7 @@
 			if l[6] == '0' and l[10] == '0': continue
 			name = l[3]
 			if name == 'name': continue
-			if regexp.match(name): continue
+			if self.regexp.match(name): continue
 			self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]))
 			if name in self.vars:
 				self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
@@ -664,17 +647,17 @@
 ### FIXME: Needs rework, does anyone care ?
 class dstat_disk24old(dstat):
 	def __init__(self):
-		self.format = '%s %s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/stat')
 		self.nick = ('read', 'write')
 		self.vars = self.vars()
 		self.name = ['disk/'+name for name in self.vars]
 		self.init(self.vars + ['total',], 2)
+		self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
 
 	def discover(self, *list):
 		ret = []
-		if self.fd and not os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
+		if not os.path.exists('/proc/partitions') and not os.path.exists('/proc/diskstats'):
 			self.fd.seek(0)
 			for line in self.fd.readlines():
 				l = string.split(line)
@@ -691,7 +674,7 @@
 			list = ('total', )
 		else:
 			list = self.discover()
-			if len(list) &gt; 2: list = list[0:2]
+#			if len(list) &gt; 2: list = list[0:2]
 			list.sort()
 		for name in list:
 			if name in self.discover('total') + op.diskset.keys():
@@ -706,11 +689,11 @@
 			if len(l) &lt; 3: continue
 			name = l[0]
 			if name == 'disk_io':
-				regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
 				for pair in string.split(line)[1:]:
-					m = regexp.match(pair)
+					m = self.regexp.match(pair)
 					if m:
 						l = m.groups()
+						if len(l) &lt; 4: continue
 						name = dev(int(l[0]), int(l[1]))
 						self.cn2[name] = ( long(l[2]), long(l[3]) )
 						self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
@@ -730,43 +713,44 @@
 class dstat_int(dstat):
 	def __init__(self):
 		self.name = 'interrupts'
-		self.format = '%ds'
-		self.len = 5
+		self.format = ('d', 5, 1000)
 		self.open('/proc/stat')
+		self.intmap = self.intmap()
+		self.vars = self.vars()
+		self.nick = self.vars
+		self.init(self.vars, 1)
 
-		self.intmap = {}
+	def intmap(self):
+		ret = {}
 		for line in dopen('/proc/interrupts').readlines():
 			l = string.split(line)
 			if len(l) &lt;= cpunr: continue
 			l1 = string.split(l[0], ':')[0]
 			l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
-			self.intmap[l1] = l1
+			ret[l1] = l1
 			for name in l2:
-				self.intmap[string.strip(string.lower(name))] = l1
+				name = string.lower(string.strip(name))
+				ret[name] = l1
+		return ret
 
-		self.vars = self.vars()
-		self.nick = self.vars
-		self.init(self.vars, 1)
-
 	def discover(self):
 		ret = []
-		if self.fd:
-			self.fd.seek(0)
-			for line in self.fd.readlines():
-				l = string.split(line)
-				if l[0] != 'intr': continue
-				for name, i in enumerate(l[2:]):
-					if long(i) &gt; 10: ret.append(str(name))
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(line)
+			if l[0] != 'intr': continue
+			for name, i in enumerate(l[2:]):
+				if long(i) &gt; 10: ret.append(str(name))
 		return ret
 
-	def check(self):
-		if self.fd and self.vars:
-			self.fd.seek(0)
-			for line in self.fd.readlines():
-				l = string.split(line)
-				if l[0] != 'intr': continue
-				return True
-		return False
+#	def check(self):
+#		if self.fd and self.vars:
+#			self.fd.seek(0)
+#			for line in self.fd.readlines():
+#				l = string.split(line)
+#				if l[0] != 'intr': continue
+#				return True
+#		return False
 
 	def vars(self):
 		ret = []
@@ -800,45 +784,45 @@
 class dstat_int24(dstat):
 	def __init__(self):
 		self.name = 'interrupts'
-		self.format = '%ds'
-		self.len = 5
+		self.format = ('f', 5, 1000)
 		self.open('/proc/interrupts')
+		self.vars = self.vars()
+		self.nick = self.vars
+		self.init(self.vars, 1)
 
-		self.intmap = {}
+	def intmap(self):
+		ret = {}
 		self.fd.seek(0)
 		for line in self.fd.readlines():
 			l = string.split(line)
 			if len(l) &lt;= cpunr: continue
 			l1 = string.split(l[0], ':')[0]
 			l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
-			self.intmap[l1] = l1
+			ret[l1] = l1
 			for name in l2:
-				self.intmap[string.strip(string.lower(name))] = l1
+				name = string.lower(string.strip(name))
+				ret[name] = l1
+		return ret
 
-		self.vars = self.vars()
-		self.nick = self.vars
-		self.init(self.vars, 1)
-
 	def discover(self):
 		ret = []
-		if self.fd:
-			self.fd.seek(0)
-			for line in self.fd.readlines():
-				l = string.split(line)
-				if len(l) &lt; cpunr+1: continue
-				name = string.split(l[0], ':')[0]
-				if long(l[1]) &gt; 10:
-					ret.append(name)
+		self.fd.seek(0)
+		for line in self.fd.readlines():
+			l = string.split(line)
+			if len(l) &lt; cpunr+1: continue
+			name = string.split(l[0], ':')[0]
+			if long(l[1]) &gt; 10:
+				ret.append(name)
 		return ret
 
-	def check(self):
-		if self.fd and self.discover():
-			self.fd.seek(0)
-			for line in self.fd.readlines():
-				l = string.split(line)
-				if l[0] != 'intr' or len(l) &gt; 2: continue
-				return True
-		return False
+#	def check(self):
+#		if self.fd and self.discover():
+#			self.fd.seek(0)
+#			for line in self.fd.readlines():
+#				l = string.split(line)
+#				if l[0] != 'intr' or len(l) &gt; 2: continue
+#				return True
+#		return False
 
 	def vars(self):
 		ret = []
@@ -879,15 +863,11 @@
 class dstat_ipc(dstat):
 	def __init__(self):
 		self.name = 'sysv ipc'
-		self.format = '%is'
-		self.len = 3
+		self.format = ('d', 3, 10)
 		self.vars = ('msg', 'sem', 'shm')
 		self.nick = self.vars
 		self.init(self.vars, 1)
 
-	def check(self):
-		return True
-
 	def extract(self):
 		for name in self.vars:
 			self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
@@ -895,18 +875,12 @@
 class dstat_load(dstat):
 	def __init__(self):
 		self.name = 'load avg'
-		self.format = '%f'
-		self.len = 4
+		self.format = ('f', 4, 10)
 		self.open('/proc/loadavg')
 		self.nick = ('1m', '5m', '15m')
 		self.vars = ('load1', 'load5', 'load15')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		self.fd.seek(0)
 		for line in self.fd.readlines():
@@ -919,18 +893,12 @@
 class dstat_lock(dstat):
 	def __init__(self):
 		self.name = 'file locks'
-		self.format = '%is'
-		self.len = 3
+		self.format = ('f', 3, 10)
 		self.open('/proc/locks')
 		self.nick = ('pos', 'lck', 'rea', 'wri')
 		self.vars = ('posix', 'flock', 'read', 'write')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		for name in self.vars: self.val[name] = 0
 		self.fd.seek(0)
@@ -949,18 +917,12 @@
 class dstat_mem(dstat):
 	def __init__(self):
 		self.name = 'memory usage'
-		self.format = '%s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/meminfo')
 		self.nick = ('used', 'buff', 'cach', 'free')
 		self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		self.fd.seek(0)
 		for line in self.fd.readlines():
@@ -973,8 +935,7 @@
 
 class dstat_net(dstat):
 	def __init__(self):
-		self.format = '%s %s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/net/dev')
 		self.nick = ('recv', 'send')
 		self.vars = self.vars()
@@ -1003,7 +964,7 @@
 			list = ('total', )
 		else:
 			list = self.discover()
-			if len(list) &gt; 2: list = list[0:2]
+#			if len(list) &gt; 2: list = list[0:2]
 			list.sort()
 		for name in list:
 			if name in self.discover('total', 'lo'):
@@ -1019,9 +980,9 @@
 			if l[2] == '0' and l[10] == '0': continue
 			name = l[0]
 			if name in self.vars :
-				self.cn2[name] = ( long(l[2]), long(l[10]) )
+				self.cn2[name] = ( long(l[1]), long(l[9]) )
 			if name not in ('lo','face'):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[10]))
+				self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[9]))
 		if update:
 			for name in self.cn2.keys():
 				self.val[name] = ( 
@@ -1034,18 +995,12 @@
 class dstat_page(dstat):
 	def __init__(self):
 		self.name = 'paging'
-		self.format = '%s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/vmstat')
 		self.nick = ('in', 'out')
 		self.vars = ('pswpin', 'pswpout')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		self.fd.seek(0)
 		for line in self.fd.readlines():
@@ -1062,17 +1017,16 @@
 class dstat_page24(dstat):
 	def __init__(self):
 		self.name = 'paging'
-		self.format = '%s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/stat')
 		self.nick = ('in', 'out')
 		self.vars = ('pswpin', 'pswpout')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd and not os.path.exists('/proc/vmstat'):
-			return True
-		return False
+#	def check(self):
+#		if self.fd and not os.path.exists('/proc/vmstat'):
+#			return True
+#		return False
 
 	def extract(self):
 		self.fd.seek(0)
@@ -1091,18 +1045,12 @@
 class dstat_proc(dstat):
 	def __init__(self):
 		self.name = 'procs'
-		self.format = '%is'
-		self.len = 3
+		self.format = ('f', 3, 10)
 		self.open('/proc/stat')
 		self.nick = ('run', 'blk', 'new')
 		self.vars = ('procs_running', 'procs_blocked', 'processes')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		self.fd.seek(0)
 		for line in self.fd.readlines():
@@ -1127,18 +1075,12 @@
 class dstat_raw(dstat):
 	def __init__(self):
 		self.name = 'raw'
-		self.format = '%is'
-		self.len = 3
+		self.format = ('f', 3, 10)
 		self.open('/proc/net/raw')
 		self.nick = ('soc',)
 		self.vars = ('sockets',)
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		self.fd.seek(0)
 		self.val['sockets'] = len(self.fd.readlines()) - 1
@@ -1146,18 +1088,12 @@
 class dstat_swap(dstat):
 	def __init__(self):
 		self.name = 'swap'
-		self.format = '%s'
-		self.len = 5
+		self.format = ('f', 5, 1024)
 		self.open('/proc/meminfo')
 		self.nick = ('used', 'free')
 		self.vars = ('SwapUsed', 'SwapFree')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		self.fd.seek(0)
 		for line in self.fd.readlines():
@@ -1171,18 +1107,12 @@
 class dstat_sys(dstat):
 	def __init__(self):
 		self.name = 'system'
-		self.format = '%ds'
-		self.len = 5
+		self.format = ('d', 5, 1000)
 		self.open('/proc/stat')
 		self.nick = ('int', 'csw')
 		self.vars = ('intr', 'ctxt')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		self.fd.seek(0)
 		for line in self.fd.readlines():
@@ -1199,18 +1129,12 @@
 class dstat_tcp(dstat):
 	def __init__(self):
 		self.name = 'tcp sockets'
-		self.format = '%is'
-		self.len = 3
+		self.format = ('f', 3, 1024)
 		self.open('/proc/net/tcp')
 		self.nick = ('lis', 'act', 'syn', 'tim')
 		self.vars = ('listen', 'established', 'syn_sent', 'time_wait')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		for name in self.vars: self.val[name] = 0
 		self.fd.seek(0)
@@ -1225,13 +1149,8 @@
 class dstat_time(dstat):
 	def __init__(self):
 		self.name = 'time'
-		self.format = '%10d'
-		self.len = 10
-		### Nice for debugging timer
-#		self.format = '%13.3f'
-#		self.len = 14
-		self.format = '%13.4f'
-		self.len = 15
+		self.format = ('t', 10, 0)
+#		self.format = ('t', 15, 0)
 		self.nick = ('epoch',)
 		self.vars = ('epoch',)
 		self.init(self.vars, 1)
@@ -1239,24 +1158,18 @@
 	def extract(self):
 		self.val['epoch'] = time.time()
 
-	def results(self):
-		return ansi['reset'] + self.format % self.val['epoch']
+#	def __repr__(self):
+#		return ansi['reset'] + self.format % self.val['epoch']
 
 class dstat_udp(dstat):
 	def __init__(self):
 		self.name = 'udp'
-		self.format = '%is'
-		self.len = 3
+		self.format = ('f', 3, 50)
 		self.open('/proc/net/udp')
 		self.nick = ('lis', 'act')
 		self.vars = ('listen', 'established')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		for name in self.vars: self.val[name] = 0
 		self.fd.seek(0)
@@ -1268,18 +1181,12 @@
 class dstat_unix(dstat):
 	def __init__(self):
 		self.name = 'unix sockets'
-		self.format = '%ds'
-		self.len = 4
+		self.format = ('d', 4, 100)
 		self.open('/proc/net/unix')
 		self.nick = ('dgrm', 'strm', 'lis', 'act')
 		self.vars = ('datagram', 'stream', 'listen', 'established')
 		self.init(self.vars, 1)
 
-	def check(self):
-		if self.fd:
-			return True
-		return False
-
 	def extract(self):
 		for name in self.vars: self.val[name] = 0
 		self.fd.seek(0)
@@ -1347,6 +1254,7 @@
 	'colon': ':',
 	'gt': '&gt;',
 	'space': ' ',
+	'dash': '-',
 }
 
 def ticks():
@@ -1364,8 +1272,9 @@
 
 def dopen(file):
 	global fds
-	if not 'fds' in globals(): fds = {}
-	if not file in fds:
+	if not os.path.exists(file): return None
+	if 'fds' not in globals(): fds = {}
+	if file not in fds:
 		fds[file] = open(file, 'r', 0)
 	else:
 		fds[file].seek(0)
@@ -1375,63 +1284,110 @@
 	global fds
 	if not 'fds' in globals(): fds = {}
 	if file in fds:
-		close(fds[file])
+		fds[file].close()
 		del(fds[file])
 
-def convlist(max, list, base = 1024):
-#	max = max / len(list)
-	retlist = ()
+def dchg(var, max, base):
+	c = 0
+	while True:
+		ret = str(int(round(var)))
+		if len(ret) &lt;= max:
+			break
+		var = var / base
+		c = c + 1
+	else:
+		c = -1
+	return ret, c
+
+def fchg(var, max, base):
+	c = 0
+	while True:
+#		ret = repr(round(var))
+#		ret = repr(long(round(var,max)))
+		ret = str(long(round(var,max)))
+		if var == 0:
+			ret = str('0')
+			break
+		if len(ret) &lt;= max:
+			i = max - len(ret)
+			while i &gt; 0:
+				ret = ('%.'+str(i)+'f') % var
+				if len(ret) &lt;= max and ret != repr(round(var)):
+					break
+				i = i - 1
+			else:
+				ret = str(int(round(var)))
+			break
+		var = var / base
+		c = c + 1
+	else:
+		c = -1
+	return ret, c
+
+def cprintlist(list, format):
+	ret = sep = ''
 	for var in list:
-		retlist = retlist + (conv(max, var, base), )
-	return retlist
+		ret = ret + sep + cprint(var, format)
+		sep = ' '
+	return ret
 
-#def convlist(max, list):
-#	return map(conv, list)
+def cprint(var, format = ('f', 4, 1000)):
+	c = -1
+	type = format[0]
+	max = format[1]
+	mp = format[2]
 
-### Use capabilities like: float=true, base=nr, color=true
-def conv(max, var, base = 1024):
+	base = 1000
+	if mp == 1024:
+		base = 1024
+
+	unit = False
+	if mp in (1000, 1024) and max &gt;= len(str(base)):
+		unit = True
+		max = max - 1
+
 	if var &lt; 0:
-		return ansi['default'] + string.rjust('- ', max)
+		if unit:
+			return ansi['default'] + string.rjust('- ', max)
+		else:
+			return ansi['default'] + string.rjust('-', max)
 
-	if step == op.delay:
-		color = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
+	units = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+	if base == 1024:
+		units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+
+	colors = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
+	if step != op.delay:
+		colors = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
+
+	if op.integer and type in ('d', 'p', 'f'):
+		ret, c = dchg(var, max, base)
+	elif type in ('d', 'p'):
+		ret, c = dchg(var, max, base)
+	elif type in ('f', 't'):
+		ret, c = fchg(var, max, base)
 	else:
-		color = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
+		ret = str(var)
 
-	if base in (0, 1, 10):
-		unit = ('', '', '', '', '', '', '', '', '', '', '')
-	elif base == 100:
-		if round(var) == 0:
-			return ansi['default'] + string.rjust('0', max)
-		else:
-			return ansi[color[int(round(var)/34)]] + string.rjust(str(int(round(var))), max)
-	elif base == 1000:
-		unit = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
-	elif base == 1024:
-		### lowercase (b) is better for the eyes than uppercase
-		unit = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+	if ret == '0':
+		color = 'default'
+	elif type in ('d', 'p'):
+		color = colors[int(var/mp)%len(colors)]
+	elif type in ('f'):
+		color = colors[c%len(colors)]
 	else:
-		return ansi['default'] + string.rjust('? ', max)
+		color = 'default'
 
-	c = 0
-	while True:
-		repr = str(int(round(var))) + unit[c]
-		if len(repr) &lt;= max:
-			if not op.integer and (base != 1000 or c &gt; 0):
-				if var != round(var) and len('%1.2f' % var + unit[c]) &lt;= max:
-					repr = '%1.2f' % var + unit[c]
-				elif var != round(var) and len('%1.1f' % var + unit[c]) &lt;= max:
-					repr = '%1.1f' % var + unit[c]
-			else:
-				var = int(round(var))
-			break
-		var = var / base
-		c = c + 1
+	ret = ansi[color] + string.rjust(ret, max)
 
-	if var == 0:
-		return ansi['default'] + string.rjust('0' + ' ' * len(unit[0]), max)
-	return ansi[color[c]] + string.rjust(repr, max)
+	if unit:
+		if c != -1 and var != 0:
+			ret = ret + units[c]
+		else:
+			ret = ret + ' '
 
+	return ret
+
 def showtitle(nr, totlist, vislist, midchar, endchar):
 	line = ''
 	for o in vislist:
@@ -1510,6 +1466,12 @@
 #			if dev == list[0]:
 #				return list[1]
 
+def readfile(file):
+	ret = ''
+	for line in open(file,'r').readlines():
+		ret = ret + line
+	return ret
+
 def signaler(signum, frame):
 	signal.alarm(interval)
 
@@ -1574,19 +1536,26 @@
 		elif mod == 'disk': objs = ( dstat_disk(), dstat_disk24(), dstat_disk24old() )
 		elif mod == 'int':  objs = ( dstat_int(), dstat_int24() )
 		elif mod == 'page': objs = ( dstat_page(), dstat_page24() )
-		elif 'dstat_'+mod in globals():
-			exec(compile('objs = ( dstat_%s(), )' % mod, '&lt;string&gt;', 'exec'))
 		else:
+			if 'dstat_'+mod not in globals():
+				try:
+#					exec(compile('from dstat_%s import *' % mod, '&lt;string&gt;', 'exec'))
+					import imp
+					file, pathname, description = imp.find_module('dstat_'+mod)
+					exec(compile(readfile(pathname), '&lt;string&gt;', 'exec'))
+				except Exception, e:
+					info(1, 'Module &quot;dstat_%s&quot; failed to load. (%s)' % (mod, e))
+					continue
 			try:
-				exec(compile('import dstat_%s\nobjs = ( dstat_%s.dstat_%s(), )' % (mod, mod, mod), '&lt;string&gt;', 'exec'))
+				exec(compile('objs = ( dstat_%s(), )' % mod, '&lt;string&gt;', 'exec'))
 			except Exception, e:
-				info(1, 'Module \'dstat_%s\' does not exist or failed to load. (%s)' % (mod, e))
+				info(1, 'Class &quot;dstat_%s&quot; has problems. (%s)' % (mod, e))
 				continue
 
 		### Remove defect stat objects and calculate line length
 		for o in objs:
 			if o.check():
-				linewidth = linewidth + o.varwidth() + 1
+				linewidth = linewidth + o.statwidth() + 1
 				totlist.append(o)
 				break
 
@@ -1608,20 +1577,25 @@
 	signal.signal(signal.SIGALRM, signaler)
 	signal.alarm(interval)
 
+	tt = 0
+
 	### Let the games begin
 	while update &lt;= op.delay * op.count or op.count == -1:
 
+		if op.debug and step == 1: tt = 0
+		if op.debug: t1 = time.time()
+
 		### Trim object list to what is visible on screen
 		rows, cols = getwinsize()
 		vislist = []
 		curwidth = 0
 		for o in totlist:
-			if curwidth + o.varwidth() + 1 &lt;= cols:
+			if curwidth + o.statwidth() + 1 &lt;= cols:
 				vislist.append(o)
-				curwidth = curwidth + o.varwidth() + 1
-			elif vislist == totlist[:-1] and curwidth + o.varwidth() &lt;= cols:
+				curwidth = curwidth + o.statwidth() + 1
+			elif vislist == totlist[:-1] and curwidth + o.statwidth() &lt;= cols:
 				vislist.append(o)
-				curwidth = curwidth + o.varwidth() + 1
+				curwidth = curwidth + o.statwidth() + 1
 
 		### Check when to display the header
 		if op.header:
@@ -1632,7 +1606,7 @@
 
 		if showheader:
 			if loop == 0 and totlist != vislist:
-				print 'Screen width too small, trimming output.'
+				info(1, 'Screen width too small, trimming output.')
 			showheader = False
 			showtitle(1, totlist, vislist, ansi['darkblue'] + char['space'], ansi['darkblue'] + char['gt'])
 			showtitle(2, totlist, vislist, ansi['silver'] + char['pipe'], ansi['darkblue'] + char['gt'])
@@ -1646,15 +1620,12 @@
 			ansi['default'] = ansi['gray']
 		line = ansi['default']
 
-		### Debugging info
-#		line = line + '[%d:%d:%d] ' % (loop, step, update)
-
 		### Calculate all objects (visible, invisible)
 		oline = ''
 		for o in totlist:
 			o.extract()
 			if o in vislist:
-				line = line + o.results() + o.showend(totlist, vislist)
+				line = line + repr(o) + o.showend(totlist, vislist)
 			if op.output and step == op.delay:
 				oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
 
@@ -1663,21 +1634,21 @@
 		if op.output and step == op.delay:
 			outputfile.write(oline + '\n')
 
+		### Print debugging output
+		if op.debug: t2 = time.time(); tt = tt + (t2 - t1) * 1000
+		if op.debug:
+			if loop == 0: tt = tt * step
+			sys.stdout.write(' %6.3f' % (tt / step))
+		if op.debug &gt; 1:
+			sys.stdout.write(' [%d:%d:%d] ' % (loop, update, step))
+
 		### If intermediate results, update increases with 1 sec (=interval)
 		update = update + interval
 
-		### Debugging/profiling
-#		global t1
-#		if not 't1' in globals(): t1 = tick
-#		sys.stdout.write(' [%4.4f' % (time.time() - t1))
-
 		### Do not pause when this is the final loop
 		if update &lt;= op.delay * op.count or op.count == -1:
 			signal.pause()
 
-		### Debuggine/profiling
-#		t1 = time.time()
-
 		### The last step in a loop is to show the definitive line on its own line
 		if step == op.delay:
 			sys.stdout.write('\n' + ansi['reset'] + ansi['clearline'] + ansi['save'])

Deleted: trunk/tools/dstat/stats/dstat.py
===================================================================
--- trunk/tools/dstat/stats/dstat.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1 +0,0 @@
-link ../dstat
\ No newline at end of file

Modified: trunk/tools/dstat/stats/dstat_battery.py
===================================================================
--- trunk/tools/dstat/stats/dstat_battery.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_battery.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,6 +1,7 @@
-import dstat, string, os
+global string
+import string
 
-class dstat_battery(dstat.dstat):
+class dstat_battery(dstat):
 	def __init__(self):
 		self.name = 'battery'
 		self.format = ('f', 4, 34)
@@ -10,12 +11,12 @@
 
 	def extract(self):
 		for battery in self.vars:
-			for line in dstat.dopen('/proc/acpi/battery/'+battery+'/info').readlines():
+			for line in dopen('/proc/acpi/battery/'+battery+'/info').readlines():
 				l = string.split(line)
 				if len(l) &lt; 4: continue
 				if l[0] == 'last':
 					full = int(l[3])
-			for line in dstat.dopen('/proc/acpi/battery/'+battery+'/state').readlines():
+			for line in dopen('/proc/acpi/battery/'+battery+'/state').readlines():
 				l = string.split(line)
 				if len(l) &lt; 3: continue
 				if l[0] == 'remaining':

Modified: trunk/tools/dstat/stats/dstat_cpufreq.py
===================================================================
--- trunk/tools/dstat/stats/dstat_cpufreq.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_cpufreq.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,6 +1,7 @@
-import dstat, string, os
+global string
+import string
 
-class dstat_cpufreq(dstat.dstat):
+class dstat_cpufreq(dstat):
 	def __init__(self):
 		self.name = 'frequency'
 		self.format = ('p', 4, 34)
@@ -20,14 +21,14 @@
 
 	def extract(self):
 		for cpu in self.vars:
-			for line in dstat.dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_max_freq').readlines():
+			for line in dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_max_freq').readlines():
 				l = string.split(line)
 				max = int(l[0])
-			for line in dstat.dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq').readlines():
+			for line in dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq').readlines():
 				l = string.split(line)
 				cur = int(l[0])
 			### Need to close because of bug in sysfs (?)
-			dstat.dclose('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq')
+			dclose('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq')
 			self.val[cpu] = cur * 100.0 / max
 
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/stats/dstat_dbus.py
===================================================================
--- trunk/tools/dstat/stats/dstat_dbus.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_dbus.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,6 +1,4 @@
-import dstat
-
-class dstat_dbus(dstat.dstat):
+class dstat_dbus(dstat):
 	def __init__(self):
 		self.name = 'dbus'
 		self.format = ('d', 3, 100)

Modified: trunk/tools/dstat/stats/dstat_freespace.py
===================================================================
--- trunk/tools/dstat/stats/dstat_freespace.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_freespace.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,14 +1,12 @@
-import dstat, os
-
 ### FIXME: This module needs infrastructure to provide a list of mountpoints
 
-class dstat_freespace(dstat.dstat):
+class dstat_freespace(dstat):
 	def __init__(self):
 		self.format = ('f', 5, 1024)
 		self.open('/etc/mtab')
 		self.vars = self.vars()
 		self.name = ['/' + os.path.basename(name) for name in self.vars]
-		self.nick = ('free', 'used')
+		self.nick = ('used', 'free')
 		self.init(self.vars, 2)
 
 	def vars(self):
@@ -28,6 +26,6 @@
 	def extract(self):
 		for name in self.vars:
 			res = os.statvfs(name)
-			self.val[name] = ( long(res.f_bavail) * long(res.f_frsize), (long(res.f_blocks) - long(res.f_bavail)) * long(res.f_frsize) )
+			self.val[name] = ( (float(res.f_blocks) - float(res.f_bavail)) * long(res.f_frsize), float(res.f_bavail) * float(res.f_frsize) )
 
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/stats/dstat_postfix.py
===================================================================
--- trunk/tools/dstat/stats/dstat_postfix.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_postfix.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,6 +1,4 @@
-import dstat, os, glob
-
-class dstat_postfix(dstat.dstat):
+class dstat_postfix(dstat):
 	def __init__(self):
 		self.name = 'postfix'
 		self.format = ('d', 4, 100)

Modified: trunk/tools/dstat/stats/dstat_sendmail.py
===================================================================
--- trunk/tools/dstat/stats/dstat_sendmail.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_sendmail.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,8 +1,8 @@
-import dstat, glob
-
 ### FIXME: Should read /var/log/mail/statistics or /etc/mail/statistics (format ?)
+global glob
+import glob
 
-class dstat_sendmail(dstat.dstat):
+class dstat_sendmail(dstat):
 	def __init__(self):
 		self.name = 'sendmail'
 		self.format = ('d', 4, 100)

Modified: trunk/tools/dstat/stats/dstat_thermal.py
===================================================================
--- trunk/tools/dstat/stats/dstat_thermal.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_thermal.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,6 +1,7 @@
-import dstat, string, os
+global string
+import string
 
-class dstat_thermal(dstat.dstat):
+class dstat_thermal(dstat):
 	def __init__(self):
 		self.name = 'thermal'
 		self.format = ('d', 4, 20)
@@ -10,7 +11,7 @@
 
 	def extract(self):
 		for zone in self.vars:
-			for line in dstat.dopen('/proc/acpi/thermal_zone/'+zone+'/temperature').readlines():
+			for line in dopen('/proc/acpi/thermal_zone/'+zone+'/temperature').readlines():
 				l = string.split(line)
 				self.val[zone] = int(l[1])
 

Modified: trunk/tools/dstat/stats/dstat_utmp.py
===================================================================
--- trunk/tools/dstat/stats/dstat_utmp.py	2005-05-11 17:13:28 UTC (rev 3208)
+++ trunk/tools/dstat/stats/dstat_utmp.py	2005-05-12 21:40:44 UTC (rev 3209)
@@ -1,6 +1,4 @@
-import dstat
-
-class dstat_utmp(dstat.dstat):
+class dstat_utmp(dstat):
 	def __init__(self):
 		self.name = 'utmp'
 		self.format = ('d', 3, 10)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002010.html">[svn] r3208 - trunk/rpms/gstreamer-plugins-extras
</A></li>
	<LI>Next message: <A HREF="002012.html">[svn] r3210 - in trunk/tools/dstat: . plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2011">[ date ]</a>
              <a href="thread.html#2011">[ thread ]</a>
              <a href="subject.html#2011">[ subject ]</a>
              <a href="author.html#2011">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
