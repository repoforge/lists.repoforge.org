<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r5391 - in trunk/tools/mrepo: . docs tests
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5391%20-%20in%20trunk/tools/mrepo%3A%20.%20docs%20tests&In-Reply-To=%3C20070512040729.090EE944B64%40pooch.vmhosting.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004189.html">
   <LINK REL="Next"  HREF="004191.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r5391 - in trunk/tools/mrepo: . docs tests</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5391%20-%20in%20trunk/tools/mrepo%3A%20.%20docs%20tests&In-Reply-To=%3C20070512040729.090EE944B64%40pooch.vmhosting.org%3E"
       TITLE="[svn] r5391 - in trunk/tools/mrepo: . docs tests">packagers at lists.rpmforge.net
       </A><BR>
    <I>Sat May 12 06:07:29 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004189.html">[svn] r5390 - trunk/rpms/pam_shield
</A></li>
        <LI>Next message: <A HREF="004191.html">[svn] r5392 - in trunk/tools/dstat: . examples plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4190">[ date ]</a>
              <a href="thread.html#4190">[ thread ]</a>
              <a href="subject.html#4190">[ subject ]</a>
              <a href="author.html#4190">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2007-05-12 06:07:27 +0200 (Sat, 12 May 2007)
New Revision: 5391

Modified:
   trunk/tools/mrepo/docs/Makefile
   trunk/tools/mrepo/gensystemid
   trunk/tools/mrepo/mrepo
   trunk/tools/mrepo/rhnget
   trunk/tools/mrepo/setup.py
   trunk/tools/mrepo/tests/rhn_query.py
   trunk/tools/mrepo/tests/rhn_tool.py
   trunk/tools/mrepo/tests/rhntest.py
Log:
Retab

Modified: trunk/tools/mrepo/docs/Makefile
===================================================================
--- trunk/tools/mrepo/docs/Makefile	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/docs/Makefile	2007-05-12 04:07:27 UTC (rev 5391)
@@ -15,8 +15,7 @@
 srcdir = $(localstatedir)/mrepo
 wwwdir = $(localstatedir)/www/mrepo
 
+all: *.txt
 
-all: .txt
-
 .txt:
 	asciidoc $@

Modified: trunk/tools/mrepo/gensystemid
===================================================================
--- trunk/tools/mrepo/gensystemid	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/gensystemid	2007-05-12 04:07:27 UTC (rev 5391)
@@ -11,126 +11,126 @@
 global cfg, loginInfo
 
 def checkrelease(release, arch):
-	releases = {
-		'5Server': ('i386', 'ia64', 'ppc', 's390', 's390x', 'x86_64'),
-		'5Client': ('i386', 'ia64', 'x86_64'),
-		'4AS': ('i386', 'ia64', 'ppc', 's390', 's390x', 'x86_64'),
-		'4ES': ('i386', 'ia64', 'x86_64'),
-		'4WS': ('i386', 'ia64', 'x86_64'),
-		'4Desktop': ('i386', 'x86_64'),
-		'3AS': ('i386', 'ia64', 'ppc', 's390', 's390x', 'x86_64'),
-		'3ES': ('i386', 'ia64', 'x86_64'),
-		'3WS': ('i386', 'ia64', 'x86_64'),
-		'3Desktop': ('i386', 'x86_64'),
-		'2.1AS': ('i386', 'ia64'),
-		'2.1ES': ('i386', ),
-		'2.1WS': ('i386', ),
-		'2.1AW': ('ia64', ),
-	}
-	if release not in releases.keys():
-		raise Exception, 'Release name %s is not a known RHN release.' % release
-	if arch not in releases[release]:
-		raise Exception, 'RHN release %s does not exist for architecture %s.' % (release, arch)
-	return True
+    releases = {
+        '5Server': ('i386', 'ia64', 'ppc', 's390', 's390x', 'x86_64'),
+        '5Client': ('i386', 'ia64', 'x86_64'),
+        '4AS': ('i386', 'ia64', 'ppc', 's390', 's390x', 'x86_64'),
+        '4ES': ('i386', 'ia64', 'x86_64'),
+        '4WS': ('i386', 'ia64', 'x86_64'),
+        '4Desktop': ('i386', 'x86_64'),
+        '3AS': ('i386', 'ia64', 'ppc', 's390', 's390x', 'x86_64'),
+        '3ES': ('i386', 'ia64', 'x86_64'),
+        '3WS': ('i386', 'ia64', 'x86_64'),
+        '3Desktop': ('i386', 'x86_64'),
+        '2.1AS': ('i386', 'ia64'),
+        '2.1ES': ('i386', ),
+        '2.1WS': ('i386', ),
+        '2.1AW': ('ia64', ),
+    }
+    if release not in releases.keys():
+        raise Exception, 'Release name %s is not a known RHN release.' % release
+    if arch not in releases[release]:
+        raise Exception, 'RHN release %s does not exist for architecture %s.' % (release, arch)
+    return True
 
 def lowarch(arch):
-	archs = {
-		'i386': ['i486', 'i586', 'i686', 'athlon'],
-		'ia64': [],
-		'ppc': ['ppc64', 'ppc64pseries', 'ppc64iseries'],
-		'x86_64': [],
-		's390': [],
-		's390x': [],
-	}
-	for key in archs:
-		if arch == key:
-			return arch
-		elif arch in archs[key]:
-			return key
-	else:
-		print 'gensystemid: Architecture %s unknown' % arch
-		return None
+    archs = {
+        'i386': ['i486', 'i586', 'i686', 'athlon'],
+        'ia64': [],
+        'ppc': ['ppc64', 'ppc64pseries', 'ppc64iseries'],
+        'x86_64': [],
+        's390': [],
+        's390x': [],
+    }
+    for key in archs:
+        if arch == key:
+            return arch
+        elif arch in archs[key]:
+            return key
+    else:
+        print 'gensystemid: Architecture %s unknown' % arch
+        return None
 
 class Options:
-	def __init__(self, args):
-		self.arch = None
-		self.hostname = None
-		self.paths = None
-		self.quiet = False
-		self.rhnpassword = None
-		self.rhnrelease = None
-		self.rhnusername = None
-		self.verbose = 1
+    def __init__(self, args):
+        self.arch = None
+        self.hostname = None
+        self.paths = None
+        self.quiet = False
+        self.rhnpassword = None
+        self.rhnrelease = None
+        self.rhnusername = None
+        self.verbose = 1
 
-		try:
-			opts, args = getopt.getopt (args, 'a:hqp:r:u:v',
-				['arch=', 'hostname=', 'quiet', 'release=', 'help', 'verbose', 'version'])
-		except getopt.error, exc:
-			print 'gensystemid: %s, try gensystemid -h for a list of all the options' % str(exc)
-			sys.exit(1)
+        try:
+            opts, args = getopt.getopt (args, 'a:hqp:r:u:v',
+                ['arch=', 'hostname=', 'quiet', 'release=', 'help', 'verbose', 'version'])
+        except getopt.error, exc:
+            print 'gensystemid: %s, try gensystemid -h for a list of all the options' % str(exc)
+            sys.exit(1)
 
-		for opt, arg in opts:
-			if opt in ['-a', '--arch']:
-				self.arch = arg
-			elif opt in ['--hostname']:
-				self.hostname = arg
-			elif opt in ['-p', '--password']:
-				self.rhnpassword = arg
-			elif opt in ['-q', '--quiet']:
-				self.quiet = True
-			elif opt in ['-r', '--release']:
-				self.rhnrelease = arg
-			elif opt in ['-u', '--username']:
-				self.rhnusername = arg
-			elif opt in ['-h', '--help']:
-				self.usage()
-				self.help()
-				sys.exit(0)
-			elif opt in ['-v', '--verbose']:
-				self.verbose = self.verbose + 1
-			elif opt in ['--version']:
-				self.version()
-				sys.exit(0)
+        for opt, arg in opts:
+            if opt in ['-a', '--arch']:
+                self.arch = arg
+            elif opt in ['--hostname']:
+                self.hostname = arg
+            elif opt in ['-p', '--password']:
+                self.rhnpassword = arg
+            elif opt in ['-q', '--quiet']:
+                self.quiet = True
+            elif opt in ['-r', '--release']:
+                self.rhnrelease = arg
+            elif opt in ['-u', '--username']:
+                self.rhnusername = arg
+            elif opt in ['-h', '--help']:
+                self.usage()
+                self.help()
+                sys.exit(0)
+            elif opt in ['-v', '--verbose']:
+                self.verbose = self.verbose + 1
+            elif opt in ['--version']:
+                self.version()
+                sys.exit(0)
 
-		if self.quiet:
-			self.verbose = 0
+        if self.quiet:
+            self.verbose = 0
 
-		if self.verbose &gt;= 3:
-			print 'Verbosity set to level %d' % self.verbose
+        if self.verbose &gt;= 3:
+            print 'Verbosity set to level %d' % self.verbose
 
-		if not self.arch:
-			self.arch = lowarch(os.uname()[4])
-			print 'gensystemid: Architecture not supplied, using system architecture %s' % self.arch
+        if not self.arch:
+            self.arch = lowarch(os.uname()[4])
+            print 'gensystemid: Architecture not supplied, using system architecture %s' % self.arch
 
-		if not self.hostname:
-			self.hostname = '%s-%s-%s-mrepo' % (os.uname()[1].split('.')[0], self.rhnrelease, lowarch(self.arch))
+        if not self.hostname:
+            self.hostname = '%s-%s-%s-mrepo' % (os.uname()[1].split('.')[0], self.rhnrelease, lowarch(self.arch))
 
-		try:
-			checkrelease(self.rhnrelease, self.arch)
-		except Exception, e:
-			print 'gensystemid:', e
-			sys.exit(2)
+        try:
+            checkrelease(self.rhnrelease, self.arch)
+        except Exception, e:
+            print 'gensystemid:', e
+            sys.exit(2)
 
-		if len(args) &lt;= 0:
-			print 'gensystemid: no destination path given'
-			sys.exit(1)
+        if len(args) &lt;= 0:
+            print 'gensystemid: no destination path given'
+            sys.exit(1)
 
-		self.paths = args
+        self.paths = args
 
-	def version(self):
-		print 'gensystemid %s' % VERSION
-		print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
-		print
-		print 'platform %s/%s' % (os.name, sys.platform)
-		print 'python %s' % sys.version
-		print
-		print 'build revision $Rev: 4107 $'
+    def version(self):
+        print 'gensystemid %s' % VERSION
+        print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
+        print
+        print 'platform %s/%s' % (os.name, sys.platform)
+        print 'python %s' % sys.version
+        print
+        print 'build revision $Rev: 4107 $'
 
-	def usage(self):
-		print 'usage: gensystemid -r release [-a arch] [-p password] [-q] [-u username] [-v] dir1 dir2 ...'
+    def usage(self):
+        print 'usage: gensystemid -r release [-a arch] [-p password] [-q] [-u username] [-v] dir1 dir2 ...'
 
-	def help(self):
-		print '''Generate a custom RHN systemid
+    def help(self):
+        print '''Generate a custom RHN systemid
 
 gensystemid options:
   -a, --arch=arch              specify architecture (i386, x86_64, ppc, ia64)
@@ -147,101 +147,101 @@
 loginInfo = {}
 
 def error(level, str):
-	&quot;Output error message&quot;
-	if level &lt;= op.verbose:
-		sys.stdout.write('gensystemid: %s\n' % str)
+    &quot;Output error message&quot;
+    if level &lt;= op.verbose:
+        sys.stdout.write('gensystemid: %s\n' % str)
 
 def info(level, str):
-	&quot;Output info message&quot;
-	if level &lt;= op.verbose:
-		sys.stdout.write('%s\n' % str)
+    &quot;Output info message&quot;
+    if level &lt;= op.verbose:
+        sys.stdout.write('%s\n' % str)
 
 def die(ret, str):
-	&quot;Print error and exit with errorcode&quot;
-	error(0, str)
-	sys.exit(ret)
+    &quot;Print error and exit with errorcode&quot;
+    error(0, str)
+    sys.exit(ret)
 
 def main():
-	if not op.rhnusername:
-		op.rhnusername = raw_input('RHN Username: ')
+    if not op.rhnusername:
+        op.rhnusername = raw_input('RHN Username: ')
 
-	if not op.rhnpassword:
-		op.rhnpassword = getpass.getpass('RHN Password: ')
+    if not op.rhnpassword:
+        op.rhnpassword = getpass.getpass('RHN Password: ')
 
-	rhnsystemid = '/tmp/systemid'
-	if os.path.isfile(rhnsystemid):
-		os.remove(rhnsystemid)
-	info(5, 'Using RHN systemid from %s' % rhnsystemid)
+    rhnsystemid = '/tmp/systemid'
+    if os.path.isfile(rhnsystemid):
+        os.remove(rhnsystemid)
+    info(5, 'Using RHN systemid from %s' % rhnsystemid)
 
-	cfg = {}
-	loginInfo = {}
+    cfg = {}
+    loginInfo = {}
 
-	cfg['systemIdPath'] = rhnsystemid
-	cfg = config.initUp2dateConfig()
-	cfg['systemIdPath'] = rhnsystemid
-	cfg['useRhn'] = 1
+    cfg['systemIdPath'] = rhnsystemid
+    cfg = config.initUp2dateConfig()
+    cfg['systemIdPath'] = rhnsystemid
+    cfg['useRhn'] = 1
 
-	if op.rhnrelease:
-		cfg['versionOverride'] = op.rhnrelease
+    if op.rhnrelease:
+        cfg['versionOverride'] = op.rhnrelease
 
-	if op.arch:
-		cfg['forceArch'] = '%s-redhat-linux' % op.arch
+    if op.arch:
+        cfg['forceArch'] = '%s-redhat-linux' % op.arch
 
-	if os.access('/var/log/up2date', os.W_OK):
-		cfg['logFile'] = '/var/log/up2date'
-	else:
-		cfg['logFile'] = os.path.expanduser('~/up2date.log')
+    if os.access('/var/log/up2date', os.W_OK):
+        cfg['logFile'] = '/var/log/up2date'
+    else:
+        cfg['logFile'] = os.path.expanduser('~/up2date.log')
 
-	### Get proxy information from environment and set up2date config accordingly
-	proxy = None
-	if os.environ.has_key('http_proxy'):
-		t, proxy, t, t, t, t = urlparse.urlparse(os.environ['http_proxy'])
-	elif os.environ.has_key('https_proxy'):
-		t, proxy, t, t, t, t = urlparse.urlparse(os.environ['https_proxy'])
-	if proxy:
-		cfg['enableProxy'] = 1
-		cfg['httpProxy'] = proxy
-		info(4, 'Setting proxy to %s' % proxy)
-		### FIXME: Implement proxy authentication
-#		if proxy.username and proxy.password:
-#			cfg['enableProxyAuth'] = 1
-#			cfg['proxyPassword'] = proxy.password
-#			cfg['proxyUser='] = proxy.username
+    ### Get proxy information from environment and set up2date config accordingly
+    proxy = None
+    if os.environ.has_key('http_proxy'):
+        t, proxy, t, t, t, t = urlparse.urlparse(os.environ['http_proxy'])
+    elif os.environ.has_key('https_proxy'):
+        t, proxy, t, t, t, t = urlparse.urlparse(os.environ['https_proxy'])
+    if proxy:
+        cfg['enableProxy'] = 1
+        cfg['httpProxy'] = proxy
+        info(4, 'Setting proxy to %s' % proxy)
+        ### FIXME: Implement proxy authentication
+#       if proxy.username and proxy.password:
+#           cfg['enableProxyAuth'] = 1
+#           cfg['proxyPassword'] = proxy.password
+#           cfg['proxyUser='] = proxy.username
 
 
-	if op.verbose &gt;= 5:
-		cfg['debug'] = 10000
+    if op.verbose &gt;= 5:
+        cfg['debug'] = 10000
 
-	### FIXME: Insert correct release_name (eg. redhat-release-es) only for RHEL2.1
-	auth = {
-			'profile_name': op.hostname,
-			'os_release': op.rhnrelease,
-			'release_name': 'redhat-release',
-			'architecture': '%s-redhat-linux' % op.arch,
-			'username': op.rhnusername,
-			'password': op.rhnpassword,
-			'uuid': '',
-			'rhnuuid': '',
-	}
+    ### FIXME: Insert correct release_name (eg. redhat-release-es) only for RHEL2.1
+    auth = {
+            'profile_name': op.hostname,
+            'os_release': op.rhnrelease,
+            'release_name': 'redhat-release',
+            'architecture': '%s-redhat-linux' % op.arch,
+            'username': op.rhnusername,
+            'password': op.rhnpassword,
+            'uuid': '',
+            'rhnuuid': '',
+    }
 
-	s = rpcServer.getServer()
-	try:
-		systemid = rpcServer.doCall(s.registration.new_user, op.rhnusername, op.rhnpassword)
-	except rpclib.Fault, f:
-		error(0, 'Error registering user. %s' % f.faultString)
-		sys.exit(1)
-		
-	s = rpcServer.getServer()
-	try:
-		systemid = rpcServer.doCall(s.registration.new_system, auth)
-	except rpclib.Fault, f:
-		error(0, 'Error registering system. %s' % f.faultString)
-		sys.exit(1)
+    s = rpcServer.getServer()
+    try:
+        systemid = rpcServer.doCall(s.registration.new_user, op.rhnusername, op.rhnpassword)
+    except rpclib.Fault, f:
+        error(0, 'Error registering user. %s' % f.faultString)
+        sys.exit(1)
+        
+    s = rpcServer.getServer()
+    try:
+        systemid = rpcServer.doCall(s.registration.new_system, auth)
+    except rpclib.Fault, f:
+        error(0, 'Error registering system. %s' % f.faultString)
+        sys.exit(1)
 
-	for path in op.paths:
-		file = os.path.join(path, 'systemid')
-		info(1, 'Writing out file %s' % file)
-		open(file, 'w').write(systemid)
+    for path in op.paths:
+        file = os.path.join(path, 'systemid')
+        info(1, 'Writing out file %s' % file)
+        open(file, 'w').write(systemid)
 
 ### Unbuffered sys.stdout
 sys.stdout = os.fdopen(1, 'w', 0)
@@ -258,13 +258,13 @@
 
 ### Main entrance
 if __name__ == '__main__':
-	op = Options(sys.argv[1:])
-	try:
-		main()
-	except KeyboardInterrupt, e:
-		die(6, 'Exiting on user request')
-	except OSError, e:
-#		print e.errno
-		die(7, 'OSError: %s' % e)
+    op = Options(sys.argv[1:])
+    try:
+        main()
+    except KeyboardInterrupt, e:
+        die(6, 'Exiting on user request')
+    except OSError, e:
+#       print e.errno
+        die(7, 'OSError: %s' % e)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/mrepo/mrepo
===================================================================
--- trunk/tools/mrepo/mrepo	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/mrepo	2007-05-12 04:07:27 UTC (rev 5391)
@@ -24,13 +24,13 @@
 VERSION = '0.8.4svn'
 
 archs = {
-	'alpha': ('alpha', 'alphaev5', 'alphaev56', 'alphaev6', 'alphaev67'),
-	'i386': ('i386', 'i486', 'i586', 'i686', 'athlon'),
-	'ia64': ('i386', 'i686', 'ia64'),
-	'ppc': ('ppc', 'ppc64', 'ppc64pseries', 'ppc64iseries'),
-	'x86_64': ('i386', 'i486', 'i586', 'i686', 'athlon', 'x86_64', 'amd64'),
-	's390': ('s390', ),
-	's390x': ('s390x', ),
+    'alpha': ('alpha', 'alphaev5', 'alphaev56', 'alphaev6', 'alphaev67'),
+    'i386': ('i386', 'i486', 'i586', 'i686', 'athlon'),
+    'ia64': ('i386', 'i686', 'ia64'),
+    'ppc': ('ppc', 'ppc64', 'ppc64pseries', 'ppc64iseries'),
+    'x86_64': ('i386', 'i486', 'i586', 'i686', 'athlon', 'x86_64', 'amd64'),
+    's390': ('s390', ),
+    's390x': ('s390x', ),
 }
 
 variables = {}
@@ -40,98 +40,98 @@
 
 ### Register rhn and rhns as a known schemes
 for scheme in ('rhn', 'rhns'):
-	urlparse.uses_netloc.insert(0, scheme)
-	urlparse.uses_query.insert(0, scheme)
+    urlparse.uses_netloc.insert(0, scheme)
+    urlparse.uses_query.insert(0, scheme)
 
 class Options:
-	def __init__(self, args):
-		self.configfile = '/etc/mrepo.conf'
-		self.dists = []
-		self.rhnrelease = None
-		self.force = False
-		self.dryrun = False
-		self.generate = False
-		self.quiet = False
-		self.remount = False
-		self.repos = []
-		self.types = []
-		self.umount = False
-		self.update = False
-		self.verbose = 1
+    def __init__(self, args):
+        self.configfile = '/etc/mrepo.conf'
+        self.dists = []
+        self.rhnrelease = None
+        self.force = False
+        self.dryrun = False
+        self.generate = False
+        self.quiet = False
+        self.remount = False
+        self.repos = []
+        self.types = []
+        self.umount = False
+        self.update = False
+        self.verbose = 1
 
-		try:
-			opts, args = getopt.getopt (args, 'c:d:fghnqr:t:uvx',
-				('config=', 'dist=', 'dryrun', 'force', 'generate', 'help', 'quiet', 'repo',
-				'remount', 'type=', 'umount', 'unmount', 'update', 'verbose', 'version', 'extras'))
-		except getopt.error, exc:
-			print 'mrepo: %s, try mrepo -h for a list of all the options' % str(exc)
-			sys.exit(1)
+        try:
+            opts, args = getopt.getopt (args, 'c:d:fghnqr:t:uvx',
+                ('config=', 'dist=', 'dryrun', 'force', 'generate', 'help', 'quiet', 'repo',
+                'remount', 'type=', 'umount', 'unmount', 'update', 'verbose', 'version', 'extras'))
+        except getopt.error, exc:
+            print 'mrepo: %s, try mrepo -h for a list of all the options' % str(exc)
+            sys.exit(1)
 
-		for opt, arg in opts:
-			if opt in ('-c', '--config'):
-				self.configfile = os.path.abspath(arg)
-			elif opt in ('-d', '--dist'):
-				print 'mrepo: the use of -d or --dist as an option is deprecated, use the argument list'
-				self.dists = self.dists + arg.split(',')
-			elif opt in ('-f', '--force'):
-				self.force = True
-			elif opt in ('-g', '--generate'):
-				self.generate = True
-			elif opt in ('-h', '--help'):
-				self.usage()
-				print
-				self.help()
-				sys.exit(0)
-			elif opt in ('-n', '--dry-run'):
-				self.dryrun = True
-			elif opt in ('-q', '--quiet'):
-				self.quiet = True
-			elif opt in ('-r', '--repo'):
-				self.repos = self.repos + arg.split(',')
-			elif opt in ('--remount', ):
-				self.remount = True
-			elif opt in ('-t', '--type'):
-				self.types = self.types + arg.split(',')
-			elif opt in ('-u', '--update'):
-				self.update = True
-			elif opt in ('--umount', '--unmount'):
-				self.umount = True
-			elif opt in ('-v', '--verbose'):
-				self.verbose = self.verbose + 1
-			elif opt in ('--version', ):
-				self.version()
-				sys.exit(0)
-			elif opt in ('-x', '--extras'):
-				print 'mrepo: the use of -x or --extras is deprecated, use -u and -r instead'
-				self.update = True
+        for opt, arg in opts:
+            if opt in ('-c', '--config'):
+                self.configfile = os.path.abspath(arg)
+            elif opt in ('-d', '--dist'):
+                print 'mrepo: the use of -d or --dist as an option is deprecated, use the argument list'
+                self.dists = self.dists + arg.split(',')
+            elif opt in ('-f', '--force'):
+                self.force = True
+            elif opt in ('-g', '--generate'):
+                self.generate = True
+            elif opt in ('-h', '--help'):
+                self.usage()
+                print
+                self.help()
+                sys.exit(0)
+            elif opt in ('-n', '--dry-run'):
+                self.dryrun = True
+            elif opt in ('-q', '--quiet'):
+                self.quiet = True
+            elif opt in ('-r', '--repo'):
+                self.repos = self.repos + arg.split(',')
+            elif opt in ('--remount', ):
+                self.remount = True
+            elif opt in ('-t', '--type'):
+                self.types = self.types + arg.split(',')
+            elif opt in ('-u', '--update'):
+                self.update = True
+            elif opt in ('--umount', '--unmount'):
+                self.umount = True
+            elif opt in ('-v', '--verbose'):
+                self.verbose = self.verbose + 1
+            elif opt in ('--version', ):
+                self.version()
+                sys.exit(0)
+            elif opt in ('-x', '--extras'):
+                print 'mrepo: the use of -x or --extras is deprecated, use -u and -r instead'
+                self.update = True
 
-		if not self.types:
-			self.types = ['file', 'fish', 'ftp', 'http', 'https', 'mc', 'rhn', 'rhns', 'rsync', 'sftp', 'mrepo']
+        if not self.types:
+            self.types = ['file', 'fish', 'ftp', 'http', 'https', 'mc', 'rhn', 'rhns', 'rsync', 'sftp', 'mrepo']
 
-		for arg in args:
-			self.dists = self.dists + arg.split(',')
+        for arg in args:
+            self.dists = self.dists + arg.split(',')
 
-		if self.quiet:
-			self.verbose = 0
+        if self.quiet:
+            self.verbose = 0
 
-		if self.verbose &gt;= 3:
-			print 'Verbosity set to level %d' % (self.verbose - 1)
-			print 'Using configfile %s' % self.configfile
+        if self.verbose &gt;= 3:
+            print 'Verbosity set to level %d' % (self.verbose - 1)
+            print 'Using configfile %s' % self.configfile
 
-	def version(self):
-		print 'mrepo %s' % VERSION
-		print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
-		print
-		print 'platform %s/%s' % (os.name, sys.platform)
-		print 'python %s' % sys.version
-		print
-		print 'build revision $Rev$'
+    def version(self):
+        print 'mrepo %s' % VERSION
+        print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
+        print
+        print 'platform %s/%s' % (os.name, sys.platform)
+        print 'python %s' % sys.version
+        print
+        print 'build revision $Rev$'
 
-	def usage(self):
-		print 'usage: mrepo [options] dist1 [dist2-arch ..]'
+    def usage(self):
+        print 'usage: mrepo [options] dist1 [dist2-arch ..]'
 
-	def help(self):
-		print '''Set up a distribution server from ISO files
+    def help(self):
+        print '''Set up a distribution server from ISO files
 
 mrepo options:
   -c, --config=file       specify alternative configfile
@@ -148,1289 +148,1289 @@
 '''
 
 class Config:
-	def __init__(self):
-		self.read(op.configfile)
+    def __init__(self):
+        self.read(op.configfile)
 
-		self.cachedir = self.getoption('main', 'cachedir', '/var/cache/mrepo')
-		self.lockdir = self.getoption('main', 'lockdir', '/var/cache/mrepo')
-		self.confdir = self.getoption('main', 'confdir', '/etc/mrepo.conf.d')
-		self.htmldir = self.getoption('main', 'htmldir', '/usr/share/mrepo/html')
-		self.pxelinux = self.getoption('main', 'pxelinux', '/usr/lib/syslinux/pxelinux.0')
-		self.srcdir = self.getoption('main', 'srcdir', '/var/mrepo')
-		self.tftpdir = self.getoption('main', 'tftpdir', '/tftpboot/mrepo')
-		self.wwwdir = self.getoption('main', 'wwwdir', '/var/www/mrepo')
-		self.logfile = self.getoption('main', 'logfile', '/var/log/mrepo.log')
+        self.cachedir = self.getoption('main', 'cachedir', '/var/cache/mrepo')
+        self.lockdir = self.getoption('main', 'lockdir', '/var/cache/mrepo')
+        self.confdir = self.getoption('main', 'confdir', '/etc/mrepo.conf.d')
+        self.htmldir = self.getoption('main', 'htmldir', '/usr/share/mrepo/html')
+        self.pxelinux = self.getoption('main', 'pxelinux', '/usr/lib/syslinux/pxelinux.0')
+        self.srcdir = self.getoption('main', 'srcdir', '/var/mrepo')
+        self.tftpdir = self.getoption('main', 'tftpdir', '/tftpboot/mrepo')
+        self.wwwdir = self.getoption('main', 'wwwdir', '/var/www/mrepo')
+        self.logfile = self.getoption('main', 'logfile', '/var/log/mrepo.log')
 
-		self.mailto = self.getoption('main', 'mailto', None)
-		self.mailfrom = self.getoption('main', 'mailfrom', 'mrepo@%s' % os.uname()[1])
-		self.smtpserver = self.getoption('main', 'smtp-server', 'localhost')
+        self.mailto = self.getoption('main', 'mailto', None)
+        self.mailfrom = self.getoption('main', 'mailfrom', 'mrepo@%s' % os.uname()[1])
+        self.smtpserver = self.getoption('main', 'smtp-server', 'localhost')
 
-		self.arch = self.getoption('main', 'arch', 'i386')
-		self.metadata = self.getoption('main', 'metadata', 'repomd repoview')
+        self.arch = self.getoption('main', 'arch', 'i386')
+        self.metadata = self.getoption('main', 'metadata', 'repomd repoview')
 
-		self.shareiso = self.getoption('main', 'shareiso', 'yes') not in disable
+        self.shareiso = self.getoption('main', 'shareiso', 'yes') not in disable
 
-		self.quiet = self.getoption('main', 'quiet', 'no') not in disable
-		if op.verbose == 1 and self.quiet:
-			op.verbose = 0
+        self.quiet = self.getoption('main', 'quiet', 'no') not in disable
+        if op.verbose == 1 and self.quiet:
+            op.verbose = 0
 
-		self.hardlink = self.getoption('main', 'hardlink', 'no') not in disable
+        self.hardlink = self.getoption('main', 'hardlink', 'no') not in disable
 
-		self.no_proxy = self.getoption('main', 'no_proxy', None)
-		self.ftp_proxy = self.getoption('main', 'ftp_proxy', None)
-		self.http_proxy = self.getoption('main', 'http_proxy', None)
-		self.https_proxy = self.getoption('main', 'https_proxy', None)
+        self.no_proxy = self.getoption('main', 'no_proxy', None)
+        self.ftp_proxy = self.getoption('main', 'ftp_proxy', None)
+        self.http_proxy = self.getoption('main', 'http_proxy', None)
+        self.https_proxy = self.getoption('main', 'https_proxy', None)
 
-		self.cmd = {}
-		self.cmd['createrepo'] = self.getoption('main', 'createrepocmd', '/usr/bin/createrepo')
-		self.cmd['genbasedir'] = self.getoption('main', 'genbasedircmd', '/usr/bin/genbasedir')
-		self.cmd['hardlink'] = self.getoption('main', 'hardlinkcmd', '/usr/sbin/hardlink')
-		self.cmd['hardlink++'] = self.getoption('main', 'hardlinkpluscmd', '/usr/bin/hardlink++')
-		self.cmd['lftp'] = self.getoption('main', 'lftpcmd', '/usr/bin/lftp')
-		self.cmd['mirrordir'] = self.getoption('main', 'mirrordircmd', '/usr/bin/mirrordir')
-		self.cmd['mount'] = self.getoption('main', 'mountcmd', '/bin/mount')
-		self.cmd['repoview'] = self.getoption('main', 'repoviewcmd', '/usr/bin/repoview')
-		self.cmd['rhnget'] = self.getoption('main', 'rhngetcmd', '/usr/bin/rhnget')
-		self.cmd['rsync'] = self.getoption('main', 'rsynccmd', '/usr/bin/rsync')
-		self.cmd['umount'] = self.getoption('main', 'umountcmd', '/bin/umount')
-		self.cmd['yumarch'] = self.getoption('main', 'yumarchcmd', '/usr/bin/yum-arch')
+        self.cmd = {}
+        self.cmd['createrepo'] = self.getoption('main', 'createrepocmd', '/usr/bin/createrepo')
+        self.cmd['genbasedir'] = self.getoption('main', 'genbasedircmd', '/usr/bin/genbasedir')
+        self.cmd['hardlink'] = self.getoption('main', 'hardlinkcmd', '/usr/sbin/hardlink')
+        self.cmd['hardlink++'] = self.getoption('main', 'hardlinkpluscmd', '/usr/bin/hardlink++')
+        self.cmd['lftp'] = self.getoption('main', 'lftpcmd', '/usr/bin/lftp')
+        self.cmd['mirrordir'] = self.getoption('main', 'mirrordircmd', '/usr/bin/mirrordir')
+        self.cmd['mount'] = self.getoption('main', 'mountcmd', '/bin/mount')
+        self.cmd['repoview'] = self.getoption('main', 'repoviewcmd', '/usr/bin/repoview')
+        self.cmd['rhnget'] = self.getoption('main', 'rhngetcmd', '/usr/bin/rhnget')
+        self.cmd['rsync'] = self.getoption('main', 'rsynccmd', '/usr/bin/rsync')
+        self.cmd['umount'] = self.getoption('main', 'umountcmd', '/bin/umount')
+        self.cmd['yumarch'] = self.getoption('main', 'yumarchcmd', '/usr/bin/yum-arch')
 
-		self.createrepooptions = self.getoption('main', 'createrepo-options', '-p')
+        self.createrepooptions = self.getoption('main', 'createrepo-options', '-p')
 
-		self.lftpbwlimit = self.getoption('main', 'lftp-bandwidth-limit', None)
-		self.lftpcleanup = self.getoption('main', 'lftp-cleanup', 'yes') not in disable
-		self.lftpexcldebug = self.getoption('main', 'lftp-exclude-debug', 'yes') not in disable
-		self.lftpexclsrpm = self.getoption('main', 'lftp-exclude-srpm', 'yes') not in disable
-		self.lftpoptions = self.getoption('main', 'lftp-options', '')
-		self.lftpcommands = self.getoption('main', 'lftp-commands', '')
-		self.lftpmirroroptions = self.getoption('main', 'lftp-mirror-options', '-c -P')
-		self.lftptimeout = self.getoption('main', 'lftp-timeout', None)
+        self.lftpbwlimit = self.getoption('main', 'lftp-bandwidth-limit', None)
+        self.lftpcleanup = self.getoption('main', 'lftp-cleanup', 'yes') not in disable
+        self.lftpexcldebug = self.getoption('main', 'lftp-exclude-debug', 'yes') not in disable
+        self.lftpexclsrpm = self.getoption('main', 'lftp-exclude-srpm', 'yes') not in disable
+        self.lftpoptions = self.getoption('main', 'lftp-options', '')
+        self.lftpcommands = self.getoption('main', 'lftp-commands', '')
+        self.lftpmirroroptions = self.getoption('main', 'lftp-mirror-options', '-c -P')
+        self.lftptimeout = self.getoption('main', 'lftp-timeout', None)
 
-		self.mirrordircleanup = self.getoption('main', 'mirrordir-cleanup', 'yes') not in disable
-		self.mirrordirexcldebug = self.getoption('main', 'mirrordir-exclude-debug', 'yes') not in disable
-		self.mirrordirexclsrpm = self.getoption('main', 'mirrordir-exclude-srpm', 'yes') not in disable
-		self.mirrordiroptions = self.getoption('main', 'mirrordir-options', '')
+        self.mirrordircleanup = self.getoption('main', 'mirrordir-cleanup', 'yes') not in disable
+        self.mirrordirexcldebug = self.getoption('main', 'mirrordir-exclude-debug', 'yes') not in disable
+        self.mirrordirexclsrpm = self.getoption('main', 'mirrordir-exclude-srpm', 'yes') not in disable
+        self.mirrordiroptions = self.getoption('main', 'mirrordir-options', '')
 
-		self.rhnlogin = self.getoption('main', 'rhnlogin', None)
-		self.rhngetoptions = self.getoption('main', 'rhnget-options', '')
-		self.rhngetcleanup = self.getoption('main', 'rhnget-cleanup', 'yes') not in disable
-		self.rhngetdownloadall = self.getoption('main', 'rhnget-download-all', 'no') not in disable
+        self.rhnlogin = self.getoption('main', 'rhnlogin', None)
+        self.rhngetoptions = self.getoption('main', 'rhnget-options', '')
+        self.rhngetcleanup = self.getoption('main', 'rhnget-cleanup', 'yes') not in disable
+        self.rhngetdownloadall = self.getoption('main', 'rhnget-download-all', 'no') not in disable
 
-		self.rsyncbwlimit = self.getoption('main', 'rsync-bandwidth-limit', None)
-		self.rsynccleanup = self.getoption('main', 'rsync-cleanup', 'yes') not in disable
-		self.rsyncexcldebug = self.getoption('main', 'rsync-exclude-debug', 'yes') not in disable
-		self.rsyncexclsrpm = self.getoption('main', 'rsync-exclude-srpm', 'yes') not in disable
-		self.rsyncoptions = self.getoption('main', 'rsync-options', '-rtHL --partial')
-		self.rsynctimeout = self.getoption('main', 'rsync-timeout', None)
+        self.rsyncbwlimit = self.getoption('main', 'rsync-bandwidth-limit', None)
+        self.rsynccleanup = self.getoption('main', 'rsync-cleanup', 'yes') not in disable
+        self.rsyncexcldebug = self.getoption('main', 'rsync-exclude-debug', 'yes') not in disable
+        self.rsyncexclsrpm = self.getoption('main', 'rsync-exclude-srpm', 'yes') not in disable
+        self.rsyncoptions = self.getoption('main', 'rsync-options', '-rtHL --partial')
+        self.rsynctimeout = self.getoption('main', 'rsync-timeout', None)
 
-		self.repoviewoptions = self.getoption('main', 'repoview-options', '')
+        self.repoviewoptions = self.getoption('main', 'repoview-options', '')
 
-		self.alldists = []
-		self.dists = []
+        self.alldists = []
+        self.dists = []
 
-		self.update(op.configfile)
+        self.update(op.configfile)
 
-	def read(self, configfile):
-		self.cfg = ConfigParser.ConfigParser()
+    def read(self, configfile):
+        self.cfg = ConfigParser.ConfigParser()
 
-		info(4, 'Reading config file %s' % (configfile))
+        info(4, 'Reading config file %s' % (configfile))
 
-		(s,b,p,q,f,o) = urlparse.urlparse(configfile)
-		if s in ('http', 'ftp', 'file'):
-			configfh = urllib.urlopen(configfile)
-			try:
-				self.cfg.readfp(configfh)
-			except ConfigParser.MissingSectionHeaderError, e:
-				die(6, 'Error accessing URL: %s' % configfile)
-		else:
-			if os.access(configfile, os.R_OK):
-				try:
-					self.cfg.read(configfile)
-				except:
-					die(7, 'Syntax error reading file: %s' % configfile)
-			else:
-				die(6, 'Error accessing file: %s' % configfile)
+        (s,b,p,q,f,o) = urlparse.urlparse(configfile)
+        if s in ('http', 'ftp', 'file'):
+            configfh = urllib.urlopen(configfile)
+            try:
+                self.cfg.readfp(configfh)
+            except ConfigParser.MissingSectionHeaderError, e:
+                die(6, 'Error accessing URL: %s' % configfile)
+        else:
+            if os.access(configfile, os.R_OK):
+                try:
+                    self.cfg.read(configfile)
+                except:
+                    die(7, 'Syntax error reading file: %s' % configfile)
+            else:
+                die(6, 'Error accessing file: %s' % configfile)
 
-	def update(self, configfile):
-		for section in ('variables', 'vars', 'DEFAULT'):
-			if section in self.cfg.sections():
-				for option in self.cfg.options(section):
-					variables[option] = self.cfg.get(section, option)
-			
-		for section in self.cfg.sections():
-			if section in ('main', 'repos', 'variables', 'vars', 'DEFAULT'):
-				continue
-			else:
-				### Check if section has appended arch
-				for arch in archs.keys():
-					if section.endswith('-%s' % arch):
-						archlist = ( arch, )
-						distname = section.split('-%s' % arch)[0]
-						break
-				else:
-					archlist = self.getoption(section, 'arch', self.arch).split()
-					distname = section
+    def update(self, configfile):
+        for section in ('variables', 'vars', 'DEFAULT'):
+            if section in self.cfg.sections():
+                for option in self.cfg.options(section):
+                    variables[option] = self.cfg.get(section, option)
+            
+        for section in self.cfg.sections():
+            if section in ('main', 'repos', 'variables', 'vars', 'DEFAULT'):
+                continue
+            else:
+                ### Check if section has appended arch
+                for arch in archs.keys():
+                    if section.endswith('-%s' % arch):
+                        archlist = ( arch, )
+                        distname = section.split('-%s' % arch)[0]
+                        break
+                else:
+                    archlist = self.getoption(section, 'arch', self.arch).split()
+                    distname = section
 
-				### Add a distribution for each arch
-				for arch in archlist:
-					dist = Dist(distname, arch, self)
-					dist.arch = arch
-					dist.metadata = self.metadata.split()
-					dist.enabled = True
-					dist.promoteepoch = True
-					for option in self.cfg.options(section):
-						if option in ('iso', 'name', 'release', 'repo', 'rhnrelease'):
-							setattr(dist, option, self.cfg.get(section, option))
-						elif option in ('arch', 'dist'):
-							pass
-						elif option in ('disabled',):
-							dist.enabled = self.cfg.get(section, option) in disable
-						elif option in ('metadata',):
-							setattr(dist, option, self.cfg.get(section, option).split())
-						elif option in ('promoteepoch',):
-							dist.promoteepoch = self.cfg.get(section, option) not in disable
-						else:
-							dist.repos.append(Repo(option, self.cfg.get(section, option), dist, self))
+                ### Add a distribution for each arch
+                for arch in archlist:
+                    dist = Dist(distname, arch, self)
+                    dist.arch = arch
+                    dist.metadata = self.metadata.split()
+                    dist.enabled = True
+                    dist.promoteepoch = True
+                    for option in self.cfg.options(section):
+                        if option in ('iso', 'name', 'release', 'repo', 'rhnrelease'):
+                            setattr(dist, option, self.cfg.get(section, option))
+                        elif option in ('arch', 'dist'):
+                            pass
+                        elif option in ('disabled',):
+                            dist.enabled = self.cfg.get(section, option) in disable
+                        elif option in ('metadata',):
+                            setattr(dist, option, self.cfg.get(section, option).split())
+                        elif option in ('promoteepoch',):
+                            dist.promoteepoch = self.cfg.get(section, option) not in disable
+                        else:
+                            dist.repos.append(Repo(option, self.cfg.get(section, option), dist, self))
 
-					dist.repos.sort(reposort)
-					dist.rewrite()
+                    dist.repos.sort(reposort)
+                    dist.rewrite()
 
-					self.alldists.append(dist)
+                    self.alldists.append(dist)
 
-					if dist.enabled:
-						self.dists.append(dist)
-					else:
-						info(5, '%s: %s is disabled' % (dist.nick, dist.name))
+                    if dist.enabled:
+                        self.dists.append(dist)
+                    else:
+                        info(5, '%s: %s is disabled' % (dist.nick, dist.name))
 
-		self.alldists.sort(distsort)
-		self.dists.sort(distsort)
+        self.alldists.sort(distsort)
+        self.dists.sort(distsort)
 
-	def getoption(self, section, option, var):
-		&quot;Get an option from a section from configfile&quot;
-		try:
-			var = self.cfg.get(section, option)
-			info(2, 'Setting option %s in section [%s] to: %s' % (option, section, var))
-		except ConfigParser.NoSectionError, e:
-			error(5, 'Failed to find section [%s]' % section)
-		except ConfigParser.NoOptionError, e:
-#			error(4, 'Failed to find option %s in [%s], set to default: %s' % (option, section, var))
-			info(5, 'Setting option %s in section [%s] to: %s (default)' % (option, section, var))
-		return var
+    def getoption(self, section, option, var):
+        &quot;Get an option from a section from configfile&quot;
+        try:
+            var = self.cfg.get(section, option)
+            info(2, 'Setting option %s in section [%s] to: %s' % (option, section, var))
+        except ConfigParser.NoSectionError, e:
+            error(5, 'Failed to find section [%s]' % section)
+        except ConfigParser.NoOptionError, e:
+#           error(4, 'Failed to find option %s in [%s], set to default: %s' % (option, section, var))
+            info(5, 'Setting option %s in section [%s] to: %s (default)' % (option, section, var))
+        return var
 
 class Dist:
-	def __init__(self, dist, arch, cf):
-		self.arch = arch
-		self.dist = dist
-		self.nick = dist + '-' + arch
-		if arch == 'none':
-			self.nick = dist
-		self.name = dist
-		self.dir = os.path.join(cf.wwwdir, self.nick)
-		self.iso = None
-		self.release = None
-		self.repos = []
-		self.rhnrelease = None
-		self.srcdir = cf.srcdir
-		self.discs = ()
-		self.isos = []
-		self.disabled = False
+    def __init__(self, dist, arch, cf):
+        self.arch = arch
+        self.dist = dist
+        self.nick = dist + '-' + arch
+        if arch == 'none':
+            self.nick = dist
+        self.name = dist
+        self.dir = os.path.join(cf.wwwdir, self.nick)
+        self.iso = None
+        self.release = None
+        self.repos = []
+        self.rhnrelease = None
+        self.srcdir = cf.srcdir
+        self.discs = ()
+        self.isos = []
+        self.disabled = False
 
-#	def __repr__(self):
-#		for key, value in vars(self).iteritems():
-#			if isinstance(value, types.StringType):
-#				print key, '-&gt;', value
+#   def __repr__(self):
+#       for key, value in vars(self).iteritems():
+#           if isinstance(value, types.StringType):
+#               print key, '-&gt;', value
 
-	def rewrite(self):
-		&quot;Rewrite (string) attributes to replace variables by other (string) attributes&quot;
-		list = variables
-		list.update({ 'arch': self.arch, 'nick': self.nick, 'dist': self.dist,
-				'release': self.release, 'rhnrelease': self.rhnrelease })
-		for key, value in vars(self).iteritems():
-			if isinstance(value, types.StringType):
-				setattr(self, key, substitute(value, list))
-		for repo in self.repos:
-			list['repo'] = repo.name
-			repo.url = substitute(repo.url, list)
+    def rewrite(self):
+        &quot;Rewrite (string) attributes to replace variables by other (string) attributes&quot;
+        list = variables
+        list.update({ 'arch': self.arch, 'nick': self.nick, 'dist': self.dist,
+                'release': self.release, 'rhnrelease': self.rhnrelease })
+        for key, value in vars(self).iteritems():
+            if isinstance(value, types.StringType):
+                setattr(self, key, substitute(value, list))
+        for repo in self.repos:
+            list['repo'] = repo.name
+            repo.url = substitute(repo.url, list)
 
-	def findisos(self):
-		&quot;Return a list of existing ISO files&quot;
-		if not self.iso: return
-		if not self.isos:
-			for file in self.iso.split(' '):
-				file = os.path.basename(file)
-				absfile = file
-				if not os.path.isabs(file):
-					absfile = os.path.join(cf.srcdir, self.nick, file)
-					info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
-					list = glob.glob(absfile)
-				if not list:
-					absfile = os.path.join(cf.srcdir, self.dist, file)
-					info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
-					list = glob.glob(absfile)
-				if not list:
-					absfile = os.path.join(cf.srcdir, 'iso', file)
-					info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
-					list = glob.glob(absfile)
-				if not list:
-					absfile = os.path.join(cf.srcdir, file)
-					info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
-					list = glob.glob(absfile)
-				list.sort()
-				for iso in list:
-					if os.path.isfile(iso) and iso not in self.isos:
-						self.isos.append(iso)
-		if self.isos:
-			info(5, '%s: Found %d ISO files at %s' % (self.nick, len(self.isos), absfile))
-			self.repos.append(Repo('os', '', self, cf))
-			self.repos.sort(reposort)
-		else:
-			info(4, '%s: No ISO files found !' % self.nick)
+    def findisos(self):
+        &quot;Return a list of existing ISO files&quot;
+        if not self.iso: return
+        if not self.isos:
+            for file in self.iso.split(' '):
+                file = os.path.basename(file)
+                absfile = file
+                if not os.path.isabs(file):
+                    absfile = os.path.join(cf.srcdir, self.nick, file)
+                    info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
+                    list = glob.glob(absfile)
+                if not list:
+                    absfile = os.path.join(cf.srcdir, self.dist, file)
+                    info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
+                    list = glob.glob(absfile)
+                if not list:
+                    absfile = os.path.join(cf.srcdir, 'iso', file)
+                    info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
+                    list = glob.glob(absfile)
+                if not list:
+                    absfile = os.path.join(cf.srcdir, file)
+                    info(6, '%s: Looking for ISO files matching %s' % (self.nick, absfile))
+                    list = glob.glob(absfile)
+                list.sort()
+                for iso in list:
+                    if os.path.isfile(iso) and iso not in self.isos:
+                        self.isos.append(iso)
+        if self.isos:
+            info(5, '%s: Found %d ISO files at %s' % (self.nick, len(self.isos), absfile))
+            self.repos.append(Repo('os', '', self, cf))
+            self.repos.sort(reposort)
+        else:
+            info(4, '%s: No ISO files found !' % self.nick)
 
-	def listrepos(self, names=None):
-		ret = []
-		for repo in self.repos:
-			if not names:
-				ret.append(repo)
-			elif repo.name in names:
-				ret.append(repo)
-		return ret
+    def listrepos(self, names=None):
+        ret = []
+        for repo in self.repos:
+            if not names:
+                ret.append(repo)
+            elif repo.name in names:
+                ret.append(repo)
+        return ret
 
-	def mount(self):
-		&quot;Loopback mount all ISOs&quot;
-		discs = []
-		discnr = 0
-		if cf.shareiso:
-			mkdir(os.path.join(self.dir, 'iso'))
-		else:
-			remove(os.path.join(self.dir, 'iso'))
-		regexp = re.compile('.+[_-]CD[0-9]?\..+')
-		opts = '-o loop,ro'
-		if readfile('/selinux/enforce') == '1':
-			opts = opts + ',context=system_u:object_r:httpd_sys_content_t'
-		for iso in self.isos:
-			if cf.shareiso:
-				symlink(iso, os.path.join(self.dir, 'iso'))
-			discnr = discnr + 1
-			discstr = 'disc'
-			if regexp.match(iso, 1):
-				discstr = 'CD'
-			disc = '%s%s' % (discstr, discnr)
-			discs.append(disc)
-			mount = os.path.join(self.dir, disc)
-			if not os.path.isfile(cf.cmd['mount']):
-				die(4, 'mount command not %s' % cf.cmd['mount'])
-			mount2 = mountpoint(iso) 
-			if mount2:
-				if mount2 != mount:
-					if os.path.exists(mount):
-						remove(mount)
-					info(5, '%s: %s already mounted, symlink ISO to %s' % (self.nick, os.path.basename(iso), mount))
-					symlink(mount2, mount)
-			else:
-				if os.path.exists(mount) and not os.path.isdir(mount):
-					os.rename(mount, os.tempnam(os.path.dirname(mount), 'bak-'))
-				mkdir(mount)
-				if not os.path.ismount(mount):
-					info(2, '%s: Mount ISO %s to %s' % (self.nick, os.path.basename(iso), mount))
-					run('%s %s %s %s' % (cf.cmd['mount'], opts, iso, mount))
-		return discs
-	
-	def umount(self):
-		&quot;Umount all mounted ISOs&quot;
-		discnr = 0
-		regexp = re.compile('.+[_-]CD[0-9]?\..+')
-		for iso in self.isos:
-			discnr = discnr + 1
-			discstr = 'disc'
-			if regexp.match(iso, 1):
-				discstr = 'CD'
-			mount = os.path.join(self.dir, discstr + str(discnr))
-			if not os.path.isfile(cf.cmd['umount']):
-				die(5, 'umount command not %s' % cf.cmd['umount'])
-			if os.path.ismount(mount):
-				info(2, '%s: Unmount ISO %s from %s' % (self.nick, os.path.basename(iso), mount))
-				run('%s %s' % (cf.cmd['umount'], mount))
+    def mount(self):
+        &quot;Loopback mount all ISOs&quot;
+        discs = []
+        discnr = 0
+        if cf.shareiso:
+            mkdir(os.path.join(self.dir, 'iso'))
+        else:
+            remove(os.path.join(self.dir, 'iso'))
+        regexp = re.compile('.+[_-]CD[0-9]?\..+')
+        opts = '-o loop,ro'
+        if readfile('/selinux/enforce') == '1':
+            opts = opts + ',context=system_u:object_r:httpd_sys_content_t'
+        for iso in self.isos:
+            if cf.shareiso:
+                symlink(iso, os.path.join(self.dir, 'iso'))
+            discnr = discnr + 1
+            discstr = 'disc'
+            if regexp.match(iso, 1):
+                discstr = 'CD'
+            disc = '%s%s' % (discstr, discnr)
+            discs.append(disc)
+            mount = os.path.join(self.dir, disc)
+            if not os.path.isfile(cf.cmd['mount']):
+                die(4, 'mount command not %s' % cf.cmd['mount'])
+            mount2 = mountpoint(iso) 
+            if mount2:
+                if mount2 != mount:
+                    if os.path.exists(mount):
+                        remove(mount)
+                    info(5, '%s: %s already mounted, symlink ISO to %s' % (self.nick, os.path.basename(iso), mount))
+                    symlink(mount2, mount)
+            else:
+                if os.path.exists(mount) and not os.path.isdir(mount):
+                    os.rename(mount, os.tempnam(os.path.dirname(mount), 'bak-'))
+                mkdir(mount)
+                if not os.path.ismount(mount):
+                    info(2, '%s: Mount ISO %s to %s' % (self.nick, os.path.basename(iso), mount))
+                    run('%s %s %s %s' % (cf.cmd['mount'], opts, iso, mount))
+        return discs
+    
+    def umount(self):
+        &quot;Umount all mounted ISOs&quot;
+        discnr = 0
+        regexp = re.compile('.+[_-]CD[0-9]?\..+')
+        for iso in self.isos:
+            discnr = discnr + 1
+            discstr = 'disc'
+            if regexp.match(iso, 1):
+                discstr = 'CD'
+            mount = os.path.join(self.dir, discstr + str(discnr))
+            if not os.path.isfile(cf.cmd['umount']):
+                die(5, 'umount command not %s' % cf.cmd['umount'])
+            if os.path.ismount(mount):
+                info(2, '%s: Unmount ISO %s from %s' % (self.nick, os.path.basename(iso), mount))
+                run('%s %s' % (cf.cmd['umount'], mount))
 
-	def pxe(self):
-		&quot;Create PXE boot setup&quot;
-		tftpbootdir = os.path.dirname(cf.tftpdir)
-		if cf.tftpdir and tftpbootdir and os.path.isdir(cf.tftpdir):
-			tftpdir = os.path.join(cf.tftpdir, self.nick)
-			mkdir(tftpdir)
-			info(1, '%s: Symlink pxe boot files to %s ' % (self.nick, tftpdir))
-			mkdir(os.path.join(tftpdir, 'pxelinux.cfg'))
+    def pxe(self):
+        &quot;Create PXE boot setup&quot;
+        tftpbootdir = os.path.dirname(cf.tftpdir)
+        if cf.tftpdir and tftpbootdir and os.path.isdir(cf.tftpdir):
+            tftpdir = os.path.join(cf.tftpdir, self.nick)
+            mkdir(tftpdir)
+            info(1, '%s: Symlink pxe boot files to %s ' % (self.nick, tftpdir))
+            mkdir(os.path.join(tftpdir, 'pxelinux.cfg'))
 
-			### For Red Hat
-			for file in glob.glob(self.dir + '/disc1/images/pxeboot/initrd*.img'):
-				copy(file, tftpdir)
-			for file in glob.glob(self.dir + '/disc1/images/pxeboot/vmlinuz'):
-				copy(file, tftpdir)
+            ### For Red Hat
+            for file in glob.glob(self.dir + '/disc1/images/pxeboot/initrd*.img'):
+                copy(file, tftpdir)
+            for file in glob.glob(self.dir + '/disc1/images/pxeboot/vmlinuz'):
+                copy(file, tftpdir)
 
-			if cf.pxelinux:
-				copy(cf.pxelinux, tftpdir)
+            if cf.pxelinux:
+                copy(cf.pxelinux, tftpdir)
 
-	def html(self):
-		&quot;Put html information in repository&quot;
-		mkdir(self.dir)
-		if not op.dryrun:
-			open(os.path.join(self.dir, '.title'), 'w').write(self.name)
-		symlink(os.path.join(cf.htmldir, 'HEADER.repo.shtml'), os.path.join(self.dir, 'HEADER.shtml'))
-		symlink(os.path.join(cf.htmldir, 'README.repo.shtml'), os.path.join(self.dir, 'README.shtml'))
+    def html(self):
+        &quot;Put html information in repository&quot;
+        mkdir(self.dir)
+        if not op.dryrun:
+            open(os.path.join(self.dir, '.title'), 'w').write(self.name)
+        symlink(os.path.join(cf.htmldir, 'HEADER.repo.shtml'), os.path.join(self.dir, 'HEADER.shtml'))
+        symlink(os.path.join(cf.htmldir, 'README.repo.shtml'), os.path.join(self.dir, 'README.shtml'))
 
 class Repo:
-	def __init__(self, name, url, dist, cf):
-		self.name = name
-		self.url = url
-		self.dist = dist
-		self.srcdir = os.path.join(cf.srcdir, dist.nick, self.name)
-		self.wwwdir = os.path.join(cf.wwwdir, dist.nick, 'RPMS.' + self.name)
+    def __init__(self, name, url, dist, cf):
+        self.name = name
+        self.url = url
+        self.dist = dist
+        self.srcdir = os.path.join(cf.srcdir, dist.nick, self.name)
+        self.wwwdir = os.path.join(cf.wwwdir, dist.nick, 'RPMS.' + self.name)
 
-		self.changed = False
+        self.changed = False
 
-		self.oldlist = Set()
-		self.newlist = Set()
+        self.oldlist = Set()
+        self.newlist = Set()
 
-	def __repr__(self):
-#		return &quot;%s/%s&quot; % (self.dist.nick, self.name)
-		return self.name
+    def __repr__(self):
+#       return &quot;%s/%s&quot; % (self.dist.nick, self.name)
+        return self.name
 
-	def mirror(self):
-		&quot;Check URL and pass on to mirror-functions.&quot;
-		global exitcode
+    def mirror(self):
+        &quot;Check URL and pass on to mirror-functions.&quot;
+        global exitcode
 
-		### Do not mirror for repository 'all'
-		if self.name == 'all':
-			return
+        ### Do not mirror for repository 'all'
+        if self.name == 'all':
+            return
 
-		### Make a snapshot of the directory
-		self.oldlist = self.rpmlist()
-		self.newlist = self.oldlist
+        ### Make a snapshot of the directory
+        self.oldlist = self.rpmlist()
+        self.newlist = self.oldlist
 
-		for url in self.url.split():
-			try:
-				info(2, '%s: Mirror packages from %s to %s' % (self.dist.nick, url, self.srcdir))
-				s, l, p, q, f, o = urlparse.urlparse(url)
-				if s not in op.types:
-					info(4, 'Ignoring mirror action for type %s' % s)
-					continue
-				if s in ('rsync', ):
-					mirrorrsync(url, self.srcdir)
-				elif s in ('ftp', ):
-					if cf.cmd['mirrordir']:
-						mirrormirrordir(url, self.srcdir)
-					else:
-						mirrorlftp(url, self.srcdir)
-				elif s in ('fish', 'http', 'https', 'sftp'):
-					mirrorlftp(url, self.srcdir)
-				elif s in ('file', ''):
-					mirrorfile(url, self.srcdir)
-				elif s in ('mrepo', ):
-					mirrormrepo(url, self.srcdir)
-				elif s in ('mc', ):
-					mirrormirrordir(url, self.srcdir)
-				elif s in ('rhn', 'rhns'):
-					mirrorrhnget(url, self.srcdir, self.dist)
-				else:
-					error(2, 'Scheme %<A HREF="s://">s://</A> not implemented yet (in %s)' % (s, url))
-			except mrepoMirrorException, e:
-				error(0, 'Mirroring failed for %s with message:\n  %s' % (url, e.value))
-				exitcode = 2
-		if not self.url:
-			### Create directory in case no URL is given
-			mkdir(self.srcdir)
+        for url in self.url.split():
+            try:
+                info(2, '%s: Mirror packages from %s to %s' % (self.dist.nick, url, self.srcdir))
+                s, l, p, q, f, o = urlparse.urlparse(url)
+                if s not in op.types:
+                    info(4, 'Ignoring mirror action for type %s' % s)
+                    continue
+                if s in ('rsync', ):
+                    mirrorrsync(url, self.srcdir)
+                elif s in ('ftp', ):
+                    if cf.cmd['mirrordir']:
+                        mirrormirrordir(url, self.srcdir)
+                    else:
+                        mirrorlftp(url, self.srcdir)
+                elif s in ('fish', 'http', 'https', 'sftp'):
+                    mirrorlftp(url, self.srcdir)
+                elif s in ('file', ''):
+                    mirrorfile(url, self.srcdir)
+                elif s in ('mrepo', ):
+                    mirrormrepo(url, self.srcdir)
+                elif s in ('mc', ):
+                    mirrormirrordir(url, self.srcdir)
+                elif s in ('rhn', 'rhns'):
+                    mirrorrhnget(url, self.srcdir, self.dist)
+                else:
+                    error(2, 'Scheme %<A HREF="s://">s://</A> not implemented yet (in %s)' % (s, url))
+            except mrepoMirrorException, e:
+                error(0, 'Mirroring failed for %s with message:\n  %s' % (url, e.value))
+                exitcode = 2
+        if not self.url:
+            ### Create directory in case no URL is given
+            mkdir(self.srcdir)
 
-		### Make a snapshot of the directory
-		self.newlist = self.rpmlist()
+        ### Make a snapshot of the directory
+        self.newlist = self.rpmlist()
 
-	def clean(self):
-		info(5, '%s: Removing %s symlinks' % (self.dist.nick, self.name))
-		mkdir(self.wwwdir)
-		remove(glob.glob(os.path.join(self.wwwdir, '*.rpm')))
+    def clean(self):
+        info(5, '%s: Removing %s symlinks' % (self.dist.nick, self.name))
+        mkdir(self.wwwdir)
+        remove(glob.glob(os.path.join(self.wwwdir, '*.rpm')))
 
-	def linkall(self):
-		&quot;Symlink all RPM packages that match a given arch&quot;
-		srcdir = os.path.join(cf.srcdir, 'all', self.name)
-		info(5, '%s: Symlink %s packages from %s' % (self.dist.nick, self.name, srcdir))
-		os.path.walk(os.path.join(cf.srcdir, 'all', self.name), rpmlink, (self.dist, self.name))
+    def linkall(self):
+        &quot;Symlink all RPM packages that match a given arch&quot;
+        srcdir = os.path.join(cf.srcdir, 'all', self.name)
+        info(5, '%s: Symlink %s packages from %s' % (self.dist.nick, self.name, srcdir))
+        os.path.walk(os.path.join(cf.srcdir, 'all', self.name), rpmlink, (self.dist, self.name))
 
-	def link(self, srcdir=None):
-		&quot;Symlink all RPM packages that match a given arch&quot;
+    def link(self, srcdir=None):
+        &quot;Symlink all RPM packages that match a given arch&quot;
 
-		mkdir(self.wwwdir)
-		mkdir(os.path.join(cf.wwwdir, self.dist.nick, 'RPMS.all'))
+        mkdir(self.wwwdir)
+        mkdir(os.path.join(cf.wwwdir, self.dist.nick, 'RPMS.all'))
 
-		if not srcdir:
-			srcdir = self.srcdir
+        if not srcdir:
+            srcdir = self.srcdir
 
-		info(5, '%s: Symlink %s packages from %s' % (self.dist.nick, self.name, srcdir))
-		os.path.walk(srcdir, rpmlink, (self.dist, self.name))
+        info(5, '%s: Symlink %s packages from %s' % (self.dist.nick, self.name, srcdir))
+        os.path.walk(srcdir, rpmlink, (self.dist, self.name))
 
-	def rpmlist(self):
-		&quot;Capture a list of packages in the repository&quot;
-		list = Set()
+    def rpmlist(self):
+        &quot;Capture a list of packages in the repository&quot;
+        list = Set()
 
-		### os.walk() is a python 2.4 feature
-#		for root, dirs, files in os.walk(self.srcdir):
-#			for file in files:
-#				if os.path.exists(file) and file.endswith('.rpm'):
-#					size = os.stat(os.path.join(root, file)).st_size
-#					list.add( (file, size) )
+        ### os.walk() is a python 2.4 feature
+#       for root, dirs, files in os.walk(self.srcdir):
+#           for file in files:
+#               if os.path.exists(file) and file.endswith('.rpm'):
+#                   size = os.stat(os.path.join(root, file)).st_size
+#                   list.add( (file, size) )
 
-		### os.path.walk() goes back further
-		def addfile((list, ), path, files):
-			for file in files:
-				if os.path.exists(os.path.join(path, file)) and file.endswith('.rpm'):
-					size = os.stat(os.path.join(path, file)).st_size
-					list.add( (file, size) )
+        ### os.path.walk() goes back further
+        def addfile((list, ), path, files):
+            for file in files:
+                if os.path.exists(os.path.join(path, file)) and file.endswith('.rpm'):
+                    size = os.stat(os.path.join(path, file)).st_size
+                    list.add( (file, size) )
 
-		os.path.walk(self.srcdir, addfile, (list,))
-		list.sort()
-		return list
+        os.path.walk(self.srcdir, addfile, (list,))
+        list.sort()
+        return list
 
-	def check(self):
-		&quot;Return what repositories require an update and write .newsha1sum&quot;
-		if not os.path.isdir(self.wwwdir):
-			return
-		sha1file = os.path.join(self.wwwdir, '.sha1sum')
-		remove(sha1file + '.tmp')
-		cursha1 = sha1dir(self.wwwdir)
-		if op.force:
-			pass
-		elif os.path.isfile(sha1file):
-			oldsha1 = open(sha1file).read()
-			if cursha1 != oldsha1:
-				info(2, '%s: Repository %s has new packages.' % (self.dist.nick, self.name))
-			else:
-				info(5, '%s: Repository %s has not changed. Skipping.' % (self.dist.nick, self.name))
-				return
-		else:
-			info(5, '%s: New repository %s detected.' % (self.dist.nick, self.name))
-		writesha1(sha1file + '.tmp', cursha1)
-		self.changed = True
+    def check(self):
+        &quot;Return what repositories require an update and write .newsha1sum&quot;
+        if not os.path.isdir(self.wwwdir):
+            return
+        sha1file = os.path.join(self.wwwdir, '.sha1sum')
+        remove(sha1file + '.tmp')
+        cursha1 = sha1dir(self.wwwdir)
+        if op.force:
+            pass
+        elif os.path.isfile(sha1file):
+            oldsha1 = open(sha1file).read()
+            if cursha1 != oldsha1:
+                info(2, '%s: Repository %s has new packages.' % (self.dist.nick, self.name))
+            else:
+                info(5, '%s: Repository %s has not changed. Skipping.' % (self.dist.nick, self.name))
+                return
+        else:
+            info(5, '%s: New repository %s detected.' % (self.dist.nick, self.name))
+        writesha1(sha1file + '.tmp', cursha1)
+        self.changed = True
 
-	def writesha1(self):
-		&quot;Verify .newsha1sum and write a .sha1sum file per repository&quot;
-		### FIXME: Repository 'all' got lost when introducing Repo class
-		sha1file = os.path.join(self.wwwdir, '.sha1sum')
-		if os.path.isfile(sha1file + '.tmp'):
-			cursha1 = sha1dir(self.wwwdir)
-			tmpsha1 = open(sha1file + '.tmp').read()
-			remove(sha1file + '.tmp')
-			if cursha1 == tmpsha1:
-				writesha1(sha1file, cursha1)
-			else:
-				info(5, '%s: Checksum is different. expect: %s, got: %s' % (self.dist.nick, cursha1, tmpsha1))
-				info(1, '%s: Directory changed during generating %s repo, please generate again.' % (self.dist.nick, self.name))
+    def writesha1(self):
+        &quot;Verify .newsha1sum and write a .sha1sum file per repository&quot;
+        ### FIXME: Repository 'all' got lost when introducing Repo class
+        sha1file = os.path.join(self.wwwdir, '.sha1sum')
+        if os.path.isfile(sha1file + '.tmp'):
+            cursha1 = sha1dir(self.wwwdir)
+            tmpsha1 = open(sha1file + '.tmp').read()
+            remove(sha1file + '.tmp')
+            if cursha1 == tmpsha1:
+                writesha1(sha1file, cursha1)
+            else:
+                info(5, '%s: Checksum is different. expect: %s, got: %s' % (self.dist.nick, cursha1, tmpsha1))
+                info(1, '%s: Directory changed during generating %s repo, please generate again.' % (self.dist.nick, self.name))
 
-	def lock(self, action):
-		if op.dryrun:
-			return True
-		lockfile = os.path.join(cf.lockdir, self.dist.nick, action + '-' + self.name + '.lock')
-		mkdir(os.path.dirname(lockfile))
-		try:
-			fd = os.open(lockfile, os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0600)
-			info(6, '%s: Setting lock %s' % (self.dist.nick, lockfile))
-			os.write(fd, '%d' % os.getpid())
-			os.close(fd)
-			return True
-		except:
-			if os.path.exists(lockfile):
-				pid = open(lockfile).read()
-				if os.path.exists('/proc/%s' % pid):
-					error(0, '%s: Found existing lock %s owned by pid %s' % (self.dist.nick, lockfile, pid))
-				else:
-					info(6, '%s: Removing stale lock %s' % (self.dist.nick, lockfile))
-					os.unlink(lockfile)
-					self.lock(action)
-					return True
-			else:
-				error(0, '%s: Lockfile %s does not exist. Cannot lock. Parallel universe ?' % (self.dist.nick, lockfile))
-		return False
+    def lock(self, action):
+        if op.dryrun:
+            return True
+        lockfile = os.path.join(cf.lockdir, self.dist.nick, action + '-' + self.name + '.lock')
+        mkdir(os.path.dirname(lockfile))
+        try:
+            fd = os.open(lockfile, os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0600)
+            info(6, '%s: Setting lock %s' % (self.dist.nick, lockfile))
+            os.write(fd, '%d' % os.getpid())
+            os.close(fd)
+            return True
+        except:
+            if os.path.exists(lockfile):
+                pid = open(lockfile).read()
+                if os.path.exists('/proc/%s' % pid):
+                    error(0, '%s: Found existing lock %s owned by pid %s' % (self.dist.nick, lockfile, pid))
+                else:
+                    info(6, '%s: Removing stale lock %s' % (self.dist.nick, lockfile))
+                    os.unlink(lockfile)
+                    self.lock(action)
+                    return True
+            else:
+                error(0, '%s: Lockfile %s does not exist. Cannot lock. Parallel universe ?' % (self.dist.nick, lockfile))
+        return False
 
-	def unlock(self, action):
-		if op.dryrun:
-			return True
-		lockfile = os.path.join(cf.lockdir, self.dist.nick, action + '-' + self.name + '.lock')
-		info(6, '%s: Removing lock %s' % (self.dist.nick, lockfile))
-		if os.path.exists(lockfile):
-			pid = open(lockfile).read()
-			if pid == '%s' % os.getpid():
-				os.unlink(lockfile)
-			else:
-				error(0, '%s: Existing lock %s found owned by another process with pid %s. This should NOT happen.' % (self.dist.nick, lockfile, pid))
-		else:
-			error(0, '%s: Lockfile %s does not exist. Cannot unlock. Something fishy here ?' % (self.dist.nick, lockfile))
-	
-	def createmd(self):
-		metadata = ('apt', 'createrepo', 'repomd', 'repoview', 'yum')
-		index = ('repoview',)
+    def unlock(self, action):
+        if op.dryrun:
+            return True
+        lockfile = os.path.join(cf.lockdir, self.dist.nick, action + '-' + self.name + '.lock')
+        info(6, '%s: Removing lock %s' % (self.dist.nick, lockfile))
+        if os.path.exists(lockfile):
+            pid = open(lockfile).read()
+            if pid == '%s' % os.getpid():
+                os.unlink(lockfile)
+            else:
+                error(0, '%s: Existing lock %s found owned by another process with pid %s. This should NOT happen.' % (self.dist.nick, lockfile, pid))
+        else:
+            error(0, '%s: Lockfile %s does not exist. Cannot unlock. Something fishy here ?' % (self.dist.nick, lockfile))
+    
+    def createmd(self):
+        metadata = ('apt', 'createrepo', 'repomd', 'repoview', 'yum')
+        index = ('repoview',)
 
-		if not self.changed and not op.force:
-			return
+        if not self.changed and not op.force:
+            return
 
-		try:
-			### Generate repository metadata
-			for md in self.dist.metadata:
-				if md in ('createrepo', 'repomd'):
-					self.repomd()
-				elif md in ('yum',):
-					self.yum()
-				elif md in ('apt',):
-					self.apt()
-				elif md not in index:
-					error(0, 'The %s metadata is unknown.' % md)
+        try:
+            ### Generate repository metadata
+            for md in self.dist.metadata:
+                if md in ('createrepo', 'repomd'):
+                    self.repomd()
+                elif md in ('yum',):
+                    self.yum()
+                elif md in ('apt',):
+                    self.apt()
+                elif md not in index:
+                    error(0, 'The %s metadata is unknown.' % md)
 
-			### Generate repository index
-			for md in self.dist.metadata:
-				if md in ('repoview',):
-					self.repoview()
-				elif md not in metadata: 
-					error(0, 'The %s index is unknown.' % md)
-		except mrepoGenerateException, e:
-			error(0, 'Generating repo failed for %s with message:\n  %s' % (self.name, e.value))
-			exitcode = 2
-		
+            ### Generate repository index
+            for md in self.dist.metadata:
+                if md in ('repoview',):
+                    self.repoview()
+                elif md not in metadata: 
+                    error(0, 'The %s index is unknown.' % md)
+        except mrepoGenerateException, e:
+            error(0, 'Generating repo failed for %s with message:\n  %s' % (self.name, e.value))
+            exitcode = 2
+        
 
-	def repomd(self):
-		&quot;Create a repomd repository&quot;
-		if not cf.cmd['createrepo']:
-			raise mrepoGenerateException('Command createrepo is not found. Skipping.')
-		opts = ' ' + cf.createrepooptions
-		if op.force:
-			opts = ' --pretty'
-		if op.verbose &lt;= 2:
-			opts = ' --quiet' + opts
-		elif op.verbose &gt;= 4:
-			opts = ' -v' + opts
-		if not self.dist.promoteepoch:
-			opts = opts + ' -n'
-		if os.path.isdir(self.wwwdir):
-			repoopts = opts
-			if cf.cachedir:
-				cachedir = os.path.join(cf.cachedir, self.dist.nick, self.name)
-				mkdir(cachedir)
-				repoopts = repoopts + ' --cachedir &quot;%s&quot;' % cachedir
-			if os.path.isdir(os.path.join(self.wwwdir, '.olddata')):
-				remove(os.path.join(self.wwwdir, '.olddata'))
-			groupfile = os.path.join(cf.srcdir, self.dist.nick, self.name + '-comps.xml')
-			if os.path.isfile(groupfile):
-				symlink(groupfile, os.path.join(self.wwwdir, 'comps.xml'))
-				repoopts = repoopts + ' --groupfile &quot;RPMS.%s/comps.xml&quot;' % self.name
-			info(2, '%s: Create repomd repository for %s' % (self.dist.nick, self.name))
-			ret = run('%s %s %s' % (cf.cmd['createrepo'], repoopts, self.wwwdir))
-			if ret:
-				raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['createrepo'], ret)))
+    def repomd(self):
+        &quot;Create a repomd repository&quot;
+        if not cf.cmd['createrepo']:
+            raise mrepoGenerateException('Command createrepo is not found. Skipping.')
+        opts = ' ' + cf.createrepooptions
+        if op.force:
+            opts = ' --pretty'
+        if op.verbose &lt;= 2:
+            opts = ' --quiet' + opts
+        elif op.verbose &gt;= 4:
+            opts = ' -v' + opts
+        if not self.dist.promoteepoch:
+            opts = opts + ' -n'
+        if os.path.isdir(self.wwwdir):
+            repoopts = opts
+            if cf.cachedir:
+                cachedir = os.path.join(cf.cachedir, self.dist.nick, self.name)
+                mkdir(cachedir)
+                repoopts = repoopts + ' --cachedir &quot;%s&quot;' % cachedir
+            if os.path.isdir(os.path.join(self.wwwdir, '.olddata')):
+                remove(os.path.join(self.wwwdir, '.olddata'))
+            groupfile = os.path.join(cf.srcdir, self.dist.nick, self.name + '-comps.xml')
+            if os.path.isfile(groupfile):
+                symlink(groupfile, os.path.join(self.wwwdir, 'comps.xml'))
+                repoopts = repoopts + ' --groupfile &quot;RPMS.%s/comps.xml&quot;' % self.name
+            info(2, '%s: Create repomd repository for %s' % (self.dist.nick, self.name))
+            ret = run('%s %s %s' % (cf.cmd['createrepo'], repoopts, self.wwwdir))
+            if ret:
+                raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['createrepo'], ret)))
 
-	def yum(self):
-		&quot;Create a (old-style) yum repository&quot;
-		if not cf.cmd['yumarch']:
-			return
-		opts = ''
-		if op.verbose &lt;= 2:
-			opts = ' -q' + opts
-		elif op.verbose == 4:
-			opts = ' -v' + opts
-		elif op.verbose &gt;= 5:
-			opts = ' -vv' + opts
-		if op.dryrun:
-			opts = opts + ' -n'
-		if os.path.exists(self.wwwdir):
-			if os.path.isdir(os.path.join(self.wwwdir, '.oldheaders')):
-				remove(os.path.join(self.wwwdir, '.oldheaders'))
-			info(2, '%s: Create (old-style) yum repository for %s' % (self.dist.nick, self.name))
-			ret = run('%s %s -l %s' % (cf.cmd['yumarch'], opts, self.wwwdir))
-			if ret:
-				raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['yumarch'], ret)))
+    def yum(self):
+        &quot;Create a (old-style) yum repository&quot;
+        if not cf.cmd['yumarch']:
+            return
+        opts = ''
+        if op.verbose &lt;= 2:
+            opts = ' -q' + opts
+        elif op.verbose == 4:
+            opts = ' -v' + opts
+        elif op.verbose &gt;= 5:
+            opts = ' -vv' + opts
+        if op.dryrun:
+            opts = opts + ' -n'
+        if os.path.exists(self.wwwdir):
+            if os.path.isdir(os.path.join(self.wwwdir, '.oldheaders')):
+                remove(os.path.join(self.wwwdir, '.oldheaders'))
+            info(2, '%s: Create (old-style) yum repository for %s' % (self.dist.nick, self.name))
+            ret = run('%s %s -l %s' % (cf.cmd['yumarch'], opts, self.wwwdir))
+            if ret:
+                raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['yumarch'], ret)))
 
-	def apt(self):
-		&quot;Create an (old-style) apt repository&quot;
-		if not cf.cmd['genbasedir']:
-			return
-		opts = ''
-		if op.verbose &gt;= 3:
-			opts = ' --progress' + opts
+    def apt(self):
+        &quot;Create an (old-style) apt repository&quot;
+        if not cf.cmd['genbasedir']:
+            return
+        opts = ''
+        if op.verbose &gt;= 3:
+            opts = ' --progress' + opts
 
-		mkdir(os.path.join(self.dist.dir, 'base'))
+        mkdir(os.path.join(self.dist.dir, 'base'))
 
-		### Write out /srcdir/nick/base/release
-		releasefile = os.path.join(self.dist.dir, 'base', 'release')
-		if op.force or not os.path.exists(releasefile):
-			open(releasefile, 'w').write(
-				'Origin: %s\n'\
-				'Label: %s\n'\
-				'Suite: Unknown\n'\
-				'Codename: %s\n'\
-				'Date: unknown\n'\
-				'Architectures: %s\n'\
-				'Components: \n'\
-				'Description: %s\n'\
-				'MD5Sum:\n'\
-				% (os.uname()[1], self.dist.name, self.dist.nick, self.dist.arch, self.dist.name))
+        ### Write out /srcdir/nick/base/release
+        releasefile = os.path.join(self.dist.dir, 'base', 'release')
+        if op.force or not os.path.exists(releasefile):
+            open(releasefile, 'w').write(
+                'Origin: %s\n'\
+                'Label: %s\n'\
+                'Suite: Unknown\n'\
+                'Codename: %s\n'\
+                'Date: unknown\n'\
+                'Architectures: %s\n'\
+                'Components: \n'\
+                'Description: %s\n'\
+                'MD5Sum:\n'\
+                % (os.uname()[1], self.dist.name, self.dist.nick, self.dist.arch, self.dist.name))
 
-		### Write out /srcdir/nick/base/release.repo
-		releasefile = os.path.join(self.dist.dir, 'base', 'release.'+ self.name)
-		if op.force or not os.path.exists(releasefile):
-			open(releasefile, 'w').write(
-				'Archive: %s\n'\
-				'Component: %s\n'\
-				'Version: %s\n'\
-				'Origin: %s\n'\
-				'Label: Repository %s for %s\n'\
-				'Architecture: %s\n'\
-				'NotAutomatic: false\n'\
-				% (self.name, self.name, self.dist.release, os.uname()[1], self.name, self.dist.name, self.dist.arch))
+        ### Write out /srcdir/nick/base/release.repo
+        releasefile = os.path.join(self.dist.dir, 'base', 'release.'+ self.name)
+        if op.force or not os.path.exists(releasefile):
+            open(releasefile, 'w').write(
+                'Archive: %s\n'\
+                'Component: %s\n'\
+                'Version: %s\n'\
+                'Origin: %s\n'\
+                'Label: Repository %s for %s\n'\
+                'Architecture: %s\n'\
+                'NotAutomatic: false\n'\
+                % (self.name, self.name, self.dist.release, os.uname()[1], self.name, self.dist.name, self.dist.arch))
 
-		info(2, '%s: Create (old-style) apt repository for %s' % (self.dist.nick, self.name))
-#		if self.newrepos == self.oldrepos:
-#			run('%s %s --flat --bloat --bz2only %s' % (cf.cmd['genbasedir'], opts, self.dist.dir))
-#		else:
-		ret = run('%s %s --flat --bloat --bz2only --partial %s %s' % (cf.cmd['genbasedir'], opts, self.dist.dir, self.name))
-		if ret:
-			raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['genbasedir'], ret)))
+        info(2, '%s: Create (old-style) apt repository for %s' % (self.dist.nick, self.name))
+#       if self.newrepos == self.oldrepos:
+#           run('%s %s --flat --bloat --bz2only %s' % (cf.cmd['genbasedir'], opts, self.dist.dir))
+#       else:
+        ret = run('%s %s --flat --bloat --bz2only --partial %s %s' % (cf.cmd['genbasedir'], opts, self.dist.dir, self.name))
+        if ret:
+            raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['genbasedir'], ret)))
 
-	def repoview(self):
-		&quot;Create a repoview index&quot;
-		if not self.changed and not op.force:
-			return
-		if not cf.cmd['repoview']:
-			return
-		opts = ''
-		if op.force:
-			opts = ' --force'
-		if op.verbose &lt;= 2:
-			opts = ' --quiet' + opts
-		if os.path.exists(self.wwwdir):
-			info(2, '%s: Create Repoview index for %s' % (self.dist.nick, self.name))
-			title = '%s repository for %s' % (self.name, self.dist.nick)
-			ret = run('%s %s --title=&quot;%s&quot; %s' % (cf.cmd['repoview'], opts, title, self.wwwdir))
-			if ret:
-				raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['repoview'], ret)))
-#			url = '<A HREF="http://mrepo/%s/RPMS.%s/">http://mrepo/%s/RPMS.%s/</A>' % (self.dist.nick, self.name)
-#			ret = run('%s %s --url=&quot;%s&quot; %s' % (cf.cmd['repoview'], opts, url, self.wwwdir))
-#			if ret:
-#				raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['repoview'], ret)))
+    def repoview(self):
+        &quot;Create a repoview index&quot;
+        if not self.changed and not op.force:
+            return
+        if not cf.cmd['repoview']:
+            return
+        opts = ''
+        if op.force:
+            opts = ' --force'
+        if op.verbose &lt;= 2:
+            opts = ' --quiet' + opts
+        if os.path.exists(self.wwwdir):
+            info(2, '%s: Create Repoview index for %s' % (self.dist.nick, self.name))
+            title = '%s repository for %s' % (self.name, self.dist.nick)
+            ret = run('%s %s --title=&quot;%s&quot; %s' % (cf.cmd['repoview'], opts, title, self.wwwdir))
+            if ret:
+                raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['repoview'], ret)))
+#           url = '<A HREF="http://mrepo/%s/RPMS.%s/">http://mrepo/%s/RPMS.%s/</A>' % (self.dist.nick, self.name)
+#           ret = run('%s %s --url=&quot;%s&quot; %s' % (cf.cmd['repoview'], opts, url, self.wwwdir))
+#           if ret:
+#               raise(mrepoGenerateException('%s failed with return code: %s' % (cf.cmd['repoview'], ret)))
 
 class Set:
-	def __init__(self):
-		self.list = []
+    def __init__(self):
+        self.list = []
 
-	def add(self, input):
-		if input not in self.list:
-			self.list.append(input)
+    def add(self, input):
+        if input not in self.list:
+            self.list.append(input)
 
-	def delete(self, input):
-		if input in self.list:
-			self.list.removed(input)
+    def delete(self, input):
+        if input in self.list:
+            self.list.removed(input)
 
-	def difference(self, other):
-		newlist = Set()
-		for element in self.list:
-			if element not in other.list:
-				newlist.add(element)
-		return newlist
+    def difference(self, other):
+        newlist = Set()
+        for element in self.list:
+            if element not in other.list:
+                newlist.add(element)
+        return newlist
 
-	def sort(self):
-		return self.list.sort()
+    def sort(self):
+        return self.list.sort()
 
-	def __str__(self):
-		return '\n\t' + '\n\t'.join([element[0] for element in self.list])
+    def __str__(self):
+        return '\n\t' + '\n\t'.join([element[0] for element in self.list])
 
-	def __len__(self):
-		return len(self.list)
+    def __len__(self):
+        return len(self.list)
 
 class mrepoMirrorException(Exception):
-	def __init__(self, value):
-		self.value = value
-	def __str__(self):
-		return repr(self.value)
+    def __init__(self, value):
+        self.value = value
+    def __str__(self):
+        return repr(self.value)
 
 class mrepoGenerateException(Exception):
-	def __init__(self, value):
-		self.value = value
-	def __str__(self):
-		return repr(self.value)
+    def __init__(self, value):
+        self.value = value
+    def __str__(self):
+        return repr(self.value)
 
 def sha1dir(dir):
-	&quot;Return sha1sum of a directory&quot;
-	files = glob.glob(dir + '/*.rpm')
-	files.sort()
-	output = ''
-	for file in files:
-		output = output + os.path.basename(file) + ' ' + str(os.stat(file).st_size) + '\n'
-	return sha.new(output).hexdigest()
+    &quot;Return sha1sum of a directory&quot;
+    files = glob.glob(dir + '/*.rpm')
+    files.sort()
+    output = ''
+    for file in files:
+        output = output + os.path.basename(file) + ' ' + str(os.stat(file).st_size) + '\n'
+    return sha.new(output).hexdigest()
 
 def writesha1(file, sha1sum=None):
-	&quot;Write out sha1sum&quot;
-	repodir = os.path.dirname(file)
-	if not sha1sum:
-		sha1sum = sha1dir(repodir)
-	if not op.dryrun:
-		open(file, 'w').write(sha1sum)
+    &quot;Write out sha1sum&quot;
+    repodir = os.path.dirname(file)
+    if not sha1sum:
+        sha1sum = sha1dir(repodir)
+    if not op.dryrun:
+        open(file, 'w').write(sha1sum)
 
 def error(level, str):
-	&quot;Output error message&quot;
-	if level &lt;= op.verbose:
-		sys.stderr.write('mrepo: %s\n' % str)
+    &quot;Output error message&quot;
+    if level &lt;= op.verbose:
+        sys.stderr.write('mrepo: %s\n' % str)
 
 def info(level, str):
-	&quot;Output info message&quot;
-	if level &lt;= op.verbose:
-		sys.stdout.write('%s\n' % str)
+    &quot;Output info message&quot;
+    if level &lt;= op.verbose:
+        sys.stdout.write('%s\n' % str)
 
 def die(ret, str):
-	&quot;Print error and exit with errorcode&quot;
-	error(0, str)
-	sys.exit(ret)
+    &quot;Print error and exit with errorcode&quot;
+    error(0, str)
+    sys.exit(ret)
 
 def run(str, dryrun=False):
-	&quot;Run command, accept user input, and print output when needed.&quot;
-	str = 'exec ' + str
-	if op.verbose &lt;= 2:
-		str = str + ' &gt;/dev/null'
-	if not op.dryrun or dryrun:
-		info(5, 'Execute: %s' % str)
-#		os.popen(str, 'w')
-		return os.system(str)
-	else:
-		info(1, 'Not execute: %s' % str)
+    &quot;Run command, accept user input, and print output when needed.&quot;
+    str = 'exec ' + str
+    if op.verbose &lt;= 2:
+        str = str + ' &gt;/dev/null'
+    if not op.dryrun or dryrun:
+        info(5, 'Execute: %s' % str)
+#       os.popen(str, 'w')
+        return os.system(str)
+    else:
+        info(1, 'Not execute: %s' % str)
 
 def readfile(file, len = 0):
-	&quot;Return content of a file&quot;
-	if not os.path.isfile(file):
-		return None
-	if len:
-		return open(file, 'r').read(len)
-	return open(file, 'r').read()
+    &quot;Return content of a file&quot;
+    if not os.path.isfile(file):
+        return None
+    if len:
+        return open(file, 'r').read(len)
+    return open(file, 'r').read()
 
 def writefile(file, str):
-	if op.dryrun:
-		return
-	fd = open(file, 'w')
-	fd.write(str)
-	fd.close()
+    if op.dryrun:
+        return
+    fd = open(file, 'w')
+    fd.write(str)
+    fd.close()
 
 _subst_sub = re.compile('\$\{?(\w+)\}?').sub
 
 def substitute(string, vars, recursion = 0):
-	&quot;Substitute variables from a string&quot;
-	if recursion &gt; 10:
-		raise RuntimeError, &quot;variable substitution loop&quot;
+    &quot;Substitute variables from a string&quot;
+    if recursion &gt; 10:
+        raise RuntimeError, &quot;variable substitution loop&quot;
 
-	def _substrepl(matchobj):
-		value = vars.get(matchobj.group(1))
-		if value is not None:
-			return substitute(value, vars, recursion + 1)
-		return matchobj.group(0)
+    def _substrepl(matchobj):
+        value = vars.get(matchobj.group(1))
+        if value is not None:
+            return substitute(value, vars, recursion + 1)
+        return matchobj.group(0)
 
-	string = _subst_sub(_substrepl, string)
-	return string
+    string = _subst_sub(_substrepl, string)
+    return string
 
 def mountpoint(dev):
-	&quot;Return the mountpoint of a mounted device/file&quot;
-	for entry in readfile('/etc/mtab').split('\n'):
-		if entry:
-			list = entry.split()
-			if dev == list[0]:
-				return list[1]
+    &quot;Return the mountpoint of a mounted device/file&quot;
+    for entry in readfile('/etc/mtab').split('\n'):
+        if entry:
+            list = entry.split()
+            if dev == list[0]:
+                return list[1]
 
 def distsort(a, b):
-	return cmp(a.nick, b.nick)
-			
+    return cmp(a.nick, b.nick)
+            
 def reposort(a, b):
-	return cmp(a.name, b.name)
+    return cmp(a.name, b.name)
 
 def symlinkglob(str, *targets):
-	&quot;Symlink files to multiple targets&quot;
-	for file in glob.glob(str):
-		for target in targets:
-			mkdir(target)
-			symlink(file, target)
+    &quot;Symlink files to multiple targets&quot;
+    for file in glob.glob(str):
+        for target in targets:
+            mkdir(target)
+            symlink(file, target)
 
 def abspath(path, reference):
-	&quot;Make absolute path from reference&quot;
-	return os.path.normpath(os.path.join(path, reference))
+    &quot;Make absolute path from reference&quot;
+    return os.path.normpath(os.path.join(path, reference))
 
 def relpath(path, reference):
-	&quot;Make relative path from reference&quot;
-	common = os.path.commonprefix([path, reference])
-	common = common[0:common.rfind('/')+1]
-	(uncommon, targetName) = os.path.split(reference.replace(common, '', 1))
-	if uncommon:
-		newpath = []
-		for component in uncommon.split('/'):
-			newpath.append('..')
-		newpath.append(path.replace(common, '', 1))
-		return '/'.join(newpath)
-	else:
-		return path
+    &quot;Make relative path from reference&quot;
+    common = os.path.commonprefix([path, reference])
+    common = common[0:common.rfind('/')+1]
+    (uncommon, targetName) = os.path.split(reference.replace(common, '', 1))
+    if uncommon:
+        newpath = []
+        for component in uncommon.split('/'):
+            newpath.append('..')
+        newpath.append(path.replace(common, '', 1))
+        return '/'.join(newpath)
+    else:
+        return path
 
 def symlink(src, dst):
-	&quot;Create a symbolic link, force if dst exists&quot;
-	if op.dryrun:
-		return
-	elif os.path.islink(dst):
-		if os.path.samefile(src, abspath(os.readlink(dst), src)):
-			return
-		os.unlink(dst)
-	elif os.path.isdir(dst):
-		if os.path.isdir(src):
-			if os.path.samefile(src, dst):
-				return
-		else:
-			dst = os.path.join(dst, os.path.basename(src))
-			symlink(src, dst)
-			return
-	elif os.path.isfile(dst):
-		if os.path.samefile(src, dst):
-			return
-		os.rename(dst, dst+'.mrepobak')
+    &quot;Create a symbolic link, force if dst exists&quot;
+    if op.dryrun:
+        return
+    elif os.path.islink(dst):
+        if os.path.samefile(src, abspath(os.readlink(dst), src)):
+            return
+        os.unlink(dst)
+    elif os.path.isdir(dst):
+        if os.path.isdir(src):
+            if os.path.samefile(src, dst):
+                return
+        else:
+            dst = os.path.join(dst, os.path.basename(src))
+            symlink(src, dst)
+            return
+    elif os.path.isfile(dst):
+        if os.path.samefile(src, dst):
+            return
+        os.rename(dst, dst+'.mrepobak')
 ### Not using filecmp increases speed with 15%
-#	if os.path.isfile(dst) and filecmp.cmp(src, dst) == 0:
+#   if os.path.isfile(dst) and filecmp.cmp(src, dst) == 0:
 
-	src = relpath(src, dst)
+    src = relpath(src, dst)
 
-	### FIXME: This check should not be required
-	if not os.path.exists(dst):
-		mkdir(os.path.dirname(dst))
-		os.symlink(src, dst)
+    ### FIXME: This check should not be required
+    if not os.path.exists(dst):
+        mkdir(os.path.dirname(dst))
+        os.symlink(src, dst)
 
 def copy(src, dst):
-	&quot;Copy a file, force if dst exists&quot;
-	if op.dryrun:
-		return
-	if os.path.isdir(dst):
-		dst = os.path.join(dst, os.path.basename(src))
-	if os.path.islink(dst) or os.path.isfile(dst):
-		os.unlink(dst)
-	mkdir(os.path.dirname(dst))
-	if not os.path.exists(dst):
-		if os.path.isfile(src):
-			shutil.copy2(src, dst)
-		elif os.path.isdir(src):
-			shutil.copytree(src, dst)
+    &quot;Copy a file, force if dst exists&quot;
+    if op.dryrun:
+        return
+    if os.path.isdir(dst):
+        dst = os.path.join(dst, os.path.basename(src))
+    if os.path.islink(dst) or os.path.isfile(dst):
+        os.unlink(dst)
+    mkdir(os.path.dirname(dst))
+    if not os.path.exists(dst):
+        if os.path.isfile(src):
+            shutil.copy2(src, dst)
+        elif os.path.isdir(src):
+            shutil.copytree(src, dst)
 
 def remove(file):
-	&quot;Remove files or directories&quot;
-	if isinstance(file, types.StringType):
-		if op.dryrun:
-			return
-		if os.path.islink(file):
-			os.unlink(file)
-		elif os.path.isdir(file):
-			try:
-				os.rmdir(file)
-			except:
-				os.path.walk(file, removedir, ())
-				os.rmdir(file)
-		elif os.path.isfile(file) or os.path.islink(file):
-			os.unlink(file)
-	else:
-		for f in file:
-			remove(f)
+    &quot;Remove files or directories&quot;
+    if isinstance(file, types.StringType):
+        if op.dryrun:
+            return
+        if os.path.islink(file):
+            os.unlink(file)
+        elif os.path.isdir(file):
+            try:
+                os.rmdir(file)
+            except:
+                os.path.walk(file, removedir, ())
+                os.rmdir(file)
+        elif os.path.isfile(file) or os.path.islink(file):
+            os.unlink(file)
+    else:
+        for f in file:
+            remove(f)
 
 def removedir(void, dir, files):
-	for file in files:
-		remove(os.path.join(dir, file))
+    for file in files:
+        remove(os.path.join(dir, file))
 
 def mkdir(path):
-	&quot;Create a directory, and parents if needed&quot;
-	if op.dryrun:
-		return
-	if os.path.islink(path):
-		os.unlink(path)
-	if not os.path.exists(path):
-		os.makedirs(path)
+    &quot;Create a directory, and parents if needed&quot;
+    if op.dryrun:
+        return
+    if os.path.islink(path):
+        os.unlink(path)
+    if not os.path.exists(path):
+        os.makedirs(path)
 
 def mirrorrsync(url, path):
-	&quot;Mirror everything from an <A HREF="rsync://">rsync://</A> URL&quot;
-	if not cf.cmd['rsync']:
-		error(1, 'rsync was not found. rsync support is therefor disabled.')
-		return
-	mkdir(path)
+    &quot;Mirror everything from an <A HREF="rsync://">rsync://</A> URL&quot;
+    if not cf.cmd['rsync']:
+        error(1, 'rsync was not found. rsync support is therefor disabled.')
+        return
+    mkdir(path)
 
-	opts = cf.rsyncoptions
-	if op.verbose &lt;= 2:
-		opts = opts + ' -q'
-	elif op.verbose == 3:
-		opts = opts + ' -v'
-	elif op.verbose == 4:
-		opts = opts + ' -v --progress'
-	elif op.verbose == 5:
-		opts = opts + ' -vv --progress'
-	elif op.verbose &gt;= 6:
-		opts = opts + ' -vvv --progress'
-	if op.dryrun:
-		opts = opts + ' --dry-run'
-	if cf.rsynctimeout:
-		opts = opts + ' --timeout=%s' % cf.rsynctimeout
-	if cf.rsynccleanup:
-		opts = opts + ' --delete-after --delete-excluded'
-	if cf.rsyncbwlimit:
-		opts = opts + ' --bwlimit=%s' % cf.rsyncbwlimit
-	opts = opts + ' --exclude=\&quot;/headers/\&quot; --exclude=\&quot;/repodata/\&quot;'
-	if cf.rsyncexclsrpm:
-		opts = opts + ' --exclude=\&quot;*.src.rpm\&quot; --exclude=\&quot;/SRPMS/\&quot;'
-	if cf.rsyncexcldebug:
-		opts = opts + ' --exclude=\&quot;*-debuginfo-*.rpm\&quot; --exclude=\&quot;/debug/\&quot;'
-	opts = opts + ' --include=\&quot;*.rpm\&quot;'
-	if cf.rsyncexclsrpm or cf.rsyncexcldebug:
-		opts = opts + ' --exclude=\&quot;*.*\&quot;'
+    opts = cf.rsyncoptions
+    if op.verbose &lt;= 2:
+        opts = opts + ' -q'
+    elif op.verbose == 3:
+        opts = opts + ' -v'
+    elif op.verbose == 4:
+        opts = opts + ' -v --progress'
+    elif op.verbose == 5:
+        opts = opts + ' -vv --progress'
+    elif op.verbose &gt;= 6:
+        opts = opts + ' -vvv --progress'
+    if op.dryrun:
+        opts = opts + ' --dry-run'
+    if cf.rsynctimeout:
+        opts = opts + ' --timeout=%s' % cf.rsynctimeout
+    if cf.rsynccleanup:
+        opts = opts + ' --delete-after --delete-excluded'
+    if cf.rsyncbwlimit:
+        opts = opts + ' --bwlimit=%s' % cf.rsyncbwlimit
+    opts = opts + ' --exclude=\&quot;/headers/\&quot; --exclude=\&quot;/repodata/\&quot;'
+    if cf.rsyncexclsrpm:
+        opts = opts + ' --exclude=\&quot;*.src.rpm\&quot; --exclude=\&quot;/SRPMS/\&quot;'
+    if cf.rsyncexcldebug:
+        opts = opts + ' --exclude=\&quot;*-debuginfo-*.rpm\&quot; --exclude=\&quot;/debug/\&quot;'
+    opts = opts + ' --include=\&quot;*.rpm\&quot;'
+    if cf.rsyncexclsrpm or cf.rsyncexcldebug:
+        opts = opts + ' --exclude=\&quot;*.*\&quot;'
 
-	ret = run('%s %s %s %s' % (cf.cmd['rsync'], opts, url, path), dryrun=True)
-	if ret:
-		raise(mrepoMirrorException('Failed with return code: %s' % ret))
+    ret = run('%s %s %s %s' % (cf.cmd['rsync'], opts, url, path), dryrun=True)
+    if ret:
+        raise(mrepoMirrorException('Failed with return code: %s' % ret))
 
 def mirrormirrordir(url, path):
-	&quot;Mirror everything from a <A HREF="ftp://">ftp://</A> or <A HREF="mc://">mc://</A> URL&quot;
-	if not cf.cmd['mirrordir']:
-		error(1, 'mirrordir was not found. ftp and mc support (using mirrordir) is therefor disabled.')
-		return
-	mkdir(path)
+    &quot;Mirror everything from a <A HREF="ftp://">ftp://</A> or <A HREF="mc://">mc://</A> URL&quot;
+    if not cf.cmd['mirrordir']:
+        error(1, 'mirrordir was not found. ftp and mc support (using mirrordir) is therefor disabled.')
+        return
+    mkdir(path)
 
-	opts = cf.mirrordiroptions
-	if op.verbose &gt;= 3:
-		opts = opts + ' -v' * (op.verbose - 3)	
-	if op.dryrun:
-		opts = opts + ' --dry-run'
-	if cf.mirrordircleanup:
-		opts = opts + ' -k'
+    opts = cf.mirrordiroptions
+    if op.verbose &gt;= 3:
+        opts = opts + ' -v' * (op.verbose - 3)  
+    if op.dryrun:
+        opts = opts + ' --dry-run'
+    if cf.mirrordircleanup:
+        opts = opts + ' -k'
 
-#	opts = opts + ' -I \&quot;*.rpm\&quot;'
-	opts = opts + ' -G \&quot;headers\&quot; -G \&quot;repodata\&quot;'
-	if cf.mirrordirexclsrpm:
-		opts = opts + ' -G \&quot;*.src.rpm\&quot; -G \&quot;SRPMS\&quot;'
-	if cf.mirrordirexcldebug:
-		opts = opts + ' -G \&quot;*-debuginfo-*.rpm\&quot; -G \&quot;debug\&quot;'
+#   opts = opts + ' -I \&quot;*.rpm\&quot;'
+    opts = opts + ' -G \&quot;headers\&quot; -G \&quot;repodata\&quot;'
+    if cf.mirrordirexclsrpm:
+        opts = opts + ' -G \&quot;*.src.rpm\&quot; -G \&quot;SRPMS\&quot;'
+    if cf.mirrordirexcldebug:
+        opts = opts + ' -G \&quot;*-debuginfo-*.rpm\&quot; -G \&quot;debug\&quot;'
 
-	ret = run(&quot;%s %s '%s' '%s'&quot; % (cf.cmd['mirrordir'], opts, url, path), dryrun=True)
-	if ret:
-		raise(mrepoMirrorException('Failed with return code: %s' % ret))
+    ret = run(&quot;%s %s '%s' '%s'&quot; % (cf.cmd['mirrordir'], opts, url, path), dryrun=True)
+    if ret:
+        raise(mrepoMirrorException('Failed with return code: %s' % ret))
 
 
 def mirrorlftp(url, path):
-	&quot;Mirror everything from a <A HREF="http://,">http://,</A> <A HREF="ftp://,">ftp://,</A> <A HREF="sftp://,">sftp://,</A> <A HREF="fish://">fish://</A> URL&quot;
-	if not cf.cmd['lftp']:
-		error(1, 'lftp was not found. fish, ftp, http and sftp support (using lftp) is therefor disabled.')
-		return
-	mkdir(path)
+    &quot;Mirror everything from a <A HREF="http://,">http://,</A> <A HREF="ftp://,">ftp://,</A> <A HREF="sftp://,">sftp://,</A> <A HREF="fish://">fish://</A> URL&quot;
+    if not cf.cmd['lftp']:
+        error(1, 'lftp was not found. fish, ftp, http and sftp support (using lftp) is therefor disabled.')
+        return
+    mkdir(path)
 
-	cmds = cf.lftpcommands + ';'
-#	cmds = 'set dns:fatal-timeout 5'
-	if cf.lftptimeout:
-		cmds = cmds + ' set net:timeout %s;' % cf.lftptimeout
-	if cf.lftpbwlimit:
-		cmds = cmds + ' set net:limit-total-rate %s:0;' % cf.lftpbwlimit
+    cmds = cf.lftpcommands + ';'
+#   cmds = 'set dns:fatal-timeout 5'
+    if cf.lftptimeout:
+        cmds = cmds + ' set net:timeout %s;' % cf.lftptimeout
+    if cf.lftpbwlimit:
+        cmds = cmds + ' set net:limit-total-rate %s:0;' % cf.lftpbwlimit
 
-	opts = cf.lftpoptions
-	if op.verbose &gt;= 6:
-		opts = opts + ' -d'
+    opts = cf.lftpoptions
+    if op.verbose &gt;= 6:
+        opts = opts + ' -d'
 
-	mirroropts = cf.lftpmirroroptions
-	if op.verbose &gt;= 3:
-		mirroropts = mirroropts + ' -v' * (op.verbose - 2)
-	if op.dryrun:
-		mirroropts = mirroropts + ' --dry-run'
-	if cf.lftpcleanup:
-		mirroropts = mirroropts + ' -e'
-	mirroropts = mirroropts + ' -I *.rpm -X \&quot;/headers/\&quot; -X \&quot;/repodata/\&quot;'
-	if cf.lftpexclsrpm:
-		mirroropts = mirroropts + ' -X \&quot;*.src.rpm\&quot; -X \&quot;/SRPMS/\&quot;'
-	if cf.lftpexcldebug:
-		mirroropts = mirroropts + ' -X \&quot;*-debuginfo-*.rpm\&quot; -X \&quot;/debug/\&quot;'
+    mirroropts = cf.lftpmirroroptions
+    if op.verbose &gt;= 3:
+        mirroropts = mirroropts + ' -v' * (op.verbose - 2)
+    if op.dryrun:
+        mirroropts = mirroropts + ' --dry-run'
+    if cf.lftpcleanup:
+        mirroropts = mirroropts + ' -e'
+    mirroropts = mirroropts + ' -I *.rpm -X \&quot;/headers/\&quot; -X \&quot;/repodata/\&quot;'
+    if cf.lftpexclsrpm:
+        mirroropts = mirroropts + ' -X \&quot;*.src.rpm\&quot; -X \&quot;/SRPMS/\&quot;'
+    if cf.lftpexcldebug:
+        mirroropts = mirroropts + ' -X \&quot;*-debuginfo-*.rpm\&quot; -X \&quot;/debug/\&quot;'
 
-	ret = run('%s %s -c \'%s mirror %s %s %s\'' % (cf.cmd['lftp'], opts, cmds, mirroropts, url, path), dryrun=True)
-	if ret:
-		raise(mrepoMirrorException('Failed with return code: %s' % ret))
+    ret = run('%s %s -c \'%s mirror %s %s %s\'' % (cf.cmd['lftp'], opts, cmds, mirroropts, url, path), dryrun=True)
+    if ret:
+        raise(mrepoMirrorException('Failed with return code: %s' % ret))
 
 def mirrorfile(url, path):
-	&quot;Mirror everything from a <A HREF="file://">file://</A> URL by symlinking&quot;
-	dir = url.replace('<A HREF="file://">file://</A>', '')
-#	while dir.endswith('/'):
-#		dir = dir[0:-1]
-	if os.path.isdir(dir):
-		symlink(dir, path)
-#	else: ### FIXME: Only if ISO file
-#		if not os.path.isabs(file):
-#			file = os.path.join(cf.srcdir, 'iso', file)
-#		list = glob.glob(file)
-#		list.sort()
-#		for iso in list:
-#			if os.path.isfile(iso):
-#				print 'Please mount %s to %s' % (iso, path)
+    &quot;Mirror everything from a <A HREF="file://">file://</A> URL by symlinking&quot;
+    dir = url.replace('<A HREF="file://">file://</A>', '')
+#   while dir.endswith('/'):
+#       dir = dir[0:-1]
+    if os.path.isdir(dir):
+        symlink(dir, path)
+#   else: ### FIXME: Only if ISO file
+#       if not os.path.isabs(file):
+#           file = os.path.join(cf.srcdir, 'iso', file)
+#       list = glob.glob(file)
+#       list.sort()
+#       for iso in list:
+#           if os.path.isfile(iso):
+#               print 'Please mount %s to %s' % (iso, path)
 
 def mirrormrepo(url, path):
-	&quot;Mirror everything from a local mrepo mirror by symlinking&quot;
-	pathname = url.replace('<A HREF="mrepo://">mrepo://</A>', '')
-	while pathname.endswith('/'):
-		pathname = pathname[0:-1]
-	while path.endswith('/'):
-		path = pathname[0:-1]
-	symlink(os.path.join(cf.srcdir, pathname), path)
-#	basename = os.path.basename(pathname)
-#	symlink(os.path.join(cf.srcdir, pathname), os.path.join(path, basename))
+    &quot;Mirror everything from a local mrepo mirror by symlinking&quot;
+    pathname = url.replace('<A HREF="mrepo://">mrepo://</A>', '')
+    while pathname.endswith('/'):
+        pathname = pathname[0:-1]
+    while path.endswith('/'):
+        path = pathname[0:-1]
+    symlink(os.path.join(cf.srcdir, pathname), path)
+#   basename = os.path.basename(pathname)
+#   symlink(os.path.join(cf.srcdir, pathname), os.path.join(path, basename))
 
 def mirrorrhnget(url, path, dist):
-	&quot;Mirror everything from a <A HREF="rhn://">rhn://</A> or <A HREF="rhns://">rhns://</A> URL&quot;
-	if not cf.cmd['rhnget']:
-		error(1, 'rhnget was not found. rhn and rhns support is therefor disabled.')
-		return
-	mkdir(path)
+    &quot;Mirror everything from a <A HREF="rhn://">rhn://</A> or <A HREF="rhns://">rhns://</A> URL&quot;
+    if not cf.cmd['rhnget']:
+        error(1, 'rhnget was not found. rhn and rhns support is therefor disabled.')
+        return
+    mkdir(path)
 
-	opts = cf.rhngetoptions
-	if op.verbose &gt;= 3:
-		opts = opts + ' -v' * (op.verbose - 3)	
-	if op.dryrun:
-		opts = opts + ' --dry-run'
-	if cf.rhngetcleanup:
-		opts = opts + ' --delete'
-	if cf.rhngetdownloadall:
-		opts = opts + ' --download-all'
+    opts = cf.rhngetoptions
+    if op.verbose &gt;= 3:
+        opts = opts + ' -v' * (op.verbose - 3)  
+    if op.dryrun:
+        opts = opts + ' --dry-run'
+    if cf.rhngetcleanup:
+        opts = opts + ' --delete'
+    if cf.rhngetdownloadall:
+        opts = opts + ' --download-all'
 
-	systemidpath = os.path.join(cf.srcdir, dist.nick, 'systemid')
-	if os.path.isfile(systemidpath):
-		opts = opts + ' --systemid=&quot;%s&quot;' % systemidpath
+    systemidpath = os.path.join(cf.srcdir, dist.nick, 'systemid')
+    if os.path.isfile(systemidpath):
+        opts = opts + ' --systemid=&quot;%s&quot;' % systemidpath
 
-	if dist.rhnrelease:
-		opts = opts + ' --release=&quot;%s&quot;' % dist.rhnrelease
+    if dist.rhnrelease:
+        opts = opts + ' --release=&quot;%s&quot;' % dist.rhnrelease
 
-	if cf.rhnlogin:
-		rhnlogin = cf.rhnlogin.split(':')
-		if len(rhnlogin) &gt; 0:
-			opts = opts + ' --username=&quot;%s&quot;' % rhnlogin[0]
-		if len(rhnlogin) &gt; 1:
-			opts = opts + ' --password=&quot;%s&quot;' % rhnlogin[1]
+    if cf.rhnlogin:
+        rhnlogin = cf.rhnlogin.split(':')
+        if len(rhnlogin) &gt; 0:
+            opts = opts + ' --username=&quot;%s&quot;' % rhnlogin[0]
+        if len(rhnlogin) &gt; 1:
+            opts = opts + ' --password=&quot;%s&quot;' % rhnlogin[1]
 
-##	opts = opts + ' -I \&quot;*.rpm\&quot;'
-#	opts = opts + ' -G \&quot;headers\&quot; -G \&quot;repodata\&quot;'
-#	if cf.mirrordirexclsrpm:
-#		opts = opts + ' -G \&quot;*.src.rpm\&quot; -G \&quot;SRPMS\&quot;'
-#	if cf.mirrordirexcldebug:
-#		opts = opts + ' -G \&quot;*-debuginfo-*.rpm\&quot; -G \&quot;debug\&quot;'
+##  opts = opts + ' -I \&quot;*.rpm\&quot;'
+#   opts = opts + ' -G \&quot;headers\&quot; -G \&quot;repodata\&quot;'
+#   if cf.mirrordirexclsrpm:
+#       opts = opts + ' -G \&quot;*.src.rpm\&quot; -G \&quot;SRPMS\&quot;'
+#   if cf.mirrordirexcldebug:
+#       opts = opts + ' -G \&quot;*-debuginfo-*.rpm\&quot; -G \&quot;debug\&quot;'
 
-	ret = run(&quot;%s %s '%s' '%s'&quot; % (cf.cmd['rhnget'], opts, url, path), dryrun=True)
-	if ret:
-		raise(mrepoMirrorException('Failed with return code: %s' % ret))
+    ret = run(&quot;%s %s '%s' '%s'&quot; % (cf.cmd['rhnget'], opts, url, path), dryrun=True)
+    if ret:
+        raise(mrepoMirrorException('Failed with return code: %s' % ret))
 
 def hardlink(srcdir):
-	info(1, 'Hardlinking duplicate packages in %s.' % srcdir)
-	opts = ''
-	if cf.cmd['hardlink++']:
-		if op.verbose &lt;= 2:
-			opts = '&gt;/dev/null'
-		run('%s %s %s' % (cf.cmd['hardlink++'], os.path.join(srcdir, ''), opts))
-	elif cf.cmd['hardlink']:
-		if op.verbose:
-			opts = opts + ' -' + ('v' * (op.verbose - 2))
-		if op.dryrun:
-			opts = opts + ' -n'
-		run('%s -c %s %s' % (cf.cmd['hardlink'], opts, os.path.join(srcdir, '')), dryrun=True)
-	else:
-		info(1, 'hardlink was not found, hardlink support is therefor disabled.')
-		return
+    info(1, 'Hardlinking duplicate packages in %s.' % srcdir)
+    opts = ''
+    if cf.cmd['hardlink++']:
+        if op.verbose &lt;= 2:
+            opts = '&gt;/dev/null'
+        run('%s %s %s' % (cf.cmd['hardlink++'], os.path.join(srcdir, ''), opts))
+    elif cf.cmd['hardlink']:
+        if op.verbose:
+            opts = opts + ' -' + ('v' * (op.verbose - 2))
+        if op.dryrun:
+            opts = opts + ' -n'
+        run('%s -c %s %s' % (cf.cmd['hardlink'], opts, os.path.join(srcdir, '')), dryrun=True)
+    else:
+        info(1, 'hardlink was not found, hardlink support is therefor disabled.')
+        return
 
 def rpmlink((dist, repo), dirpath, filelist):
-	archlist = ['noarch', ]
-	if archs.has_key(dist.arch):
-		archlist.extend(archs[dist.arch])
-	else:
-		archlist.extend(dist.arch)
-	for arch in archlist:
-		regexp = re.compile('.+[\._-]' + arch + '\.rpm$')
-		for file in filelist:
-			src = os.path.join(dirpath, file)
-			if os.path.islink(src):
-				os.path.walk(src, rpmlink, (dist, repo))
-			elif regexp.match(file, 1):
-				symlink(src, os.path.join(dist.dir, 'RPMS.' + repo))
-				symlink(src, os.path.join(dist.dir, 'RPMS.all'))
-	
+    archlist = ['noarch', ]
+    if archs.has_key(dist.arch):
+        archlist.extend(archs[dist.arch])
+    else:
+        archlist.extend(dist.arch)
+    for arch in archlist:
+        regexp = re.compile('.+[\._-]' + arch + '\.rpm$')
+        for file in filelist:
+            src = os.path.join(dirpath, file)
+            if os.path.islink(src):
+                os.path.walk(src, rpmlink, (dist, repo))
+            elif regexp.match(file, 1):
+                symlink(src, os.path.join(dist.dir, 'RPMS.' + repo))
+                symlink(src, os.path.join(dist.dir, 'RPMS.all'))
+    
 def which(cmd):
-	&quot;Find executables in PATH environment&quot;
-	for path in os.environ.get('PATH','$PATH').split(':'):
-		if os.path.isfile(os.path.join(path, cmd)):
-			info(5, 'Found command %s in path %s' % (cmd, path))
-			return os.path.join(path, cmd)
-	return ''
+    &quot;Find executables in PATH environment&quot;
+    for path in os.environ.get('PATH','$PATH').split(':'):
+        if os.path.isfile(os.path.join(path, cmd)):
+            info(5, 'Found command %s in path %s' % (cmd, path))
+            return os.path.join(path, cmd)
+    return ''
 
 def htmlindex():
-	symlink(cf.htmldir + '/HEADER.index.shtml', cf.wwwdir + '/HEADER.shtml')
-	symlink(cf.htmldir + '/README.index.shtml', cf.wwwdir + '/README.shtml')
+    symlink(cf.htmldir + '/HEADER.index.shtml', cf.wwwdir + '/HEADER.shtml')
+    symlink(cf.htmldir + '/README.index.shtml', cf.wwwdir + '/README.shtml')
 
 def mail(subject, msg):
-	info(2, 'Sending mail to: %s' % cf.mailto)
-	try:
-		import smtplib
-		smtp = smtplib.SMTP(cf.smtpserver)
-#		server.set_debuglevel(1)
-		msg = 'Subject: [mrepo] %s\n\n%s' % (subject, msg)
-		for email in cf.mailto.split():
-			smtp.sendmail(cf.mailfrom, email, 'To: %s\n%s' % (email, msg))
-		smtp.quit()
-	except:
-		info(1, 'Sending mail via %s failed.' % cf.smtpserver)
+    info(2, 'Sending mail to: %s' % cf.mailto)
+    try:
+        import smtplib
+        smtp = smtplib.SMTP(cf.smtpserver)
+#       server.set_debuglevel(1)
+        msg = 'Subject: [mrepo] %s\n\n%s' % (subject, msg)
+        for email in cf.mailto.split():
+            smtp.sendmail(cf.mailfrom, email, 'To: %s\n%s' % (email, msg))
+        smtp.quit()
+    except:
+        info(1, 'Sending mail via %s failed.' % cf.smtpserver)
 
 def readconfig():
-	cf = Config()
-	if cf.confdir and os.path.isdir(cf.confdir):
-		files = glob.glob(os.path.join(cf.confdir, '*.conf'))
-		files.sort()
-		for configfile in files:
-			cf.read(configfile)
-			cf.update(configfile)
-	return cf
+    cf = Config()
+    if cf.confdir and os.path.isdir(cf.confdir):
+        files = glob.glob(os.path.join(cf.confdir, '*.conf'))
+        files.sort()
+        for configfile in files:
+            cf.read(configfile)
+            cf.update(configfile)
+    return cf
 
 def main():
-	### Check availability of commands
-	for cmd in cf.cmd.keys():
-		if not cf.cmd[cmd]:
-			continue
-		list = cf.cmd[cmd].split()
-		if not os.path.isfile(list[0]):
-			list[0] = which(list[0])
-		if list[0] and not os.path.isfile(list[0]):
-			error(4, '%s command not found as %s, support disabled' % (cmd, list[0]))
-			cf.cmd[cmd] = ''
-		else:
-			cf.cmd[cmd] = ' '.join(list)
-	if not cf.cmd['createrepo'] and not cf.cmd['yumarch'] and not cf.cmd['genbasedir']:
-		error(1, 'No tools found to generate repository metadata. Please install apt, yum or createrepo.')
+    ### Check availability of commands
+    for cmd in cf.cmd.keys():
+        if not cf.cmd[cmd]:
+            continue
+        list = cf.cmd[cmd].split()
+        if not os.path.isfile(list[0]):
+            list[0] = which(list[0])
+        if list[0] and not os.path.isfile(list[0]):
+            error(4, '%s command not found as %s, support disabled' % (cmd, list[0]))
+            cf.cmd[cmd] = ''
+        else:
+            cf.cmd[cmd] = ' '.join(list)
+    if not cf.cmd['createrepo'] and not cf.cmd['yumarch'] and not cf.cmd['genbasedir']:
+        error(1, 'No tools found to generate repository metadata. Please install apt, yum or createrepo.')
 
-	### Set proxy-related environment variables
-	if cf.no_proxy:
-		os.environ['no_proxy'] = cf.no_proxy
-	if cf.ftp_proxy:
-		os.environ['ftp_proxy'] = cf.ftp_proxy
-	if cf.http_proxy:
-		os.environ['http_proxy'] = cf.http_proxy
-	if cf.https_proxy:
-		os.environ['https_proxy'] = cf.https_proxy
+    ### Set proxy-related environment variables
+    if cf.no_proxy:
+        os.environ['no_proxy'] = cf.no_proxy
+    if cf.ftp_proxy:
+        os.environ['ftp_proxy'] = cf.ftp_proxy
+    if cf.http_proxy:
+        os.environ['http_proxy'] = cf.http_proxy
+    if cf.https_proxy:
+        os.environ['https_proxy'] = cf.https_proxy
 
-	### Select list of distributions in order of appearance
-	if not op.dists:
-		dists = cf.dists
-	else:
-		dists = []
-		for name in op.dists:
-			append = False
-			for dist in cf.alldists:
-				if name == dist.nick or name == dist.dist:
-					dists.append(dist)
-					append = True
-			if not append:
-				error(1, 'Distribution %s not defined' % name)
+    ### Select list of distributions in order of appearance
+    if not op.dists:
+        dists = cf.dists
+    else:
+        dists = []
+        for name in op.dists:
+            append = False
+            for dist in cf.alldists:
+                if name == dist.nick or name == dist.dist:
+                    dists.append(dist)
+                    append = True
+            if not append:
+                error(1, 'Distribution %s not defined' % name)
 
-	sumnew = 0
-	sumremoved = 0
-	msg = 'The following changes to mrepo\'s repositories on %s have been made:' % os.uname()[1]
+    sumnew = 0
+    sumremoved = 0
+    msg = 'The following changes to mrepo\'s repositories on %s have been made:' % os.uname()[1]
 
-	### Mounting and mirroring available distributions/repositories
-	for dist in dists:
-		dist.findisos()
-		### Mount ISOs
-		if dist.isos:
-			if op.umount or op.remount:
-				dist.umount()
-			if not op.umount or op.remount:
-				dist.discs = dist.mount()
+    ### Mounting and mirroring available distributions/repositories
+    for dist in dists:
+        dist.findisos()
+        ### Mount ISOs
+        if dist.isos:
+            if op.umount or op.remount:
+                dist.umount()
+            if not op.umount or op.remount:
+                dist.discs = dist.mount()
 
-		if op.update:
-			msg = msg + '\n\nDist: %s (%s)' % (dist.name, dist.nick)
-			info(1, '%s: Updating %s' % (dist.nick, dist.name))
+        if op.update:
+            msg = msg + '\n\nDist: %s (%s)' % (dist.name, dist.nick)
+            info(1, '%s: Updating %s' % (dist.nick, dist.name))
 
-			distnew = 0
-			distremoved = 0
+            distnew = 0
+            distremoved = 0
 
-			### Downloading things
-			for repo in dist.listrepos(op.repos):
-				if not repo.lock('update'):
-					continue
-				if repo.name in ('os', 'core'):
-					if not dist.isos:
-						repo.mirror()
-				elif repo in dist.listrepos():
-					repo.mirror()
-				else:
-					info(2, '%s: Repository %s does not exist' % (dist.nick, repo.name))
-				repo.unlock('update')
+            ### Downloading things
+            for repo in dist.listrepos(op.repos):
+                if not repo.lock('update'):
+                    continue
+                if repo.name in ('os', 'core'):
+                    if not dist.isos:
+                        repo.mirror()
+                elif repo in dist.listrepos():
+                    repo.mirror()
+                else:
+                    info(2, '%s: Repository %s does not exist' % (dist.nick, repo.name))
+                repo.unlock('update')
 
-				new = repo.newlist.difference(repo.oldlist)
-				removed = repo.oldlist.difference(repo.newlist)
+                new = repo.newlist.difference(repo.oldlist)
+                removed = repo.oldlist.difference(repo.newlist)
 
-				if new or removed:
-					msg = msg + '\n\n\tRepo: %s' % repo.name
-					info(2, '%s: Repository %s changed (new: %d, removed: %d)' % (dist.nick, repo.name, len(new), len(removed)))
-					fd = open(cf.logfile, 'a+')
-					date = time.strftime(&quot;%b %d %H:%M:%S&quot;, time.gmtime())
+                if new or removed:
+                    msg = msg + '\n\n\tRepo: %s' % repo.name
+                    info(2, '%s: Repository %s changed (new: %d, removed: %d)' % (dist.nick, repo.name, len(new), len(removed)))
+                    fd = open(cf.logfile, 'a+')
+                    date = time.strftime(&quot;%b %d %H:%M:%S&quot;, time.gmtime())
 
-					if new.list:
-						info(4, '%s: New packages: %s' % (dist.nick, new))
-						distnew += len(new)
-						for element in new.list:
-							fd.write('%s %s/%s Added %s (%d kiB)\n' % (date, dist.nick, repo.name, element[0], element[1]/1024))
-							msg = msg + '\n\t\t+ %s (%d kiB)' % (element[0], element[1]/1024)
+                    if new.list:
+                        info(4, '%s: New packages: %s' % (dist.nick, new))
+                        distnew += len(new)
+                        for element in new.list:
+                            fd.write('%s %s/%s Added %s (%d kiB)\n' % (date, dist.nick, repo.name, element[0], element[1]/1024))
+                            msg = msg + '\n\t\t+ %s (%d kiB)' % (element[0], element[1]/1024)
 
-					if removed.list:
-						info(4, '%s: Removed packages: %s' % (dist.nick, removed))
-						distremoved += len(removed)
-						for element in removed.list:
-							fd.write('%s %s/%s Removed %s (%d kiB)\n' % (date, dist.nick, repo.name, element[0], element[1]/1024))
-							msg = msg + '\n\t\t- %s (%d kiB)' % (element[0], element[1]/1024)
+                    if removed.list:
+                        info(4, '%s: Removed packages: %s' % (dist.nick, removed))
+                        distremoved += len(removed)
+                        for element in removed.list:
+                            fd.write('%s %s/%s Removed %s (%d kiB)\n' % (date, dist.nick, repo.name, element[0], element[1]/1024))
+                            msg = msg + '\n\t\t- %s (%d kiB)' % (element[0], element[1]/1024)
 
-					fd.close()
-					repo.changed = True
+                    fd.close()
+                    repo.changed = True
 
-			if distnew or distremoved:
-				msg = msg + '\n'
-				info(1, '%s: Distribution updated (new: %d, removed: %d)' % (dist.nick, distnew, distremoved))
-				sumnew = sumnew + distnew
-				sumremoved = sumremoved + distremoved
+            if distnew or distremoved:
+                msg = msg + '\n'
+                info(1, '%s: Distribution updated (new: %d, removed: %d)' % (dist.nick, distnew, distremoved))
+                sumnew = sumnew + distnew
+                sumremoved = sumremoved + distremoved
 
-	if sumnew or sumremoved:
-		subject = 'changes to %s (new: %d, removed: %d)' % (os.uname()[1], sumnew, sumremoved)
-		mail(subject, msg)
+    if sumnew or sumremoved:
+        subject = 'changes to %s (new: %d, removed: %d)' % (os.uname()[1], sumnew, sumremoved)
+        mail(subject, msg)
 
-	if not op.generate:
-		sys.exit(0)
+    if not op.generate:
+        sys.exit(0)
 
-	htmlindex()
+    htmlindex()
 
-	### Generating metadata for available distributions/repositories
-	for dist in dists:
-		dist.html()
+    ### Generating metadata for available distributions/repositories
+    for dist in dists:
+        dist.html()
 
-		info(1, '%s: Generating %s meta-data' % (dist.nick, dist.name))
+        info(1, '%s: Generating %s meta-data' % (dist.nick, dist.name))
 
-		info(5, '%s: Removing %s symlinks' % (dist.nick, 'all'))
-		mkdir(os.path.join(cf.wwwdir, dist.nick, 'RPMS.all'))
-		remove(glob.glob(os.path.join(cf.wwwdir, dist.nick, 'RPMS.all', '*.rpm')))
+        info(5, '%s: Removing %s symlinks' % (dist.nick, 'all'))
+        mkdir(os.path.join(cf.wwwdir, dist.nick, 'RPMS.all'))
+        remove(glob.glob(os.path.join(cf.wwwdir, dist.nick, 'RPMS.all', '*.rpm')))
 
-		for repo in dist.listrepos(op.repos):
-			if not repo.lock('generate'):
-				continue
-			repo.clean()
-			if repo.name in ('os', 'core') and dist.isos:
-				repo.url = None
-				for disc in dist.discs:
-					repo.link(os.path.join(dist.dir, disc))
-				for file in glob.glob(os.path.join(dist.dir + '/disc1/*/base/comps.xml')):
-					if not os.path.exists(os.path.join(cf.srcdir, dist.nick, 'os-comps.xml')):
-						copy(file, os.path.join(cf.srcdir, dist.nick, 'os-comps.xml'))
-			repo.linkall()
-			repo.link()
+        for repo in dist.listrepos(op.repos):
+            if not repo.lock('generate'):
+                continue
+            repo.clean()
+            if repo.name in ('os', 'core') and dist.isos:
+                repo.url = None
+                for disc in dist.discs:
+                    repo.link(os.path.join(dist.dir, disc))
+                for file in glob.glob(os.path.join(dist.dir + '/disc1/*/base/comps.xml')):
+                    if not os.path.exists(os.path.join(cf.srcdir, dist.nick, 'os-comps.xml')):
+                        copy(file, os.path.join(cf.srcdir, dist.nick, 'os-comps.xml'))
+            repo.linkall()
+            repo.link()
 
-			### Check if repository is updated
-			repo.check()
-			repo.createmd()
+            ### Check if repository is updated
+            repo.check()
+            repo.createmd()
 
-			### After generation, write a sha1sum
-			repo.writesha1()
+            ### After generation, write a sha1sum
+            repo.writesha1()
 
-			repo.unlock('generate')
+            repo.unlock('generate')
 
-		dist.pxe()
+        dist.pxe()
 
-	if cf.hardlink and not op.dists:
-		hardlink(cf.srcdir)
+    if cf.hardlink and not op.dists:
+        hardlink(cf.srcdir)
 
 ### Unbuffered sys.stdout
 sys.stdout = os.fdopen(1, 'w', 0)
@@ -1445,17 +1445,17 @@
 
 ### Main entrance
 if __name__ == '__main__':
-	exitcode = 0
+    exitcode = 0
 
-	op = Options(sys.argv[1:])
-	cf = readconfig()
-	try:
-		main()
-	except KeyboardInterrupt, e:
-		die(6, 'Exiting on user request')
-#	except OSError, e:
-#		print e.errno
-#		die(7, 'OSError: %s' % e)
-	sys.exit(exitcode)
+    op = Options(sys.argv[1:])
+    cf = readconfig()
+    try:
+        main()
+    except KeyboardInterrupt, e:
+        die(6, 'Exiting on user request')
+#   except OSError, e:
+#       print e.errno
+#       die(7, 'OSError: %s' % e)
+    sys.exit(exitcode)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/mrepo/rhnget
===================================================================
--- trunk/tools/mrepo/rhnget	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/rhnget	2007-05-12 04:07:27 UTC (rev 5391)
@@ -18,10 +18,10 @@
 import signal, xmlrpclib, getpass, glob, fnmatch
 
 if os.path.exists('/usr/share/rhn/') and os.path.exists('/usr/share/rhn/up2date_client/'):
-	sys.path.insert(0, '/usr/share/rhn/')
-	sys.path.insert(1, '/usr/share/rhn/up2date_client/')
+    sys.path.insert(0, '/usr/share/rhn/')
+    sys.path.insert(1, '/usr/share/rhn/up2date_client/')
 else:
-	die(1,'up2date is not installed. Aborting execution')
+    die(1,'up2date is not installed. Aborting execution')
 
 from up2date_client import config, rpcServer, wrapperUtils, up2dateErrors, repoDirector
 from rhn import rpclib
@@ -37,98 +37,98 @@
 
 ### Register rhn and rhns as a known schemes
 for scheme in ('rhn', 'rhns'):
-	urlparse.uses_netloc.insert(0, scheme)
-	urlparse.uses_query.insert(0, scheme)
+    urlparse.uses_netloc.insert(0, scheme)
+    urlparse.uses_query.insert(0, scheme)
 
 class Options:
-	def __init__(self, args):
-		self.cleanup = False
-		self.downloadall = False
-		self.dryrun = False
-		self.filter = None
-		self.list = None
-		self.quiet = False
-		self.rhnpassword = None
-		self.rhnrelease = None
-		self.rhnusername = None
-		self.systemid = '/etc/sysconfig/rhn/systemid'
-		self.verbose = 1
+    def __init__(self, args):
+        self.cleanup = False
+        self.downloadall = False
+        self.dryrun = False
+        self.filter = None
+        self.list = None
+        self.quiet = False
+        self.rhnpassword = None
+        self.rhnrelease = None
+        self.rhnusername = None
+        self.systemid = '/etc/sysconfig/rhn/systemid'
+        self.verbose = 1
 
-		try:
-			opts, args = getopt.getopt (args, 'hlnqp:r:s:u:v',
-				('delete', 'download-all', 'dryrun', 'filter=', 'help', 'list', 'password=', 'quiet',
-				 'release=', 'systemid=', 'username=', 'verbose', 'version' ))
-		except getopt.error, exc:
-			print 'rhnget: %s, try rhnget -h for a list of all the options' % str(exc)
-			sys.exit(1)
+        try:
+            opts, args = getopt.getopt (args, 'hlnqp:r:s:u:v',
+                ('delete', 'download-all', 'dryrun', 'filter=', 'help', 'list', 'password=', 'quiet',
+                 'release=', 'systemid=', 'username=', 'verbose', 'version' ))
+        except getopt.error, exc:
+            print 'rhnget: %s, try rhnget -h for a list of all the options' % str(exc)
+            sys.exit(1)
 
-		for opt, arg in opts:
-			if opt in ('--delete', ):
-				self.cleanup = True
-			elif opt in ('--download-all', ):
-				self.downloadall = True
-			elif opt in ('--filter', ):
-				self.filter = arg
-				self.downloadall = True
-			elif opt in ('-h', '--help'):
-				self.usage()
-				print
-				self.help()
-				sys.exit(0)
-			elif opt in ('-l', '--list'):
-				self.list = True
-				self.downloadall = True
-			elif opt in ('-n', '--dry-run'):
-				self.dryrun = True
-			elif opt in ['-p', '--password']:
-				self.rhnpassword = arg
-			elif opt in ('-q', '--quiet'):
-				self.quiet = True
-			elif opt in ('-r', '--release'):
-				self.rhnrelease = arg
-			elif opt in ('-s', '--systemid'):
-				self.systemid = os.path.abspath(arg)
-			elif opt in ['-u', '--username']:
-				self.rhnusername = arg
-			elif opt in ('-v', '--verbose'):
-				self.verbose = self.verbose + 1
-			elif opt in ('--version', ):
-				self.version()
-				sys.exit(0)
+        for opt, arg in opts:
+            if opt in ('--delete', ):
+                self.cleanup = True
+            elif opt in ('--download-all', ):
+                self.downloadall = True
+            elif opt in ('--filter', ):
+                self.filter = arg
+                self.downloadall = True
+            elif opt in ('-h', '--help'):
+                self.usage()
+                print
+                self.help()
+                sys.exit(0)
+            elif opt in ('-l', '--list'):
+                self.list = True
+                self.downloadall = True
+            elif opt in ('-n', '--dry-run'):
+                self.dryrun = True
+            elif opt in ['-p', '--password']:
+                self.rhnpassword = arg
+            elif opt in ('-q', '--quiet'):
+                self.quiet = True
+            elif opt in ('-r', '--release'):
+                self.rhnrelease = arg
+            elif opt in ('-s', '--systemid'):
+                self.systemid = os.path.abspath(arg)
+            elif opt in ['-u', '--username']:
+                self.rhnusername = arg
+            elif opt in ('-v', '--verbose'):
+                self.verbose = self.verbose + 1
+            elif opt in ('--version', ):
+                self.version()
+                sys.exit(0)
 
-		if len(args) &lt; 1:
-			self.usage()
-			print
-			self.help()
-			sys.exit(1)
+        if len(args) &lt; 1:
+            self.usage()
+            print
+            self.help()
+            sys.exit(1)
 
-		self.uri = args[0]
+        self.uri = args[0]
 
-		if len(args) == 2:
-			self.destination = args[1]
-		else:
-			self.destination = os.getcwd()
+        if len(args) == 2:
+            self.destination = args[1]
+        else:
+            self.destination = os.getcwd()
 
-		if self.quiet:
-			self.verbose = 0
+        if self.quiet:
+            self.verbose = 0
 
-		if self.verbose &gt;= 3:
-			print 'Verbosity set to level %d' % (self.verbose - 1)
+        if self.verbose &gt;= 3:
+            print 'Verbosity set to level %d' % (self.verbose - 1)
 
-	def version(self):
-		print 'rhnget %s' % VERSION
-		print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
-		print
-		print 'platform %s/%s' % (os.name, sys.platform)
-		print 'python %s' % sys.version
-		print
-		print 'build revision $Rev: 4786 $'
+    def version(self):
+        print 'rhnget %s' % VERSION
+        print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
+        print
+        print 'platform %s/%s' % (os.name, sys.platform)
+        print 'python %s' % sys.version
+        print
+        print 'build revision $Rev: 4786 $'
 
-	def usage(self):
-		print 'usage: rhnget [options] <A HREF="rhns://server/channel">rhns://server/channel</A> destination-path'
+    def usage(self):
+        print 'usage: rhnget [options] <A HREF="rhns://server/channel">rhns://server/channel</A> destination-path'
 
-	def help(self):
-		print '''Download packages from Red Hat Network (RHN)
+    def help(self):
+        print '''Download packages from Red Hat Network (RHN)
 
 rhnget options:
       --delete            delete files that are not on the sender side
@@ -144,339 +144,339 @@
 '''
 
 class Set:
-	def __init__(self):
-		self.list = []
+    def __init__(self):
+        self.list = []
 
-	def add(self, input):
-		if input not in self.list:
-			self.list.append(input)
+    def add(self, input):
+        if input not in self.list:
+            self.list.append(input)
     
-	def delete(self, input):
-		if input in self.list:
-			self.list.removed(input)
+    def delete(self, input):
+        if input in self.list:
+            self.list.removed(input)
     
-	def difference(self, other):
-		newlist = Set()
-		for element in self.list:
-			if element not in other.list:
-				newlist.add(element)
-		return newlist
+    def difference(self, other):
+        newlist = Set()
+        for element in self.list:
+            if element not in other.list:
+                newlist.add(element)
+        return newlist
 
-	def sort(self):
-		return self.list.sort()
+    def sort(self):
+        return self.list.sort()
     
-	def __str__(self):
-		return '\n\t' + '\n\t'.join([element[0] for element in self.list])
+    def __str__(self):
+        return '\n\t' + '\n\t'.join([element[0] for element in self.list])
 
-	def __len__(self):
-		return len(self.list)
+    def __len__(self):
+        return len(self.list)
 
 class MirrorException(Exception):
-	def __init__(self, value):
-		self.value = value
-	def __str__(self):
-		return repr(self.value)
+    def __init__(self, value):
+        self.value = value
+    def __str__(self):
+        return repr(self.value)
 
 def error(level, str):
-	&quot;Output error message&quot;
-	if level &lt;= op.verbose:
-		sys.stderr.write('rhnget: %s\n' % str)
+    &quot;Output error message&quot;
+    if level &lt;= op.verbose:
+        sys.stderr.write('rhnget: %s\n' % str)
 
 def info(level, str):
-	&quot;Output info message&quot;
-	if level &lt;= op.verbose:
-		sys.stdout.write('%s\n' % str)
+    &quot;Output info message&quot;
+    if level &lt;= op.verbose:
+        sys.stdout.write('%s\n' % str)
 
 def die(ret, str):
-	&quot;Print error and exit with errorcode&quot;
-	error(0, str)
-	sys.exit(ret)
+    &quot;Print error and exit with errorcode&quot;
+    error(0, str)
+    sys.exit(ret)
 
 def remove(file):
-	&quot;Remove files or directories&quot;
-	if isinstance(file, types.StringType):
-		if op.dryrun:
-			return
-		if os.path.islink(file):
-			os.unlink(file)
-		elif os.path.isdir(file):
-			try:
-				os.rmdir(file)
-			except:
-				os.path.walk(file, removedir, ())
-				os.rmdir(file)
-		elif os.path.isfile(file) or os.path.islink(file):
-			os.unlink(file)
-	else:
-		for f in file:
-			remove(f)
+    &quot;Remove files or directories&quot;
+    if isinstance(file, types.StringType):
+        if op.dryrun:
+            return
+        if os.path.islink(file):
+            os.unlink(file)
+        elif os.path.isdir(file):
+            try:
+                os.rmdir(file)
+            except:
+                os.path.walk(file, removedir, ())
+                os.rmdir(file)
+        elif os.path.isfile(file) or os.path.islink(file):
+            os.unlink(file)
+    else:
+        for f in file:
+            remove(f)
 
 def removedir(void, dir, files):
-	for file in files:
-		remove(os.path.join(dir, file))
+    for file in files:
+        remove(os.path.join(dir, file))
 
 def mkdir(path):
-	&quot;Create a directory, and parents if needed&quot;
-	if op.dryrun:
-		return
-	if os.path.islink(path):
-		os.unlink(path)
-	if not os.path.exists(path):
-		os.makedirs(path)
+    &quot;Create a directory, and parents if needed&quot;
+    if op.dryrun:
+        return
+    if os.path.islink(path):
+        os.unlink(path)
+    if not os.path.exists(path):
+        os.makedirs(path)
 
 def rhnlogin(url, path, force=False):
-	'Log on to RHN and return cfg, loginInfo and systemid'
-	global cfg, loginInfo, rd, config, rpcServer
+    'Log on to RHN and return cfg, loginInfo and systemid'
+    global cfg, loginInfo, rd, config, rpcServer
 
-	### Look for the usual suspects
-	if os.path.isfile(op.systemid):
-		systemidpath = op.systemid
-	elif os.path.isfile('/etc/sysconfig/rhn/systemid'):
-		systemidpath = '/etc/sysconfig/rhn/systemid'
-	else:
-		info(1, 'No RHN systemid found, skipping download.')
-		return
-	info(3, 'Using RHN systemid from %s' % systemidpath)
+    ### Look for the usual suspects
+    if os.path.isfile(op.systemid):
+        systemidpath = op.systemid
+    elif os.path.isfile('/etc/sysconfig/rhn/systemid'):
+        systemidpath = '/etc/sysconfig/rhn/systemid'
+    else:
+        info(1, 'No RHN systemid found, skipping download.')
+        return
+    info(3, 'Using RHN systemid from %s' % systemidpath)
 
-	systemid = open(systemidpath).read()
+    systemid = open(systemidpath).read()
 
-	cfg['systemIdPath'] = systemidpath
-	cfg = config.initUp2dateConfig()
-	cfg['systemIdPath'] = systemidpath
-	cfg['storageDir'] = path
-	cfg['retrieveOnly'] = 1
-	cfg['keepAfterInstall'] = 1
-	cfg['noReboot'] = 1
-	cfg['useRhn'] = 1
-	cfg['showChannels'] = 1
-	cfg['showAvailablePackages'] = 1
-	cfg['isatty'] = 1
-	cfg['networkRetries'] = 3
-#	cfg['headerFetchCount'] = 20
-	cfg['enableProxy'] = 0
-	cfg['enableProxyAuth'] = 0
-	cfg['httpProxy'] = ''
-	cfg['proxyUser='] = ''
-	cfg['proxyPassword'] = ''
-	cfg[&quot;sslCACert&quot;] = '/usr/share/rhn/RHNS-CA-CERT'
+    cfg['systemIdPath'] = systemidpath
+    cfg = config.initUp2dateConfig()
+    cfg['systemIdPath'] = systemidpath
+    cfg['storageDir'] = path
+    cfg['retrieveOnly'] = 1
+    cfg['keepAfterInstall'] = 1
+    cfg['noReboot'] = 1
+    cfg['useRhn'] = 1
+    cfg['showChannels'] = 1
+    cfg['showAvailablePackages'] = 1
+    cfg['isatty'] = 1
+    cfg['networkRetries'] = 3
+#   cfg['headerFetchCount'] = 20
+    cfg['enableProxy'] = 0
+    cfg['enableProxyAuth'] = 0
+    cfg['httpProxy'] = ''
+    cfg['proxyUser='] = ''
+    cfg['proxyPassword'] = ''
+    cfg[&quot;sslCACert&quot;] = '/usr/share/rhn/RHNS-CA-CERT'
 
-	### Override the version if forced in mrepo configuration (to allow single systemid usage)
-	if op.rhnrelease:
-		cfg['versionOverride'] = op.rhnrelease
-	else:
-		cfg['versionOverride'] = rpclib.xmlrpclib.loads(systemid)[0][0]['os_release']
-	info(3, 'Using RHN release %s' % cfg['versionOverride'])
+    ### Override the version if forced in mrepo configuration (to allow single systemid usage)
+    if op.rhnrelease:
+        cfg['versionOverride'] = op.rhnrelease
+    else:
+        cfg['versionOverride'] = rpclib.xmlrpclib.loads(systemid)[0][0]['os_release']
+    info(3, 'Using RHN release %s' % cfg['versionOverride'])
 
-#	if op.arch:
-#		cfg['forceArch'] = '%s-redhat-linux' % op.arch
+#   if op.arch:
+#       cfg['forceArch'] = '%s-redhat-linux' % op.arch
 
-	### Modify the logfile in case we have no rights to write in /var/log/up2date (non-root)
-	if os.access('/var/log/up2date', os.W_OK):
-		cfg['logFile'] = '/var/log/up2date'
-	else:
-		cfg['logFile'] = os.path.expanduser('~/up2date.log')
+    ### Modify the logfile in case we have no rights to write in /var/log/up2date (non-root)
+    if os.access('/var/log/up2date', os.W_OK):
+        cfg['logFile'] = '/var/log/up2date'
+    else:
+        cfg['logFile'] = os.path.expanduser('~/up2date.log')
 
-	### If we're not targetting the default RHN server, change the location
-	rhnscheme, rhnserver, t, t, t, t = urlparse.urlparse(url)
-	if not rhnserver:
-		rhnserver = 'xmlrpc.rhn.redhat.com'
+    ### If we're not targetting the default RHN server, change the location
+    rhnscheme, rhnserver, t, t, t, t = urlparse.urlparse(url)
+    if not rhnserver:
+        rhnserver = 'xmlrpc.rhn.redhat.com'
 
-	cfg['noSSLServerURL'] = '<A HREF="http://%s/XMLRPC">http://%s/XMLRPC</A>' % rhnserver
-	if rhnscheme == 'rhn':
-		cfg['serverURL'] = '<A HREF="http://%s/XMLRPC">http://%s/XMLRPC</A>' % rhnserver
-	else:
-		cfg['serverURL'] = '<A HREF="https://%s/XMLRPC">https://%s/XMLRPC</A>' % rhnserver
+    cfg['noSSLServerURL'] = '<A HREF="http://%s/XMLRPC">http://%s/XMLRPC</A>' % rhnserver
+    if rhnscheme == 'rhn':
+        cfg['serverURL'] = '<A HREF="http://%s/XMLRPC">http://%s/XMLRPC</A>' % rhnserver
+    else:
+        cfg['serverURL'] = '<A HREF="https://%s/XMLRPC">https://%s/XMLRPC</A>' % rhnserver
 
-	### Get proxy information from environment and set up2date config accordingly
-	proxy = None
-	if os.environ.has_key('http_proxy') and rhnscheme == 'rhn':
-		t, proxy, t, t, t, t = urlparse.urlparse(os.environ['http_proxy'])
-	elif os.environ.has_key('https_proxy') and rhnscheme == 'rhns':
-		t, proxy, t, t, t, t = urlparse.urlparse(os.environ['https_proxy'])
-	if proxy:
-		cfg['enableProxy'] = 1
-		cfg['httpProxy'] = proxy
-		info(4, 'Setting proxy for %s to %s' % (rhnscheme, proxy))
-		### FIXME: Implement proxy authentication
-#		if proxy.username and proxy.password:
-#			cfg['enableProxyAuth'] = 1
-#			cfg['proxyPassword'] = proxy.password
-#			cfg['proxyUser='] = proxy.username
+    ### Get proxy information from environment and set up2date config accordingly
+    proxy = None
+    if os.environ.has_key('http_proxy') and rhnscheme == 'rhn':
+        t, proxy, t, t, t, t = urlparse.urlparse(os.environ['http_proxy'])
+    elif os.environ.has_key('https_proxy') and rhnscheme == 'rhns':
+        t, proxy, t, t, t, t = urlparse.urlparse(os.environ['https_proxy'])
+    if proxy:
+        cfg['enableProxy'] = 1
+        cfg['httpProxy'] = proxy
+        info(4, 'Setting proxy for %s to %s' % (rhnscheme, proxy))
+        ### FIXME: Implement proxy authentication
+#       if proxy.username and proxy.password:
+#           cfg['enableProxyAuth'] = 1
+#           cfg['proxyPassword'] = proxy.password
+#           cfg['proxyUser='] = proxy.username
 
-	### Set debugging information to something very high (there seems to be no granularity)
-	if op.verbose &gt;= 3:
-		cfg['debug'] = 1
+    ### Set debugging information to something very high (there seems to be no granularity)
+    if op.verbose &gt;= 3:
+        cfg['debug'] = 1
 
-	info(4, '\nBEFORE LOGIN: logininfo: %s\n' % loginInfo)
-	try:
-		server = rpcServer.getServer()
-		li = rpcServer.doCall(server.up2date.login, systemid)
-		loginInfo.update(li)
-	except rpclib.Fault, f:
-		error(1, 'Error logging in with systemid %s. %s' % (systemidpath, f.faultString))
-		return None
-	info(4, '\nAFTER LOGIN: logininfo: %s\n' % loginInfo)
+    info(4, '\nBEFORE LOGIN: logininfo: %s\n' % loginInfo)
+    try:
+        server = rpcServer.getServer()
+        li = rpcServer.doCall(server.up2date.login, systemid)
+        loginInfo.update(li)
+    except rpclib.Fault, f:
+        error(1, 'Error logging in with systemid %s. %s' % (systemidpath, f.faultString))
+        return None
+    info(4, '\nAFTER LOGIN: logininfo: %s\n' % loginInfo)
 
-	return systemid
+    return systemid
 
 def rhngetchannel(channels, label):
-	'Return the channel with given label, if found'
-	for c in channels:
-		if isinstance(c, types.ListType):
-			l, v = c[0], c[1]
-		else:
-			l, v = c['label'], c['version']
-		if l == label:
-			return {
-				'label': l,
-				'version': v,
-				'type': 'up2date',
-				'url': cfg['serverURL'],
-			}
-	return None
+    'Return the channel with given label, if found'
+    for c in channels:
+        if isinstance(c, types.ListType):
+            l, v = c[0], c[1]
+        else:
+            l, v = c['label'], c['version']
+        if l == label:
+            return {
+                'label': l,
+                'version': v,
+                'type': 'up2date',
+                'url': cfg['serverURL'],
+            }
+    return None
 
 def mirrorrhn(url, path):
-	'Mirror a channel from RHN'
-	global cfg, loginInfo, rd, repoDirector, rpcServer
+    'Mirror a channel from RHN'
+    global cfg, loginInfo, rd, repoDirector, rpcServer
 
-	t, t, label, t, t, t = urlparse.urlparse(url)
-	label = label.strip('/')
+    t, t, label, t, t, t = urlparse.urlparse(url)
+    label = label.strip('/')
 
-	### Log on to RHN
-	systemid = rhnlogin(url, path)
-	if not systemid:
-		return
+    ### Log on to RHN
+    systemid = rhnlogin(url, path)
+    if not systemid:
+        return
 
-	mkdir(cfg['storageDir'])
+    mkdir(cfg['storageDir'])
 
-	### Try to find a channel with label
-	channel = rhngetchannel(loginInfo.get('X-RHN-Auth-Channels'), label)
-	if not channel:
-#		raise(Exception('Error system not subscribe to channel %s, skipping.' % label))
-		if not op.rhnusername:
-			op.rhnusername = raw_input('RHN Username: ')
+    ### Try to find a channel with label
+    channel = rhngetchannel(loginInfo.get('X-RHN-Auth-Channels'), label)
+    if not channel:
+#       raise(Exception('Error system not subscribe to channel %s, skipping.' % label))
+        if not op.rhnusername:
+            op.rhnusername = raw_input('RHN Username: ')
 
-		if op.rhnusername and not op.rhnpassword:
-			op.rhnpassword = getpass.getpass('RHN Password for user %s: ' % op.rhnusername)
+        if op.rhnusername and not op.rhnpassword:
+            op.rhnpassword = getpass.getpass('RHN Password for user %s: ' % op.rhnusername)
 
-		if op.rhnusername and op.rhnpassword:
-		   	try:
-				server = rpcServer.getServer()
-				channels = rpcServer.doCall(server.up2date.subscribeChannels, systemid, (label,), op.rhnusername, op.rhnpassword)
-			except rpclib.Fault, f:
-				raise(Exception('Error subscribing to channel %s, skipping.%s' % (label, f.faultString)))
-			systemid = rhnlogin(url, path, force=True)
-			if not systemid:
-				return
-			info(4, '\nAFTER SUBSC: logininfo: %s\n' % loginInfo)
-			channel = rhngetchannel(loginInfo.get('X-RHN-Auth-Channels'), label)
-			if not channel:
-				raise(Exception('Failed to subscribe RHN id to channel %s, skipping.' % label))
-		else:
-			raise(Exception('No RHN username or password supplied. Please add channel %s on RHN website manually. Skipping.' % label))
+        if op.rhnusername and op.rhnpassword:
+            try:
+                server = rpcServer.getServer()
+                channels = rpcServer.doCall(server.up2date.subscribeChannels, systemid, (label,), op.rhnusername, op.rhnpassword)
+            except rpclib.Fault, f:
+                raise(Exception('Error subscribing to channel %s, skipping.%s' % (label, f.faultString)))
+            systemid = rhnlogin(url, path, force=True)
+            if not systemid:
+                return
+            info(4, '\nAFTER SUBSC: logininfo: %s\n' % loginInfo)
+            channel = rhngetchannel(loginInfo.get('X-RHN-Auth-Channels'), label)
+            if not channel:
+                raise(Exception('Failed to subscribe RHN id to channel %s, skipping.' % label))
+        else:
+            raise(Exception('No RHN username or password supplied. Please add channel %s on RHN website manually. Skipping.' % label))
 
-	### Download packagelist for this channel
-	try:
-		repos = repoDirector.initRepoDirector()
-	except xmlrpclib.Fault, f:
-		raise(MirrorException('Problem setting up XML communication for channel %s.\n%s' % (label, f.faultString)))
-		return
-	except up2dateErrors.ServerCapabilityError, e:
-		raise(MirrorException('Problem negotiating capabilities for channel %s.\n%s' % (label, e)))
-		return
+    ### Download packagelist for this channel
+    try:
+        repos = repoDirector.initRepoDirector()
+    except xmlrpclib.Fault, f:
+        raise(MirrorException('Problem setting up XML communication for channel %s.\n%s' % (label, f.faultString)))
+        return
+    except up2dateErrors.ServerCapabilityError, e:
+        raise(MirrorException('Problem negotiating capabilities for channel %s.\n%s' % (label, e)))
+        return
 
-	try:
-		if op.downloadall == True:
-			package_list, type = rpcServer.doCall(repos.listAllPackages, channel, None, None)
-		else:
-			package_list, type = rpcServer.doCall(repos.listPackages, channel, None, None)
-	except rpclib.Fault, f:
-		raise(MirrorException('Error listing packages from channel %s. Skipping. %s' % (label, f.faultString)))
-	except up2dateErrors.CommunicationError, e:
-		raise(MirrorException('Error listing packages from channel %s. Skipping.\n%s' % (label, e)))
-	except KeyError, e:
-		if e == &quot;'up2date'&quot;:
-			raise(MirrorException('Missing up2date entry in /etc/sysconfig/rhn/sources.'))
-		else:
-			raise(MirrorException('Unknown error that needs more debugging occured with channel %s. Skipping.\n%s' % (label, e)))
+    try:
+        if op.downloadall == True:
+            package_list, type = rpcServer.doCall(repos.listAllPackages, channel, None, None)
+        else:
+            package_list, type = rpcServer.doCall(repos.listPackages, channel, None, None)
+    except rpclib.Fault, f:
+        raise(MirrorException('Error listing packages from channel %s. Skipping. %s' % (label, f.faultString)))
+    except up2dateErrors.CommunicationError, e:
+        raise(MirrorException('Error listing packages from channel %s. Skipping.\n%s' % (label, e)))
+    except KeyError, e:
+        if e == &quot;'up2date'&quot;:
+            raise(MirrorException('Missing up2date entry in /etc/sysconfig/rhn/sources.'))
+        else:
+            raise(MirrorException('Unknown error that needs more debugging occured with channel %s. Skipping.\n%s' % (label, e)))
 
-	### Download packages from the packagelist
-	signal.signal(signal.SIGINT, signal.SIG_DFL)
-	for pkg in package_list:
-		### FIXME: Check if not already on ISO-file or repository as well
-		filename = '%s-%s-%s.%s.rpm' % (pkg[0], pkg[1], pkg[2], pkg[4])
+    ### Download packages from the packagelist
+    signal.signal(signal.SIGINT, signal.SIG_DFL)
+    for pkg in package_list:
+        ### FIXME: Check if not already on ISO-file or repository as well
+        filename = '%s-%s-%s.%s.rpm' % (pkg[0], pkg[1], pkg[2], pkg[4])
 
-		### Filter packagelist
-		if op.filter and not fnmatch.fnmatch(filename, op.filter):
-			info(4, 'Packages %s excluded by filter' % filename)
-			continue
+        ### Filter packagelist
+        if op.filter and not fnmatch.fnmatch(filename, op.filter):
+            info(4, 'Packages %s excluded by filter' % filename)
+            continue
 
-		### List only files if requested
-		if op.list:
-			info(0, filename)
-			continue
+        ### List only files if requested
+        if op.list:
+            info(0, filename)
+            continue
 
-		### If file (or symlink target) exists
-		if os.path.isfile(os.path.join(path, filename)):
-			stat = os.stat(os.path.join(path, filename))
-			if stat.st_size == int(pkg[5]):
-				info(3, 'File %s is already in %s' % (filename, path))
-				continue
-			else:
-				info(2, 'File %s has wrong size (found: %s, expected: %s), refetching.' % (filename, stat.st_size, pkg[5]))
-				remove(os.path.join(path, filename))
+        ### If file (or symlink target) exists
+        if os.path.isfile(os.path.join(path, filename)):
+            stat = os.stat(os.path.join(path, filename))
+            if stat.st_size == int(pkg[5]):
+                info(3, 'File %s is already in %s' % (filename, path))
+                continue
+            else:
+                info(2, 'File %s has wrong size (found: %s, expected: %s), refetching.' % (filename, stat.st_size, pkg[5]))
+                remove(os.path.join(path, filename))
 
-		### If symlink target does not exist, remove symlink
-		elif os.path.islink(os.path.join(path, filename)):
-			remove(os.path.join(path, filename))
+        ### If symlink target does not exist, remove symlink
+        elif os.path.islink(os.path.join(path, filename)):
+            remove(os.path.join(path, filename))
 
-		if op.dryrun:
-			info(1, 'Not downloading package %s' % filename)
-			continue
+        if op.dryrun:
+            info(1, 'Not downloading package %s' % filename)
+            continue
 
-		try:
-			if op.verbose &lt;= 1:
-				rpcServer.doCall(repos.getPackage, pkg, None, None)
-			else:
-				rpcServer.doCall(repos.getPackage, pkg, wrapperUtils.printPkg, wrapperUtils.printRetrieveHash)
-		except rpclib.Fault, f:
-			error(0, 'rpcError: Error getting package %s from %s. %s' % (filename, label, f.faultString))
-		except TypeError, e:
-			error(0, 'TypeError: Error downloading package %s from %s. Skipping.\n%s' % (filename, label, e))
-		except up2dateErrors.CommunicationError, e:
-			error(0, 'CommunicationError: Error downloading package %s from %s. Skipping.\n%s' % (filename, label, e))
+        try:
+            if op.verbose &lt;= 1:
+                rpcServer.doCall(repos.getPackage, pkg, None, None)
+            else:
+                rpcServer.doCall(repos.getPackage, pkg, wrapperUtils.printPkg, wrapperUtils.printRetrieveHash)
+        except rpclib.Fault, f:
+            error(0, 'rpcError: Error getting package %s from %s. %s' % (filename, label, f.faultString))
+        except TypeError, e:
+            error(0, 'TypeError: Error downloading package %s from %s. Skipping.\n%s' % (filename, label, e))
+        except up2dateErrors.CommunicationError, e:
+            error(0, 'CommunicationError: Error downloading package %s from %s. Skipping.\n%s' % (filename, label, e))
 
-	### Remove packages on the receiver side that are not on the sender side
-	if op.cleanup:
+    ### Remove packages on the receiver side that are not on the sender side
+    if op.cleanup:
 
-		### Collect receiver side
-		receiver = Set()
-		for file in glob.glob(os.path.join(path, '*.rpm')):
-			if os.path.exists(file):
-				filename = os.path.basename(file)
-				size = os.stat(file).st_size
-				receiver.add( (filename, size) )
-		receiver.sort()
+        ### Collect receiver side
+        receiver = Set()
+        for file in glob.glob(os.path.join(path, '*.rpm')):
+            if os.path.exists(file):
+                filename = os.path.basename(file)
+                size = os.stat(file).st_size
+                receiver.add( (filename, size) )
+        receiver.sort()
 
-		### Collect sender side
-		sender = Set()
-		for pkg in package_list:
-			filename = '%s-%s-%s.%s.rpm' % (pkg[0], pkg[1], pkg[2], pkg[4])
-			size = int(pkg[5])
-			sender.add( (filename, size) )
-		sender.sort()
+        ### Collect sender side
+        sender = Set()
+        for pkg in package_list:
+            filename = '%s-%s-%s.%s.rpm' % (pkg[0], pkg[1], pkg[2], pkg[4])
+            size = int(pkg[5])
+            sender.add( (filename, size) )
+        sender.sort()
 
-		### Remove difference between receiver and sender
-		cleanse = receiver.difference(sender)
-		for filename, size in cleanse.list:
-			info(3, 'Cleaning up obsolete file %s (%d kiB)' % (filename, size))
-			remove(os.path.join(path, filename))
+        ### Remove difference between receiver and sender
+        cleanse = receiver.difference(sender)
+        for filename, size in cleanse.list:
+            info(3, 'Cleaning up obsolete file %s (%d kiB)' % (filename, size))
+            remove(os.path.join(path, filename))
 
 def main():
-	try:
-		mirrorrhn(op.uri, op.destination)
-	except Exception, e:
-		die(1, e)
+    try:
+        mirrorrhn(op.uri, op.destination)
+    except Exception, e:
+        die(1, e)
 
 ### Unbuffered sys.stdout
 sys.stdout = os.fdopen(1, 'w', 0)
@@ -491,13 +491,13 @@
 
 ### Main entrance
 if __name__ == '__main__':
-	exitcode = 0
+    exitcode = 0
 
-	op = Options(sys.argv[1:])
-	try:
-		main()
-	except KeyboardInterrupt, e:
-		die(6, 'Exiting on user request')
-	sys.exit(exitcode)
+    op = Options(sys.argv[1:])
+    try:
+        main()
+    except KeyboardInterrupt, e:
+        die(6, 'Exiting on user request')
+    sys.exit(exitcode)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/mrepo/setup.py
===================================================================
--- trunk/tools/mrepo/setup.py	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/setup.py	2007-05-12 04:07:27 UTC (rev 5391)
@@ -25,40 +25,40 @@
 #ez_setup.use_setuptools()
 
 try:
-	from setuptools import setup
+    from setuptools import setup
 except ImportError:
-	from distutils.core import setup
+    from distutils.core import setup
 
 setup(
-	name = 'mrepo',
-	version = '0.8.4svn',
-	description = 'RPM repository mirroring tool',
-	author = 'Dag Wieers',
-	author_email ='<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>',
-	url = &quot;<A HREF="http://dag.wieers.com/home-made/mrepo/">http://dag.wieers.com/home-made/mrepo/</A>&quot;,
-	scripts=['mrepo', 'gensystemid'],
-	data_files=[
-		('/etc', ['config/mrepo.conf']),
-		('/etc/init.d', ['config/mrepo']),
-		('/etc/httpd/conf.d', ['config/httpd/mrepo.conf']),
-		('/var/cache/mrepo', []),
-		('/var/www/mrepo', []),
-		('/var/mrepo/all/local', []),
-		('/usr/share/mrepo/html', ['html/HEADER.index.shtml', 'html/HEADER.repo.shtml', 'html/README.index.shtml', 'html/README.repo.shtml']),
-	],
-	download_url = '<A HREF="http://dag.wieers.com/home-made/mrepo/mrepo-0.8.4svn.tar.gz">http://dag.wieers.com/home-made/mrepo/mrepo-0.8.4svn.tar.gz</A>',
-	license = 'GPL',
-	platforms = 'Posix',
-	classifiers = [
-		'Internet :: WWW/HTTP :: Site Management',
-		'System :: Archiving :: Mirroring',
-		'System :: Archiving :: Packaging',
-		'System :: Installation/Setup',
-		'System :: Software Distribution',
-		'System :: Software Distribution Tools',
-		'System :: Systems Administration',
-	],
-	long_description = '''
+    name = 'mrepo',
+    version = '0.8.4svn',
+    description = 'RPM repository mirroring tool',
+    author = 'Dag Wieers',
+    author_email ='<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>',
+    url = &quot;<A HREF="http://dag.wieers.com/home-made/mrepo/">http://dag.wieers.com/home-made/mrepo/</A>&quot;,
+    scripts=['mrepo', 'gensystemid'],
+    data_files=[
+        ('/etc', ['config/mrepo.conf']),
+        ('/etc/init.d', ['config/mrepo']),
+        ('/etc/httpd/conf.d', ['config/httpd/mrepo.conf']),
+        ('/var/cache/mrepo', []),
+        ('/var/www/mrepo', []),
+        ('/var/mrepo/all/local', []),
+        ('/usr/share/mrepo/html', ['html/HEADER.index.shtml', 'html/HEADER.repo.shtml', 'html/README.index.shtml', 'html/README.repo.shtml']),
+    ],
+    download_url = '<A HREF="http://dag.wieers.com/home-made/mrepo/mrepo-0.8.4svn.tar.gz">http://dag.wieers.com/home-made/mrepo/mrepo-0.8.4svn.tar.gz</A>',
+    license = 'GPL',
+    platforms = 'Posix',
+    classifiers = [
+        'Internet :: WWW/HTTP :: Site Management',
+        'System :: Archiving :: Mirroring',
+        'System :: Archiving :: Packaging',
+        'System :: Installation/Setup',
+        'System :: Software Distribution',
+        'System :: Software Distribution Tools',
+        'System :: Systems Administration',
+    ],
+    long_description = '''
 mrepo builds a local APT/Yum RPM repository from local ISO files, downloaded
 updates, and extra packages from RHN (Red Hat Network) and 3rd party
 repositories. It takes care of setting up the ISO files, downloading the
@@ -70,7 +70,7 @@
 is equally suitable for an organization's centralized update server.
 
 Depending on the use it may require:
-	apt, up2date, yum, createrepo, repoview, hardlink and/or hardlink++
+    apt, up2date, yum, createrepo, repoview, hardlink and/or hardlink++
 ''',
 )
 

Modified: trunk/tools/mrepo/tests/rhn_query.py
===================================================================
--- trunk/tools/mrepo/tests/rhn_query.py	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/tests/rhn_query.py	2007-05-12 04:07:27 UTC (rev 5391)
@@ -15,15 +15,15 @@
 
 systems = server.system.list_user_systems(session)
 if len(systems) == 0:
-	print &quot;No systems are subscribed to RHN.&quot;
+    print &quot;No systems are subscribed to RHN.&quot;
 else:
-	print &quot;These machines are subscribed to RHN\n\n&quot;
-	print &quot;Name: \t\tcheckin: \t\t\tsid: &quot;
-      	for vals in systems:
-		print &quot;%s\t\t%s\t\t%s&quot; % (vals['name'],vals['last_checkin'],vals['id'])
+    print &quot;These machines are subscribed to RHN\n\n&quot;
+    print &quot;Name: \t\tcheckin: \t\t\tsid: &quot;
+        for vals in systems:
+        print &quot;%s\t\t%s\t\t%s&quot; % (vals['name'],vals['last_checkin'],vals['id'])
 
 methods = server.system.listMethods()
 print methods
 
 for method in methods:
-	print server.system.methodHelp(method)
+    print server.system.methodHelp(method)

Modified: trunk/tools/mrepo/tests/rhn_tool.py
===================================================================
--- trunk/tools/mrepo/tests/rhn_tool.py	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/tests/rhn_tool.py	2007-05-12 04:07:27 UTC (rev 5391)
@@ -4,40 +4,40 @@
 from optparse import OptionParser
 
 def GetOptions():
-	parser=OptionParser()
+    parser=OptionParser()
 
-	parser.add_option(&quot;-d&quot;, &quot;--delete&quot;,
-		action=&quot;store_true&quot;, dest=&quot;delete&quot;, default=False,
-		help = &quot;Deletes system, group, or channel&quot;)
+    parser.add_option(&quot;-d&quot;, &quot;--delete&quot;,
+        action=&quot;store_true&quot;, dest=&quot;delete&quot;, default=False,
+        help = &quot;Deletes system, group, or channel&quot;)
 
-	parser.add_option(&quot;-s&quot;, &quot;--system&quot;,
-		action=&quot;store_true&quot;, dest=&quot;system&quot;, default=False,
-		help=&quot;Used when performing operations to machines subscribe to RHN.&quot;)
+    parser.add_option(&quot;-s&quot;, &quot;--system&quot;,
+        action=&quot;store_true&quot;, dest=&quot;system&quot;, default=False,
+        help=&quot;Used when performing operations to machines subscribe to RHN.&quot;)
 
         parser.add_option(&quot;-q&quot;, &quot;--query&quot;,
-		action=&quot;store_true&quot;, dest=&quot;query&quot;, default=False,
-		help=&quot;Used in conjuction with -s to show subscribed systems.&quot;)
+        action=&quot;store_true&quot;, dest=&quot;query&quot;, default=False,
+        help=&quot;Used in conjuction with -s to show subscribed systems.&quot;)
 
 
-	parser.add_option(&quot;-n&quot;, &quot;--name&quot;,dest=&quot;hostname&quot;,
-		help=&quot;hostname of machine to perform operation on.&quot;, metavar=&quot; hostname&quot;)
+    parser.add_option(&quot;-n&quot;, &quot;--name&quot;,dest=&quot;hostname&quot;,
+        help=&quot;hostname of machine to perform operation on.&quot;, metavar=&quot; hostname&quot;)
 
-	global options
-	(options,args) = parser.parse_args()
+    global options
+    (options,args) = parser.parse_args()
 
-	return options.delete, options.system, options.hostname
+    return options.delete, options.system, options.hostname
 
 def getSystemIds():
-	systems = server.system.list_user_systems(session)
-	return systems
+    systems = server.system.list_user_systems(session)
+    return systems
 
 def deleteSystem(sid):
-	try:
-		print &quot;attempting to remove SID %s... with hostname of %s&quot; % (sid,options.hostname)
-    		delete = server.system.delete_systems(session,sid)
-		print &quot;Deletion of %s successfull.&quot; % (options.hostname)
-	except:
-		print &quot;Deletion of %s unsuccessfull.&quot; % (options.hostname)
+    try:
+        print &quot;attempting to remove SID %s... with hostname of %s&quot; % (sid,options.hostname)
+            delete = server.system.delete_systems(session,sid)
+        print &quot;Deletion of %s successfull.&quot; % (options.hostname)
+    except:
+        print &quot;Deletion of %s unsuccessfull.&quot; % (options.hostname)
 
 host = 'xmlrpc.rhn.redhat.com'
 username='IBM_RHN'
@@ -51,17 +51,17 @@
 GetOptions()
 
 if options.system:
-	systems = getSystemIds()
-	if options.query:
-		if len(systems) == 0:
-			print &quot;No systems are subscribed to RHN.&quot;
-		else:
-			print &quot;These machines are subscribed to RHN\n\n&quot;
-			print &quot;Name: \t\tcheckin: \t\t\tsid: &quot;
-      			for vals in systems:
-				print &quot;%s\t\t%s\t\t%s&quot; % (vals['name'],vals['last_checkin'],vals['id'])
+    systems = getSystemIds()
+    if options.query:
+        if len(systems) == 0:
+            print &quot;No systems are subscribed to RHN.&quot;
+        else:
+            print &quot;These machines are subscribed to RHN\n\n&quot;
+            print &quot;Name: \t\tcheckin: \t\t\tsid: &quot;
+                for vals in systems:
+                print &quot;%s\t\t%s\t\t%s&quot; % (vals['name'],vals['last_checkin'],vals['id'])
 
-	if options.delete:
-		for vals in systems:
-			if vals['name'] == options.hostname:
-				deleteSystem(vals['id'])
+    if options.delete:
+        for vals in systems:
+            if vals['name'] == options.hostname:
+                deleteSystem(vals['id'])

Modified: trunk/tools/mrepo/tests/rhntest.py
===================================================================
--- trunk/tools/mrepo/tests/rhntest.py	2007-05-12 01:32:14 UTC (rev 5390)
+++ trunk/tools/mrepo/tests/rhntest.py	2007-05-12 04:07:27 UTC (rev 5391)
@@ -12,46 +12,46 @@
 from up2date_client import rhnChannel
 
 def getSystemId(dist):
-	return open('/var/yam/'+dist+'/rhn-systemid').read(131072)
+    return open('/var/yam/'+dist+'/rhn-systemid').read(131072)
 
 def subscribedChannels():
-	ret = []
-	debugprint(ret)
-	li = up2dateAuth.getLoginInfo()
-	if not li: return []
+    ret = []
+    debugprint(ret)
+    li = up2dateAuth.getLoginInfo()
+    if not li: return []
         
-	channels = li.get('X-RHN-Auth-Channels')
-	if not channels: return []
+    channels = li.get('X-RHN-Auth-Channels')
+    if not channels: return []
 
-	for label, version, t, t in channels:
-		ret.append(rhnChannel.rhnChannel(label = label, version = version, type = 'up2date', url = cfg['serverURL']))
+    for label, version, t, t in channels:
+        ret.append(rhnChannel.rhnChannel(label = label, version = version, type = 'up2date', url = cfg['serverURL']))
 
-	return ret
+    return ret
 
 def debugprint(obj):
-	if '__name__' in dir(obj):
-		print 'DEBUGPRINT object %s' % obj.__name__
-		print '  repr', obj
-		print '  dir', dir(obj)
-	elif '__class__' in dir(obj):
-		print 'DEBUGPRINT class %s' % obj.__class__
-		print '  repr', obj
-		print '  dir', dir(obj)
-		try: print '  keys', obj.keys()
-		except: print 'FAILED'
-		try:
-			print '  list', 
-			for i in obj: print i,
-		except: print 'FAILED'
-	elif '__module__' in dir(obj):
-		print 'DEBUGPRINT module %s' % obj.__module__
-		print '  repr', obj
-		print '  dir', dir(obj)
-	else:
-		print 'DEBUGPRINT unknown ', dir(obj)
-		print '  repr', obj
-		print '  dir', dir(obj)
-	print
+    if '__name__' in dir(obj):
+        print 'DEBUGPRINT object %s' % obj.__name__
+        print '  repr', obj
+        print '  dir', dir(obj)
+    elif '__class__' in dir(obj):
+        print 'DEBUGPRINT class %s' % obj.__class__
+        print '  repr', obj
+        print '  dir', dir(obj)
+        try: print '  keys', obj.keys()
+        except: print 'FAILED'
+        try:
+            print '  list', 
+            for i in obj: print i,
+        except: print 'FAILED'
+    elif '__module__' in dir(obj):
+        print 'DEBUGPRINT module %s' % obj.__module__
+        print '  repr', obj
+        print '  dir', dir(obj)
+    else:
+        print 'DEBUGPRINT unknown ', dir(obj)
+        print '  repr', obj
+        print '  dir', dir(obj)
+    print
 
 registered = getSystemId('rhel3as-i386')
 up2dateAuth.updateLoginInfo()
@@ -80,18 +80,18 @@
 debugprint(up2dateAuth.getLoginInfo())
 
 for channel in subscribedChannels():
-	cfg['storageDir'] = '/var/yam/rhel4as-i386/'+channel['label']
-	try: os.makedirs(cfg['storageDir'], 0755)
-	except: pass
-	print channel['label'], channel['type'], channel['url'], channel['version']
-	package_list, type = rpcServer.doCall(repos.listPackages, channel, None, None)
-	print channel['label'], 'has', len(package_list), 'packages'
-#	for name, version, release, test, arch, test, label in package_list:
-#		print name,
-#	for pkg in package_list:
-#		name, version, release, test, arch, test, label = pkg
-#		rpcServer.doCall(repos.getPackage, pkg)
-#		rpcServer.doCall(repos.getPackage, pkg, wrapperUtils.printPkg, wrapperUtils.printRetrieveHash)
+    cfg['storageDir'] = '/var/yam/rhel4as-i386/'+channel['label']
+    try: os.makedirs(cfg['storageDir'], 0755)
+    except: pass
+    print channel['label'], channel['type'], channel['url'], channel['version']
+    package_list, type = rpcServer.doCall(repos.listPackages, channel, None, None)
+    print channel['label'], 'has', len(package_list), 'packages'
+#   for name, version, release, test, arch, test, label in package_list:
+#       print name,
+#   for pkg in package_list:
+#       name, version, release, test, arch, test, label = pkg
+#       rpcServer.doCall(repos.getPackage, pkg)
+#       rpcServer.doCall(repos.getPackage, pkg, wrapperUtils.printPkg, wrapperUtils.printRetrieveHash)
 
 ### Print packages
 #printList(rhnPackageInfo.getAvailableAllArchPackageList(), cfg['showChannels'])


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004189.html">[svn] r5390 - trunk/rpms/pam_shield
</A></li>
	<LI>Next message: <A HREF="004191.html">[svn] r5392 - in trunk/tools/dstat: . examples plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4190">[ date ]</a>
              <a href="thread.html#4190">[ thread ]</a>
              <a href="subject.html#4190">[ subject ]</a>
              <a href="author.html#4190">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
