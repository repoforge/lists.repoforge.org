<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r9030 - /trunk/rpms/xpdf/
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r9030%20-%20/trunk/rpms/xpdf/&In-Reply-To=%3C201008031707.o73H7o1A023889%40surya.karan.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007822.html">
   <LINK REL="Next"  HREF="007824.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r9030 - /trunk/rpms/xpdf/</H1>
    <B>Dag Wieers</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r9030%20-%20/trunk/rpms/xpdf/&In-Reply-To=%3C201008031707.o73H7o1A023889%40surya.karan.org%3E"
       TITLE="[svn] r9030 - /trunk/rpms/xpdf/">dag at wieers.com
       </A><BR>
    <I>Tue Aug  3 19:07:50 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="007822.html">[svn] r9028 - /trunk/rpms/perl-Mouse/perl-Mouse.spec
</A></li>
        <LI>Next message: <A HREF="007824.html">[svn] r9031 - in /trunk/rpms/detex: ./	detex-2.8-mallocandtroff.patch detex.spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7823">[ date ]</a>
              <a href="thread.html#7823">[ thread ]</a>
              <a href="subject.html#7823">[ subject ]</a>
              <a href="author.html#7823">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: Tue Aug  3 18:07:50 2010
New Revision: 9030

URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge?rev=9030&amp;view=rev">http://svn.rpmforge.net/viewvc/rpmforge?rev=9030&amp;view=rev</A>
Log:
Imported xpdf for RHEL5.

Added:
    trunk/rpms/xpdf/
    trunk/rpms/xpdf/02_permissions.dpatch
    trunk/rpms/xpdf/10_add_accelerators.dpatch
    trunk/rpms/xpdf/fix-437725.dpatch
    trunk/rpms/xpdf/fix-444648.dpatch
    trunk/rpms/xpdf/fix-462544.dpatch
    trunk/rpms/xpdf/fix-479467.dpatch
    trunk/rpms/xpdf/xpdf-2.02-ext.patch
    trunk/rpms/xpdf/xpdf-3.00-64bit.patch
    trunk/rpms/xpdf/xpdf-3.00-core.patch
    trunk/rpms/xpdf/xpdf-3.00-gcc4.patch
    trunk/rpms/xpdf/xpdf-3.00-papersize.patch
    trunk/rpms/xpdf/xpdf-3.00-xfont.patch
    trunk/rpms/xpdf/xpdf-3.01-nocmap.patch
    trunk/rpms/xpdf/xpdf-3.01-redhat-new.patch
    trunk/rpms/xpdf/xpdf-3.02-additionalzoom.patch
    trunk/rpms/xpdf/xpdf-3.02-crash.patch
    trunk/rpms/xpdf/xpdf-3.02-fontlist.patch
    trunk/rpms/xpdf/xpdf-3.02-mousebuttons.patch
    trunk/rpms/xpdf/xpdf-3.02-mousebuttons_view.patch
    trunk/rpms/xpdf/xpdf-3.02-ownerpw.patch
    trunk/rpms/xpdf/xpdf-3.02-x86_64-fix.patch
    trunk/rpms/xpdf/xpdf-3.02pl1.patch
    trunk/rpms/xpdf/xpdf-3.02pl2.patch
    trunk/rpms/xpdf/xpdf-3.02pl3.patch
    trunk/rpms/xpdf/xpdf-3.02pl4.patch
    trunk/rpms/xpdf/xpdf.png   (with props)
    trunk/rpms/xpdf/xpdf.spec   (with props)

Added: trunk/rpms/xpdf/02_permissions.dpatch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/02_permissions.dpatch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/02_permissions.dpatch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/02_permissions.dpatch (added)
+++ trunk/rpms/xpdf/02_permissions.dpatch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,176 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## permissions.dpatch by  &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">hamish at debian.org</A>&gt;
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Remove PDF file permission checks
+
<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">+ at DPATCH</A>@
+diff -urNad xpdf-3.02~/xpdf/PDFCore.cc xpdf-3.02/xpdf/PDFCore.cc
+--- xpdf-3.02~/xpdf/PDFCore.cc	2007-02-28 09:05:52.000000000 +1100
++++ xpdf-3.02/xpdf/PDFCore.cc	2007-04-24 23:43:59.000000000 +1000
+@@ -4,6 +4,8 @@
+ //
+ // Copyright 2004 Glyph &amp; Cog, LLC
+ //
++// Modified for Debian by Hamish Moffatt, 18 August 2005.
++//
+ //========================================================================
+ 
+ #include &lt;aconf.h&gt;
+@@ -1563,9 +1565,11 @@
+   int x0, y0, x1, y1, t;
+   GString *s;
+ 
++#ifdef ENFORCE_PERMISSIONS
+   if (!doc-&gt;okToCopy()) {
+     return NULL;
+   }
++#endif
+   if ((page = findPage(pg))) {
+     cvtUserToDev(pg, xMin, yMin, &amp;x0, &amp;y0);
+     cvtUserToDev(pg, xMax, yMax, &amp;x1, &amp;y1);
+diff -urNad xpdf-3.02~/xpdf/XPDFCore.cc xpdf-3.02/xpdf/XPDFCore.cc
+--- xpdf-3.02~/xpdf/XPDFCore.cc	2007-02-28 09:05:52.000000000 +1100
++++ xpdf-3.02/xpdf/XPDFCore.cc	2007-04-24 23:46:39.000000000 +1000
+@@ -4,6 +4,8 @@
+ //
+ // Copyright 2002-2003 Glyph &amp; Cog, LLC
+ //
++// Modified for Debian by Hamish Moffatt, 22 May 2002.
++//
+ //========================================================================
+ 
+ #include &lt;aconf.h&gt;
+@@ -384,11 +386,15 @@
+ #ifndef NO_TEXT_SELECT
+       if (selectULX != selectLRX &amp;&amp;
+ 	  selectULY != selectLRY) {
++#ifdef ENFORCE_PERMISSIONS
+ 	if (doc-&gt;okToCopy()) {
+ 	  copySelection();
+ 	} else {
+ 	  error(-1, &quot;Copying of text from this document is not allowed.&quot;);
+ 	}
++#else
++        copySelection();
++#endif
+       }
+ #endif
+     }
+@@ -407,9 +413,11 @@
+   int pg;
+   double ulx, uly, lrx, lry;
+ 
++#ifdef ENFORCE_PERMISSIONS
+   if (!doc-&gt;okToCopy()) {
+     return;
+   }
++#endif
+   if (getSelection(&amp;pg, &amp;ulx, &amp;uly, &amp;lrx, &amp;lry)) {
+     //~ for multithreading: need a mutex here
+     if (currentSelection) {
+diff -urNad xpdf-3.02~/xpdf/XPDFViewer.cc xpdf-3.02/xpdf/XPDFViewer.cc
+--- xpdf-3.02~/xpdf/XPDFViewer.cc	2007-02-28 09:05:52.000000000 +1100
++++ xpdf-3.02/xpdf/XPDFViewer.cc	2007-04-24 23:43:59.000000000 +1000
+@@ -4,6 +4,8 @@
+ //
+ // Copyright 2002-2003 Glyph &amp; Cog, LLC
+ //
++// Modified for Debian by Hamish Moffatt, 22 May 2002.
++//
+ //========================================================================
+ 
+ #include &lt;aconf.h&gt;
+@@ -3406,10 +3408,12 @@
+   PSOutputDev *psOut;
+ 
+   doc = viewer-&gt;core-&gt;getDoc();
++#ifdef ENFORCE_PERMISSIONS
+   if (!doc-&gt;okToPrint()) {
+     error(-1, &quot;Printing this document is not allowed.&quot;);
+     return;
+   }
++#endif
+ 
+   viewer-&gt;core-&gt;setBusyCursor(gTrue);
+ 
+diff -urNad xpdf-3.02~/xpdf/pdfimages.cc xpdf-3.02/xpdf/pdfimages.cc
+--- xpdf-3.02~/xpdf/pdfimages.cc	2007-02-28 09:05:52.000000000 +1100
++++ xpdf-3.02/xpdf/pdfimages.cc	2007-04-24 23:43:59.000000000 +1000
+@@ -4,6 +4,8 @@
+ //
+ // Copyright 1998-2003 Glyph &amp; Cog, LLC
+ //
++// Modified for Debian by Hamish Moffatt, 22 May 2002.
++//
+ //========================================================================
+ 
+ #include &lt;aconf.h&gt;
+@@ -119,11 +121,13 @@
+   }
+ 
+   // check for copy permission
++#ifdef ENFORCE_PERMISSIONS
+   if (!doc-&gt;okToCopy()) {
+     error(-1, &quot;Copying of images from this document is not allowed.&quot;);
+     exitCode = 3;
+     goto err1;
+   }
++#endif
+ 
+   // get page range
+   if (firstPage &lt; 1)
+diff -urNad xpdf-3.02~/xpdf/pdftops.cc xpdf-3.02/xpdf/pdftops.cc
+--- xpdf-3.02~/xpdf/pdftops.cc	2007-02-28 09:05:52.000000000 +1100
++++ xpdf-3.02/xpdf/pdftops.cc	2007-04-24 23:43:59.000000000 +1000
+@@ -4,6 +4,8 @@
+ //
+ // Copyright 1996-2003 Glyph &amp; Cog, LLC
+ //
++// Modified for Debian by Hamish Moffatt, 22 May 2002.
++//
+ //========================================================================
+ 
+ #include &lt;aconf.h&gt;
+@@ -278,12 +280,14 @@
+     goto err1;
+   }
+ 
++#ifdef ENFORCE_PERMISSIONS
+   // check for print permission
+   if (!doc-&gt;okToPrint()) {
+     error(-1, &quot;Printing this document is not allowed.&quot;);
+     exitCode = 3;
+     goto err1;
+   }
++#endif
+ 
+   // construct PostScript file name
+   if (argc == 3) {
+diff -urNad xpdf-3.02~/xpdf/pdftotext.cc xpdf-3.02/xpdf/pdftotext.cc
+--- xpdf-3.02~/xpdf/pdftotext.cc	2007-02-28 09:05:52.000000000 +1100
++++ xpdf-3.02/xpdf/pdftotext.cc	2007-04-24 23:43:59.000000000 +1000
+@@ -4,6 +4,8 @@
+ //
+ // Copyright 1997-2003 Glyph &amp; Cog, LLC
+ //
++// Modified for Debian by Hamish Moffatt, 22 May 2002.
++//
+ //========================================================================
+ 
+ #include &lt;aconf.h&gt;
+@@ -160,12 +162,14 @@
+     goto err2;
+   }
+ 
++#ifdef ENFORCE_PERMISSIONS
+   // check for copy permission
+   if (!doc-&gt;okToCopy()) {
+     error(-1, &quot;Copying of text from this document is not allowed.&quot;);
+     exitCode = 3;
+     goto err2;
+   }
++#endif
+ 
+   // construct text file name
+   if (argc == 3) {

Added: trunk/rpms/xpdf/10_add_accelerators.dpatch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/10_add_accelerators.dpatch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/10_add_accelerators.dpatch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/10_add_accelerators.dpatch (added)
+++ trunk/rpms/xpdf/10_add_accelerators.dpatch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,33 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10_add_accelerators.dpatch by  &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">hamish at noddy.cloud.net.au</A>&gt;
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Add keyboard accelerators for rotate (#385962)
+
<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">+ at DPATCH</A>@
+diff -urNad xpdf-3.02~/xpdf/XPDFViewer.cc xpdf-3.02/xpdf/XPDFViewer.cc
+--- xpdf-3.02~/xpdf/XPDFViewer.cc	2007-04-25 01:40:50.000000000 +1000
++++ xpdf-3.02/xpdf/XPDFViewer.cc	2007-04-25 01:42:13.000000000 +1000
+@@ -1958,16 +1958,22 @@
+   n = 0;
+   s = XmStringCreateLocalized(&quot;Rotate counterclockwise&quot;);
+   XtSetArg(args[n], XmNlabelString, s); ++n;
++  s2 = XmStringCreateLocalized(&quot;[&quot;);
++  XtSetArg(args[n], XmNacceleratorText, s2); ++n;
+   btn = XmCreatePushButton(popupMenu, &quot;rotateCCW&quot;, args, n);
+   XmStringFree(s);
++  XmStringFree(s2);
+   XtManageChild(btn);
+   XtAddCallback(btn, XmNactivateCallback,
+ 		&amp;rotateCCWCbk, (XtPointer)this);
+   n = 0;
+   s = XmStringCreateLocalized(&quot;Rotate clockwise&quot;);
+   XtSetArg(args[n], XmNlabelString, s); ++n;
++  s2 = XmStringCreateLocalized(&quot;]&quot;);
++  XtSetArg(args[n], XmNacceleratorText, s2); ++n;
+   btn = XmCreatePushButton(popupMenu, &quot;rotateCW&quot;, args, n);
+   XmStringFree(s);
++  XmStringFree(s2);
+   XtManageChild(btn);
+   XtAddCallback(btn, XmNactivateCallback,
+ 		&amp;rotateCWCbk, (XtPointer)this);

Added: trunk/rpms/xpdf/fix-437725.dpatch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-437725.dpatch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-437725.dpatch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/fix-437725.dpatch (added)
+++ trunk/rpms/xpdf/fix-437725.dpatch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,42 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## fix-437725.dpatch from Arno Renevier &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">arenevier at fdn.fr</A>&gt;
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fix segmentation fault when pressing Ctrl-W in full screen mode
+
<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">+ at DPATCH</A>@
+--- a/xpdf/XPDFViewer.cc	2007-08-13 22:41:36.000000000 +0200
++++ b/xpdf/XPDFViewer.cc	2007-08-13 23:01:07.000000000 +0200
+@@ -400,18 +400,21 @@ void XPDFViewer::clear() {
+   title = app-&gt;getTitle() ? app-&gt;getTitle()-&gt;getCString()
+                           : (char *)xpdfAppName;
+   XtVaSetValues(win, XmNtitle, title, XmNiconName, title, NULL);
+-  s = XmStringCreateLocalized(&quot;&quot;);
+-  XtVaSetValues(pageNumText, XmNlabelString, s, NULL);
+-  XmStringFree(s);
+-  s = XmStringCreateLocalized(&quot; of 0&quot;);
+-  XtVaSetValues(pageCountLabel, XmNlabelString, s, NULL);
+-  XmStringFree(s);
+ 
+-  // disable buttons
+-  XtVaSetValues(prevTenPageBtn, XmNsensitive, False, NULL);
+-  XtVaSetValues(prevPageBtn, XmNsensitive, False, NULL);
+-  XtVaSetValues(nextTenPageBtn, XmNsensitive, False, NULL);
+-  XtVaSetValues(nextPageBtn, XmNsensitive, False, NULL);
++  if (toolBar != None) {
++      s = XmStringCreateLocalized(&quot;&quot;);
++      XtVaSetValues(pageNumText, XmNlabelString, s, NULL);
++      XmStringFree(s);
++      s = XmStringCreateLocalized(&quot; of 0&quot;);
++      XtVaSetValues(pageCountLabel, XmNlabelString, s, NULL);
++      XmStringFree(s);
++
++      // disable buttons
++      XtVaSetValues(prevTenPageBtn, XmNsensitive, False, NULL);
++      XtVaSetValues(prevPageBtn, XmNsensitive, False, NULL);
++      XtVaSetValues(nextTenPageBtn, XmNsensitive, False, NULL);
++      XtVaSetValues(nextPageBtn, XmNsensitive, False, NULL);
++  }
+ 
+   // remove the old outline
+ #ifndef DISABLE_OUTLINE

Added: trunk/rpms/xpdf/fix-444648.dpatch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-444648.dpatch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-444648.dpatch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/fix-444648.dpatch (added)
+++ trunk/rpms/xpdf/fix-444648.dpatch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,18 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## fix-444648.dpatch by Bernhard R. Link &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">brlink at debian.org</A>&gt;
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Do proper PS stream encoding on 64 bit architectures
+
<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">+ at DPATCH</A>@
+--- xpdf-3.02/xpdf/Stream.cc.BAD	2008-12-10 12:16:16.000000000 -0500
++++ xpdf-3.02/xpdf/Stream.cc	2008-12-10 12:16:21.000000000 -0500
+@@ -4514,7 +4514,7 @@ void ASCII85Encoder::reset() {
+ GBool ASCII85Encoder::fillBuf() {
+   Guint t;
+   char buf1[5];
+-  int c0, c1, c2, c3;
++  unsigned int c0, c1, c2, c3;
+   int n, i;
+ 
+   if (eof) {

Added: trunk/rpms/xpdf/fix-462544.dpatch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-462544.dpatch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-462544.dpatch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/fix-462544.dpatch (added)
+++ trunk/rpms/xpdf/fix-462544.dpatch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,28 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## fix-462544.dpatch from Jiri Palecek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jpalecek at web.de</A>&gt;
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fix segmentation fault in image handling
+
<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">+ at DPATCH</A>@
+--- xpdf-3.02/xpdf/SplashOutputDev.cc	2007-02-27 23:05:52.000000000 +0100
++++ xpdf-3.02.new/xpdf/SplashOutputDev.cc	2008-02-17 17:28:46.000000000 +0100
+@@ -2475,14 +2461,14 @@
+   tx = (int)floor(xMin);
+   if (tx &lt; 0) {
+     tx = 0;
+-  } else if (tx &gt; bitmap-&gt;getWidth()) {
+-    tx = bitmap-&gt;getWidth();
++  } else if (tx &gt;= bitmap-&gt;getWidth()) {
++    tx = bitmap-&gt;getWidth()-1;
+   }
+   ty = (int)floor(yMin);
+   if (ty &lt; 0) {
+     ty = 0;
+-  } else if (ty &gt; bitmap-&gt;getHeight()) {
+-    ty = bitmap-&gt;getHeight();
++  } else if (ty &gt;= bitmap-&gt;getHeight()) {
++    ty = bitmap-&gt;getHeight()-1;
+   }
+   w = (int)ceil(xMax) - tx + 1;
+   if (tx + w &gt; bitmap-&gt;getWidth()) {

Added: trunk/rpms/xpdf/fix-479467.dpatch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-479467.dpatch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/fix-479467.dpatch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/fix-479467.dpatch (added)
+++ trunk/rpms/xpdf/fix-479467.dpatch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,20 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## fix-479467.dpatch from Stephan Beyer &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">s-beyer at gmx.net</A>&gt;
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fix segmentation fault when pressing g in full screen mode
+
<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">+ at DPATCH</A>@
+diff -ruN xpdf-3.02.old/xpdf/XPDFViewer.cc xpdf-3.02.fix/xpdf/XPDFViewer.cc
+--- xpdf-3.02.old/xpdf/XPDFViewer.cc	2007-02-27 23:05:52.000000000 +0100
++++ xpdf-3.02.fix/xpdf/XPDFViewer.cc	2008-05-04 21:29:34.000000000 +0200
+@@ -834,6 +834,9 @@
+ 
+ void XPDFViewer::cmdFocusToPageNum(GString *args[], int nArgs,
+ 				   XEvent *event) {
++  if (core-&gt;getFullScreen()) {
++    return;
++  }
+   XmTextFieldSetSelection(pageNumText, 0,
+ 			  strlen(XmTextFieldGetString(pageNumText)),
+ 			  XtLastTimestampProcessed(display));

Added: trunk/rpms/xpdf/xpdf-2.02-ext.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-2.02-ext.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-2.02-ext.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-2.02-ext.patch (added)
+++ trunk/rpms/xpdf/xpdf-2.02-ext.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,50 @@
+--- xpdf-2.02/goo/gfile.cc.orig	2003-03-31 16:45:50.000000000 +0200
++++ xpdf-2.02/goo/gfile.cc	2003-03-31 17:09:19.000000000 +0200
+@@ -486,32 +486,14 @@
+   char *s;
+   int fd;
+ 
+-  if (ext) {
+-#if HAVE_MKSTEMPS
+-    if ((s = getenv(&quot;TMPDIR&quot;))) {
+-      *name = new GString(s);
+-    } else {
+-      *name = new GString(&quot;/tmp&quot;);
+-    }
+-    (*name)-&gt;append(&quot;/XXXXXX&quot;)-&gt;append(ext);
+-    fd = mkstemps((*name)-&gt;getCString(), strlen(ext));
+-#else
+-    if (!(s = tmpnam(NULL))) {
+-      return gFalse;
+-    }
++#if HAVE_MKSTEMP
++  if ((s = getenv(&quot;TMPDIR&quot;))) {
+     *name = new GString(s);
+-    (*name)-&gt;append(ext);
+-    fd = open((*name)-&gt;getCString(), O_WRONLY | O_CREAT | O_EXCL, 0600);
+-#endif
+   } else {
+-#if HAVE_MKSTEMP
+-    if ((s = getenv(&quot;TMPDIR&quot;))) {
+-      *name = new GString(s);
+-    } else {
+-      *name = new GString(&quot;/tmp&quot;);
+-    }
+-    (*name)-&gt;append(&quot;/XXXXXX&quot;);
+-    fd = mkstemp((*name)-&gt;getCString());
++    *name = new GString(&quot;/tmp&quot;);
++  }
++  (*name)-&gt;append(&quot;/XXXXXX&quot;);
++  fd = mkstemp((*name)-&gt;getCString());
+ #else // HAVE_MKSTEMP
+     if (!(s = tmpnam(NULL))) {
+       return gFalse;
+@@ -519,7 +501,7 @@
+     *name = new GString(s);
+     fd = open((*name)-&gt;getCString(), O_WRONLY | O_CREAT | O_EXCL, 0600);
+ #endif // HAVE_MKSTEMP
+-  }
++
+   if (fd &lt; 0 || !(*f = fdopen(fd, mode))) {
+     delete *name;
+     return gFalse;

Added: trunk/rpms/xpdf/xpdf-3.00-64bit.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-64bit.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-64bit.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.00-64bit.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.00-64bit.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,57 @@
+diff -up xpdf-3.02/goo/gmem.cc.BAD xpdf-3.02/goo/gmem.cc
+--- xpdf-3.02/goo/gmem.cc.BAD	2007-08-01 17:20:00.000000000 -0500
++++ xpdf-3.02/goo/gmem.cc	2007-08-01 17:22:04.000000000 -0500
+@@ -47,9 +47,9 @@ static int gMemInUse = 0;
+ 
+ #endif /* DEBUG_MEM */
+ 
+-void *gmalloc(int size) GMEM_EXCEP {
++void *gmalloc(size_t size) GMEM_EXCEP {
+ #ifdef DEBUG_MEM
+-  int size1;
++  size_t size1;
+   char *mem;
+   GMemHdr *hdr;
+   void *data;
+@@ -106,11 +106,11 @@ void *gmalloc(int size) GMEM_EXCEP {
+ #endif
+ }
+ 
+-void *grealloc(void *p, int size) GMEM_EXCEP {
++void *grealloc(void *p, size_t size) GMEM_EXCEP {
+ #ifdef DEBUG_MEM
+   GMemHdr *hdr;
+   void *q;
+-  int oldSize;
++  size_t oldSize;
+ 
+   if (size &lt;= 0) {
+     if (p) {
+@@ -195,7 +195,7 @@ void *greallocn(void *p, int nObjs, int 
+ 
+ void gfree(void *p) {
+ #ifdef DEBUG_MEM
+-  int size;
++  size_t size;
+   GMemHdr *hdr;
+   unsigned long *trl, *clr;
+ 
+diff -up xpdf-3.02/goo/gmem.h.BAD xpdf-3.02/goo/gmem.h
+--- xpdf-3.02/goo/gmem.h.BAD	2007-08-01 17:23:11.000000000 -0500
++++ xpdf-3.02/goo/gmem.h	2007-08-01 17:23:45.000000000 -0500
+@@ -36,13 +36,13 @@ extern &quot;C&quot; {
+  * Same as malloc, but prints error message and exits if malloc()
+  * returns NULL.
+  */
+-extern void *gmalloc(int size) GMEM_EXCEP;
++extern void *gmalloc(size_t size) GMEM_EXCEP;
+ 
+ /*
+  * Same as realloc, but prints error message and exits if realloc()
+  * returns NULL.  If &lt;p&gt; is NULL, calls malloc instead of realloc().
+  */
+-extern void *grealloc(void *p, int size) GMEM_EXCEP;
++extern void *grealloc(void *p, size_t size) GMEM_EXCEP;
+ 
+ /*
+  * These are similar to gmalloc and grealloc, but take an object count

Added: trunk/rpms/xpdf/xpdf-3.00-core.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-core.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-core.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.00-core.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.00-core.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,13 @@
+--- xpdf-3.00/xpdf/XPDFCore.cc.ud	2004-10-07 12:44:23.000000000 -0700
++++ xpdf-3.00/xpdf/XPDFCore.cc	2004-10-07 12:44:26.000000000 -0700
+@@ -1051,6 +1051,10 @@
+   GString *msg;
+   int i;
+ 
++  if (action == NULL)
++    // Nothing to do.
++    return;
++
+   switch (kind = action-&gt;getKind()) {
+ 
+   // GoTo / GoToR action

Added: trunk/rpms/xpdf/xpdf-3.00-gcc4.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-gcc4.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-gcc4.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.00-gcc4.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.00-gcc4.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,29 @@
+--- xpdf-3.00/xpdf/TextOutputDev.h.orig	2005-06-13 10:11:17.000000000 +0200
++++ xpdf-3.00/xpdf/TextOutputDev.h	2005-06-13 10:27:18.000000000 +0200
+@@ -169,7 +169,7 @@
+ class TextLine {
+ public:
+ 
+-  TextLine(TextBlock *blkA, int rotA, double baseA);
++  TextLine(class TextBlock *blkA, int rotA, double baseA);
+   ~TextLine();
+ 
+   void addWord(TextWord *word);
+@@ -226,7 +226,7 @@
+ class TextBlock {
+ public:
+ 
+-  TextBlock(TextPage *pageA, int rotA);
++  TextBlock(class TextPage *pageA, int rotA);
+   ~TextBlock();
+ 
+   void addWord(TextWord *word);
+@@ -416,7 +416,7 @@
+ private:
+ 
+   void clear();
+-  void assignColumns(TextLineFrag *frags, int nFrags, int rot);
++  void assignColumns(class TextLineFrag *frags, int nFrags, int rot);
+   int dumpFragment(Unicode *text, int len, UnicodeMap *uMap, GString *s);
+ 
+   GBool rawOrder;		// keep text in content stream order

Added: trunk/rpms/xpdf/xpdf-3.00-papersize.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-papersize.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-papersize.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.00-papersize.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.00-papersize.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,13 @@
+--- xpdf-3.00/xpdf/config.h.orig	2004-11-29 17:14:12.583102885 +0100
++++ xpdf-3.00/xpdf/config.h	2004-11-29 17:14:54.312235643 +0100
+@@ -41,8 +41,8 @@
+ #define defPaperWidth  595    // ISO A4 (210x297 mm)
+ #define defPaperHeight 842
+ #else
+-#define defPaperWidth  612    // American letter (8.5x11&quot;)
+-#define defPaperHeight 792
++#define defPaperWidth  -1     // match
++#define defPaperHeight -1
+ #endif
+ 
+ //------------------------------------------------------------------------

Added: trunk/rpms/xpdf/xpdf-3.00-xfont.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-xfont.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.00-xfont.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.00-xfont.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.00-xfont.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,11 @@
+--- xpdf-3.00/xpdf/XPDFViewer.cc.orig	2004-10-12 12:24:57.055068037 +0200
++++ xpdf-3.00/xpdf/XPDFViewer.cc	2004-10-12 12:24:47.707449614 +0200
+@@ -1742,7 +1742,7 @@
+   aboutBigFont =
+     createFontList(&quot;-*-times-bold-i-normal--20-*-*-*-*-*-iso8859-1&quot;);
+   aboutVersionFont =
+-    createFontList(&quot;-*-times-medium-r-normal--16-*-*-*-*-*-iso8859-1&quot;);
++    createFontList(&quot;-*-times-medium-r-normal--14-*-*-*-*-*-iso8859-1&quot;);
+   aboutFixedFont =
+     createFontList(&quot;-*-courier-medium-r-normal--12-*-*-*-*-*-iso8859-1&quot;);
+ 

Added: trunk/rpms/xpdf/xpdf-3.01-nocmap.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.01-nocmap.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.01-nocmap.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.01-nocmap.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.01-nocmap.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,49 @@
+--- xpdf-3.01/xpdf-chinese-traditional/add-to-xpdfrc.NOCMAP	2006-09-25 15:26:58.000000000 -0500
++++ xpdf-3.01/xpdf-chinese-traditional/add-to-xpdfrc	2006-09-25 15:27:04.000000000 -0500
+@@ -2,7 +2,7 @@
+ cidToUnicode	Adobe-CNS1	/usr/share/xpdf/chinese-traditional/Adobe-CNS1.cidToUnicode
+ unicodeMap	Big5		/usr/share/xpdf/chinese-traditional/Big5.unicodeMap
+ unicodeMap	Big5ascii	/usr/share/xpdf/chinese-traditional/Big5ascii.unicodeMap
+-cMapDir		Adobe-CNS1	/usr/share/xpdf/chinese-traditional/CMap
+-toUnicodeDir			/usr/share/xpdf/chinese-traditional/CMap
++#cMapDir		Adobe-CNS1	/usr/share/xpdf/chinese-traditional/CMap
++#toUnicodeDir			/usr/share/xpdf/chinese-traditional/CMap
+ #displayCIDFontTT	Adobe-CNS1	/usr/..../bkai00mp.ttf
+ #----- end Chinese Traditional support package
+--- xpdf-3.01/xpdf-korean/add-to-xpdfrc.NOCMAP	2006-09-25 15:27:33.000000000 -0500
++++ xpdf-3.01/xpdf-korean/add-to-xpdfrc	2006-09-25 15:27:48.000000000 -0500
+@@ -1,8 +1,8 @@
+ #----- begin Korean support package (2005-jul-07)
+ cidToUnicode	Adobe-Korea1	/usr/share/xpdf/korean/Adobe-Korea1.cidToUnicode
+ unicodeMap	ISO-2022-KR	/usr/share/xpdf/korean/ISO-2022-KR.unicodeMap
+-cMapDir		Adobe-Korea1	/usr/share/xpdf/korean/CMap
+-toUnicodeDir			/usr/share/xpdf/korean/CMap
++#cMapDir		Adobe-Korea1	/usr/share/xpdf/korean/CMap
++#toUnicodeDir			/usr/share/xpdf/korean/CMap
+ #displayCIDFontTT	Adobe-Korea1	/usr/..../batang.ttf&quot;
+ #displayCIDFontTT	Unidocs-Korea1	/usr/..../batang.ttf&quot;
+ #----- end Korean support package
+--- xpdf-3.01/xpdf-chinese-simplified/add-to-xpdfrc.NOCMAP	2006-09-25 15:26:43.000000000 -0500
++++ xpdf-3.01/xpdf-chinese-simplified/add-to-xpdfrc	2006-09-25 15:26:49.000000000 -0500
+@@ -3,7 +3,7 @@ cidToUnicode	Adobe-GB1	/usr/share/xpdf/c
+ unicodeMap	ISO-2022-CN	/usr/share/xpdf/chinese-simplified/ISO-2022-CN.unicodeMap
+ unicodeMap	EUC-CN		/usr/share/xpdf/chinese-simplified/EUC-CN.unicodeMap
+ unicodeMap	GBK		/usr/share/xpdf/chinese-simplified/GBK.unicodeMap
+-cMapDir		Adobe-GB1	/usr/share/xpdf/chinese-simplified/CMap
+-toUnicodeDir			/usr/share/xpdf/chinese-simplified/CMap
++#cMapDir		Adobe-GB1	/usr/share/xpdf/chinese-simplified/CMap
++#toUnicodeDir			/usr/share/xpdf/chinese-simplified/CMap
+ #displayCIDFontTT	Adobe-GB1	/usr/..../gkai00mp.ttf
+ #----- end Chinese Simplified support package
+--- xpdf-3.01/xpdf-japanese/add-to-xpdfrc.NOCMAP	2006-09-25 15:27:16.000000000 -0500
++++ xpdf-3.01/xpdf-japanese/add-to-xpdfrc	2006-09-25 15:27:20.000000000 -0500
+@@ -3,7 +3,7 @@ cidToUnicode	Adobe-Japan1	/usr/share/xpd
+ unicodeMap	ISO-2022-JP	/usr/share/xpdf/japanese/ISO-2022-JP.unicodeMap
+ unicodeMap	EUC-JP		/usr/share/xpdf/japanese/EUC-JP.unicodeMap
+ unicodeMap	Shift-JIS	/usr/share/xpdf/japanese/Shift-JIS.unicodeMap
+-cMapDir		Adobe-Japan1	/usr/share/xpdf/japanese/CMap
+-toUnicodeDir			/usr/share/xpdf/japanese/CMap
++#cMapDir		Adobe-Japan1	/usr/share/xpdf/japanese/CMap
++#toUnicodeDir			/usr/share/xpdf/japanese/CMap
+ #displayCIDFontTT	Adobe-Japan1	/usr/..../kochi-mincho.ttf
+ #----- end Japanese support package

Added: trunk/rpms/xpdf/xpdf-3.01-redhat-new.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.01-redhat-new.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.01-redhat-new.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.01-redhat-new.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.01-redhat-new.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,258 @@
+--- xpdf-3.01/xpdf-chinese-traditional/add-to-xpdfrc.orig	2004-07-27 17:28:07.000000000 -0500
++++ xpdf-3.01/xpdf-chinese-traditional/add-to-xpdfrc	2006-09-25 12:58:50.000000000 -0500
+@@ -1,8 +1,8 @@
+ #----- begin Chinese Traditional support package (2004-jul-27)
+-cidToUnicode	Adobe-CNS1	/usr/local/share/xpdf/chinese-traditional/Adobe-CNS1.cidToUnicode
+-unicodeMap	Big5		/usr/local/share/xpdf/chinese-traditional/Big5.unicodeMap
+-unicodeMap	Big5ascii	/usr/local/share/xpdf/chinese-traditional/Big5ascii.unicodeMap
+-cMapDir		Adobe-CNS1	/usr/local/share/xpdf/chinese-traditional/CMap
+-toUnicodeDir			/usr/local/share/xpdf/chinese-traditional/CMap
++cidToUnicode	Adobe-CNS1	/usr/share/xpdf/chinese-traditional/Adobe-CNS1.cidToUnicode
++unicodeMap	Big5		/usr/share/xpdf/chinese-traditional/Big5.unicodeMap
++unicodeMap	Big5ascii	/usr/share/xpdf/chinese-traditional/Big5ascii.unicodeMap
++cMapDir		Adobe-CNS1	/usr/share/xpdf/chinese-traditional/CMap
++toUnicodeDir			/usr/share/xpdf/chinese-traditional/CMap
+ #displayCIDFontTT	Adobe-CNS1	/usr/..../bkai00mp.ttf
+ #----- end Chinese Traditional support package
+--- xpdf-3.01/xpdf-korean/add-to-xpdfrc.orig	2005-07-07 13:05:05.000000000 -0500
++++ xpdf-3.01/xpdf-korean/add-to-xpdfrc	2006-09-25 12:56:15.000000000 -0500
+@@ -1,8 +1,8 @@
+ #----- begin Korean support package (2005-jul-07)
+-cidToUnicode	Adobe-Korea1	/usr/local/share/xpdf/korean/Adobe-Korea1.cidToUnicode
+-unicodeMap	ISO-2022-KR	/usr/local/share/xpdf/korean/ISO-2022-KR.unicodeMap
+-cMapDir		Adobe-Korea1	/usr/local/share/xpdf/korean/CMap
+-toUnicodeDir			/usr/local/share/xpdf/korean/CMap
++cidToUnicode	Adobe-Korea1	/usr/share/xpdf/korean/Adobe-Korea1.cidToUnicode
++unicodeMap	ISO-2022-KR	/usr/share/xpdf/korean/ISO-2022-KR.unicodeMap
++cMapDir		Adobe-Korea1	/usr/share/xpdf/korean/CMap
++toUnicodeDir			/usr/share/xpdf/korean/CMap
+ #displayCIDFontTT	Adobe-Korea1	/usr/..../batang.ttf&quot;
+ #displayCIDFontTT	Unidocs-Korea1	/usr/..../batang.ttf&quot;
+ #----- end Korean support package
+--- xpdf-3.01/xpdf-chinese-simplified/add-to-xpdfrc.orig	2004-07-27 17:28:08.000000000 -0500
++++ xpdf-3.01/xpdf-chinese-simplified/add-to-xpdfrc	2006-09-25 12:57:18.000000000 -0500
+@@ -1,9 +1,9 @@
+ #----- begin Chinese Simplified support package (2004-jul-27)
+-cidToUnicode	Adobe-GB1	/usr/local/share/xpdf/chinese-simplified/Adobe-GB1.cidToUnicode
+-unicodeMap	ISO-2022-CN	/usr/local/share/xpdf/chinese-simplified/ISO-2022-CN.unicodeMap
+-unicodeMap	EUC-CN		/usr/local/share/xpdf/chinese-simplified/EUC-CN.unicodeMap
+-unicodeMap	GBK		/usr/local/share/xpdf/chinese-simplified/GBK.unicodeMap
+-cMapDir		Adobe-GB1	/usr/local/share/xpdf/chinese-simplified/CMap
+-toUnicodeDir			/usr/local/share/xpdf/chinese-simplified/CMap
++cidToUnicode	Adobe-GB1	/usr/share/xpdf/chinese-simplified/Adobe-GB1.cidToUnicode
++unicodeMap	ISO-2022-CN	/usr/share/xpdf/chinese-simplified/ISO-2022-CN.unicodeMap
++unicodeMap	EUC-CN		/usr/share/xpdf/chinese-simplified/EUC-CN.unicodeMap
++unicodeMap	GBK		/usr/share/xpdf/chinese-simplified/GBK.unicodeMap
++cMapDir		Adobe-GB1	/usr/share/xpdf/chinese-simplified/CMap
++toUnicodeDir			/usr/share/xpdf/chinese-simplified/CMap
+ #displayCIDFontTT	Adobe-GB1	/usr/..../gkai00mp.ttf
+ #----- end Chinese Simplified support package
+--- xpdf-3.01/xpdf-japanese/add-to-xpdfrc.orig	2004-07-27 17:28:07.000000000 -0500
++++ xpdf-3.01/xpdf-japanese/add-to-xpdfrc	2006-09-25 12:58:10.000000000 -0500
+@@ -1,9 +1,9 @@
+ #----- begin Japanese support package (2004-jul-27)
+-cidToUnicode	Adobe-Japan1	/usr/local/share/xpdf/japanese/Adobe-Japan1.cidToUnicode
+-unicodeMap	ISO-2022-JP	/usr/local/share/xpdf/japanese/ISO-2022-JP.unicodeMap
+-unicodeMap	EUC-JP		/usr/local/share/xpdf/japanese/EUC-JP.unicodeMap
+-unicodeMap	Shift-JIS	/usr/local/share/xpdf/japanese/Shift-JIS.unicodeMap
+-cMapDir		Adobe-Japan1	/usr/local/share/xpdf/japanese/CMap
+-toUnicodeDir			/usr/local/share/xpdf/japanese/CMap
++cidToUnicode	Adobe-Japan1	/usr/share/xpdf/japanese/Adobe-Japan1.cidToUnicode
++unicodeMap	ISO-2022-JP	/usr/share/xpdf/japanese/ISO-2022-JP.unicodeMap
++unicodeMap	EUC-JP		/usr/share/xpdf/japanese/EUC-JP.unicodeMap
++unicodeMap	Shift-JIS	/usr/share/xpdf/japanese/Shift-JIS.unicodeMap
++cMapDir		Adobe-Japan1	/usr/share/xpdf/japanese/CMap
++toUnicodeDir			/usr/share/xpdf/japanese/CMap
+ #displayCIDFontTT	Adobe-Japan1	/usr/..../kochi-mincho.ttf
+ #----- end Japanese support package
+--- xpdf-3.01/doc/xpdfrc.5.orig	2005-08-17 00:34:30.000000000 -0500
++++ xpdf-3.01/doc/xpdfrc.5	2006-09-25 12:54:53.000000000 -0500
+@@ -7,7 +7,7 @@ All of the Xpdf tools read a single conf
+ .I .xpdfrc
+ file in your home directory, it will be read.  Otherwise, a
+ system-wide configuration file will be read from
+-.IR /usr/local/etc/xpdfrc ,
++.IR /etc/xpdfrc ,
+ if it exists.  (This is its default location; depending on build
+ options, it may be placed elsewhere.)  On Win32 systems, the
+ .I xpdfrc
+@@ -459,7 +459,7 @@ urlCommand      &quot;netscape -remote 'openU
+ .fi
+ .SH FILES
+ .TP
+-.B /usr/local/etc/xpdfrc
++.B /etc/xpdfrc
+ This is the default location for the system-wide configuration file.
+ Depending on build options, it may be placed elsewhere.
+ .TP
+--- xpdf-3.01/doc/sample-xpdfrc.orig	2005-08-17 00:34:30.000000000 -0500
++++ xpdf-3.01/doc/sample-xpdfrc	2006-09-25 12:54:53.000000000 -0500
+@@ -56,7 +56,7 @@
+ 
+ # Set the default PostScript file or command.
+ 
+-#psFile			&quot;|lpr -Pmyprinter&quot;
++psFile			&quot;|lpr&quot;
+ 
+ # Set the default PostScript paper size -- this can be letter, legal,
+ # A4, or A3.  You can also specify a paper size as width and height
+@@ -88,4 +88,11 @@
+ # Set the command used to run a web browser when a URL hyperlink is
+ # clicked.
+ 
++urlCommand &quot;htmlview '%s'&quot;
+ #urlCommand	&quot;netscape -remote 'openURL(%s)'&quot;
++
++# CJK
++include /etc/xpdf/add-to-xpdfrc.japanese
++include /etc/xpdf/add-to-xpdfrc.korean
++include /etc/xpdf/add-to-xpdfrc.chinese-simplified
++include /etc/xpdf/add-to-xpdfrc.chinese-traditional
+--- xpdf-3.01/doc/xpdf.1.orig	2005-08-17 00:34:30.000000000 -0500
++++ xpdf-3.01/doc/xpdf.1	2006-09-25 12:54:53.000000000 -0500
+@@ -41,7 +41,7 @@ xpdf
+ .SH CONFIGURATION FILE
+ Xpdf reads a configuration file at startup.  It first tries to find
+ the user's private config file, ~/.xpdfrc.  If that doesn't exist, it
+-looks for a system-wide config file, typically /usr/local/etc/xpdfrc
++looks for a system-wide config file, typically /etc/xpdfrc
+ (but this location can be changed when xpdf is built).  See the
+ .BR xpdfrc (5)
+ man page for details.
+--- xpdf-3.01/doc/pdfimages.1.orig	2005-08-17 00:34:30.000000000 -0500
++++ xpdf-3.01/doc/pdfimages.1	2006-09-25 12:54:53.000000000 -0500
+@@ -29,7 +29,7 @@ color inversion, etc. done by the PDF co
+ Pdfimages reads a configuration file at startup.  It first tries to
+ find the user's private config file, ~/.xpdfrc.  If that doesn't
+ exist, it looks for a system-wide config file, typically
+-/usr/local/etc/xpdfrc (but this location can be changed when pdfimages
++/etc/xpdfrc (but this location can be changed when pdfimages
+ is built).  See the
+ .BR xpdfrc (5)
+ man page for details.
+--- xpdf-3.01/xpdf-chinese-traditional/README.orig	2006-09-25 13:33:34.000000000 -0500
++++ xpdf-3.01/xpdf-chinese-traditional/README	2006-09-25 13:37:33.000000000 -0500
+@@ -19,13 +19,13 @@ Contents:
+ 
+ Place all of these files in a directory, typically:
+ 
+-    Unix - /usr/local/share/xpdf/chinese-traditional
++    Unix - /usr/share/xpdf/chinese-traditional
+     Win32 - C:\Program Files\xpdf\chinese-traditional
+ 
+ Add the contents of the &quot;add-to-xpdfrc&quot; file to your system-wide
+ xpdfrc config file, which is typically:
+ 
+-    Unix - /usr/local/etc/xpdfrc
++    Unix - /etc/xpdfrc
+     Win32 - C:\Program Files\xpdf\xpdfrc
+ 
+ Alternatively, on Unix systems you can add these lines to your
+--- xpdf-3.01/xpdf-korean/README.orig	2006-09-25 13:34:27.000000000 -0500
++++ xpdf-3.01/xpdf-korean/README	2006-09-25 13:38:26.000000000 -0500
+@@ -18,13 +18,13 @@ Contents:
+ 
+ Place all of these files in a directory, typically:
+ 
+-    Unix - /usr/local/share/xpdf/korean
++    Unix - /usr/share/xpdf/korean
+     Win32 - C:\Program Files\xpdf\korean
+ 
+ Add the contents of the &quot;add-to-xpdfrc&quot; file to your system-wide
+ xpdfrc config file, which is typically:
+ 
+-    Unix - /usr/local/etc/xpdfrc
++    Unix - /etc/xpdfrc
+     Win32 - C:\Program Files\Xpdf\xpdfrc
+ 
+ Alternatively, on Unix systems you can add these lines to your
+--- xpdf-3.01/xpdf-chinese-simplified/README.orig	2006-09-25 13:33:18.000000000 -0500
++++ xpdf-3.01/xpdf-chinese-simplified/README	2006-09-25 13:37:45.000000000 -0500
+@@ -20,13 +20,13 @@ Contents:
+ 
+ Place all of these files in a directory, typically:
+ 
+-    Unix - /usr/local/share/xpdf/chinese-simplified
++    Unix - /usr/share/xpdf/chinese-simplified
+     Win32 - C:\Program Files\xpdf\chinese-simplified
+ 
+ Add the contents of the &quot;add-to-xpdfrc&quot; file to your system-wide
+ xpdfrc config file, which is typically:
+ 
+-    Unix - /usr/local/etc/xpdfrc
++    Unix - /etc/xpdfrc
+     Win32 - C:\Program Files\xpdf\xpdfrc
+ 
+ Alternatively, on Unix systems you can add these lines to your
+--- xpdf-3.01/xpdf-japanese/README.orig	2006-09-25 13:33:47.000000000 -0500
++++ xpdf-3.01/xpdf-japanese/README	2006-09-25 13:38:12.000000000 -0500
+@@ -20,13 +20,13 @@ Contents:
+ 
+ Place all of these files in a directory, typically:
+ 
+-    Unix - /usr/local/share/xpdf/japanese
++    Unix - /usr/share/xpdf/japanese
+     Win32 - C:\Program Files\xpdf\japanese
+ 
+ Add the contents of the &quot;add-to-xpdfrc&quot; file to your system-wide
+ xpdfrc config file, which is typically:
+ 
+-    Unix - /usr/local/etc/xpdfrc
++    Unix - /etc/xpdfrc
+     Win32 - C:\Program Files\xpdf\xpdfrc
+ 
+ Alternatively, on Unix systems you can add these lines to your
+--- xpdf-3.01/xpdf-thai/README.BAD	2006-09-25 15:42:22.000000000 -0500
++++ xpdf-3.01/xpdf-thai/README	2006-09-25 15:42:33.000000000 -0500
+@@ -18,13 +18,13 @@ Contents:
+ 
+ Place all of these files in a directory, typically:
+ 
+-    Unix - /usr/local/share/xpdf/thai
++    Unix - /usr/share/xpdf/thai
+     Win32 - C:\Program Files\xpdf\thai
+ 
+ Add the contents of the &quot;add-to-xpdfrc&quot; file to your system-wide
+ xpdfrc config file, which is typically:
+ 
+-    Unix - /usr/local/etc/xpdfrc
++    Unix - /etc/xpdfrc
+     Win32 - C:\Program Files\xpdf\xpdfrc
+ 
+ Alternatively, on Unix systems you can add these lines to your
+--- xpdf-3.01/xpdf-thai/add-to-xpdfrc.BAD	2006-09-25 15:43:35.000000000 -0500
++++ xpdf-3.01/xpdf-thai/add-to-xpdfrc	2006-09-25 15:43:44.000000000 -0500
+@@ -1,4 +1,4 @@
+ #----- begin Thai support package (2002-jan-16)
+-nameToUnicode			/usr/local/share/xpdf/thai/Thai.nameToUnicode
+-unicodeMap	TIS-620		/usr/local/share/xpdf/thai/TIS-620.unicodeMap
++nameToUnicode			/usr/share/xpdf/thai/Thai.nameToUnicode
++unicodeMap	TIS-620		/usr/share/xpdf/thai/TIS-620.unicodeMap
+ #----- end Thai support package
+--- xpdf-3.01/xpdf-cyrillic/README.BAD	2006-09-25 15:42:48.000000000 -0500
++++ xpdf-3.01/xpdf-cyrillic/README	2006-09-25 15:42:59.000000000 -0500
+@@ -18,13 +18,13 @@ Contents:
+ 
+ Place all of these files in a directory, typically:
+ 
+-    Unix - /usr/local/share/xpdf/cyrillic
++    Unix - /usr/share/xpdf/cyrillic
+     Win32 - C:\Program Files\xpdf\cyrillic
+ 
+ Add the contents of the &quot;add-to-xpdfrc&quot; file to your system-wide
+ xpdfrc config file, which is typically:
+ 
+-    Unix - /usr/local/etc/xpdfrc
++    Unix - /etc/xpdfrc
+     Win32 - C:\Program Files\xpdf\xpdfrc
+ 
+ Alternatively, on Unix systems you can add these lines to your
+--- xpdf-3.01/xpdf-cyrillic/add-to-xpdfrc.BAD	2006-09-25 15:43:28.000000000 -0500
++++ xpdf-3.01/xpdf-cyrillic/add-to-xpdfrc	2006-09-25 15:43:11.000000000 -0500
+@@ -1,4 +1,4 @@
+ #----- begin Cyrillic support package (2003-jun-28)
+-nameToUnicode			/usr/local/share/xpdf/cyrillic/Bulgarian.nameToUnicode
+-unicodeMap	KOI8-R		/usr/local/share/xpdf/cyrillic/KOI8-R.unicodeMap
++nameToUnicode			/usr/share/xpdf/cyrillic/Bulgarian.nameToUnicode
++unicodeMap	KOI8-R		/usr/share/xpdf/cyrillic/KOI8-R.unicodeMap
+ #----- end Cyrillic support package

Added: trunk/rpms/xpdf/xpdf-3.02-additionalzoom.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-additionalzoom.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-additionalzoom.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02-additionalzoom.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02-additionalzoom.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,26 @@
+diff -up xpdf-3.02/xpdf/XPDFViewer.cc.BAD xpdf-3.02/xpdf/XPDFViewer.cc
+--- xpdf-3.02/xpdf/XPDFViewer.cc.BAD	2007-08-28 14:44:09.000000000 -0400
++++ xpdf-3.02/xpdf/XPDFViewer.cc	2007-08-28 14:44:47.000000000 -0400
+@@ -140,6 +140,8 @@ struct ZoomMenuInfo {
+ 
+ static ZoomMenuInfo zoomMenuInfo[nZoomMenuItems] = {
+   { &quot;400%&quot;,      400 },
++  { &quot;300%&quot;,      300 },
++  { &quot;250%&quot;,      250 },
+   { &quot;200%&quot;,      200 },
+   { &quot;150%&quot;,      150 },
+   { &quot;125%&quot;,      125 },
+diff -up xpdf-3.02/xpdf/Stream.cc.BAD xpdf-3.02/xpdf/Stream.cc
+diff -up xpdf-3.02/xpdf/XPDFViewer.h.BAD xpdf-3.02/xpdf/XPDFViewer.h
+diff -up xpdf-3.02/xpdf/XPDFViewer.h.BAD xpdf-3.02/xpdf/XPDFViewer.h
+--- xpdf-3.02/xpdf/XPDFViewer.h.BAD	2007-08-28 16:46:48.000000000 -0400
++++ xpdf-3.02/xpdf/XPDFViewer.h	2007-08-28 16:46:57.000000000 -0400
+@@ -41,7 +41,7 @@ class XPDFViewer;
+ //------------------------------------------------------------------------
+ 
+ // NB: this must match the defn of zoomMenuBtnInfo in XPDFViewer.cc
+-#define nZoomMenuItems 10
++#define nZoomMenuItems 12
+ 
+ //------------------------------------------------------------------------
+ 

Added: trunk/rpms/xpdf/xpdf-3.02-crash.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-crash.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-crash.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02-crash.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02-crash.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,48 @@
+diff -up xpdf-3.02/fofi/FoFiType1.cc.crash xpdf-3.02/fofi/FoFiType1.cc
+--- xpdf-3.02/fofi/FoFiType1.cc.crash	2007-02-27 17:05:51.000000000 -0500
++++ xpdf-3.02/fofi/FoFiType1.cc	2009-02-11 11:31:04.000000000 -0500
+@@ -235,9 +235,14 @@ void FoFiType1::parse() {
+ 	    }
+ 	  }
+ 	} else {
+-	  if (strtok(buf, &quot; \t&quot;) &amp;&amp;
+-	      (p = strtok(NULL, &quot; \t\n\r&quot;)) &amp;&amp; !strcmp(p, &quot;def&quot;)) {
+-	    break;
++	  p = strtok(buf, &quot; \t\n\r&quot;);
++	  if (p)
++	  {
++	    if (!strcmp(p, &quot;def&quot;)) break;
++	    if (!strcmp(p, &quot;readonly&quot;)) break;
++	    // the spec does not says this but i'm mantaining old xpdf behaviour that accepts &quot;foo def&quot; as end of the encoding array
++	    p = strtok(buf, &quot; \t\n\r&quot;);
++	    if (p &amp;&amp; !strcmp(p, &quot;def&quot;)) break;
+ 	  }
+ 	}
+       }
+diff -up xpdf-3.02/splash/Splash.cc.crash xpdf-3.02/splash/Splash.cc
+--- xpdf-3.02/splash/Splash.cc.crash	2007-02-27 17:05:52.000000000 -0500
++++ xpdf-3.02/splash/Splash.cc	2009-02-11 11:34:45.000000000 -0500
+@@ -1501,6 +1501,11 @@ SplashError Splash::fillWithPattern(Spla
+     xPath-&gt;aaScale();
+   }
+   xPath-&gt;sort();
++  if (!&amp;xPath-&gt;segs[0])
++  {
++    delete xPath;
++    return splashErrEmptyPath;
++  }
+   scanner = new SplashXPathScanner(xPath, eo);
+ 
+   // get the min and max x and y values
+@@ -1573,6 +1578,11 @@ SplashError Splash::xorFill(SplashPath *
+   }
+   xPath = new SplashXPath(path, state-&gt;matrix, state-&gt;flatness, gTrue);
+   xPath-&gt;sort();
++  if (!&amp;xPath-&gt;segs[0])
++  {
++    delete xPath;
++    return splashErrEmptyPath;
++  }
+   scanner = new SplashXPathScanner(xPath, eo);
+ 
+   // get the min and max x and y values

Added: trunk/rpms/xpdf/xpdf-3.02-fontlist.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-fontlist.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-fontlist.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02-fontlist.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02-fontlist.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,32 @@
+--- xpdf-3.02/xpdf/XPDFApp.cc.fntlist	2007-02-27 15:05:52.000000000 -0700
++++ xpdf-3.02/xpdf/XPDFApp.cc	2007-08-02 20:39:26.000000000 -0600
+@@ -35,9 +35,9 @@
+ //------------------------------------------------------------------------
+ 
+ static String fallbackResources[] = {
+-  &quot;*.zoomComboBox*fontList: -*-helvetica-medium-r-normal--12-*-*-*-*-*-iso8859-1&quot;,
+-  &quot;*XmTextField.fontList: -*-courier-medium-r-normal--12-*-*-*-*-*-iso8859-1&quot;,
+-  &quot;*.fontList: -*-helvetica-medium-r-normal--12-*-*-*-*-*-iso8859-1&quot;,
++  &quot;*.zoomComboBox*fontList: -*-helvetica-medium-r-normal-*-12-*-*-*-*-*-iso8859-1&quot;,
++  &quot;*XmTextField.fontList: -*-courier-medium-r-*-12-*-*-*-*-*-iso8859-1&quot;,
++  &quot;*.fontList: -*-helvetica-medium-r-normal-*-12-*-*-*-*-*-iso8859-1&quot;,
+   &quot;*XmTextField.translations: #override\\n&quot;
+   &quot;  Ctrl&lt;Key&gt;a:beginning-of-line()\\n&quot;
+   &quot;  Ctrl&lt;Key&gt;b:backward-character()\\n&quot;
+--- xpdf-3.02/xpdf/XPDFViewer.cc.fntlist	2007-08-02 20:25:21.000000000 -0600
++++ xpdf-3.02/xpdf/XPDFViewer.cc	2007-08-02 20:38:03.000000000 -0600
+@@ -2789,11 +2789,11 @@ void XPDFViewer::initAboutDialog() {
+ 
+   //----- fonts
+   aboutBigFont =
+-    createFontList(&quot;-*-times-bold-i-normal--20-*-*-*-*-*-iso8859-1&quot;);
++    createFontList(&quot;-*-times-bold-i-normal-*-20-*-*-*-*-*-iso8859-1&quot;);
+   aboutVersionFont =
+-    createFontList(&quot;-*-times-medium-r-normal--14-*-*-*-*-*-iso8859-1&quot;);
++    createFontList(&quot;-*-times-medium-r-normal-*-14-*-*-*-*-*-iso8859-1&quot;);
+   aboutFixedFont =
+-    createFontList(&quot;-*-courier-medium-r-normal--12-*-*-*-*-*-iso8859-1&quot;);
++    createFontList(&quot;-*-courier-medium-r-*-12-*-*-*-*-*-iso8859-1&quot;);
+ 
+   //----- heading
+   n = 0;

Added: trunk/rpms/xpdf/xpdf-3.02-mousebuttons.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-mousebuttons.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-mousebuttons.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02-mousebuttons.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02-mousebuttons.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,51 @@
+diff -up xpdf-3.02/xpdf/GlobalParams.cc.BAD xpdf-3.02/xpdf/GlobalParams.cc
+--- xpdf-3.02/xpdf/GlobalParams.cc.BAD	2007-08-28 14:30:13.000000000 -0400
++++ xpdf-3.02/xpdf/GlobalParams.cc	2007-08-28 14:30:38.000000000 -0400
+@@ -1574,10 +1574,10 @@ GBool GlobalParams::parseKey(GString *mo
+ 	     !p0[3]) {
+     *code = xpdfKeyCodeF1 + 10 * (p0[1] - '0') + (p0[2] - '0') - 1;
+   } else if (!strncmp(p0, &quot;mousePress&quot;, 10) &amp;&amp;
+-	     p0[10] &gt;= '1' &amp;&amp; p0[10] &lt;= '7' &amp;&amp; !p0[11]) {
++	     p0[10] &gt;= '1' &amp;&amp; p0[10] &lt;= '9' &amp;&amp; !p0[11]) {
+     *code = xpdfKeyCodeMousePress1 + (p0[10] - '1');
+   } else if (!strncmp(p0, &quot;mouseRelease&quot;, 12) &amp;&amp;
+-	     p0[12] &gt;= '1' &amp;&amp; p0[12] &lt;= '7' &amp;&amp; !p0[13]) {
++	     p0[12] &gt;= '1' &amp;&amp; p0[12] &lt;= '9' &amp;&amp; !p0[13]) {
+     *code = xpdfKeyCodeMouseRelease1 + (p0[12] - '1');
+   } else if (*p0 &gt;= 0x20 &amp;&amp; *p0 &lt;= 0x7e &amp;&amp; !p0[1]) {
+     *code = (int)*p0;
+diff -up xpdf-3.02/xpdf/GlobalParams.h.BAD xpdf-3.02/xpdf/GlobalParams.h
+--- xpdf-3.02/xpdf/GlobalParams.h.BAD	2007-08-28 14:30:44.000000000 -0400
++++ xpdf-3.02/xpdf/GlobalParams.h	2007-08-28 14:31:12.000000000 -0400
+@@ -164,6 +164,8 @@ public:
+ #define xpdfKeyCodeMousePress5    0x2005
+ #define xpdfKeyCodeMousePress6    0x2006
+ #define xpdfKeyCodeMousePress7    0x2007
++#define xpdfKeyCodeMousePress8    0x2008
++#define xpdfKeyCodeMousePress9    0x2009
+ #define xpdfKeyCodeMouseRelease1  0x2101
+ #define xpdfKeyCodeMouseRelease2  0x2102
+ #define xpdfKeyCodeMouseRelease3  0x2103
+@@ -171,6 +173,8 @@ public:
+ #define xpdfKeyCodeMouseRelease5  0x2105
+ #define xpdfKeyCodeMouseRelease6  0x2106
+ #define xpdfKeyCodeMouseRelease7  0x2107
++#define xpdfKeyCodeMouseRelease8  0x2108
++#define xpdfKeyCodeMouseRelease9  0x2109
+ #define xpdfKeyModNone            0
+ #define xpdfKeyModShift           (1 &lt;&lt; 0)
+ #define xpdfKeyModCtrl            (1 &lt;&lt; 1)
+diff -up xpdf-3.02/doc/xpdfrc.5.BAD xpdf-3.02/doc/xpdfrc.5
+--- xpdf-3.02/doc/xpdfrc.5.BAD	2007-08-28 14:31:25.000000000 -0400
++++ xpdf-3.02/doc/xpdfrc.5	2007-08-28 14:31:35.000000000 -0400
+@@ -483,8 +483,8 @@ can be a regular ASCII character, or any
+     pgdn
+     left / right / up / down        (arrow keys)
+     f1 .. f35                       (function keys)
+-    mousePress1 .. mousePress7      (mouse buttons)
+-    mouseRelease1 .. mouseRelease7  (mouse buttons)
++    mousePress1 .. mousePress9      (mouse buttons)
++    mouseRelease1 .. mouseRelease9  (mouse buttons)
+ 
+ .fi
+ .I Context

Added: trunk/rpms/xpdf/xpdf-3.02-mousebuttons_view.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-mousebuttons_view.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-mousebuttons_view.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02-mousebuttons_view.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02-mousebuttons_view.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,18 @@
+--- xpdf-3.02/xpdf/XPDFViewer.cc~	2009-02-02 01:58:55.000000000 -0700
++++ xpdf-3.02/xpdf/XPDFViewer.cc	2009-02-02 02:27:04.000000000 -0700
+@@ -592,13 +592,13 @@ void XPDFViewer::mouseCbk(void *data, XE
+   int i;
+ 
+   if (event-&gt;type == ButtonPress) {
+-    if (event-&gt;xbutton.button &gt;= 1 &amp;&amp; event-&gt;xbutton.button &lt;= 7) {
++    if (event-&gt;xbutton.button &gt;= 1 &amp;&amp; event-&gt;xbutton.button &lt;= 9) {
+       keyCode = xpdfKeyCodeMousePress1 + event-&gt;xbutton.button - 1;
+     } else {
+       return;
+     }
+   } else if (event-&gt;type == ButtonRelease) {
+-    if (event-&gt;xbutton.button &gt;= 1 &amp;&amp; event-&gt;xbutton.button &lt;= 7) {
++    if (event-&gt;xbutton.button &gt;= 1 &amp;&amp; event-&gt;xbutton.button &lt;= 9) {
+       keyCode = xpdfKeyCodeMouseRelease1 + event-&gt;xbutton.button - 1;
+     } else {
+       return;

Added: trunk/rpms/xpdf/xpdf-3.02-ownerpw.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-ownerpw.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-ownerpw.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02-ownerpw.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02-ownerpw.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,27 @@
+$OpenBSD: patch-xpdf_XRef_cc,v 1.5 2010/05/27 14:55:40 jasper Exp $
+--- xpdf/XRef.cc.orig   Thu May 27 12:16:32 2010
++++ xpdf/XRef.cc    Thu May 27 12:16:32 2010
+@@ -782,19 +782,19 @@ void XRef::setEncryption(int permFlagsA, GBool ownerPa
+ }
+ 
+ GBool XRef::okToPrint(GBool ignoreOwnerPW) {
+-  return (!ignoreOwnerPW &amp;&amp; ownerPasswordOk) || (permFlags &amp; permPrint);
++  return (1);
+ }
+ 
+ GBool XRef::okToChange(GBool ignoreOwnerPW) {
+-  return (!ignoreOwnerPW &amp;&amp; ownerPasswordOk) || (permFlags &amp; permChange);
++  return (1);
+ }
+ 
+ GBool XRef::okToCopy(GBool ignoreOwnerPW) {
+-  return (!ignoreOwnerPW &amp;&amp; ownerPasswordOk) || (permFlags &amp; permCopy);
++  return (1);
+ }
+ 
+ GBool XRef::okToAddNotes(GBool ignoreOwnerPW) {
+-  return (!ignoreOwnerPW &amp;&amp; ownerPasswordOk) || (permFlags &amp; permNotes);
++  return (1);
+ }
+ 
+ Object *XRef::fetch(int num, int gen, Object *obj) {

Added: trunk/rpms/xpdf/xpdf-3.02-x86_64-fix.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-x86_64-fix.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02-x86_64-fix.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02-x86_64-fix.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02-x86_64-fix.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,12 @@
+diff -up xpdf-3.02/xpdf/Stream.cc.BAD xpdf-3.02/xpdf/Stream.cc
+--- xpdf-3.02/xpdf/Stream.cc.BAD	2007-08-21 16:20:40.000000000 -0400
++++ xpdf-3.02/xpdf/Stream.cc	2007-08-21 16:20:44.000000000 -0400
+@@ -4451,7 +4451,7 @@ void ASCII85Encoder::reset() {
+ }
+ 
+ GBool ASCII85Encoder::fillBuf() {
+-  Gulong t;
++  Guint t;
+   char buf1[5];
+   int c0, c1, c2, c3;
+   int n, i;

Added: trunk/rpms/xpdf/xpdf-3.02pl1.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl1.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl1.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02pl1.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02pl1.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,33 @@
+*** xpdf-3.02.orig/xpdf/Stream.cc	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/xpdf/Stream.cc	Thu Jul 26 14:44:43 2007
+***************
+*** 410,424 ****
+    ok = gFalse;
+  
+    nVals = width * nComps;
+-   if (width &lt;= 0 || nComps &lt;= 0 || nBits &lt;= 0 ||
+-       nComps &gt;= INT_MAX / nBits ||
+-       width &gt;= INT_MAX / nComps / nBits ||
+-       nVals * nBits + 7 &lt; 0) {
+-     return;
+-   }
+    pixBytes = (nComps * nBits + 7) &gt;&gt; 3;
+    rowBytes = ((nVals * nBits + 7) &gt;&gt; 3) + pixBytes;
+!   if (rowBytes &lt;= 0) {
+      return;
+    }
+    predLine = (Guchar *)gmalloc(rowBytes);
+--- 410,422 ----
+    ok = gFalse;
+  
+    nVals = width * nComps;
+    pixBytes = (nComps * nBits + 7) &gt;&gt; 3;
+    rowBytes = ((nVals * nBits + 7) &gt;&gt; 3) + pixBytes;
+!   if (width &lt;= 0 || nComps &lt;= 0 || nBits &lt;= 0 ||
+!       nComps &gt; gfxColorMaxComps ||
+!       nBits &gt; 16 ||
+!       width &gt;= INT_MAX / nComps ||      // check for overflow in nVals 
+!       nVals &gt;= (INT_MAX - 7) / nBits) { // check for overflow in rowBytes
+      return;
+    }
+    predLine = (Guchar *)gmalloc(rowBytes);

Added: trunk/rpms/xpdf/xpdf-3.02pl2.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl2.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl2.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02pl2.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02pl2.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,823 @@
+diff -c -r xpdf-3.02pl1.orig/xpdf/Stream.cc xpdf-3.02/xpdf/Stream.cc
+*** xpdf-3.02pl1.orig/xpdf/Stream.cc	Thu Oct 25 15:47:38 2007
+--- xpdf-3.02/xpdf/Stream.cc	Thu Oct 25 15:48:19 2007
+***************
+*** 1243,1265 ****
+    columns = columnsA;
+    if (columns &lt; 1) {
+      columns = 1;
+!   }
+!   if (columns + 4 &lt;= 0) {
+!     columns = INT_MAX - 4;
+    }
+    rows = rowsA;
+    endOfBlock = endOfBlockA;
+    black = blackA;
+!   refLine = (short *)gmallocn(columns + 3, sizeof(short));
+!   codingLine = (short *)gmallocn(columns + 2, sizeof(short));
+  
+    eof = gFalse;
+    row = 0;
+    nextLine2D = encoding &lt; 0;
+    inputBits = 0;
+!   codingLine[0] = 0;
+!   codingLine[1] = refLine[2] = columns;
+!   a0 = 1;
+  
+    buf = EOF;
+  }
+--- 1243,1268 ----
+    columns = columnsA;
+    if (columns &lt; 1) {
+      columns = 1;
+!   } else if (columns &gt; INT_MAX - 2) {
+!     columns = INT_MAX - 2;
+    }
+    rows = rowsA;
+    endOfBlock = endOfBlockA;
+    black = blackA;
+!   // 0 &lt;= codingLine[0] &lt; codingLine[1] &lt; ... &lt; codingLine[n] = columns
+!   // ---&gt; max codingLine size = columns + 1
+!   // refLine has one extra guard entry at the end
+!   // ---&gt; max refLine size = columns + 2
+!   codingLine = (int *)gmallocn(columns + 1, sizeof(int));
+!   refLine = (int *)gmallocn(columns + 2, sizeof(int));
+  
+    eof = gFalse;
+    row = 0;
+    nextLine2D = encoding &lt; 0;
+    inputBits = 0;
+!   codingLine[0] = columns;
+!   a0i = 0;
+!   outputBits = 0;
+  
+    buf = EOF;
+  }
+***************
+*** 1278,1286 ****
+    row = 0;
+    nextLine2D = encoding &lt; 0;
+    inputBits = 0;
+!   codingLine[0] = 0;
+!   codingLine[1] = columns;
+!   a0 = 1;
+    buf = EOF;
+  
+    // skip any initial zero bits and end-of-line marker, and get the 2D
+--- 1281,1289 ----
+    row = 0;
+    nextLine2D = encoding &lt; 0;
+    inputBits = 0;
+!   codingLine[0] = columns;
+!   a0i = 0;
+!   outputBits = 0;
+    buf = EOF;
+  
+    // skip any initial zero bits and end-of-line marker, and get the 2D
+***************
+*** 1297,1507 ****
+    }
+  }
+  
+  int CCITTFaxStream::lookChar() {
+    short code1, code2, code3;
+!   int a0New;
+!   GBool err, gotEOL;
+!   int ret;
+!   int bits, i;
+  
+!   // if at eof just return EOF
+!   if (eof &amp;&amp; codingLine[a0] &gt;= columns) {
+!     return EOF;
+    }
+  
+    // read the next row
+!   err = gFalse;
+!   if (codingLine[a0] &gt;= columns) {
+  
+      // 2-D encoding
+      if (nextLine2D) {
+-       // state:
+-       //   a0New = current position in coding line (0 &lt;= a0New &lt;= columns)
+-       //   codingLine[a0] = last change in coding line
+-       //                    (black-to-white if a0 is even,
+-       //                     white-to-black if a0 is odd)
+-       //   refLine[b1] = next change in reference line of opposite color
+-       //                 to a0
+-       // invariants:
+-       //   0 &lt;= codingLine[a0] &lt;= a0New
+-       //           &lt;= refLine[b1] &lt;= refLine[b1+1] &lt;= columns
+-       //   0 &lt;= a0 &lt;= columns+1
+-       //   refLine[0] = 0
+-       //   refLine[n] = refLine[n+1] = columns
+-       //     -- for some 1 &lt;= n &lt;= columns+1
+-       // end condition:
+-       //   0 = codingLine[0] &lt;= codingLine[1] &lt; codingLine[2] &lt; ...
+-       //     &lt; codingLine[n-1] &lt; codingLine[n] = columns
+-       //     -- where 1 &lt;= n &lt;= columns+1
+        for (i = 0; codingLine[i] &lt; columns; ++i) {
+  	refLine[i] = codingLine[i];
+        }
+!       refLine[i] = refLine[i + 1] = columns;
+!       b1 = 1;
+!       a0New = codingLine[a0 = 0] = 0;
+!       do {
+  	code1 = getTwoDimCode();
+  	switch (code1) {
+  	case twoDimPass:
+! 	  if (refLine[b1] &lt; columns) {
+! 	    a0New = refLine[b1 + 1];
+! 	    b1 += 2;
+  	  }
+  	  break;
+  	case twoDimHoriz:
+! 	  if ((a0 &amp; 1) == 0) {
+! 	    code1 = code2 = 0;
+  	    do {
+! 	      code1 += code3 = getWhiteCode();
+  	    } while (code3 &gt;= 64);
+  	    do {
+! 	      code2 += code3 = getBlackCode();
+  	    } while (code3 &gt;= 64);
+  	  } else {
+- 	    code1 = code2 = 0;
+  	    do {
+! 	      code1 += code3 = getBlackCode();
+  	    } while (code3 &gt;= 64);
+  	    do {
+! 	      code2 += code3 = getWhiteCode();
+  	    } while (code3 &gt;= 64);
+  	  }
+! 	  if (code1 &gt; 0 || code2 &gt; 0) {
+! 	    if (a0New + code1 &lt;= columns) {
+! 	      codingLine[a0 + 1] = a0New + code1;
+! 	    } else {
+! 	      codingLine[a0 + 1] = columns;
+! 	    }
+! 	    ++a0;
+! 	    if (codingLine[a0] + code2 &lt;= columns) {
+! 	      codingLine[a0 + 1] = codingLine[a0] + code2;
+! 	    } else {
+! 	      codingLine[a0 + 1] = columns;
+! 	    }
+! 	    ++a0;
+! 	    a0New = codingLine[a0];
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+  	  }
+  	  break;
+! 	case twoDimVert0:
+! 	  if (refLine[b1] &lt; columns) {
+! 	    a0New = codingLine[++a0] = refLine[b1];
+! 	    ++b1;
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+- 	  } else {
+- 	    a0New = codingLine[++a0] = columns;
+  	  }
+  	  break;
+  	case twoDimVertR1:
+! 	  if (refLine[b1] + 1 &lt; columns) {
+! 	    a0New = codingLine[++a0] = refLine[b1] + 1;
+! 	    ++b1;
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+- 	  } else {
+- 	    a0New = codingLine[++a0] = columns;
+  	  }
+  	  break;
+! 	case twoDimVertL1:
+! 	  if (refLine[b1] - 1 &gt; a0New || (a0 == 0 &amp;&amp; refLine[b1] == 1)) {
+! 	    a0New = codingLine[++a0] = refLine[b1] - 1;
+! 	    --b1;
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+  	  }
+  	  break;
+! 	case twoDimVertR2:
+! 	  if (refLine[b1] + 2 &lt; columns) {
+! 	    a0New = codingLine[++a0] = refLine[b1] + 2;
+! 	    ++b1;
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+- 	  } else {
+- 	    a0New = codingLine[++a0] = columns;
+  	  }
+  	  break;
+  	case twoDimVertL2:
+! 	  if (refLine[b1] - 2 &gt; a0New || (a0 == 0 &amp;&amp; refLine[b1] == 2)) {
+! 	    a0New = codingLine[++a0] = refLine[b1] - 2;
+! 	    --b1;
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+! 	  }
+! 	  break;
+! 	case twoDimVertR3:
+! 	  if (refLine[b1] + 3 &lt; columns) {
+! 	    a0New = codingLine[++a0] = refLine[b1] + 3;
+! 	    ++b1;
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+- 	  } else {
+- 	    a0New = codingLine[++a0] = columns;
+  	  }
+  	  break;
+! 	case twoDimVertL3:
+! 	  if (refLine[b1] - 3 &gt; a0New || (a0 == 0 &amp;&amp; refLine[b1] == 3)) {
+! 	    a0New = codingLine[++a0] = refLine[b1] - 3;
+! 	    --b1;
+! 	    while (refLine[b1] &lt;= a0New &amp;&amp; refLine[b1] &lt; columns) {
+! 	      b1 += 2;
+  	    }
+  	  }
+  	  break;
+  	case EOF:
+  	  eof = gTrue;
+! 	  codingLine[a0 = 0] = columns;
+! 	  return EOF;
+  	default:
+  	  error(getPos(), &quot;Bad 2D code %04x in CCITTFax stream&quot;, code1);
+  	  err = gTrue;
+  	  break;
+  	}
+!       } while (codingLine[a0] &lt; columns);
+  
+      // 1-D encoding
+      } else {
+!       codingLine[a0 = 0] = 0;
+!       while (1) {
+  	code1 = 0;
+! 	do {
+! 	  code1 += code3 = getWhiteCode();
+! 	} while (code3 &gt;= 64);
+! 	codingLine[a0+1] = codingLine[a0] + code1;
+! 	++a0;
+! 	if (codingLine[a0] &gt;= columns) {
+! 	  break;
+! 	}
+! 	code2 = 0;
+! 	do {
+! 	  code2 += code3 = getBlackCode();
+! 	} while (code3 &gt;= 64);
+! 	codingLine[a0+1] = codingLine[a0] + code2;
+! 	++a0;
+! 	if (codingLine[a0] &gt;= columns) {
+! 	  break;
+  	}
+        }
+      }
+  
+-     if (codingLine[a0] != columns) {
+-       error(getPos(), &quot;CCITTFax row is wrong length (%d)&quot;, codingLine[a0]);
+-       // force the row to be the correct length
+-       while (codingLine[a0] &gt; columns) {
+- 	--a0;
+-       }
+-       codingLine[++a0] = columns;
+-       err = gTrue;
+-     }
+- 
+      // byte-align the row
+      if (byteAlign) {
+        inputBits &amp;= ~7;
+--- 1300,1529 ----
+    }
+  }
+  
++ inline void CCITTFaxStream::addPixels(int a1, int blackPixels) {
++   if (a1 &gt; codingLine[a0i]) {
++     if (a1 &gt; columns) {
++       error(getPos(), &quot;CCITTFax row is wrong length (%d)&quot;, a1);
++       err = gTrue;
++       a1 = columns;
++     }
++     if ((a0i &amp; 1) ^ blackPixels) {
++       ++a0i;
++     }
++     codingLine[a0i] = a1;
++   }
++ }
++ 
++ inline void CCITTFaxStream::addPixelsNeg(int a1, int blackPixels) {
++   if (a1 &gt; codingLine[a0i]) {
++     if (a1 &gt; columns) {
++       error(getPos(), &quot;CCITTFax row is wrong length (%d)&quot;, a1);
++       err = gTrue;
++       a1 = columns;
++     }
++     if ((a0i &amp; 1) ^ blackPixels) {
++       ++a0i;
++     }
++     codingLine[a0i] = a1;
++   } else if (a1 &lt; codingLine[a0i]) {
++     if (a1 &lt; 0) {
++       error(getPos(), &quot;Invalid CCITTFax code&quot;);
++       err = gTrue;
++       a1 = 0;
++     }
++     while (a0i &gt; 0 &amp;&amp; a1 &lt;= codingLine[a0i - 1]) {
++       --a0i;
++     }
++     codingLine[a0i] = a1;
++   }
++ }
++ 
+  int CCITTFaxStream::lookChar() {
+    short code1, code2, code3;
+!   int b1i, blackPixels, i, bits;
+!   GBool gotEOL;
+  
+!   if (buf != EOF) {
+!     return buf;
+    }
+  
+    // read the next row
+!   if (outputBits == 0) {
+! 
+!     // if at eof just return EOF
+!     if (eof) {
+!       return EOF;
+!     }
+! 
+!     err = gFalse;
+  
+      // 2-D encoding
+      if (nextLine2D) {
+        for (i = 0; codingLine[i] &lt; columns; ++i) {
+  	refLine[i] = codingLine[i];
+        }
+!       refLine[i++] = columns;
+!       refLine[i] = columns;
+!       codingLine[0] = 0;
+!       a0i = 0;
+!       b1i = 0;
+!       blackPixels = 0;
+!       // invariant:
+!       // refLine[b1i-1] &lt;= codingLine[a0i] &lt; refLine[b1i] &lt; refLine[b1i+1]
+!       //                                                             &lt;= columns
+!       // exception at left edge:
+!       //   codingLine[a0i = 0] = refLine[b1i = 0] = 0 is possible
+!       // exception at right edge:
+!       //   refLine[b1i] = refLine[b1i+1] = columns is possible
+!       while (codingLine[a0i] &lt; columns) {
+  	code1 = getTwoDimCode();
+  	switch (code1) {
+  	case twoDimPass:
+! 	  addPixels(refLine[b1i + 1], blackPixels);
+! 	  if (refLine[b1i + 1] &lt; columns) {
+! 	    b1i += 2;
+  	  }
+  	  break;
+  	case twoDimHoriz:
+! 	  code1 = code2 = 0;
+! 	  if (blackPixels) {
+  	    do {
+! 	      code1 += code3 = getBlackCode();
+  	    } while (code3 &gt;= 64);
+  	    do {
+! 	      code2 += code3 = getWhiteCode();
+  	    } while (code3 &gt;= 64);
+  	  } else {
+  	    do {
+! 	      code1 += code3 = getWhiteCode();
+  	    } while (code3 &gt;= 64);
+  	    do {
+! 	      code2 += code3 = getBlackCode();
+  	    } while (code3 &gt;= 64);
+  	  }
+! 	  addPixels(codingLine[a0i] + code1, blackPixels);
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    addPixels(codingLine[a0i] + code2, blackPixels ^ 1);
+! 	  }
+! 	  while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	    b1i += 2;
+! 	  }
+! 	  break;
+! 	case twoDimVertR3:
+! 	  addPixels(refLine[b1i] + 3, blackPixels);
+! 	  blackPixels ^= 1;
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    ++b1i;
+! 	    while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	      b1i += 2;
+  	    }
+  	  }
+  	  break;
+! 	case twoDimVertR2:
+! 	  addPixels(refLine[b1i] + 2, blackPixels);
+! 	  blackPixels ^= 1;
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    ++b1i;
+! 	    while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	      b1i += 2;
+  	    }
+  	  }
+  	  break;
+  	case twoDimVertR1:
+! 	  addPixels(refLine[b1i] + 1, blackPixels);
+! 	  blackPixels ^= 1;
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    ++b1i;
+! 	    while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	      b1i += 2;
+  	    }
+  	  }
+  	  break;
+! 	case twoDimVert0:
+! 	  addPixels(refLine[b1i], blackPixels);
+! 	  blackPixels ^= 1;
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    ++b1i;
+! 	    while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	      b1i += 2;
+  	    }
+  	  }
+  	  break;
+! 	case twoDimVertL3:
+! 	  addPixelsNeg(refLine[b1i] - 3, blackPixels);
+! 	  blackPixels ^= 1;
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    if (b1i &gt; 0) {
+! 	      --b1i;
+! 	    } else {
+! 	      ++b1i;
+! 	    }
+! 	    while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	      b1i += 2;
+  	    }
+  	  }
+  	  break;
+  	case twoDimVertL2:
+! 	  addPixelsNeg(refLine[b1i] - 2, blackPixels);
+! 	  blackPixels ^= 1;
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    if (b1i &gt; 0) {
+! 	      --b1i;
+! 	    } else {
+! 	      ++b1i;
+  	    }
+! 	    while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	      b1i += 2;
+  	    }
+  	  }
+  	  break;
+! 	case twoDimVertL1:
+! 	  addPixelsNeg(refLine[b1i] - 1, blackPixels);
+! 	  blackPixels ^= 1;
+! 	  if (codingLine[a0i] &lt; columns) {
+! 	    if (b1i &gt; 0) {
+! 	      --b1i;
+! 	    } else {
+! 	      ++b1i;
+! 	    }
+! 	    while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; columns) {
+! 	      b1i += 2;
+  	    }
+  	  }
+  	  break;
+  	case EOF:
++ 	  addPixels(columns, 0);
+  	  eof = gTrue;
+! 	  break;
+  	default:
+  	  error(getPos(), &quot;Bad 2D code %04x in CCITTFax stream&quot;, code1);
++ 	  addPixels(columns, 0);
+  	  err = gTrue;
+  	  break;
+  	}
+!       }
+  
+      // 1-D encoding
+      } else {
+!       codingLine[0] = 0;
+!       a0i = 0;
+!       blackPixels = 0;
+!       while (codingLine[a0i] &lt; columns) {
+  	code1 = 0;
+! 	if (blackPixels) {
+! 	  do {
+! 	    code1 += code3 = getBlackCode();
+! 	  } while (code3 &gt;= 64);
+! 	} else {
+! 	  do {
+! 	    code1 += code3 = getWhiteCode();
+! 	  } while (code3 &gt;= 64);
+  	}
++ 	addPixels(codingLine[a0i] + code1, blackPixels);
++ 	blackPixels ^= 1;
+        }
+      }
+  
+      // byte-align the row
+      if (byteAlign) {
+        inputBits &amp;= ~7;
+***************
+*** 1560,1573 ****
+      // this if we know the stream contains end-of-line markers because
+      // the &quot;just plow on&quot; technique tends to work better otherwise
+      } else if (err &amp;&amp; endOfLine) {
+!       do {
+  	if (code1 == EOF) {
+  	  eof = gTrue;
+  	  return EOF;
+  	}
+  	eatBits(1);
+! 	code1 = lookBits(13);
+!       } while ((code1 &gt;&gt; 1) != 0x001);
+        eatBits(12); 
+        if (encoding &gt; 0) {
+  	eatBits(1);
+--- 1582,1598 ----
+      // this if we know the stream contains end-of-line markers because
+      // the &quot;just plow on&quot; technique tends to work better otherwise
+      } else if (err &amp;&amp; endOfLine) {
+!       while (1) {
+! 	code1 = lookBits(13);
+  	if (code1 == EOF) {
+  	  eof = gTrue;
+  	  return EOF;
+  	}
++ 	if ((code1 &gt;&gt; 1) == 0x001) {
++ 	  break;
++ 	}
+  	eatBits(1);
+!       }
+        eatBits(12); 
+        if (encoding &gt; 0) {
+  	eatBits(1);
+***************
+*** 1575,1585 ****
+        }
+      }
+  
+!     a0 = 0;
+!     outputBits = codingLine[1] - codingLine[0];
+!     if (outputBits == 0) {
+!       a0 = 1;
+!       outputBits = codingLine[2] - codingLine[1];
+      }
+  
+      ++row;
+--- 1600,1610 ----
+        }
+      }
+  
+!     // set up for output
+!     if (codingLine[0] &gt; 0) {
+!       outputBits = codingLine[a0i = 0];
+!     } else {
+!       outputBits = codingLine[a0i = 1];
+      }
+  
+      ++row;
+***************
+*** 1587,1625 ****
+  
+    // get a byte
+    if (outputBits &gt;= 8) {
+!     ret = ((a0 &amp; 1) == 0) ? 0xff : 0x00;
+!     if ((outputBits -= 8) == 0) {
+!       ++a0;
+!       if (codingLine[a0] &lt; columns) {
+! 	outputBits = codingLine[a0 + 1] - codingLine[a0];
+!       }
+      }
+    } else {
+      bits = 8;
+!     ret = 0;
+      do {
+        if (outputBits &gt; bits) {
+! 	i = bits;
+! 	bits = 0;
+! 	if ((a0 &amp; 1) == 0) {
+! 	  ret |= 0xff &gt;&gt; (8 - i);
+  	}
+! 	outputBits -= i;
+        } else {
+! 	i = outputBits;
+! 	bits -= outputBits;
+! 	if ((a0 &amp; 1) == 0) {
+! 	  ret |= (0xff &gt;&gt; (8 - i)) &lt;&lt; bits;
+  	}
+  	outputBits = 0;
+! 	++a0;
+! 	if (codingLine[a0] &lt; columns) {
+! 	  outputBits = codingLine[a0 + 1] - codingLine[a0];
+  	}
+        }
+!     } while (bits &gt; 0 &amp;&amp; codingLine[a0] &lt; columns);
+    }
+-   buf = black ? (ret ^ 0xff) : ret;
+    return buf;
+  }
+  
+--- 1612,1654 ----
+  
+    // get a byte
+    if (outputBits &gt;= 8) {
+!     buf = (a0i &amp; 1) ? 0x00 : 0xff;
+!     outputBits -= 8;
+!     if (outputBits == 0 &amp;&amp; codingLine[a0i] &lt; columns) {
+!       ++a0i;
+!       outputBits = codingLine[a0i] - codingLine[a0i - 1];
+      }
+    } else {
+      bits = 8;
+!     buf = 0;
+      do {
+        if (outputBits &gt; bits) {
+! 	buf &lt;&lt;= bits;
+! 	if (!(a0i &amp; 1)) {
+! 	  buf |= 0xff &gt;&gt; (8 - bits);
+  	}
+! 	outputBits -= bits;
+! 	bits = 0;
+        } else {
+! 	buf &lt;&lt;= outputBits;
+! 	if (!(a0i &amp; 1)) {
+! 	  buf |= 0xff &gt;&gt; (8 - outputBits);
+  	}
++ 	bits -= outputBits;
+  	outputBits = 0;
+! 	if (codingLine[a0i] &lt; columns) {
+! 	  ++a0i;
+! 	  outputBits = codingLine[a0i] - codingLine[a0i - 1];
+! 	} else if (bits &gt; 0) {
+! 	  buf &lt;&lt;= bits;
+! 	  bits = 0;
+  	}
+        }
+!     } while (bits);
+!   }
+!   if (black) {
+!     buf ^= 0xff;
+    }
+    return buf;
+  }
+  
+***************
+*** 1661,1666 ****
+--- 1690,1698 ----
+    code = 0; // make gcc happy
+    if (endOfBlock) {
+      code = lookBits(12);
++     if (code == EOF) {
++       return 1;
++     }
+      if ((code &gt;&gt; 5) == 0) {
+        p = &amp;whiteTab1[code];
+      } else {
+***************
+*** 1673,1678 ****
+--- 1705,1713 ----
+    } else {
+      for (n = 1; n &lt;= 9; ++n) {
+        code = lookBits(n);
++       if (code == EOF) {
++ 	return 1;
++       }
+        if (n &lt; 9) {
+  	code &lt;&lt;= 9 - n;
+        }
+***************
+*** 1684,1689 ****
+--- 1719,1727 ----
+      }
+      for (n = 11; n &lt;= 12; ++n) {
+        code = lookBits(n);
++       if (code == EOF) {
++ 	return 1;
++       }
+        if (n &lt; 12) {
+  	code &lt;&lt;= 12 - n;
+        }
+***************
+*** 1709,1717 ****
+    code = 0; // make gcc happy
+    if (endOfBlock) {
+      code = lookBits(13);
+      if ((code &gt;&gt; 7) == 0) {
+        p = &amp;blackTab1[code];
+!     } else if ((code &gt;&gt; 9) == 0) {
+        p = &amp;blackTab2[(code &gt;&gt; 1) - 64];
+      } else {
+        p = &amp;blackTab3[code &gt;&gt; 7];
+--- 1747,1758 ----
+    code = 0; // make gcc happy
+    if (endOfBlock) {
+      code = lookBits(13);
++     if (code == EOF) {
++       return 1;
++     }
+      if ((code &gt;&gt; 7) == 0) {
+        p = &amp;blackTab1[code];
+!     } else if ((code &gt;&gt; 9) == 0 &amp;&amp; (code &gt;&gt; 7) != 0) {
+        p = &amp;blackTab2[(code &gt;&gt; 1) - 64];
+      } else {
+        p = &amp;blackTab3[code &gt;&gt; 7];
+***************
+*** 1723,1728 ****
+--- 1764,1772 ----
+    } else {
+      for (n = 2; n &lt;= 6; ++n) {
+        code = lookBits(n);
++       if (code == EOF) {
++ 	return 1;
++       }
+        if (n &lt; 6) {
+  	code &lt;&lt;= 6 - n;
+        }
+***************
+*** 1734,1739 ****
+--- 1778,1786 ----
+      }
+      for (n = 7; n &lt;= 12; ++n) {
+        code = lookBits(n);
++       if (code == EOF) {
++ 	return 1;
++       }
+        if (n &lt; 12) {
+  	code &lt;&lt;= 12 - n;
+        }
+***************
+*** 1747,1752 ****
+--- 1794,1802 ----
+      }
+      for (n = 10; n &lt;= 13; ++n) {
+        code = lookBits(n);
++       if (code == EOF) {
++ 	return 1;
++       }
+        if (n &lt; 13) {
+  	code &lt;&lt;= 13 - n;
+        }
+***************
+*** 1961,1966 ****
+--- 2011,2022 ----
+      // allocate a buffer for the whole image
+      bufWidth = ((width + mcuWidth - 1) / mcuWidth) * mcuWidth;
+      bufHeight = ((height + mcuHeight - 1) / mcuHeight) * mcuHeight;
++     if (bufWidth &lt;= 0 || bufHeight &lt;= 0 ||
++ 	bufWidth &gt; INT_MAX / bufWidth / (int)sizeof(int)) {
++       error(getPos(), &quot;Invalid image size in DCT stream&quot;);
++       y = height;
++       return;
++     }
+      for (i = 0; i &lt; numComps; ++i) {
+        frameBuf[i] = (int *)gmallocn(bufWidth * bufHeight, sizeof(int));
+        memset(frameBuf[i], 0, bufWidth * bufHeight * sizeof(int));
+***************
+*** 3036,3041 ****
+--- 3092,3102 ----
+    }
+    scanInfo.firstCoeff = str-&gt;getChar();
+    scanInfo.lastCoeff = str-&gt;getChar();
++   if (scanInfo.firstCoeff &lt; 0 || scanInfo.lastCoeff &gt; 63 ||
++       scanInfo.firstCoeff &gt; scanInfo.lastCoeff) {
++     error(getPos(), &quot;Bad DCT coefficient numbers in scan info block&quot;);
++     return gFalse;
++   }
+    c = str-&gt;getChar();
+    scanInfo.ah = (c &gt;&gt; 4) &amp; 0x0f;
+    scanInfo.al = c &amp; 0x0f;
+diff -c -r xpdf-3.02pl1.orig/xpdf/Stream.h xpdf-3.02/xpdf/Stream.h
+*** xpdf-3.02pl1.orig/xpdf/Stream.h	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/xpdf/Stream.h	Thu Oct 25 15:48:15 2007
+***************
+*** 528,540 ****
+    int row;			// current row
+    int inputBuf;			// input buffer
+    int inputBits;		// number of bits in input buffer
+!   short *refLine;		// reference line changing elements
+!   int b1;			// index into refLine
+!   short *codingLine;		// coding line changing elements
+!   int a0;			// index into codingLine
+    int outputBits;		// remaining ouput bits
+    int buf;			// character buffer
+  
+    short getTwoDimCode();
+    short getWhiteCode();
+    short getBlackCode();
+--- 528,542 ----
+    int row;			// current row
+    int inputBuf;			// input buffer
+    int inputBits;		// number of bits in input buffer
+!   int *codingLine;		// coding line changing elements
+!   int *refLine;			// reference line changing elements
+!   int a0i;			// index into codingLine
+!   GBool err;			// error on current line
+    int outputBits;		// remaining ouput bits
+    int buf;			// character buffer
+  
++   void addPixels(int a1, int black);
++   void addPixelsNeg(int a1, int black);
+    short getTwoDimCode();
+    short getWhiteCode();
+    short getBlackCode();

Added: trunk/rpms/xpdf/xpdf-3.02pl3.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl3.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl3.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02pl3.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02pl3.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,1145 @@
+diff -r -c xpdf-3.02.orig/goo/gmem.cc xpdf-3.02/goo/gmem.cc
+*** xpdf-3.02.orig/goo/gmem.cc	Tue Feb 27 14:05:51 2007
+--- xpdf-3.02/goo/gmem.cc	Thu Mar 19 15:47:25 2009
+***************
+*** 55,61 ****
+    void *data;
+    unsigned long *trl, *p;
+  
+!   if (size &lt;= 0) {
+      return NULL;
+    }
+    size1 = gMemDataSize(size);
+--- 55,69 ----
+    void *data;
+    unsigned long *trl, *p;
+  
+!   if (size &lt; 0) {
+! #if USE_EXCEPTIONS
+!     throw GMemException();
+! #else
+!     fprintf(stderr, &quot;Invalid memory allocation size\n&quot;);
+!     exit(1);
+! #endif
+!   }
+!   if (size == 0) {
+      return NULL;
+    }
+    size1 = gMemDataSize(size);
+***************
+*** 91,97 ****
+  #else
+    void *p;
+  
+!   if (size &lt;= 0) {
+      return NULL;
+    }
+    if (!(p = malloc(size))) {
+--- 99,113 ----
+  #else
+    void *p;
+  
+!   if (size &lt; 0) {
+! #if USE_EXCEPTIONS
+!     throw GMemException();
+! #else
+!     fprintf(stderr, &quot;Invalid memory allocation size\n&quot;);
+!     exit(1);
+! #endif
+!   }
+!   if (size == 0) {
+      return NULL;
+    }
+    if (!(p = malloc(size))) {
+***************
+*** 112,118 ****
+    void *q;
+    size_t oldSize;
+  
+!   if (size &lt;= 0) {
+      if (p) {
+        gfree(p);
+      }
+--- 128,142 ----
+    void *q;
+    size_t oldSize;
+  
+!   if (size &lt; 0) {
+! #if USE_EXCEPTIONS
+!     throw GMemException();
+! #else
+!     fprintf(stderr, &quot;Invalid memory allocation size\n&quot;);
+!     exit(1);
+! #endif
+!   }
+!   if (size == 0) {
+      if (p) {
+        gfree(p);
+      }
+***************
+*** 131,137 ****
+  #else
+    void *q;
+  
+!   if (size &lt;= 0) {
+      if (p) {
+        free(p);
+      }
+--- 155,169 ----
+  #else
+    void *q;
+  
+!   if (size &lt; 0) {
+! #if USE_EXCEPTIONS
+!     throw GMemException();
+! #else
+!     fprintf(stderr, &quot;Invalid memory allocation size\n&quot;);
+!     exit(1);
+! #endif
+!   }
+!   if (size == 0) {
+      if (p) {
+        free(p);
+      }
+diff -r -c xpdf-3.02.orig/xpdf/JBIG2Stream.cc xpdf-3.02/xpdf/JBIG2Stream.cc
+*** xpdf-3.02.orig/xpdf/JBIG2Stream.cc	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/xpdf/JBIG2Stream.cc	Tue Mar 31 10:55:23 2009
+***************
+*** 422,433 ****
+    table[i] = table[len];
+  
+    // assign prefixes
+!   i = 0;
+!   prefix = 0;
+!   table[i++].prefix = prefix++;
+!   for (; table[i].rangeLen != jbig2HuffmanEOT; ++i) {
+!     prefix &lt;&lt;= table[i].prefixLen - table[i-1].prefixLen;
+!     table[i].prefix = prefix++;
+    }
+  }
+  
+--- 422,435 ----
+    table[i] = table[len];
+  
+    // assign prefixes
+!   if (table[0].rangeLen != jbig2HuffmanEOT) {
+!     i = 0;
+!     prefix = 0;
+!     table[i++].prefix = prefix++;
+!     for (; table[i].rangeLen != jbig2HuffmanEOT; ++i) {
+!       prefix &lt;&lt;= table[i].prefixLen - table[i-1].prefixLen;
+!       table[i].prefix = prefix++;
+!     }
+    }
+  }
+  
+***************
+*** 491,497 ****
+    }
+    if (p-&gt;bits &lt; 0) {
+      error(str-&gt;getPos(), &quot;Bad two dim code in JBIG2 MMR stream&quot;);
+!     return 0;
+    }
+    bufLen -= p-&gt;bits;
+    return p-&gt;n;
+--- 493,499 ----
+    }
+    if (p-&gt;bits &lt; 0) {
+      error(str-&gt;getPos(), &quot;Bad two dim code in JBIG2 MMR stream&quot;);
+!     return EOF;
+    }
+    bufLen -= p-&gt;bits;
+    return p-&gt;n;
+***************
+*** 507,513 ****
+      ++nBytesRead;
+    }
+    while (1) {
+!     if (bufLen &gt;= 7 &amp;&amp; ((buf &gt;&gt; (bufLen - 7)) &amp; 0x7f) == 0) {
+        if (bufLen &lt;= 12) {
+  	code = buf &lt;&lt; (12 - bufLen);
+        } else {
+--- 509,515 ----
+      ++nBytesRead;
+    }
+    while (1) {
+!     if (bufLen &gt;= 11 &amp;&amp; ((buf &gt;&gt; (bufLen - 7)) &amp; 0x7f) == 0) {
+        if (bufLen &lt;= 12) {
+  	code = buf &lt;&lt; (12 - bufLen);
+        } else {
+***************
+*** 550,563 ****
+      ++nBytesRead;
+    }
+    while (1) {
+!     if (bufLen &gt;= 6 &amp;&amp; ((buf &gt;&gt; (bufLen - 6)) &amp; 0x3f) == 0) {
+        if (bufLen &lt;= 13) {
+  	code = buf &lt;&lt; (13 - bufLen);
+        } else {
+  	code = buf &gt;&gt; (bufLen - 13);
+        }
+        p = &amp;blackTab1[code &amp; 0x7f];
+!     } else if (bufLen &gt;= 4 &amp;&amp; ((buf &gt;&gt; (bufLen - 4)) &amp; 0x0f) == 0) {
+        if (bufLen &lt;= 12) {
+  	code = buf &lt;&lt; (12 - bufLen);
+        } else {
+--- 552,566 ----
+      ++nBytesRead;
+    }
+    while (1) {
+!     if (bufLen &gt;= 10 &amp;&amp; ((buf &gt;&gt; (bufLen - 6)) &amp; 0x3f) == 0) {
+        if (bufLen &lt;= 13) {
+  	code = buf &lt;&lt; (13 - bufLen);
+        } else {
+  	code = buf &gt;&gt; (bufLen - 13);
+        }
+        p = &amp;blackTab1[code &amp; 0x7f];
+!     } else if (bufLen &gt;= 7 &amp;&amp; ((buf &gt;&gt; (bufLen - 4)) &amp; 0x0f) == 0 &amp;&amp;
+! 	       ((buf &gt;&gt; (bufLen - 6)) &amp; 0x03) != 0) {
+        if (bufLen &lt;= 12) {
+  	code = buf &lt;&lt; (12 - bufLen);
+        } else {
+***************
+*** 683,690 ****
+    h = hA;
+    line = (wA + 7) &gt;&gt; 3;
+    if (w &lt;= 0 || h &lt;= 0 || line &lt;= 0 || h &gt;= (INT_MAX - 1) / line) {
+!     data = NULL;
+!     return;
+    }
+    // need to allocate one extra guard byte for use in combine()
+    data = (Guchar *)gmalloc(h * line + 1);
+--- 686,694 ----
+    h = hA;
+    line = (wA + 7) &gt;&gt; 3;
+    if (w &lt;= 0 || h &lt;= 0 || line &lt;= 0 || h &gt;= (INT_MAX - 1) / line) {
+!     // force a call to gmalloc(-1), which will throw an exception
+!     h = -1;
+!     line = 2;
+    }
+    // need to allocate one extra guard byte for use in combine()
+    data = (Guchar *)gmalloc(h * line + 1);
+***************
+*** 698,705 ****
+    h = bitmap-&gt;h;
+    line = bitmap-&gt;line;
+    if (w &lt;= 0 || h &lt;= 0 || line &lt;= 0 || h &gt;= (INT_MAX - 1) / line) {
+!     data = NULL;
+!     return;
+    }
+    // need to allocate one extra guard byte for use in combine()
+    data = (Guchar *)gmalloc(h * line + 1);
+--- 702,710 ----
+    h = bitmap-&gt;h;
+    line = bitmap-&gt;line;
+    if (w &lt;= 0 || h &lt;= 0 || line &lt;= 0 || h &gt;= (INT_MAX - 1) / line) {
+!     // force a call to gmalloc(-1), which will throw an exception
+!     h = -1;
+!     line = 2;
+    }
+    // need to allocate one extra guard byte for use in combine()
+    data = (Guchar *)gmalloc(h * line + 1);
+***************
+*** 754,759 ****
+--- 759,766 ----
+  inline void JBIG2Bitmap::getPixelPtr(int x, int y, JBIG2BitmapPtr *ptr) {
+    if (y &lt; 0 || y &gt;= h || x &gt;= w) {
+      ptr-&gt;p = NULL;
++     ptr-&gt;shift = 0; // make gcc happy
++     ptr-&gt;x = 0; // make gcc happy
+    } else if (x &lt; 0) {
+      ptr-&gt;p = &amp;data[y * line];
+      ptr-&gt;shift = 7;
+***************
+*** 798,803 ****
+--- 805,814 ----
+    Guint src0, src1, src, dest, s1, s2, m1, m2, m3;
+    GBool oneByte;
+  
++   // check for the pathological case where y = -2^31
++   if (y &lt; -0x7fffffff) {
++     return;
++   }
+    if (y &lt; 0) {
+      y0 = -y;
+    } else {
+***************
+*** 1011,1018 ****
+--- 1022,1034 ----
+  JBIG2SymbolDict::JBIG2SymbolDict(Guint segNumA, Guint sizeA):
+    JBIG2Segment(segNumA)
+  {
++   Guint i;
++ 
+    size = sizeA;
+    bitmaps = (JBIG2Bitmap **)gmallocn(size, sizeof(JBIG2Bitmap *));
++   for (i = 0; i &lt; size; ++i) {
++     bitmaps[i] = NULL;
++   }
+    genericRegionStats = NULL;
+    refinementRegionStats = NULL;
+  }
+***************
+*** 1021,1027 ****
+    Guint i;
+  
+    for (i = 0; i &lt; size; ++i) {
+!     delete bitmaps[i];
+    }
+    gfree(bitmaps);
+    if (genericRegionStats) {
+--- 1037,1045 ----
+    Guint i;
+  
+    for (i = 0; i &lt; size; ++i) {
+!     if (bitmaps[i]) {
+!       delete bitmaps[i];
+!     }
+    }
+    gfree(bitmaps);
+    if (genericRegionStats) {
+***************
+*** 1296,1301 ****
+--- 1314,1326 ----
+        goto eofError2;
+      }
+  
++     // check for missing page information segment
++     if (!pageBitmap &amp;&amp; ((segType &gt;= 4 &amp;&amp; segType &lt;= 7) ||
++ 			(segType &gt;= 20 &amp;&amp; segType &lt;= 43))) {
++       error(getPos(), &quot;First JBIG2 segment associated with a page must be a page information segment&quot;);
++       goto syntaxError;
++     }
++ 
+      // read the segment data
+      switch (segType) {
+      case 0:
+***************
+*** 1411,1416 ****
+--- 1436,1443 ----
+    Guint i, j, k;
+    Guchar *p;
+  
++   symWidths = NULL;
++ 
+    // symbol dictionary flags
+    if (!readUWord(&amp;flags)) {
+      goto eofError;
+***************
+*** 1466,1485 ****
+    codeTables = new GList();
+    numInputSyms = 0;
+    for (i = 0; i &lt; nRefSegs; ++i) {
+!     seg = findSegment(refSegs[i]);
+!     if (seg-&gt;getType() == jbig2SegSymbolDict) {
+!       numInputSyms += ((JBIG2SymbolDict *)seg)-&gt;getSize();
+!     } else if (seg-&gt;getType() == jbig2SegCodeTable) {
+!       codeTables-&gt;append(seg);
+      }
+    }
+  
+    // compute symbol code length
+!   symCodeLen = 0;
+!   i = 1;
+!   while (i &lt; numInputSyms + numNewSyms) {
+      ++symCodeLen;
+!     i &lt;&lt;= 1;
+    }
+  
+    // get the input symbol bitmaps
+--- 1493,1524 ----
+    codeTables = new GList();
+    numInputSyms = 0;
+    for (i = 0; i &lt; nRefSegs; ++i) {
+!     if ((seg = findSegment(refSegs[i]))) {
+!       if (seg-&gt;getType() == jbig2SegSymbolDict) {
+! 	j = ((JBIG2SymbolDict *)seg)-&gt;getSize();
+! 	if (numInputSyms &gt; UINT_MAX - j) {
+! 	  error(getPos(), &quot;Too many input symbols in JBIG2 symbol dictionary&quot;);
+! 	  delete codeTables;
+! 	  goto eofError;
+! 	}
+! 	numInputSyms += j;
+!       } else if (seg-&gt;getType() == jbig2SegCodeTable) {
+! 	codeTables-&gt;append(seg);
+!       }
+      }
+    }
++   if (numInputSyms &gt; UINT_MAX - numNewSyms) {
++     error(getPos(), &quot;Too many input symbols in JBIG2 symbol dictionary&quot;);
++     delete codeTables;
++     goto eofError;
++   }
+  
+    // compute symbol code length
+!   symCodeLen = 1;
+!   i = (numInputSyms + numNewSyms) &gt;&gt; 1;
+!   while (i) {
+      ++symCodeLen;
+!     i &gt;&gt;= 1;
+    }
+  
+    // get the input symbol bitmaps
+***************
+*** 1491,1501 ****
+    k = 0;
+    inputSymbolDict = NULL;
+    for (i = 0; i &lt; nRefSegs; ++i) {
+!     seg = findSegment(refSegs[i]);
+!     if (seg-&gt;getType() == jbig2SegSymbolDict) {
+!       inputSymbolDict = (JBIG2SymbolDict *)seg;
+!       for (j = 0; j &lt; inputSymbolDict-&gt;getSize(); ++j) {
+! 	bitmaps[k++] = inputSymbolDict-&gt;getBitmap(j);
+        }
+      }
+    }
+--- 1530,1541 ----
+    k = 0;
+    inputSymbolDict = NULL;
+    for (i = 0; i &lt; nRefSegs; ++i) {
+!     if ((seg = findSegment(refSegs[i]))) {
+!       if (seg-&gt;getType() == jbig2SegSymbolDict) {
+! 	inputSymbolDict = (JBIG2SymbolDict *)seg;
+! 	for (j = 0; j &lt; inputSymbolDict-&gt;getSize(); ++j) {
+! 	  bitmaps[k++] = inputSymbolDict-&gt;getBitmap(j);
+! 	}
+        }
+      }
+    }
+***************
+*** 1510,1515 ****
+--- 1550,1558 ----
+      } else if (huffDH == 1) {
+        huffDHTable = huffTableE;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffDHTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffDW == 0) {
+***************
+*** 1517,1533 ****
+--- 1560,1585 ----
+      } else if (huffDW == 1) {
+        huffDWTable = huffTableC;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffDWTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffBMSize == 0) {
+        huffBMSizeTable = huffTableA;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffBMSizeTable =
+  	  ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffAggInst == 0) {
+        huffAggInstTable = huffTableA;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffAggInstTable =
+  	  ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+***************
+*** 1560,1566 ****
+    }
+  
+    // allocate symbol widths storage
+-   symWidths = NULL;
+    if (huff &amp;&amp; !refAgg) {
+      symWidths = (Guint *)gmallocn(numNewSyms, sizeof(Guint));
+    }
+--- 1612,1617 ----
+***************
+*** 1602,1607 ****
+--- 1653,1662 ----
+  	goto syntaxError;
+        }
+        symWidth += dw;
++       if (i &gt;= numNewSyms) {
++ 	error(getPos(), &quot;Too many symbols in JBIG2 symbol dictionary&quot;);
++ 	goto syntaxError;
++       }
+  
+        // using a collective bitmap, so don't read a bitmap here
+        if (huff &amp;&amp; !refAgg) {
+***************
+*** 1638,1643 ****
+--- 1693,1702 ----
+  	    arithDecoder-&gt;decodeInt(&amp;refDX, iardxStats);
+  	    arithDecoder-&gt;decodeInt(&amp;refDY, iardyStats);
+  	  }
++ 	  if (symID &gt;= numInputSyms + i) {
++ 	    error(getPos(), &quot;Invalid symbol ID in JBIG2 symbol dictionary&quot;);
++ 	    goto syntaxError;
++ 	  }
+  	  refBitmap = bitmaps[symID];
+  	  bitmaps[numInputSyms + i] =
+  	      readGenericRefinementRegion(symWidth, symHeight,
+***************
+*** 1704,1709 ****
+--- 1763,1774 ----
+      } else {
+        arithDecoder-&gt;decodeInt(&amp;run, iaexStats);
+      }
++     if (i + run &gt; numInputSyms + numNewSyms ||
++ 	(ex &amp;&amp; j + run &gt; numExSyms)) {
++       error(getPos(), &quot;Too many exported symbols in JBIG2 symbol dictionary&quot;);
++       delete symbolDict;
++       goto syntaxError;
++     }
+      if (ex) {
+        for (cnt = 0; cnt &lt; run; ++cnt) {
+  	symbolDict-&gt;setBitmap(j++, bitmaps[i++]-&gt;copy());
+***************
+*** 1713,1718 ****
+--- 1778,1788 ----
+      }
+      ex = !ex;
+    }
++   if (j != numExSyms) {
++     error(getPos(), &quot;Too few symbols in JBIG2 symbol dictionary&quot;);
++     delete symbolDict;
++     goto syntaxError;
++   }
+  
+    for (i = 0; i &lt; numNewSyms; ++i) {
+      delete bitmaps[numInputSyms + i];
+***************
+*** 1735,1740 ****
+--- 1805,1814 ----
+  
+    return gTrue;
+  
++  codeTableError:
++   error(getPos(), &quot;Missing code table in JBIG2 symbol dictionary&quot;);
++   delete codeTables;
++ 
+   syntaxError:
+    for (i = 0; i &lt; numNewSyms; ++i) {
+      if (bitmaps[numInputSyms + i]) {
+***************
+*** 1837,1842 ****
+--- 1911,1918 ----
+        }
+      } else {
+        error(getPos(), &quot;Invalid segment reference in JBIG2 text region&quot;);
++       delete codeTables;
++       return;
+      }
+    }
+    symCodeLen = 0;
+***************
+*** 1871,1876 ****
+--- 1947,1955 ----
+      } else if (huffFS == 1) {
+        huffFSTable = huffTableG;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffFSTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffDS == 0) {
+***************
+*** 1880,1885 ****
+--- 1959,1967 ----
+      } else if (huffDS == 2) {
+        huffDSTable = huffTableJ;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffDSTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffDT == 0) {
+***************
+*** 1889,1894 ****
+--- 1971,1979 ----
+      } else if (huffDT == 2) {
+        huffDTTable = huffTableM;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffDTTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffRDW == 0) {
+***************
+*** 1896,1901 ****
+--- 1981,1989 ----
+      } else if (huffRDW == 1) {
+        huffRDWTable = huffTableO;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffRDWTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffRDH == 0) {
+***************
+*** 1903,1908 ****
+--- 1991,1999 ----
+      } else if (huffRDH == 1) {
+        huffRDHTable = huffTableO;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffRDHTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffRDX == 0) {
+***************
+*** 1910,1915 ****
+--- 2001,2009 ----
+      } else if (huffRDX == 1) {
+        huffRDXTable = huffTableO;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffRDXTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffRDY == 0) {
+***************
+*** 1917,1927 ****
+--- 2011,2027 ----
+      } else if (huffRDY == 1) {
+        huffRDYTable = huffTableO;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffRDYTable = ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+      if (huffRSize == 0) {
+        huffRSizeTable = huffTableA;
+      } else {
++       if (i &gt;= (Guint)codeTables-&gt;getLength()) {
++ 	goto codeTableError;
++       }
+        huffRSizeTable =
+  	  ((JBIG2CodeTable *)codeTables-&gt;get(i++))-&gt;getHuffTable();
+      }
+***************
+*** 2016,2023 ****
+--- 2116,2130 ----
+  
+    return;
+  
++  codeTableError:
++   error(getPos(), &quot;Missing code table in JBIG2 text region&quot;);
++   gfree(codeTables);
++   delete syms;
++   return;
++ 
+   eofError:
+    error(getPos(), &quot;Unexpected EOF in JBIG2 stream&quot;);
++   return;
+  }
+  
+  JBIG2Bitmap *JBIG2Stream::readTextRegion(GBool huff, GBool refine,
+***************
+*** 2324,2331 ****
+      error(getPos(), &quot;Bad symbol dictionary reference in JBIG2 halftone segment&quot;);
+      return;
+    }
+!   seg = findSegment(refSegs[0]);
+!   if (seg-&gt;getType() != jbig2SegPatternDict) {
+      error(getPos(), &quot;Bad symbol dictionary reference in JBIG2 halftone segment&quot;);
+      return;
+    }
+--- 2431,2438 ----
+      error(getPos(), &quot;Bad symbol dictionary reference in JBIG2 halftone segment&quot;);
+      return;
+    }
+!   if (!(seg = findSegment(refSegs[0])) ||
+!       seg-&gt;getType() != jbig2SegPatternDict) {
+      error(getPos(), &quot;Bad symbol dictionary reference in JBIG2 halftone segment&quot;);
+      return;
+    }
+***************
+*** 2483,2489 ****
+  
+    // read the bitmap
+    bitmap = readGenericBitmap(mmr, w, h, templ, tpgdOn, gFalse,
+! 			     NULL, atx, aty, mmr ? 0 : length - 18);
+  
+    // combine the region bitmap into the page bitmap
+    if (imm) {
+--- 2590,2596 ----
+  
+    // read the bitmap
+    bitmap = readGenericBitmap(mmr, w, h, templ, tpgdOn, gFalse,
+! 			     NULL, atx, aty, mmr ? length - 18 : 0);
+  
+    // combine the region bitmap into the page bitmap
+    if (imm) {
+***************
+*** 2505,2510 ****
+--- 2612,2654 ----
+    error(getPos(), &quot;Unexpected EOF in JBIG2 stream&quot;);
+  }
+  
++ inline void JBIG2Stream::mmrAddPixels(int a1, int blackPixels,
++ 				      int *codingLine, int *a0i, int w) {
++   if (a1 &gt; codingLine[*a0i]) {
++     if (a1 &gt; w) {
++       error(getPos(), &quot;JBIG2 MMR row is wrong length ({0:d})&quot;, a1);
++       a1 = w;
++     }
++     if ((*a0i &amp; 1) ^ blackPixels) {
++       ++*a0i;
++     }
++     codingLine[*a0i] = a1;
++   }
++ }
++ 
++ inline void JBIG2Stream::mmrAddPixelsNeg(int a1, int blackPixels,
++ 					 int *codingLine, int *a0i, int w) {
++   if (a1 &gt; codingLine[*a0i]) {
++     if (a1 &gt; w) {
++       error(getPos(), &quot;JBIG2 MMR row is wrong length ({0:d})&quot;, a1);
++       a1 = w;
++     }
++     if ((*a0i &amp; 1) ^ blackPixels) {
++       ++*a0i;
++     }
++     codingLine[*a0i] = a1;
++   } else if (a1 &lt; codingLine[*a0i]) {
++     if (a1 &lt; 0) {
++       error(getPos(), &quot;Invalid JBIG2 MMR code&quot;);
++       a1 = 0;
++     }
++     while (*a0i &gt; 0 &amp;&amp; a1 &lt;= codingLine[*a0i - 1]) {
++       --*a0i;
++     }
++     codingLine[*a0i] = a1;
++   }
++ }
++ 
+  JBIG2Bitmap *JBIG2Stream::readGenericBitmap(GBool mmr, int w, int h,
+  					    int templ, GBool tpgdOn,
+  					    GBool useSkip, JBIG2Bitmap *skip,
+***************
+*** 2517,2523 ****
+    JBIG2BitmapPtr atPtr0, atPtr1, atPtr2, atPtr3;
+    int *refLine, *codingLine;
+    int code1, code2, code3;
+!   int x, y, a0, pix, i, refI, codingI;
+  
+    bitmap = new JBIG2Bitmap(0, w, h);
+    bitmap-&gt;clearToZero();
+--- 2661,2667 ----
+    JBIG2BitmapPtr atPtr0, atPtr1, atPtr2, atPtr3;
+    int *refLine, *codingLine;
+    int code1, code2, code3;
+!   int x, y, a0i, b1i, blackPixels, pix, i;
+  
+    bitmap = new JBIG2Bitmap(0, w, h);
+    bitmap-&gt;clearToZero();
+***************
+*** 2527,2535 ****
+    if (mmr) {
+  
+      mmrDecoder-&gt;reset();
+      refLine = (int *)gmallocn(w + 2, sizeof(int));
+!     codingLine = (int *)gmallocn(w + 2, sizeof(int));
+!     codingLine[0] = codingLine[1] = w;
+  
+      for (y = 0; y &lt; h; ++y) {
+  
+--- 2671,2688 ----
+    if (mmr) {
+  
+      mmrDecoder-&gt;reset();
++     if (w &gt; INT_MAX - 2) {
++       error(getPos(), &quot;Bad width in JBIG2 generic bitmap&quot;);
++       // force a call to gmalloc(-1), which will throw an exception
++       w = -3;
++     }
++     // 0 &lt;= codingLine[0] &lt; codingLine[1] &lt; ... &lt; codingLine[n] = w
++     // ---&gt; max codingLine size = w + 1
++     // refLine has one extra guard entry at the end
++     // ---&gt; max refLine size = w + 2
++     codingLine = (int *)gmallocn(w + 1, sizeof(int));
+      refLine = (int *)gmallocn(w + 2, sizeof(int));
+!     codingLine[0] = w;
+  
+      for (y = 0; y &lt; h; ++y) {
+  
+***************
+*** 2537,2664 ****
+        for (i = 0; codingLine[i] &lt; w; ++i) {
+  	refLine[i] = codingLine[i];
+        }
+!       refLine[i] = refLine[i + 1] = w;
+  
+        // decode a line
+!       refI = 0;     // b1 = refLine[refI]
+!       codingI = 0;  // a1 = codingLine[codingI]
+!       a0 = 0;
+!       do {
+  	code1 = mmrDecoder-&gt;get2DCode();
+  	switch (code1) {
+  	case twoDimPass:
+! 	  if (refLine[refI] &lt; w) {
+! 	    a0 = refLine[refI + 1];
+! 	    refI += 2;
+! 	  }
+! 	  break;
+  	case twoDimHoriz:
+! 	  if (codingI &amp; 1) {
+! 	    code1 = 0;
+! 	    do {
+! 	      code1 += code3 = mmrDecoder-&gt;getBlackCode();
+! 	    } while (code3 &gt;= 64);
+! 	    code2 = 0;
+! 	    do {
+! 	      code2 += code3 = mmrDecoder-&gt;getWhiteCode();
+! 	    } while (code3 &gt;= 64);
+! 	  } else {
+! 	    code1 = 0;
+! 	    do {
+! 	      code1 += code3 = mmrDecoder-&gt;getWhiteCode();
+! 	    } while (code3 &gt;= 64);
+! 	    code2 = 0;
+! 	    do {
+! 	      code2 += code3 = mmrDecoder-&gt;getBlackCode();
+! 	    } while (code3 &gt;= 64);
+! 	  }
+! 	  if (code1 &gt; 0 || code2 &gt; 0) {
+! 	    a0 = codingLine[codingI++] = a0 + code1;
+! 	    a0 = codingLine[codingI++] = a0 + code2;
+! 	    while (refLine[refI] &lt;= a0 &amp;&amp; refLine[refI] &lt; w) {
+! 	      refI += 2;
+! 	    }
+! 	  }
+! 	  break;
+! 	case twoDimVert0:
+! 	  a0 = codingLine[codingI++] = refLine[refI];
+! 	  if (refLine[refI] &lt; w) {
+! 	    ++refI;
+! 	  }
+! 	  break;
+! 	case twoDimVertR1:
+! 	  a0 = codingLine[codingI++] = refLine[refI] + 1;
+! 	  if (refLine[refI] &lt; w) {
+! 	    ++refI;
+! 	    while (refLine[refI] &lt;= a0 &amp;&amp; refLine[refI] &lt; w) {
+! 	      refI += 2;
+! 	    }
+! 	  }
+! 	  break;
+! 	case twoDimVertR2:
+! 	  a0 = codingLine[codingI++] = refLine[refI] + 2;
+! 	  if (refLine[refI] &lt; w) {
+! 	    ++refI;
+! 	    while (refLine[refI] &lt;= a0 &amp;&amp; refLine[refI] &lt; w) {
+! 	      refI += 2;
+! 	    }
+! 	  }
+! 	  break;
+  	case twoDimVertR3:
+! 	  a0 = codingLine[codingI++] = refLine[refI] + 3;
+! 	  if (refLine[refI] &lt; w) {
+! 	    ++refI;
+! 	    while (refLine[refI] &lt;= a0 &amp;&amp; refLine[refI] &lt; w) {
+! 	      refI += 2;
+! 	    }
+! 	  }
+! 	  break;
+! 	case twoDimVertL1:
+! 	  a0 = codingLine[codingI++] = refLine[refI] - 1;
+! 	  if (refI &gt; 0) {
+! 	    --refI;
+! 	  } else {
+! 	    ++refI;
+! 	  }
+! 	  while (refLine[refI] &lt;= a0 &amp;&amp; refLine[refI] &lt; w) {
+! 	    refI += 2;
+! 	  }
+! 	  break;
+! 	case twoDimVertL2:
+! 	  a0 = codingLine[codingI++] = refLine[refI] - 2;
+! 	  if (refI &gt; 0) {
+! 	    --refI;
+! 	  } else {
+! 	    ++refI;
+! 	  }
+! 	  while (refLine[refI] &lt;= a0 &amp;&amp; refLine[refI] &lt; w) {
+! 	    refI += 2;
+! 	  }
+! 	  break;
+  	case twoDimVertL3:
+! 	  a0 = codingLine[codingI++] = refLine[refI] - 3;
+! 	  if (refI &gt; 0) {
+! 	    --refI;
+! 	  } else {
+! 	    ++refI;
+! 	  }
+! 	  while (refLine[refI] &lt;= a0 &amp;&amp; refLine[refI] &lt; w) {
+! 	    refI += 2;
+! 	  }
+! 	  break;
+  	default:
+  	  error(getPos(), &quot;Illegal code in JBIG2 MMR bitmap data&quot;);
+  	  break;
+  	}
+!       } while (a0 &lt; w);
+!       codingLine[codingI++] = w;
+  
+        // convert the run lengths to a bitmap line
+        i = 0;
+!       while (codingLine[i] &lt; w) {
+  	for (x = codingLine[i]; x &lt; codingLine[i+1]; ++x) {
+  	  bitmap-&gt;setPixel(x, y);
+  	}
+  	i += 2;
+        }
+      }
+--- 2690,2846 ----
+        for (i = 0; codingLine[i] &lt; w; ++i) {
+  	refLine[i] = codingLine[i];
+        }
+!       refLine[i++] = w;
+!       refLine[i] = w;
+  
+        // decode a line
+!       codingLine[0] = 0;
+!       a0i = 0;
+!       b1i = 0;
+!       blackPixels = 0;
+!       // invariant:
+!       // refLine[b1i-1] &lt;= codingLine[a0i] &lt; refLine[b1i] &lt; refLine[b1i+1] &lt;= w
+!       // exception at left edge:
+!       //   codingLine[a0i = 0] = refLine[b1i = 0] = 0 is possible
+!       // exception at right edge:
+!       //   refLine[b1i] = refLine[b1i+1] = w is possible
+!       while (codingLine[a0i] &lt; w) {
+  	code1 = mmrDecoder-&gt;get2DCode();
+  	switch (code1) {
+  	case twoDimPass:
+!           mmrAddPixels(refLine[b1i + 1], blackPixels, codingLine, &amp;a0i, w);
+!           if (refLine[b1i + 1] &lt; w) {
+!             b1i += 2;
+!           }
+!           break;
+  	case twoDimHoriz:
+!           code1 = code2 = 0;
+!           if (blackPixels) {
+!             do {
+!               code1 += code3 = mmrDecoder-&gt;getBlackCode();
+!             } while (code3 &gt;= 64);
+!             do {
+!               code2 += code3 = mmrDecoder-&gt;getWhiteCode();
+!             } while (code3 &gt;= 64);
+!           } else {
+!             do {
+!               code1 += code3 = mmrDecoder-&gt;getWhiteCode();
+!             } while (code3 &gt;= 64);
+!             do {
+!               code2 += code3 = mmrDecoder-&gt;getBlackCode();
+!             } while (code3 &gt;= 64);
+!           }
+!           mmrAddPixels(codingLine[a0i] + code1, blackPixels,
+! 		       codingLine, &amp;a0i, w);
+!           if (codingLine[a0i] &lt; w) {
+!             mmrAddPixels(codingLine[a0i] + code2, blackPixels ^ 1,
+! 			 codingLine, &amp;a0i, w);
+!           }
+!           while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!             b1i += 2;
+!           }
+!           break;
+  	case twoDimVertR3:
+!           mmrAddPixels(refLine[b1i] + 3, blackPixels, codingLine, &amp;a0i, w);
+!           blackPixels ^= 1;
+!           if (codingLine[a0i] &lt; w) {
+!             ++b1i;
+!             while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!               b1i += 2;
+!             }
+!           }
+!           break;
+! 	case twoDimVertR2:
+!           mmrAddPixels(refLine[b1i] + 2, blackPixels, codingLine, &amp;a0i, w);
+!           blackPixels ^= 1;
+!           if (codingLine[a0i] &lt; w) {
+!             ++b1i;
+!             while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!               b1i += 2;
+!             }
+!           }
+!           break;
+! 	case twoDimVertR1:
+!           mmrAddPixels(refLine[b1i] + 1, blackPixels, codingLine, &amp;a0i, w);
+!           blackPixels ^= 1;
+!           if (codingLine[a0i] &lt; w) {
+!             ++b1i;
+!             while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!               b1i += 2;
+!             }
+!           }
+!           break;
+! 	case twoDimVert0:
+!           mmrAddPixels(refLine[b1i], blackPixels, codingLine, &amp;a0i, w);
+!           blackPixels ^= 1;
+!           if (codingLine[a0i] &lt; w) {
+!             ++b1i;
+!             while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!               b1i += 2;
+!             }
+!           }
+!           break;
+  	case twoDimVertL3:
+!           mmrAddPixelsNeg(refLine[b1i] - 3, blackPixels, codingLine, &amp;a0i, w);
+!           blackPixels ^= 1;
+!           if (codingLine[a0i] &lt; w) {
+!             if (b1i &gt; 0) {
+!               --b1i;
+!             } else {
+!               ++b1i;
+!             }
+!             while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!               b1i += 2;
+!             }
+!           }
+!           break;
+! 	case twoDimVertL2:
+!           mmrAddPixelsNeg(refLine[b1i] - 2, blackPixels, codingLine, &amp;a0i, w);
+!           blackPixels ^= 1;
+!           if (codingLine[a0i] &lt; w) {
+!             if (b1i &gt; 0) {
+!               --b1i;
+!             } else {
+!               ++b1i;
+!             }
+!             while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!               b1i += 2;
+!             }
+!           }
+!           break;
+! 	case twoDimVertL1:
+!           mmrAddPixelsNeg(refLine[b1i] - 1, blackPixels, codingLine, &amp;a0i, w);
+!           blackPixels ^= 1;
+!           if (codingLine[a0i] &lt; w) {
+!             if (b1i &gt; 0) {
+!               --b1i;
+!             } else {
+!               ++b1i;
+!             }
+!             while (refLine[b1i] &lt;= codingLine[a0i] &amp;&amp; refLine[b1i] &lt; w) {
+!               b1i += 2;
+!             }
+!           }
+!           break;
+! 	case EOF:
+!           mmrAddPixels(w, 0, codingLine, &amp;a0i, w);
+!           break;
+  	default:
+  	  error(getPos(), &quot;Illegal code in JBIG2 MMR bitmap data&quot;);
++           mmrAddPixels(w, 0, codingLine, &amp;a0i, w);
+  	  break;
+  	}
+!       }
+  
+        // convert the run lengths to a bitmap line
+        i = 0;
+!       while (1) {
+  	for (x = codingLine[i]; x &lt; codingLine[i+1]; ++x) {
+  	  bitmap-&gt;setPixel(x, y);
+  	}
++ 	if (codingLine[i+1] &gt;= w || codingLine[i+2] &gt;= w) {
++ 	  break;
++ 	}
+  	i += 2;
+        }
+      }
+***************
+*** 2706,2712 ****
+  	  ltp = !ltp;
+  	}
+  	if (ltp) {
+! 	  bitmap-&gt;duplicateRow(y, y-1);
+  	  continue;
+  	}
+        }
+--- 2888,2896 ----
+  	  ltp = !ltp;
+  	}
+  	if (ltp) {
+! 	  if (y &gt; 0) {
+! 	    bitmap-&gt;duplicateRow(y, y-1);
+! 	  }
+  	  continue;
+  	}
+        }
+***************
+*** 2909,2916 ****
+      return;
+    }
+    if (nRefSegs == 1) {
+!     seg = findSegment(refSegs[0]);
+!     if (seg-&gt;getType() != jbig2SegBitmap) {
+        error(getPos(), &quot;Bad bitmap reference in JBIG2 generic refinement segment&quot;);
+        return;
+      }
+--- 3093,3100 ----
+      return;
+    }
+    if (nRefSegs == 1) {
+!     if (!(seg = findSegment(refSegs[0])) ||
+! 	seg-&gt;getType() != jbig2SegBitmap) {
+        error(getPos(), &quot;Bad bitmap reference in JBIG2 generic refinement segment&quot;);
+        return;
+      }
+***************
+*** 3004,3009 ****
+--- 3188,3197 ----
+  	tpgrCX2 = refBitmap-&gt;nextPixel(&amp;tpgrCXPtr2);
+  	tpgrCX2 = (tpgrCX2 &lt;&lt; 1) | refBitmap-&gt;nextPixel(&amp;tpgrCXPtr2);
+  	tpgrCX2 = (tpgrCX2 &lt;&lt; 1) | refBitmap-&gt;nextPixel(&amp;tpgrCXPtr2);
++       } else {
++ 	tpgrCXPtr0.p = tpgrCXPtr1.p = tpgrCXPtr2.p = NULL; // make gcc happy
++ 	tpgrCXPtr0.shift = tpgrCXPtr1.shift = tpgrCXPtr2.shift = 0;
++ 	tpgrCXPtr0.x = tpgrCXPtr1.x = tpgrCXPtr2.x = 0;
+        }
+  
+        for (x = 0; x &lt; w; ++x) {
+***************
+*** 3075,3080 ****
+--- 3263,3272 ----
+  	tpgrCX2 = refBitmap-&gt;nextPixel(&amp;tpgrCXPtr2);
+  	tpgrCX2 = (tpgrCX2 &lt;&lt; 1) | refBitmap-&gt;nextPixel(&amp;tpgrCXPtr2);
+  	tpgrCX2 = (tpgrCX2 &lt;&lt; 1) | refBitmap-&gt;nextPixel(&amp;tpgrCXPtr2);
++       } else {
++ 	tpgrCXPtr0.p = tpgrCXPtr1.p = tpgrCXPtr2.p = NULL; // make gcc happy
++ 	tpgrCXPtr0.shift = tpgrCXPtr1.shift = tpgrCXPtr2.shift = 0;
++ 	tpgrCXPtr0.x = tpgrCXPtr1.x = tpgrCXPtr2.x = 0;
+        }
+  
+        for (x = 0; x &lt; w; ++x) {
+diff -r -c xpdf-3.02.orig/xpdf/JBIG2Stream.h xpdf-3.02/xpdf/JBIG2Stream.h
+*** xpdf-3.02.orig/xpdf/JBIG2Stream.h	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/xpdf/JBIG2Stream.h	Tue Mar 31 10:50:07 2009
+***************
+*** 78,83 ****
+--- 78,87 ----
+  			     Guint *refSegs, Guint nRefSegs);
+    void readGenericRegionSeg(Guint segNum, GBool imm,
+  			    GBool lossless, Guint length);
++   void mmrAddPixels(int a1, int blackPixels,
++ 		    int *codingLine, int *a0i, int w);
++   void mmrAddPixelsNeg(int a1, int blackPixels,
++ 		       int *codingLine, int *a0i, int w);
+    JBIG2Bitmap *readGenericBitmap(GBool mmr, int w, int h,
+  				 int templ, GBool tpgdOn,
+  				 GBool useSkip, JBIG2Bitmap *skip,

Added: trunk/rpms/xpdf/xpdf-3.02pl4.patch
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl4.patch?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf-3.02pl4.patch?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf-3.02pl4.patch (added)
+++ trunk/rpms/xpdf/xpdf-3.02pl4.patch Tue Aug  3 18:07:50 2010
@@ -1,0 +1,282 @@
+*** xpdf-3.02.orig/xpdf/Stream.cc	Fri Jul 24 14:30:46 2009
+--- xpdf-3.02/xpdf/Stream.cc	Mon Oct  5 11:07:49 2009
+***************
+*** 323,328 ****
+--- 323,332 ----
+    } else {
+      imgLineSize = nVals;
+    }
++   if (width &gt; INT_MAX / nComps) {
++     // force a call to gmallocn(-1,...), which will throw an exception
++     imgLineSize = -1;
++   }
+    imgLine = (Guchar *)gmallocn(imgLineSize, sizeof(Guchar));
+    imgIdx = nVals;
+  }
+*** xpdf-3.02.orig/xpdf/PSOutputDev.cc	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/xpdf/PSOutputDev.cc	Fri Oct  2 12:38:58 2009
+***************
+*** 4301,4307 ****
+  	     width, -height, height);
+  
+    // allocate a line buffer
+!   lineBuf = (Guchar *)gmalloc(4 * width);
+  
+    // set up to process the data stream
+    imgStr = new ImageStream(str, width, colorMap-&gt;getNumPixelComps(),
+--- 4301,4307 ----
+  	     width, -height, height);
+  
+    // allocate a line buffer
+!   lineBuf = (Guchar *)gmallocn(width, 4);
+  
+    // set up to process the data stream
+    imgStr = new ImageStream(str, width, colorMap-&gt;getNumPixelComps(),
+diff -r -c xpdf-3.02.orig/splash/Splash.cc xpdf-3.02/splash/Splash.cc
+*** xpdf-3.02.orig/splash/Splash.cc	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/splash/Splash.cc	Fri Aug 14 14:05:08 2009
+***************
+*** 12,17 ****
+--- 12,18 ----
+  
+  #include &lt;stdlib.h&gt;
+  #include &lt;string.h&gt;
++ #include &lt;limits.h&gt;
+  #include &quot;gmem.h&quot;
+  #include &quot;SplashErrorCodes.h&quot;
+  #include &quot;SplashMath.h&quot;
+***************
+*** 1912,1918 ****
+    xq = w % scaledWidth;
+  
+    // allocate pixel buffer
+!   pixBuf = (SplashColorPtr)gmalloc((yp + 1) * w);
+  
+    // initialize the pixel pipe
+    pipeInit(&amp;pipe, 0, 0, state-&gt;fillPattern, NULL, state-&gt;fillAlpha,
+--- 1913,1922 ----
+    xq = w % scaledWidth;
+  
+    // allocate pixel buffer
+!   if (yp &lt; 0 || yp &gt; INT_MAX - 1) {
+!     return splashErrBadArg;
+!   }
+!   pixBuf = (SplashColorPtr)gmallocn(yp + 1, w);
+  
+    // initialize the pixel pipe
+    pipeInit(&amp;pipe, 0, 0, state-&gt;fillPattern, NULL, state-&gt;fillAlpha,
+***************
+*** 2208,2216 ****
+    xq = w % scaledWidth;
+  
+    // allocate pixel buffers
+!   colorBuf = (SplashColorPtr)gmalloc((yp + 1) * w * nComps);
+    if (srcAlpha) {
+!     alphaBuf = (Guchar *)gmalloc((yp + 1) * w);
+    } else {
+      alphaBuf = NULL;
+    }
+--- 2212,2223 ----
+    xq = w % scaledWidth;
+  
+    // allocate pixel buffers
+!   if (yp &lt; 0 || yp &gt; INT_MAX - 1 || w &gt; INT_MAX / nComps) {
+!     return splashErrBadArg;
+!   }
+!   colorBuf = (SplashColorPtr)gmallocn(yp + 1, w * nComps);
+    if (srcAlpha) {
+!     alphaBuf = (Guchar *)gmallocn(yp + 1, w);
+    } else {
+      alphaBuf = NULL;
+    }
+diff -r -c xpdf-3.02.orig/splash/SplashErrorCodes.h xpdf-3.02/splash/SplashErrorCodes.h
+*** xpdf-3.02.orig/splash/SplashErrorCodes.h	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/splash/SplashErrorCodes.h	Fri Aug 14 14:03:46 2009
+***************
+*** 29,32 ****
+--- 29,34 ----
+  
+  #define splashErrSingularMatrix  8	// matrix is singular
+  
++ #define splashErrBadArg          9	// bad argument
++ 
+  #endif
+*** xpdf-3.02.orig/splash/SplashBitmap.cc	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/splash/SplashBitmap.cc	Wed Aug 19 14:55:39 2009
+***************
+*** 11,16 ****
+--- 11,17 ----
+  #endif
+  
+  #include &lt;stdio.h&gt;
++ #include &lt;limits.h&gt;
+  #include &quot;gmem.h&quot;
+  #include &quot;SplashErrorCodes.h&quot;
+  #include &quot;SplashBitmap.h&quot;
+***************
+*** 27,56 ****
+    mode = modeA;
+    switch (mode) {
+    case splashModeMono1:
+!     rowSize = (width + 7) &gt;&gt; 3;
+      break;
+    case splashModeMono8:
+!     rowSize = width;
+      break;
+    case splashModeRGB8:
+    case splashModeBGR8:
+!     rowSize = width * 3;
+      break;
+  #if SPLASH_CMYK
+    case splashModeCMYK8:
+!     rowSize = width * 4;
+      break;
+  #endif
+    }
+!   rowSize += rowPad - 1;
+!   rowSize -= rowSize % rowPad;
+!   data = (SplashColorPtr)gmalloc(rowSize * height);
+    if (!topDown) {
+      data += (height - 1) * rowSize;
+      rowSize = -rowSize;
+    }
+    if (alphaA) {
+!     alpha = (Guchar *)gmalloc(width * height);
+    } else {
+      alpha = NULL;
+    }
+--- 28,75 ----
+    mode = modeA;
+    switch (mode) {
+    case splashModeMono1:
+!     if (width &gt; 0) {
+!       rowSize = (width + 7) &gt;&gt; 3;
+!     } else {
+!       rowSize = -1;
+!     }
+      break;
+    case splashModeMono8:
+!     if (width &gt; 0) {
+!       rowSize = width;
+!     } else {
+!       rowSize = -1;
+!     }
+      break;
+    case splashModeRGB8:
+    case splashModeBGR8:
+!     if (width &gt; 0 &amp;&amp; width &lt;= INT_MAX / 3) {
+!       rowSize = width * 3;
+!     } else {
+!       rowSize = -1;
+!     }
+      break;
+  #if SPLASH_CMYK
+    case splashModeCMYK8:
+!     if (width &gt; 0 &amp;&amp; width &lt;= INT_MAX / 4) {
+!       rowSize = width * 4;
+!     } else {
+!       rowSize = -1;
+!     }
+      break;
+  #endif
+    }
+!   if (rowSize &gt; 0) {
+!     rowSize += rowPad - 1;
+!     rowSize -= rowSize % rowPad;
+!   }
+!   data = (SplashColorPtr)gmallocn(height, rowSize);
+    if (!topDown) {
+      data += (height - 1) * rowSize;
+      rowSize = -rowSize;
+    }
+    if (alphaA) {
+!     alpha = (Guchar *)gmallocn(width, height);
+    } else {
+      alpha = NULL;
+    }
+*** xpdf-3.02.orig/xpdf/XRef.cc	Tue Feb 27 14:05:52 2007
+--- xpdf-3.02/xpdf/XRef.cc	Tue Oct 13 11:57:24 2009
+***************
+*** 52,57 ****
+--- 52,59 ----
+    // generation 0.
+    ObjectStream(XRef *xref, int objStrNumA);
+  
++   GBool isOk() { return ok; }
++ 
+    ~ObjectStream();
+  
+    // Return the object number of this object stream.
+***************
+*** 67,72 ****
+--- 69,75 ----
+    int nObjects;			// number of objects in the stream
+    Object *objs;			// the objects (length = nObjects)
+    int *objNums;			// the object numbers (length = nObjects)
++   GBool ok;
+  };
+  
+  ObjectStream::ObjectStream(XRef *xref, int objStrNumA) {
+***************
+*** 80,85 ****
+--- 83,89 ----
+    nObjects = 0;
+    objs = NULL;
+    objNums = NULL;
++   ok = gFalse;
+  
+    if (!xref-&gt;fetch(objStrNum, 0, &amp;objStr)-&gt;isStream()) {
+      goto err1;
+***************
+*** 105,110 ****
+--- 109,121 ----
+      goto err1;
+    }
+  
++   // this is an arbitrary limit to avoid integer overflow problems
++   // in the 'new Object[nObjects]' call (Acrobat apparently limits
++   // object streams to 100-200 objects)
++   if (nObjects &gt; 1000000) {
++     error(-1, &quot;Too many objects in an object stream&quot;);
++     goto err1;
++   }
+    objs = new Object[nObjects];
+    objNums = (int *)gmallocn(nObjects, sizeof(int));
+    offsets = (int *)gmallocn(nObjects, sizeof(int));
+***************
+*** 161,170 ****
+    }
+  
+    gfree(offsets);
+  
+   err1:
+    objStr.free();
+-   return;
+  }
+  
+  ObjectStream::~ObjectStream() {
+--- 172,181 ----
+    }
+  
+    gfree(offsets);
++   ok = gTrue;
+  
+   err1:
+    objStr.free();
+  }
+  
+  ObjectStream::~ObjectStream() {
+***************
+*** 837,842 ****
+--- 848,858 ----
+  	delete objStr;
+        }
+        objStr = new ObjectStream(this, e-&gt;offset);
++       if (!objStr-&gt;isOk()) {
++ 	delete objStr;
++ 	objStr = NULL;
++ 	goto err;
++       }
+      }
+      objStr-&gt;getObject(e-&gt;gen, num, obj);
+      break;

Added: trunk/rpms/xpdf/xpdf.png
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf.png?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf.png?rev=9030&amp;view=markup</A>
==============================================================================
Binary file - no diff available.

Propchange: trunk/rpms/xpdf/xpdf.png
------------------------------------------------------------------------------
    svn:mime-type = application/octet-stream

Added: trunk/rpms/xpdf/xpdf.spec
URL: <A HREF="http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf.spec?rev=9030&amp;view=markup">http://svn.rpmforge.net/viewvc/rpmforge/trunk/rpms/xpdf/xpdf.spec?rev=9030&amp;view=markup</A>
==============================================================================
--- trunk/rpms/xpdf/xpdf.spec (added)
+++ trunk/rpms/xpdf/xpdf.spec Tue Aug  3 18:07:50 2010
@@ -1,0 +1,271 @@
+# $Id$
+# Authority: dag
+
+### RHEL5 and newer do not include xpdf
+# ExcludeDist: el3 el4
+
+%define desktop_vendor rpmforge
+
+Summary: Portable Document Format (PDF) viewer
+Name: xpdf
+Version: 3.02
+Release: 6
+License: GPLv2
+Group: Applications/Publishing
+URL: <A HREF="http://www.foolabs.com/xpdf/">http://www.foolabs.com/xpdf/</A>
+
+Source0: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version">ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version</A>}.tar.gz
+Source3: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-chinese-simplified-2004-jul-27.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-chinese-simplified-2004-jul-27.tar.gz</A>
+Source4: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-chinese-traditional-2004-jul-27.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-chinese-traditional-2004-jul-27.tar.gz</A>
+Source5: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-japanese-2004-jul-27.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-japanese-2004-jul-27.tar.gz</A>
+Source6: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-korean-2005-jul-07.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-korean-2005-jul-07.tar.gz</A>
+Source7: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-cyrillic-2003-jun-28.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-cyrillic-2003-jun-28.tar.gz</A>
+Source8: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-thai-2002-jan-16.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-thai-2002-jan-16.tar.gz</A>
+Source11: xpdf.png
+Source12: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-arabic-2003-feb-16.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-arabic-2003-feb-16.tar.gz</A>
+Source13: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-greek-2003-jun-28.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-greek-2003-jun-28.tar.gz</A>
+Source14: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-hebrew-2003-feb-16.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-hebrew-2003-feb-16.tar.gz</A>
+Source15: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-latin2-2002-oct-22.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-latin2-2002-oct-22.tar.gz</A>
+Source16: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-turkish-2002-apr-10.tar.gz">ftp://ftp.foolabs.com/pub/xpdf/xpdf-turkish-2002-apr-10.tar.gz</A>
+Patch0: xpdf-3.01-redhat-new.patch
+Patch3: xpdf-2.02-ext.patch
+Patch6: xpdf-3.00-core.patch
+Patch7: xpdf-3.00-xfont.patch
+Patch9: xpdf-3.00-papersize.patch
+Patch10: xpdf-3.00-gcc4.patch
+Patch11: xpdf-3.02-crash.patch
+Patch12: xpdf-3.00-64bit.patch
+Patch15: xpdf-3.01-nocmap.patch
+Patch16: xpdf-3.02-fontlist.patch
+Patch17: xpdf-3.02-x86_64-fix.patch
+Patch18: xpdf-3.02-mousebuttons.patch
+Patch19: xpdf-3.02-additionalzoom.patch
+Patch20: xpdf-3.02-mousebuttons_view.patch
+### Security patches
+Patch100: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version">ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version</A>}pl1.patch
+Patch101: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version">ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version</A>}pl2.patch
+Patch102: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version">ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version</A>}pl3.patch
+Patch103: <A HREF="ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version">ftp://ftp.foolabs.com/pub/xpdf/xpdf-%{version</A>}pl4.patch
+### Debian patches
+Patch200: 02_permissions.dpatch
+Patch201: 10_add_accelerators.dpatch
+# Fix crash with ctrl-W in full screen mode
+Patch202: fix-437725.dpatch
+# Proper stream encoding on 64bit platforms
+Patch203: fix-444648.dpatch
+# Fix segfault in image handling
+Patch204: fix-462544.dpatch
+# Fix crash with &quot;g&quot; in full screen mode
+Patch205: fix-479467.dpatch
+### Remove password protection
+Patch300: xpdf-3.02-ownerpw.patch
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+Provides: xpdf-chinese-simplified = %{version}-%{release}
+Obsoletes: xpdf-chinese-simplified
+Provides: xpdf-chinese-traditional = %{version}-%{release}
+Obsoletes: xpdf-chinese-traditional
+Provides: xpdf-japanese = %{version}-%{release}
+Obsoletes: xpdf-japanese
+Provides: xpdf-korean = %{version}-%{release}
+Obsoletes: xpdf-korean
+
+BuildRequires: desktop-file-utils
+BuildRequires: fileutils
+BuildRequires: freetype-devel &gt;= 2.1.7
+BuildRequires: libpaper-devel
+BuildRequires: libX11-devel
+BuildRequires: openmotif-devel
+BuildRequires: t1lib-devel
+BuildRequires: wxGTK
+Requires: poppler-utils
+Requires: urw-fonts
+Requires: xdg-utils
+Requires: xorg-x11-fonts-ISO8859-1-75dpi
+Requires: xorg-x11-fonts-ISO8859-1-100dpi
+
+%description
+Xpdf is an open source viewer for Portable Document Format (PDF)
+files.  (These are also sometimes also called 'Acrobat' files, from
+the name of Adobe's PDF software.)  The Xpdf project also includes a
+PDF text extractor, PDF-to-PostScript converter, and various other
+utilities.
+
+Xpdf runs under the X Window System on UNIX, VMS, and OS/2.  The non-X
+components (pdftops, pdftotext, etc.) also run on Win32 systems and
+should run on pretty much any system with a decent C++ compiler.
+
+Xpdf is designed to be small and efficient.  It can use Type 1 or
+TrueType fonts.
+
+%prep
+%setup -a 3 -a 4 -a 5 -a 6 -a 7 -a 8 -a 12 -a 13 -a 14 -a 15 -a 16
+%patch0 -p1
+%patch3 -p1 -b .ext
+%patch6 -p1 -b .core
+%patch7 -p1 -b .fonts
+%patch9 -p1 -b .papersize
+%patch10 -p1 -b .gcc4
+%patch11 -p1 -b .crash
+%patch12 -p1 -b .alloc
+%patch15 -p1
+%patch16 -p1 -b .fontlist
+%patch17 -p1
+%patch18 -p1
+%patch19 -p1
+%patch20 -p1
+
+### security patches
+%patch100 -p1 -b .security
+%patch101 -p1 -b .security2
+%patch102 -p1 -b .security3
+%patch103 -p1 -b .security4
+
+### debian patches
+%patch200 -p1 -b .permissions
+%patch201 -p1 -b .accelerators
+%patch202 -p1 -b .fullscreen-crashfix
+%patch203 -p1 -b .64bit-stream
+%patch204 -p1 -b .segfaultfix
+%patch205 -p1 -b .fullscreen-crashfix2
+
+### Additional patches
+%patch300 -p0 -b .owernpw
+
+%{__cat} &lt;&lt;EOF &gt;xpdf.desktop
+[Desktop Entry]
+Encoding=UTF-8
+Categories=Application;Graphics;
+Name=Xpdf PDF Viewer
+Comment=View PDF files
+Exec=xpdf
+Terminal=0
+Type=Application
+Icon=xpdf.png
+MimeType=application/pdf
+EOF
+
+%build
+%configure \
+    --enable-multithreaded \
+    --enable-opi \
+    --enable-wordlist \
+    --with-appdef-dir=&quot;%{_datadir}/X11/app-defaults/&quot; \
+    --with-gzip \
+    --with-freetype2-library=&quot;%{_libdir}&quot; \
+    --with-freetype2-includes=&quot;%{_includedir}/freetype2&quot; \
+    --with-t1-library \
+    --with-x \
+    --without-Xp-library
+%{__make} %{?_smp_mflags}
+%{__make} xpdf %{?_smp_mflags}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/arabic/
+%{__cp} -av xpdf-arabic/* %{buildroot}%{_datadir}/xpdf/arabic/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/chinese-simplified/
+%{__cp} -av xpdf-chinese-simplified/* %{buildroot}%{_datadir}/xpdf/chinese-simplified/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/chinese-traditional/
+%{__cp} -av xpdf-chinese-traditional/* %{buildroot}%{_datadir}/xpdf/chinese-traditional/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/cyrillic/
+%{__cp} -av xpdf-cyrillic/* %{buildroot}%{_datadir}/xpdf/cyrillic/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/greek/
+%{__cp} -av xpdf-greek/* %{buildroot}%{_datadir}/xpdf/greek/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/hebrew/
+%{__cp} -av xpdf-hebrew/* %{buildroot}%{_datadir}/xpdf/hebrew/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/japanese/
+%{__cp} -av xpdf-japanese/* %{buildroot}%{_datadir}/xpdf/japanese/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/korean/
+%{__cp} -av xpdf-korean/* %{buildroot}%{_datadir}/xpdf/korean/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/latin2/
+%{__cp} -av xpdf-latin2/* %{buildroot}%{_datadir}/xpdf/latin2/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/thai/
+%{__cp} -av xpdf-thai/* %{buildroot}%{_datadir}/xpdf/thai/
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/xpdf/turkish/
+%{__cp} -av xpdf-turkish/* %{buildroot}%{_datadir}/xpdf/turkish/
+
+%{__install} -d -m0755 %{buildroot}%{_sysconfdir}/xpdf/
+for lang in arabic chinese-simplified chinese-traditional cyrillic greek hebrew japanese korean latin2 thai turkish; do
+     %{__mv} -v %{buildroot}%{_datadir}/xpdf/$lang/README README.$lang
+     %{__mv} -v %{buildroot}%{_datadir}/xpdf/$lang/add-to-xpdfrc %{buildroot}%{_sysconfdir}/xpdf/add-to-xpdfrc.$lang
+done
+
+### xpdfrc cleanup
+%{__perl} -pi -e 's|/usr/local/share/|%{_datadir}/|g' %{buildroot}%{_sysconfdir}/xpdfrc
+
+### CJK are already in the file
+for lang in arabic cyrillic greek hebrew latin2 thai turkish; do
+    echo -e &quot;# $lang\ninclude %{_sysconfdir}/xpdf/add-to-xpdfrc.$lang&quot; &gt;&gt;%{buildroot}%{_sysconfdir}/xpdfrc
+done
+
+%{__install} -d -m0755 %{buildroot}%{_datadir}/applications/
+desktop-file-install --vendor %{desktop_vendor}       \
+    --dir $RPM_BUILD_ROOT%{_datadir}/applications \
+    xpdf.desktop
+%{__install} -Dp -m0644 %{SOURCE11} %{buildroot}%{_datadir}/icons/hicolor/48x48/apps/xpdf.png
+
+%post
+touch --no-create %{_datadir}/icons/hicolor || :
+%{_bindir}/gtk-update-icon-cache --quiet %{_datadir}/icons/hicolor || :
+update-desktop-database &amp;&gt;/dev/null ||:
+
+%postun
+touch --no-create %{_datadir}/icons/hicolor || :
+%{_bindir}/gtk-update-icon-cache --quiet %{_datadir}/icons/hicolor || :
+update-desktop-database &amp;&gt;/dev/null ||:
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%doc ANNOUNCE CHANGES COPYING INSTALL README*
+%doc %{_mandir}/man1/pdftoppm.1*
+%doc %{_mandir}/man1/xpdf.1*
+%doc %{_mandir}/man5/xpdfrc.5*
+%config(noreplace) %verify(not md5 size mtime) %{_sysconfdir}/xpdfrc
+%config(noreplace) %verify(not md5 size mtime) %{_sysconfdir}/xpdf/
+%{_bindir}/pdftoppm
+%{_bindir}/xpdf
+%{_datadir}/applications/%{desktop_vendor}-xpdf.desktop
+%{_datadir}/icons/hicolor/48x48/apps/xpdf.png
+%{_datadir}/xpdf/
+### These files are provided by poppler
+%exclude %{_bindir}/pdffonts
+%exclude %{_bindir}/pdfimages
+%exclude %{_bindir}/pdfinfo
+#exclude %{_bindir}/pdftoppm
+%exclude %{_bindir}/pdftops
+%exclude %{_bindir}/pdftotext
+%exclude %{_mandir}/man1/pdffonts.1*
+%exclude %{_mandir}/man1/pdfimages.1*
+%exclude %{_mandir}/man1/pdfinfo.1*
+#exclude %{_mandir}/man1/pdftoppm.1*
+%exclude %{_mandir}/man1/pdftops.1*
+%exclude %{_mandir}/man1/pdftotext.1*
+
+%changelog
+* Tue Aug 03 2010 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.02-6
+- Imported package and added patches from fedora.
+
+* Thu Nov 20 2008 Geerd-Dietger Hoffman &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ribalba at gmail.com</A>&gt; - 3.02-5
+- Added 3.02pl2.patch.
+
+* Fri Aug 24 2007 Martin Brisby &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">rpms at mbrisby.org</A>&gt;
+- Added 3.02pl1 patch.
+
+* Sat Jun 16 2007 Martin Brisby &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">rpms at mbrisby.org</A>&gt;
+- Initial specfile.

Propchange: trunk/rpms/xpdf/xpdf.spec
------------------------------------------------------------------------------
    svn:eol-style = native

Propchange: trunk/rpms/xpdf/xpdf.spec
------------------------------------------------------------------------------
    svn:keywords = Id Revision


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007822.html">[svn] r9028 - /trunk/rpms/perl-Mouse/perl-Mouse.spec
</A></li>
	<LI>Next message: <A HREF="007824.html">[svn] r9031 - in /trunk/rpms/detex: ./	detex-2.8-mallocandtroff.patch detex.spec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7823">[ date ]</a>
              <a href="thread.html#7823">[ thread ]</a>
              <a href="subject.html#7823">[ subject ]</a>
              <a href="author.html#7823">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
