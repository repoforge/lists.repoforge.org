<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r7974 - in trunk/tools/dstat: . plugins
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r7974%20-%20in%20trunk/tools/dstat%3A%20.%20plugins&In-Reply-To=%3C200911010025.nA10PdJd000567%40surya.karan.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="006771.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r7974 - in trunk/tools/dstat: . plugins</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r7974%20-%20in%20trunk/tools/dstat%3A%20.%20plugins&In-Reply-To=%3C200911010025.nA10PdJd000567%40surya.karan.org%3E"
       TITLE="[svn] r7974 - in trunk/tools/dstat: . plugins">packagers at lists.rpmforge.net
       </A><BR>
    <I>Sun Nov  1 01:25:39 CET 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="006771.html">[svn] r7975 - in trunk/tools/dstat: . docs plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6770">[ date ]</a>
              <a href="thread.html#6770">[ thread ]</a>
              <a href="subject.html#6770">[ subject ]</a>
              <a href="author.html#6770">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2009-11-01 00:25:38 +0000 (Sun, 01 Nov 2009)
New Revision: 7974

Removed:
   trunk/tools/dstat/dstat15
Modified:
   trunk/tools/dstat/ChangeLog
   trunk/tools/dstat/dstat
   trunk/tools/dstat/dstat.spec
   trunk/tools/dstat/plugins/dstat_battery.py
   trunk/tools/dstat/plugins/dstat_cpufreq.py
   trunk/tools/dstat/plugins/dstat_dbus.py
   trunk/tools/dstat/plugins/dstat_fan.py
   trunk/tools/dstat/plugins/dstat_freespace.py
   trunk/tools/dstat/plugins/dstat_gpfs.py
   trunk/tools/dstat/plugins/dstat_gpfsop.py
   trunk/tools/dstat/plugins/dstat_helloworld.py
   trunk/tools/dstat/plugins/dstat_innodb_buffer.py
   trunk/tools/dstat/plugins/dstat_innodb_io.py
   trunk/tools/dstat/plugins/dstat_innodb_ops.py
   trunk/tools/dstat/plugins/dstat_lustre.py
   trunk/tools/dstat/plugins/dstat_memcache_hits.py
   trunk/tools/dstat/plugins/dstat_mysql5_com.py
   trunk/tools/dstat/plugins/dstat_mysql5_conn.py
   trunk/tools/dstat/plugins/dstat_mysql5_io.py
   trunk/tools/dstat/plugins/dstat_mysql5_keys.py
   trunk/tools/dstat/plugins/dstat_mysql_io.py
   trunk/tools/dstat/plugins/dstat_mysql_keys.py
   trunk/tools/dstat/plugins/dstat_net_packets.py
   trunk/tools/dstat/plugins/dstat_nfs3.py
   trunk/tools/dstat/plugins/dstat_nfs3op.py
   trunk/tools/dstat/plugins/dstat_nfsd3.py
   trunk/tools/dstat/plugins/dstat_nfsd3op.py
   trunk/tools/dstat/plugins/dstat_ntp.py
   trunk/tools/dstat/plugins/dstat_postfix.py
   trunk/tools/dstat/plugins/dstat_power.py
   trunk/tools/dstat/plugins/dstat_rpc.py
   trunk/tools/dstat/plugins/dstat_rpcd.py
   trunk/tools/dstat/plugins/dstat_sendmail.py
   trunk/tools/dstat/plugins/dstat_snooze.py
   trunk/tools/dstat/plugins/dstat_thermal.py
   trunk/tools/dstat/plugins/dstat_topbio.py
   trunk/tools/dstat/plugins/dstat_topcpu.py
   trunk/tools/dstat/plugins/dstat_topio.py
   trunk/tools/dstat/plugins/dstat_topmem.py
   trunk/tools/dstat/plugins/dstat_topoom.py
   trunk/tools/dstat/plugins/dstat_utmp.py
   trunk/tools/dstat/plugins/dstat_vmkhba.py
   trunk/tools/dstat/plugins/dstat_vmkint.py
   trunk/tools/dstat/plugins/dstat_vmknic.py
   trunk/tools/dstat/plugins/dstat_vmmemctl.py
   trunk/tools/dstat/plugins/dstat_vzcpu.py
   trunk/tools/dstat/plugins/dstat_vzubc.py
   trunk/tools/dstat/plugins/dstat_wifi.py
Log:
Preparing for 0.7.0 release !
- Various changes to simplify plugin interface and performance improvements
- This release was sponsored by the Linux Foundation during the Japan Linux Symposium


Modified: trunk/tools/dstat/ChangeLog
===================================================================
--- trunk/tools/dstat/ChangeLog	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/ChangeLog	2009-11-01 00:25:38 UTC (rev 7974)
@@ -1,4 +1,4 @@
-* 0.6.9svn - Tokyo - release 22/10/2009
+* 0.7.0 - Tokyo - release 31/10/2009
 - Fixed dstat_disk plugin for total calculation on 2.6.25+ kernels (Noel J. Bergman)
 - Precompile regular expressions used as a disk filter (self.diskfilter)
 - Raise a warning when discovery returns empty
@@ -10,13 +10,15 @@
 - Filtering out more interfaces (eg. bonding) in total values (Bert de Bruijn)
 - Provide error output when now power information is available (AC power)
 - Make topcpu plugin SMP aware (values are not percent per CPU)
-- Drop support for Python 1.5
+- Drop support for Python 1.5 (and removed dstat15 version)
 - Introduced splitlines() function that allows a replace/split on readlines()
 - Added external dstat_fan plugin to show fan speed
 - Added theming support (not exposed to users yet)
 - Added --bw/--blackonwhite option to use dark colors on white background
 - Allow any plugin to be added by long options (ie. --topbio)
 - Added external dstat_memcache_hits plugin to show memcache hits and misses (Dean Wilson)
+- Various changes to simplify plugin interface and performance improvements
+- This release was 'sponsored' by the Linux Foundation during the Japan Linux Symposium
 
 * 0.6.9 - Locarno - release 02/12/2008
 - Input text color is now gray (again)

Modified: trunk/tools/dstat/dstat
===================================================================
--- trunk/tools/dstat/dstat	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/dstat	2009-11-01 00:25:38 UTC (rev 7974)
@@ -16,7 +16,7 @@
 
 from __future__ import generators
 
-VERSION = '0.6.9svn'
+VERSION = '0.7.0'
 
 theme = { 'default': '' }
 
@@ -308,21 +308,38 @@
     name = None
     nick = None
     type = 'f'
-    width = 4
-    scale = 1000
+    width = 5
+    scale = 1024
+    cols = 0
+#    val = {}
+#    set1 = {}
+#    set2 = {}
 
-    ### Initialise default variables
-    def init(self, vars=(), len=0):
-        if vars:
-            self.val = {}; self.cn1 = {}; self.cn2 = {}
-            for name in vars:
-                if len &lt;= 1:
-                    self.val[name] = self.cn1[name] = self.cn2[name] = 0
-                else:
-                    self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
-                    for i in range(len):
-                        self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
+    def prepare(self):
+        if callable(self.discover):
+            self.discover = self.discover()
+        if callable(self.vars):
+            self.vars = self.vars()
+        if not self.vars:
+            raise Exception, 'No counter objects to monitor'
+        if callable(self.name):
+            self.name = self.name()
+        if callable(self.nick):
+            self.nick = self.nick()
+        if not self.nick:
+            self.nick = self.vars
 
+        self.val = {}; self.set1 = {}; self.set2 = {}
+        if self.cols &lt;= 0:
+            for name in self.vars:
+                self.val[name] = self.set1[name] = self.set2[name] = 0
+        else:
+            for name in self.vars + [ 'total', ]:
+                self.val[name] = self.set1[name] = self.set2[name] = range(self.cols)
+                for i in range(self.cols):
+                    self.val[name][i] = self.set1[name][i] = self.set2[name][i] = 0
+#        print self.val
+
     def open(self, *filenames):
         &quot;Open stat file descriptor&quot;
         self.file = []
@@ -333,7 +350,7 @@
                 self.file.append(filename)
                 self.fd.append(fd)
         if not self.fd:
-            raise Exception, 'Cannot open file %s.' % filename
+            raise Exception, 'Cannot open file %s' % filename
 
     def readlines(self):
         &quot;Return lines from any file descriptor&quot;
@@ -390,13 +407,13 @@
         ret = ''
         if isinstance(self.name, types.StringType):
             for i, nick in enumerate(self.nick):
-                ret = ret + theme['subtitle'] + nick.center(self.width) + theme['default']
+                ret = ret + theme['subtitle'] + nick[0:self.width].center(self.width) + theme['default']
                 if i + 1 != len(self.nick): ret = ret + char['space']
             return ret
         else:
             for i, name in enumerate(self.name):
                 for j, nick in enumerate(self.nick):
-                    ret = ret + theme['subtitle'] + nick.center(self.width) + theme['default']
+                    ret = ret + theme['subtitle'] + nick[0:self.width].center(self.width) + theme['default']
                     if j + 1 != len(self.nick): ret = ret + char['space']
                 if i + 1 != len(self.name): ret = ret + theme['frame'] + char['colon']
             return ret
@@ -504,7 +521,6 @@
         self.open('/proc/sys/fs/aio-nr')
         self.nick = ('#aio',)
         self.vars = ('aio',)
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
@@ -518,10 +534,7 @@
         self.scale = 34
         self.open('/proc/stat')
         self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = self.name()
-        self.init(self.vars + ['total',], 6)
+        self.cols = 6
 
     def discover(self, *objlist):
         ret = []
@@ -532,15 +545,6 @@
         for item in objlist: ret.append(item)
         return ret
 
-    def name(self):
-        ret = []
-        for name in self.vars:
-            if name == 'total':
-                ret.append('total cpu usage')
-            else:
-                ret.append('cpu' + name + ' usage')
-        return ret
-
     def vars(self):
         ret = []
         if op.cpulist:
@@ -559,21 +563,30 @@
                 ret.append(name)
         return ret
 
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name == 'total':
+                ret.append('total cpu usage')
+            else:
+                ret.append('cpu' + name + ' usage')
+        return ret
+
     def extract(self):
         for l in self.splitlines():
             if len(l) &lt; 8: continue
             for name in self.vars:
                 if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
+                    self.set2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
         for name in self.vars:
             for i in range(6):
-                if sum(self.cn2[name]) &gt; sum(self.cn1[name]):
-                    self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+                if sum(self.set2[name]) &gt; sum(self.set1[name]):
+                    self.val[name][i] = 100.0 * (self.set2[name][i] - self.set1[name][i]) / (sum(self.set2[name]) - sum(self.set1[name]))
                 else:
                     self.val[name][i] = 0
 #                    print &gt;&gt;sys.stderr, &quot;Error: tick problem detected, this should never happen !&quot;
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_cpu24(dstat):
     def __init__(self):
@@ -582,20 +595,8 @@
         self.scale = 34
         self.open('/proc/stat')
         self.nick = ( 'usr', 'sys', 'idl')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = self.name()
-        self.init(self.vars + ['total',], 3)
+        self.cols = 3
 
-    def name(self):
-        ret = []
-        for name in self.vars:
-            if name:
-                ret.append('cpu' + name)
-            else:
-                ret.append('cpu total')
-        return ret
-
     def discover(self, *objlist):
         ret = []
         for l in self.splitlines():
@@ -623,29 +624,32 @@
                 ret.append(name)
         return ret
 
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name:
+                ret.append('cpu' + name)
+            else:
+                ret.append('cpu total')
+        return ret
+
     def extract(self):
         for l in self.splitlines():
             for name in self.vars:
                 if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
+                    self.set2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
         for name in self.vars:
             for i in range(3):
-                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+                self.val[name][i] = 100.0 * (self.set2[name][i] - self.set1[name][i]) / (sum(self.set2[name]) - sum(self.set1[name]))
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_disk(dstat):
     def __init__(self):
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.diskfilter = re.compile('^(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)$')
         self.open('/proc/diskstats')
         self.nick = ('read', 'writ')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = ['dsk/'+name for name in self.vars]
-        self.init(self.vars + ['total',], 2)
+        self.cols = 2
 
     def discover(self, *objlist):
         ret = []
@@ -679,44 +683,41 @@
                 ret.append(name)
         return ret
 
+    def name(self):
+        return ['dsk/'+name for name in self.vars]
+
     def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
+        for name in self.vars: self.set2[name] = (0, 0)
         for l in self.splitlines():
             if len(l) &lt; 13: continue
             if l[5] == '0' and l[9] == '0': continue
             name = l[2]
             if l[3:] == ['0',] * 11: continue
             if not self.diskfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
+                self.set2['total'] = ( self.set2['total'][0] + long(l[5]), self.set2['total'][1] + long(l[9]) )
             if name in self.vars and name != 'total':
-                self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
+                self.set2[name] = ( self.set2[name][0] + long(l[5]), self.set2[name][1] + long(l[9]) )
             for diskset in self.vars:
                 if diskset in op.diskset.keys():
                     for disk in op.diskset[diskset]:
                         if re.match('^'+disk+'$', name):
-                            self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[5]), self.cn2[diskset][1] + long(l[9]) )
-        for name in self.cn2.keys():
+                            self.set2[diskset] = ( self.set2[diskset][0] + long(l[5]), self.set2[diskset][1] + long(l[9]) )
+        for name in self.set2.keys():
             self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+                (self.set2[name][0] - self.set1[name][0]) * 512.0 / tick,
+                (self.set2[name][1] - self.set1[name][1]) * 512.0 / tick,
             )
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_disk24(dstat):
     def __init__(self):
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.diskfilter = re.compile('(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)')
         self.open('/proc/partitions')
         self.nick = ('read', 'writ')
-        self.discover = self.discover()
-        self.vars = self.vars()
         if self.fd and not self.discover:
             raise Exception, 'Kernel is not compiled with CONFIG_BLK_STATS'
-        self.name = ['dsk/'+sysfs_dev(name) for name in self.vars]
-        self.init(self.vars + ['total',], 2)
+        self.cols = 2
 
     def discover(self, *objlist):
         ret = []
@@ -747,42 +748,39 @@
                 ret.append(name)
         return ret
 
+    def name(self):
+        return ['dsk/'+sysfs_dev(name) for name in self.vars]
+
     def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
+        for name in self.vars: self.set2[name] = (0, 0)
         for l in self.splitlines():
             if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
             name = l[3]
             if not self.diskfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]) )
+                self.set2['total'] = ( self.set2['total'][0] + long(l[6]), self.set2['total'][1] + long(l[10]) )
             if name in self.vars:
-                self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
+                self.set2[name] = ( self.set2[name][0] + long(l[6]), self.set2[name][1] + long(l[10]) )
             for diskset in self.vars:
                 if diskset in op.diskset.keys():
                     for disk in op.diskset[diskset]:
                         if re.match('^'+disk+'$', name):
-                            self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[6]), self.cn2[diskset][1] + long(l[10]) )
-        for name in self.cn2.keys():
+                            self.set2[diskset] = ( self.set2[diskset][0] + long(l[6]), self.set2[diskset][1] + long(l[10]) )
+        for name in self.set2.keys():
             self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+                (self.set2[name][0] - self.set1[name][0]) * 512.0 / tick,
+                (self.set2[name][1] - self.set1[name][1]) * 512.0 / tick,
             )
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 ### FIXME: Needs rework, does anyone care ?
 class dstat_disk24old(dstat):
     def __init__(self):
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.diskfilter = re.compile('(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)')
         self.open('/proc/stat')
         self.nick = ('read', 'writ')
         self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = ['dsk/'+name for name in self.vars]
-        self.init(self.vars + ['total',], 2)
+        self.cols = 2
 
     def discover(self, *objlist):
         ret = []
@@ -821,8 +819,11 @@
                 ret.append(name)
         return ret
 
+    def name(self):
+        return ['dsk/'+name for name in self.vars]
+
     def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
+        for name in self.vars: self.set2[name] = (0, 0)
         for line in self.splitlines(':'):
             if len(l) &lt; 3: continue
             name = l[0]
@@ -834,45 +835,40 @@
                 if len(l) &lt; 4: continue
                 name = dev(int(l[0]), int(l[1]))
                 if not self.diskfilter.match(name):
-                    self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
+                    self.set2['total'] = ( self.set2['total'][0] + long(l[2]), self.set2['total'][1] + long(l[3]) )
                 if name in self.vars and name != 'total':
-                    self.cn2[name] = ( self.cn2[name][0] + long(l[2]), self.cn2[name][1] + long(l[3]) )
+                    self.set2[name] = ( self.set2[name][0] + long(l[2]), self.set2[name][1] + long(l[3]) )
                 for diskset in self.vars:
                     if diskset in op.diskset.keys():
                         for disk in op.diskset[diskset]:
                             if re.match('^'+disk+'$', name):
-                                self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[2]), self.cn2[diskset][1] + long(l[3]) )
+                                self.set2[diskset] = ( self.set2[diskset][0] + long(l[2]), self.set2[diskset][1] + long(l[3]) )
             break
-        for name in self.cn2.keys():
+        for name in self.set2.keys():
             self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+                (self.set2[name][0] - self.set1[name][0]) * 512.0 / tick,
+                (self.set2[name][1] - self.set1[name][1]) * 512.0 / tick,
             )
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_epoch(dstat):
     def __init__(self):
         self.name = 'epoch'
-        self.type = 't'
+        self.type = 's'
         self.width = 10
         self.scale = 0
         if op.debug:
-            self.type = 't'
-        self.width = 14
+            self.width = 13
         self.scale = 0
         self.nick = ('epoch',)
         self.vars = self.nick
-        self.init(self.vars, 1)
 
     ### We are now using the starttime instead of the execution time of this plugin
     def extract(self):
 #        self.val['epoch'] = time.time()
         self.val['epoch'] = starttime
 
-#   def show(self):
-#       return ansi['reset'] + ( '%10.2f' % self.val['epoch'] )
-
 class dstat_fs(dstat):
     def __init__(self):
         self.name = 'filesystem'
@@ -881,7 +877,6 @@
         self.scale = 1000
         self.nick = ('files', 'inodes')
         self.vars = self.nick
-        self.init(self.vars, 1)
 
     def extract(self):
         for line in dopen('/proc/sys/fs/file-nr'):
@@ -900,11 +895,7 @@
         self.width = 5
         self.scale = 1000
         self.open('/proc/stat')
-        self.discover = self.discover()
         self.intmap = self.intmap()
-        self.vars = self.vars()
-        self.nick = self.vars
-        self.init(self.vars + ['total',], 1)
 
     def intmap(self):
         ret = {}
@@ -956,12 +947,12 @@
             if not l or l[0] != 'intr': continue
             for name in self.vars:
                 if name != 'total':
-                    self.cn2[name] = long(l[int(name) + 2])
-            self.cn2['total'] = long(l[1])
+                    self.set2[name] = long(l[int(name) + 2])
+            self.set2['total'] = long(l[1])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_int24(dstat):
     def __init__(self):
@@ -970,10 +961,6 @@
         self.width = 5
         self.scale = 1000
         self.open('/proc/interrupts')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.nick = self.vars
-        self.init(self.vars, 1)
 
     def intmap(self):
         ret = {}
@@ -1025,17 +1012,17 @@
             if len(l) &lt; cpunr+1: continue
             name = l[0].split(':')[0]
             if name in self.vars:
-                self.cn2[name] = 0
+                self.set2[name] = 0
                 for i in l[1:1+cpunr]:
-                    self.cn2[name] = self.cn2[name] + long(i)
+                    self.set2[name] = self.set2[name] + long(i)
 #           elif len(l) &gt; 2 + cpunr:
 #               for hw in self.vars:
 #                   for mod in l[2+cpunr:]:
-#                       self.cn2[mod] = long(l[1])
-        for name in self.cn2.keys():
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+#                       self.set2[mod] = long(l[1])
+        for name in self.set2.keys():
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_io(dstat):
     def __init__(self):
@@ -1045,10 +1032,7 @@
         self.diskfilter = re.compile('(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)')
         self.open('/proc/diskstats')
         self.nick = ('read', 'writ')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = ['io/'+name for name in self.vars]
-        self.init(self.vars + ['total',], 3)
+        self.cols = 3
 
     def discover(self, *objlist):
         ret = []
@@ -1082,29 +1066,32 @@
                 ret.append(name)
         return ret
 
+    def name(self):
+        return ['io/'+name for name in self.vars]
+
     def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
+        for name in self.vars: self.set2[name] = (0, 0)
         for l in self.splitlines():
             if len(l) &lt; 13: continue
             if l[3] == '0' and l[7] == '0': continue
             name = l[2]
             if l[3:] == ['0',] * 11: continue
             if not self.diskfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[3]), self.cn2['total'][1] + long(l[7]) )
+                self.set2['total'] = ( self.set2['total'][0] + long(l[3]), self.set2['total'][1] + long(l[7]) )
             if name in self.vars and name != 'total':
-                self.cn2[name] = ( self.cn2[name][0] + long(l[3]), self.cn2[name][1] + long(l[7]) )
+                self.set2[name] = ( self.set2[name][0] + long(l[3]), self.set2[name][1] + long(l[7]) )
             for diskset in self.vars:
                 if diskset in op.diskset.keys():
                     for disk in op.diskset[diskset]:
                         if re.match('^'+disk+'$', name):
-                            self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[3]), self.cn2[diskset][1] + long(l[7]) )
-        for name in self.cn2.keys():
+                            self.set2[diskset] = ( self.set2[diskset][0] + long(l[3]), self.set2[diskset][1] + long(l[7]) )
+        for name in self.set2.keys():
             self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
+                (self.set2[name][0] - self.set1[name][0]) * 1.0 / tick,
+                (self.set2[name][1] - self.set1[name][1]) * 1.0 / tick,
             )
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_ipc(dstat):
     def __init__(self):
@@ -1114,7 +1101,6 @@
         self.scale = 10
         self.vars = ('msg', 'sem', 'shm')
         self.nick = self.vars
-        self.init(self.vars, 1)
 
     def extract(self):
         for name in self.vars:
@@ -1129,7 +1115,6 @@
         self.open('/proc/loadavg')
         self.nick = ('1m', '5m', '15m')
         self.vars = ('load1', 'load5', 'load15')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
@@ -1147,7 +1132,6 @@
         self.open('/proc/locks')
         self.nick = ('pos', 'lck', 'rea', 'wri')
         self.vars = ('posix', 'flock', 'read', 'write')
-        self.init(self.vars, 1)
 
     def extract(self):
         for name in self.vars: self.val[name] = 0
@@ -1165,13 +1149,9 @@
 class dstat_mem(dstat):
     def __init__(self):
         self.name = 'memory usage'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.open('/proc/meminfo')
         self.nick = ('used', 'buff', 'cach', 'free')
         self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
@@ -1183,16 +1163,10 @@
 
 class dstat_net(dstat):
     def __init__(self):
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.open('/proc/net/dev')
         self.nick = ('recv', 'send')
         self.totalfilter = re.compile('^(lo|bond[0-9]+|face|.+\.[0-9]+)$')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = ['net/'+name for name in self.vars]
-        self.init(self.vars + ['total',], 2)
+        self.cols = 2
 
     def discover(self, *objlist):
         ret = []
@@ -1223,70 +1197,65 @@
             raise Exception, &quot;No suitable network interfaces found to monitor&quot;
         return ret
 
+    def name(self):
+        return ['net/'+name for name in self.vars]
+
     def extract(self):
-        self.cn2['total'] = [0, 0]
+        self.set2['total'] = [0, 0]
         for l in self.splitlines(replace=':'):
             if len(l) &lt; 17: continue
             if l[2] == '0' and l[10] == '0': continue
             name = l[0]
             if name in self.vars :
-                self.cn2[name] = ( long(l[1]), long(l[9]) )
+                self.set2[name] = ( long(l[1]), long(l[9]) )
             if not self.totalfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[9]))
+                self.set2['total'] = ( self.set2['total'][0] + long(l[1]), self.set2['total'][1] + long(l[9]))
         if update:
-            for name in self.cn2.keys():
+            for name in self.set2.keys():
                 self.val[name] = (
-                    (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-                    (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
+                    (self.set2[name][0] - self.set1[name][0]) * 1.0 / tick,
+                    (self.set2[name][1] - self.set1[name][1]) * 1.0 / tick,
                  )
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_page(dstat):
     def __init__(self):
         self.name = 'paging'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.open('/proc/vmstat')
         self.nick = ('in', 'out')
         self.vars = ('pswpin', 'pswpout')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
             if len(l) &lt; 2: continue
             name = l[0]
             if name in self.vars:
-                self.cn2[name] = long(l[1])
+                self.set2[name] = long(l[1])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * pagesize * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_page24(dstat):
     def __init__(self):
         self.name = 'paging'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.open('/proc/stat')
         self.nick = ('in', 'out')
         self.vars = ('pswpin', 'pswpout')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
             if len(l) &lt; 3: continue
             name = l[0]
             if name != 'swap': continue
-            self.cn2['pswpin'] = long(l[1])
-            self.cn2['pswpout'] = long(l[2])
+            self.set2['pswpin'] = long(l[1])
+            self.set2['pswpout'] = long(l[2])
             break
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * pagesize * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_proc(dstat):
     def __init__(self):
@@ -1297,7 +1266,6 @@
         self.open('/proc/stat')
         self.nick = ('run', 'blk', 'new')
         self.vars = ('procs_running', 'procs_blocked', 'processes')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
@@ -1305,18 +1273,18 @@
             name = l[0]
             if name == 'processes':
                 self.val['processes'] = 0
-                self.cn2[name] = long(l[1])
+                self.set2[name] = long(l[1])
             elif name == 'procs_running':
-                self.cn2[name] = self.cn2[name] + long(l[1]) - 1
+                self.set2[name] = self.set2[name] + long(l[1]) - 1
             elif name == 'procs_blocked':
-                self.cn2[name] = self.cn2[name] + long(l[1])
-        self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
+                self.set2[name] = self.set2[name] + long(l[1])
+        self.val['processes'] = (self.set2['processes'] - self.set1['processes']) * 1.0 / tick
         for name in ('procs_running', 'procs_blocked'):
-            self.val[name] = self.cn2[name] * 1.0 / tick
+            self.val[name] = self.set2[name] * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
             for name in ('procs_running', 'procs_blocked'):
-                self.cn2[name] = 0
+                self.set2[name] = 0
 
 class dstat_raw(dstat):
     def __init__(self):
@@ -1327,7 +1295,6 @@
         self.open('/proc/net/raw')
         self.nick = ('raw',)
         self.vars = ('sockets',)
-        self.init(self.vars, 1)
 
     def extract(self):
         lines = -1
@@ -1346,7 +1313,6 @@
         self.open('/proc/net/sockstat')
         self.nick = ('tot', 'tcp', 'udp', 'raw', 'frg')
         self.vars = ('sockets:', 'TCP:', 'UDP:', 'RAW:', 'FRAG:')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
@@ -1357,15 +1323,9 @@
 class dstat_swap(dstat):
     def __init__(self):
         self.name = 'swap'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.open('/proc/swaps')
         self.nick = ('used', 'free')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = ['swp/'+improve(name) for name in self.vars]
-        self.init(self.vars + ['total',], 2)
+        self.cols = 2
 
     def discover(self, *objlist):
         ret = []
@@ -1400,6 +1360,9 @@
             raise Exception, &quot;No suitable swap devices found to monitor&quot;
         return ret
 
+    def name(self):
+        return ['swp/'+improve(name) for name in self.vars]
+
     def extract(self):
         self.val['total'] = [0, 0]
         for l in self.splitlines():
@@ -1411,13 +1374,9 @@
 class dstat_swapold(dstat):
     def __init__(self):
         self.name = 'swap'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.open('/proc/meminfo')
         self.nick = ('used', 'free')
         self.vars = ('SwapUsed', 'SwapFree')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
@@ -1436,18 +1395,17 @@
         self.open('/proc/stat')
         self.nick = ('int', 'csw')
         self.vars = ('intr', 'ctxt')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
             if len(l) &lt; 2: continue
             name = l[0]
             if name in self.vars:
-                self.cn2[name] = long(l[1])
+                self.set2[name] = long(l[1])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 class dstat_tcp(dstat):
     def __init__(self):
@@ -1458,7 +1416,6 @@
         self.open('/proc/net/tcp', '/proc/net/tcp6')
         self.nick = ('lis', 'act', 'syn', 'tim', 'clo')
         self.vars = ('listen', 'established', 'syn', 'wait', 'close')
-        self.init(self.vars, 1)
 
     def extract(self):
         for name in self.vars: self.val[name] = 0
@@ -1486,7 +1443,6 @@
         self.scale = 0
         self.nick = ('date/time',)
         self.vars = ('time',)
-        self.init(self.vars, 1)
 
     ### We are now using the starttime for this plugin, not the execution time of this plugin
     def extract(self):
@@ -1495,13 +1451,6 @@
         else:
             self.val['time'] = time.strftime(self.timefmt, time.localtime(starttime))
 
-    def show(self):
-        if step == op.delay:
-            color = 'text_lo'
-        else:
-            color = 'text_hi'
-        return theme[color] + self.val['time']
-
 class dstat_udp(dstat):
     def __init__(self):
         self.name = 'udp'
@@ -1511,7 +1460,6 @@
         self.open('/proc/net/udp', '/proc/net/udp6')
         self.nick = ('lis', 'act')
         self.vars = ('listen', 'established')
-        self.init(self.vars, 1)
 
     def extract(self):
         for name in self.vars: self.val[name] = 0
@@ -1528,7 +1476,6 @@
         self.open('/proc/net/unix')
         self.nick = ('dgm', 'str', 'lis', 'act')
         self.vars = ('datagram', 'stream', 'listen', 'established')
-        self.init(self.vars, 1)
 
     def extract(self):
         for name in self.vars: self.val[name] = 0
@@ -1551,17 +1498,16 @@
         self.open('/proc/vmstat')
         self.nick = ('majpf', 'minpf', 'alloc', 'free')
         self.vars = ('pgmajfault', 'pgfault', 'pgalloc_normal', 'pgfree')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
             if len(l) &lt; 2: continue
             if l[0] not in self.vars: continue
-            self.cn2[l[0]] = long(l[1])
+            self.set2[l[0]] = long(l[1])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 ### END STATS DEFINITIONS ###
 
@@ -1799,26 +1745,23 @@
 
 def cprint(var, type = 'f', width = 4, scale = 1000):
     &quot;Color print one column&quot;
-    vartype = type
-    maxlen = width
-    mp = scale
 
     base = 1000
-    if mp == 1024:
+    if scale == 1024:
         base = 1024
 
     ### Use units when base is exact 1000 or 1024
     unit = False
-    if mp in (1000, 1024) and maxlen &gt;= len(str(base)):
+    if scale in (1000, 1024) and width &gt;= len(str(base)):
         unit = True
-        maxlen = maxlen - 1
+        width = width - 1
 
     ### If this is a negative value, return a dash
     if var &lt; 0:
         if unit:
-            return theme['error'] + '-'.rjust(maxlen) + ' ' + theme['default']
+            return theme['error'] + '-'.rjust(width) + ' ' + theme['default']
         else:
-            return theme['error'] + '-'.rjust(maxlen) + theme['default']
+            return theme['error'] + '-'.rjust(width) + theme['default']
 
     if base == 1024:
         units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
@@ -1827,43 +1770,40 @@
 
     if step == op.delay:
         colors = theme['colors_lo']
+        text = theme['text_lo']
     else:
         colors = theme['colors_hi']
+        text = theme['text_hi']
 
     ### Convert value to string given base and field-length
-    if op.integer and vartype in ('d', 'p', 'f'):
-        ret, c = dchg(var, maxlen, base)
-    elif vartype in ('d', 'p'):
-        ret, c = dchg(var, maxlen, base)
-    elif vartype in ('f'):
-        ret, c = fchg(var, maxlen, base)
-    elif vartype in ('t'):
-        ret, c = fchg(var, maxlen+1, base)
+    if op.integer and type in ('d', 'p', 'f'):
+        ret, c = dchg(var, width, base)
+    elif type in ('d', 'p'):
+        ret, c = dchg(var, width, base)
+    elif type in ('f'):
+        ret, c = fchg(var, width, base)
+    elif type in ('s'):
+        ret, c = str(var), text
+    elif type in ('t'):
+        ret, c = '%2dh%02d' % (var / 60, var % 60), text
     else:
-        ret, c = str(var), -1
+        raise Exception, 'Type %s not known to dstat.' % type
 
-    if step == op.delay:
-        colors = theme['colors_lo']
-        text = theme['text_lo']
-    else:
-        colors = theme['colors_hi']
-        text = theme['text_hi']
-
     ### Set the counter color
     if ret == '0':
         color = text
-    elif vartype in ('d', 'p'):
-        color = colors[int(round(var)/mp)%len(colors)]
-    elif vartype in ('f'):
+    elif type in ('d', 'p'):
+        color = colors[int(round(var)/scale)%len(colors)]
+    elif type in ('f'):
         color = colors[c%len(colors)]
     else:
         color = text
 
     ### Justify value to left if string
-    if vartype in ('s',):
-        ret = color + ret.ljust(maxlen)
+    if type in ('s',):
+        ret = color + ret.ljust(width)
     else:
-        ret = color + ret.rjust(maxlen)
+        ret = color + ret.rjust(width)
 
     ### Add unit to output
     if unit:
@@ -2204,12 +2144,12 @@
                     ### Try loading python plugin
                     if description[0] in ('.py'):
                             execfile(pathname)
-                            exec 'o = dstat_%s()' % mod
+                            exec 'o = dstat_%s(); o.check(); o.prepare();' % mod
 
                     ### Try loading C plugin
                     elif description[0] == '.so':
                         exec 'import dstat_%s' % mod
-                        exec 'o = dstat_%s.new()' % mod
+                        exec 'o = dstat_%s.new(); o.check(); o.prepare();' % mod
 #                        exec 'o = dstat_%s.init(dstat)' % mod
 #                        print dir(o)
 #                        print o.__module__
@@ -2217,11 +2157,8 @@
                     else:
                         print &gt;&gt;sys.stderr, 'Module %s is of unknown type.' % mod
 
-                    ### Remove defect stat objects and calculate line length
-                    if not o.check():
-                        raise Exception, 'Unknown problem, please report'
                 else:
-                    exec 'o = dstat_%s()' % mod
+                    exec 'o = dstat_%s(); o.check(); o.prepare();' % mod
 #                print o.__module__
             except Exception, e:
                 if mod == mods[-1]:
@@ -2386,7 +2323,6 @@
         if not op.update:
             sys.stdout.write('\n')
 
-
 ### Main entrance
 if __name__ == '__main__':
     try:

Modified: trunk/tools/dstat/dstat.spec
===================================================================
--- trunk/tools/dstat/dstat.spec	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/dstat.spec	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,7 +9,7 @@
 
 Summary: Versatile resource statistics tool
 Name: dstat
-Version: 0.6.9svn
+Version: 0.7.0
 Release: 1
 License: GPL
 Group: System Environment/Base

Deleted: trunk/tools/dstat/dstat15
===================================================================
--- trunk/tools/dstat/dstat15	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/dstat15	2009-11-01 00:25:38 UTC (rev 7974)
@@ -1,2283 +0,0 @@
-#!/usr/bin/env python
-
-### This program is free software; you can redistribute it and/or modify
-### it under the terms of the GNU Library General Public License as published by
-### the Free Software Foundation; version 2 only
-###
-### This program is distributed in the hope that it will be useful,
-### but WITHOUT ANY WARRANTY; without even the implied warranty of
-### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-### GNU Library General Public License for more details.
-###
-### You should have received a copy of the GNU Library General Public License
-### along with this program; if not, write to the Free Software
-### Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-### Copyright 2004-2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;
-
-#from __future__ import generators
-
-VERSION = '0.6.9svn'
-
-def inspath(path):
-    if os.path.isdir(path) and path not in sys.path:
-        sys.path.insert(1, path)
-
-try:
-    import sys, os, time, sched, re, string
-    import types, resource, getpass, glob
-    inspath('/usr/local/share/dstat/')
-    inspath('/usr/share/dstat/')
-    inspath(os.path.abspath(os.path.dirname(sys.argv[0])) + '/plugins/')    # binary path + /plugins/
-    inspath(os.getcwd() + '/plugins/')                                      # current path + /plugins/
-    inspath(os.getcwd())                                                    # current path
-    inspath(os.path.expanduser('~/.dstat/'))                                # home + /.dstat/
-except KeyboardInterrupt, e:
-    pass
-
-#if sys.version_info &lt; (1, 5):
-#   sys.exit('error: Python 1.5 or later required')
-
-### Workaround for python &lt;= 2.2.1
-try:
-    True, False
-except NameError:
-    True = 1
-    False = 0
-
-### Workaround for python &lt; 2.3 (FIXME: check for sys.version_info existence)
-if True:
-    def enumerate(sequence):
-        index = 0
-        list = []
-        for item in sequence:
-            list.append((index, item))
-            index = index + 1
-        return list
-
-### Workaround for python &lt; 2.3
-if True:
-    def sum(sequence):
-        ret = 0
-        for i in sequence:
-            ret = ret + i
-        return ret
-
-class Options:
-    def __init__(self, args):
-        self.args = args
-        self.count = -1
-        self.cpulist = None
-        self.debug = 0
-        self.delay = 1
-        self.disklist = None
-        self.full = False
-        self.integer = False
-        self.intlist = None
-        self.netlist = None
-        self.swaplist = None
-        self.color = True
-        self.update = True
-        self.header = True
-        self.output = False
-        self.pidfile = False
-
-        ### Implicit if no terminal is used
-        if not sys.stdout.isatty():
-            self.color = False
-            self.header = False
-            self.update = False
-
-        ### Temporary hardcoded for my own project
-        self.diskset = {
-            'local': ('sda', 'hd[a-d]'),
-            'lores': ('sd[b-k]', 'sd[v-z]', 'sda[a-e]'),
-            'hires': ('sd[l-u]', 'sda[f-o]'),
-        }
-
-        try:
-            import getopt
-            opts, args = getopt.getopt (args, 'acdfghilmno:prstTvyC:D:I:M:N:S:V',
-                ['aio', 'cpu', 'disk', 'epoch', 'fs', 'filesystem', 'int', 'io', 'ipc',
-                 'load', 'lock', 'mem', 'net', 'page', 'proc', 'raw', 'socket', 'swap',
-                 'sys', 'tcp', 'time', 'udp', 'unix', 'vm',
-                 'all', 'debug', 'full', 'help', 'integer', 'list', 'mods', 'modules',
-                 'nocolor', 'noheaders', 'noupdate', 'output=', 'pidfile=', 'version',
-                 'vmstat'])
-        except getopt.error, exc:
-            print 'dstat: %s, try dstat -h for a list of all the options' % str(exc)
-            sys.exit(1)
-
-        self.modlist = []
-
-        for opt, arg in opts:
-            if opt in ['-c', '--cpu']:
-                self.modlist.append('cpu')
-            elif opt in ['-C']:
-                self.cpulist = string.split(arg, ',')
-            elif opt in ['-d', '--disk']:
-                self.modlist.append('disk')
-            elif opt in ['-D']:
-                self.disklist = string.split(arg, ',')
-            elif opt in ['-g', '--page']:
-                self.modlist.append('page')
-            elif opt in ['-i', '--int']:
-                self.modlist.append('int')
-            elif opt in ['-I']:
-                self.intlist = string.split(arg, ',')
-            elif opt in ['-l', '--load']:
-                self.modlist.append('load')
-            elif opt in ['-m', '--mem']:
-                self.modlist.append('mem')
-            elif opt in ['-M', '--mods', '--modules']:
-                self.modlist = self.modlist + string.split(arg, ',')
-            elif opt in ['-n', '--net']:
-                self.modlist.append('net')
-            elif opt in ['-N']:
-                self.netlist = string.split(arg, ',')
-            elif opt in ['-p', '--proc']:
-                self.modlist.append('proc')
-            elif opt in ['-r', '--io']:
-                self.modlist.append('io')
-            elif opt in ['-s', '--swap']:
-                self.modlist.append('swap')
-            elif opt in ['-S']:
-                self.swaplist = string.split(arg, ',')
-            elif opt in ['-t', '--time']:
-                self.modlist.append('time')
-            elif opt in ['-T', '--epoch']:
-                self.modlist.append('epoch')
-            elif opt in ['-y', '--sys']:
-                self.modlist.append('sys')
-
-            elif opt in ['--aio']:
-                self.modlist.append('aio')
-            elif opt in ['--fs', '--filesystem']:
-                self.modlist.append('fs')
-            elif opt in ['--ipc']:
-                self.modlist.append('ipc')
-            elif opt in ['--lock']:
-                self.modlist.append('lock')
-            elif opt in ['--raw']:
-                self.modlist.append('raw')
-            elif opt in ['--socket']:
-                self.modlist.append('socket')
-            elif opt in ['--tcp']:
-                self.modlist.append('tcp')
-            elif opt in ['--udp']:
-                self.modlist.append('udp')
-            elif opt in ['--unix']:
-                self.modlist.append('unix')
-            elif opt in ['--vm']:
-                self.modlist.append('vm')
-
-            elif opt in ['-a', '--all']:
-                self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys' ]
-            elif opt in ['-v', '--vmstat']:
-                self.modlist = self.modlist + [ 'proc', 'mem', 'page', 'disk', 'sys', 'cpu' ]
-            elif opt in ['-f', '--full']:
-                self.full = True
-
-            elif opt in ['--debug']:
-                self.debug = self.debug + 1
-            elif opt in ['--integer']:
-                self.integer = True
-            elif opt in ['--list']:
-                listmodules()
-                sys.exit(0)
-            elif opt in ['--nocolor']:
-                self.color = False
-                self.update = False
-            elif opt in ['--noheaders']:
-                self.header = False
-            elif opt in ['--noupdate']:
-                self.update = False
-            elif opt in ['-o', '--output']:
-                self.output = arg
-            elif opt in ['--pidfile']:
-                self.pidfile = arg
-            elif opt in ['-h', '--help']:
-                self.usage()
-                self.help()
-                sys.exit(0)
-            elif opt in ['-V', '--version']:
-                self.version()
-                sys.exit(0)
-
-        if not self.modlist:
-            self.modlist = [ 'cpu', 'disk', 'net', 'page', 'sys' ]
-
-        try:
-            if len(args) &gt; 0: self.delay = int(args[0])
-            if len(args) &gt; 1: self.count = int(args[1])
-        except:
-            print 'dstat: incorrect argument, try dstat -h for the correct syntax'
-            sys.exit(1)
-
-        if self.delay &lt;= 0:
-            print 'dstat: delay must be an integer, greater than zero'
-            sys.exit(1)
-
-    def version(self):
-        print 'Dstat %s' % VERSION
-        print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
-        print 'Homepage at <A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>'
-        print
-        print 'Platform %s/%s' % (os.name, sys.platform)
-        print 'Kernel %s' % os.uname()[2]
-        print 'Python %s' % sys.version
-        print
-
-        color = &quot;&quot;
-        if not gettermcolor(self.color):
-            color = &quot;no &quot;
-        print 'Terminal type: %s (%scolor support)' % (getenv('TERM'), color)
-        rows, cols = gettermsize()
-        print 'Terminal size: %d lines, %d columns' % (rows, cols)
-        print
-        print 'Processors: %d' % getcpunr()
-        print 'Pagesize: %d' % resource.getpagesize()
-#        print 'Clock ticks per secs: %d' % os.sysconf('SC_CLK_TCK')
-        print
-
-        global op
-        op = self
-        listmodules()
-
-    def usage(self):
-        print 'Usage: dstat [-afv] [options..] [delay [count]]'
-
-    def help(self):
-        print '''Versatile tool for generating system resource statistics
-
-Dstat options:
-  -c, --cpu              enable cpu stats
-     -C 0,3,total           include cpu0, cpu3 and total
-  -d, --disk             enable disk stats
-     -D total,hda           include hda and total
-  -g, --page             enable page stats
-  -i, --int              enable interrupt stats
-     -I 5,eth2              include int5 and interrupt used by eth2
-  -l, --load             enable load stats
-  -m, --mem              enable memory stats
-  -n, --net              enable network stats
-     -N eth1,total          include eth1 and total
-  -p, --proc             enable process stats
-  -r, --io               enable io stats (I/O requests completed)
-  -s, --swap             enable swap stats
-     -S swap1,total         include swap1 and total
-  -t, --time             enable time/date output
-  -T, --epoch            enable time counter (seconds since epoch)
-  -y, --sys              enable system stats
-
-  --aio                  enable aio stats
-  --fs                   enable fs stats
-  --ipc                  enable ipc stats
-  --lock                 enable lock stats
-  --raw                  enable raw stats
-  --socket               enable socket stats
-  --tcp                  enable tcp stats
-  --udp                  enable udp stats
-  --unix                 enable unix stats
-  --vm                   enable vm stats
-
-  -M stat1,stat2         enable external plugins
-     --mods stat1,stat2
-
-  --list                 list all internal and external plugins
-
-  -a, --all              equals -cdngy (default)
-  -f, --full             expand -C, -D, -I, -N and -S discovery lists
-  -v, --vmstat           equals -pmgdsc -D total
-
-  --integer              show integer values
-  --nocolor              disable colors (implies --noupdate)
-  --noheaders            disable repetitive headers
-  --noupdate             disable intermediate updates
-  --output file          write CSV output to file
-
-  delay is the delay in seconds between each update
-  count is the number of updates to display before exiting
-  The default delay is 1 and count is unspecified (unlimited)
-'''
-
-### START STATS DEFINITIONS ###
-class dstat:
-    vars = None
-    name = None
-    nick = None
-    format = ()
-
-    ### Initialise default variables
-    def init(self, vars=(), len=0):
-        if vars:
-            self.val = {}; self.cn1 = {}; self.cn2 = {}
-            for name in vars:
-                if len &lt;= 1:
-                    self.val[name] = self.cn1[name] = self.cn2[name] = 0
-                else:
-                    self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
-                    for i in range(len):
-                        self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
-
-    def open(self, *filenames):
-        &quot;Open stat file descriptor&quot;
-        self.file = []
-        self.fd = []
-        for filename in filenames:
-            fd = dopen(filename)
-            if fd:
-                self.file.append(filename)
-                self.fd.append(fd)
-        if not self.fd:
-            raise Exception, 'Cannot open file %s.' % filename
-
-    def readlines(self):
-        ret = []
-        for fd in self.fd:
-            fd.seek(0)
-            ret = ret + fd.readlines()
-        return ret
-
-    def statwidth(self):
-        &quot;Return complete stat width&quot;
-        return len(self.vars) * self.width() + len(self.vars) - 1
-
-    def width(self):
-        &quot;Return column width&quot;
-        if isinstance(self.name, types.StringType):
-            return self.format[1]
-        else:
-            return len(self.nick) * self.format[1] + len(self.nick) - 1
-
-    def title(self, nr):
-        if nr == 1:
-            return self.title1()
-        else:
-            return self.title2()
-
-    def title1(self):
-        ret = ansi['darkblue']
-        if isinstance(self.name, types.StringType):
-            maxlen = self.statwidth()
-            return ret + string.replace(string.center(self.name[0:maxlen], maxlen), ' ', '-') + ansi['default']
-        for i, name in enumerate(self.name):
-            maxlen = self.width()
-            ret = ret + string.replace(string.center(name[0:maxlen], maxlen), ' ', '-')
-            if i + 1 != len(self.name):
-                if op.color:
-                    ret = ret + ansi['blue'] + char['dash'] + ansi['darkblue']
-                else:
-                    ret = ret + char['space']
-        return ret
-
-    def title2(self):
-        if isinstance(self.name, types.StringType):
-            ret = ''
-            for i, nick in enumerate(self.nick):
-                ret = ret + ansi['blue'] + ansi['underline'] + string.center(nick, self.format[1]) + ansi['default']
-                if i + 1 != len(self.nick): ret = ret + char['space']
-            return ret
-        else:
-            ret = ''
-            for i, name in enumerate(self.name):
-                for j, nick in enumerate(self.nick):
-                    ret = ret + ansi['blue'] + ansi['underline'] + string.center(nick, self.format[1]) + ansi['default']
-                    if j + 1 != len(self.nick): ret = ret + char['space']
-                if i + 1 != len(self.name): ret = ret + ansi['gray'] + char['colon']
-            return ret
-
-    def titlecsv(self, nr):
-        if nr == 1:
-            return self.titlecsv1()
-        else:
-            return self.titlecsv2()
-
-    def titlecsv1(self):
-        if isinstance(self.name, types.StringType):
-            return '&quot;' + self.name + '&quot;' + ',' * (len(self.nick) - 1)
-        else:
-            ret = ''
-            for i, name in enumerate(self.name):
-                ret = ret + '&quot;' + name + '&quot;' + ',' * (len(self.nick) - 1)
-                if i + 1 != len(self.name): ret = ret + ','
-            return ret
-
-    def titlecsv2(self):
-        if isinstance(self.name, types.StringType):
-            ret = ''
-            for i, nick in enumerate(self.nick):
-                ret = ret + '&quot;' + nick + '&quot;'
-                if i + 1 != len(self.nick): ret = ret + ','
-            return ret
-        else:
-            ret = ''
-            for i, name in enumerate(self.name):
-                for j, nick in enumerate(self.nick):
-                    ret = ret + '&quot;' + nick + '&quot;'
-                    if j + 1 != len(self.nick): ret = ret + ','
-                if i + 1 != len(self.name): ret = ret + ','
-            return ret
-
-    def check(self):
-        &quot;Check if stat is applicable&quot;
-#       if hasattr(self, 'fd') and not self.fd:
-#           raise Exception, 'File %s does not exist' % self.file
-        if not self.vars:
-            raise Exception, 'No objects found, no stats available'
-        if not self.discover:
-            raise Exception, 'No objects discovered, no stats available'
-        if self.width():
-            return True
-        raise Exception, 'Unknown problem, please report'
-
-    def discover(self, *objlist):
-        return True
-
-    def show(self):
-        &quot;Display stat results&quot;
-        line = ''
-        for i, name in enumerate(self.vars):
-            if isinstance(self.val[name], types.TupleType) or isinstance(self.val[name], types.ListType):
-                line = line + cprintlist(self.val[name], self.format)
-                sep = ansi['gray'] + char['colon']
-            else:
-                line = line + cprint(self.val[name], self.format)
-                sep = char['space']
-            if i + 1 != len(self.vars):
-                line = line + sep
-        return line
-
-    def showend(self, totlist, vislist):
-        if self is not vislist[-1]:
-            return ansi['gray'] + char['pipe']
-        elif totlist != vislist:
-            return ansi['gray'] + char['gt']
-        return ''
-
-    def showcsv(self):
-        def printcsv(var):
-            if var != round(var):
-                return '%.3f' % var
-            return '%s' % round(var)
-
-        line = ''
-        for i, name in enumerate(self.vars):
-            if isinstance(self.val[name], types.ListType) or isinstance(self.val[name], types.TupleType):
-                for j, val in enumerate(self.val[name]):
-                    line = line + printcsv(val)
-                    if j + 1 != len(self.val[name]):
-                        line = line + ','
-            elif isinstance(self.val[name], types.StringType):
-                line = line + self.val[name]
-            else:
-                line = line + printcsv(self.val[name])
-            if i + 1 != len(self.vars):
-                line = line + ','
-        return line
-
-    def showcsvend(self, totlist, vislist):
-        if self is not vislist[-1]:
-            return ','
-        elif self is not totlist[-1]:
-            return ','
-        return ''
-
-class dstat_aio(dstat):
-    def __init__(self):
-        self.name = 'async'
-        self.format = ('d', 5, 1000)
-        self.open('/proc/sys/fs/aio-nr')
-        self.nick = ('#aio',)
-        self.vars = ('aio',)
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 1: continue
-            self.val['aio'] = long(l[0])
-
-class dstat_cpu(dstat):
-    def __init__(self):
-        self.format = ('p', 3, 34)
-        self.open('/proc/stat')
-        self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = self.name()
-        self.init(self.vars + ['total',], 6)
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
-            ret.append(l[0][3:])
-        ret.sort()
-        for item in objlist: ret.append(item)
-        return ret
-
-    def name(self):
-        ret = []
-        for name in self.vars:
-            if name == 'total':
-                ret.append('total cpu usage')
-            else:
-                ret.append('cpu' + name + ' usage')
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.cpulist:
-            varlist = op.cpulist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = []
-            cpu = 0
-            while cpu &lt; cpunr:
-                varlist.append(str(cpu))
-                cpu = cpu + 1
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-        for name in varlist:
-            if name in self.discover + ['total']:
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 8: continue
-            for name in self.vars:
-                if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
-        for name in self.vars:
-            for i in range(6):
-                if sum(self.cn2[name]) &gt; sum(self.cn1[name]):
-                    self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
-                else:
-                    self.val[name][i] = 0
-#                    print &quot;Error: tick problem detected, this should never happen !&quot;
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_cpu24(dstat):
-    def __init__(self):
-        self.format = ('p', 3, 34)
-        self.open('/proc/stat')
-        self.nick = ( 'usr', 'sys', 'idl')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = self.name()
-        self.init(self.vars + ['total',], 3)
-
-    def name(self):
-        ret = []
-        for name in self.vars:
-            if name:
-                ret.append('cpu' + name)
-            else:
-                ret.append('cpu total')
-        return ret
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) != 5 or l[0][0:3] != 'cpu': continue
-            ret.append(l[0][3:])
-        ret.sort()
-        for item in objlist: ret.append(item)
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.cpulist:
-            varlist = op.cpulist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = []
-            cpu = 0
-            while cpu &lt; cpunr:
-                varlist.append(str(cpu))
-                cpu = cpu + 1
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-        for name in varlist:
-            if name in self.discover + ['total']:
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            for name in self.vars:
-                if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
-        for name in self.vars:
-            for i in range(3):
-                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_disk(dstat):
-    def __init__(self):
-        self.format = ('f', 5, 1024)
-        self.diskfilter = re.compile('(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)')
-        self.open('/proc/diskstats')
-        self.nick = ('read', 'writ')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = []
-        for name in self.vars: self.name.append('dsk/' + name)
-        self.init(self.vars + ['total',], 2)
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 13: continue
-            if l[3:] == ['0',] * 11: continue
-            name = l[2]
-            ret.append(name)
-        for item in objlist: ret.append(item)
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.disklist:
-            varlist = op.disklist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = []
-            for name in self.discover:
-                if not self.diskfilter.match(name):
-                    varlist.append(name)
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-            varlist.sort()
-        for name in varlist:
-            if name in self.discover + ['total'] + op.diskset.keys():
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 13: continue
-            if l[5] == '0' and l[9] == '0': continue
-            name = l[2]
-            if l[3:] == ['0',] * 11: continue
-            if not self.diskfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
-            if name in self.vars and name != 'total':
-                self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
-            for diskset in self.vars:
-                if diskset in op.diskset.keys():
-                    for disk in op.diskset[diskset]:
-                        if re.match('^'+disk+'$', name):
-                            self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[5]), self.cn2[diskset][1] + long(l[9]) )
-        for name in self.cn2.keys():
-            self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-            )
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_disk24(dstat):
-    def __init__(self):
-        self.format = ('f', 5, 1024)
-        self.diskfilter = re.compile('(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)')
-        self.open('/proc/partitions')
-        self.nick = ('read', 'writ')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        if self.fd and not self.discover:
-            raise Exception, 'Kernel is not compiled with CONFIG_BLK_STATS'
-        self.name = []
-        for name in self.vars: self.name.append('dsk/' + sysfs_dev(name))
-        self.init(self.vars + ['total',], 2)
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
-            name = l[3]
-            ret.append(name)
-        for item in objlist: ret.append(item)
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.disklist:
-            varlist = op.disklist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = []
-            for name in self.discover:
-                if not self.diskfilter.match(name):
-                    varlist.append(name)
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-            varlist.sort()
-        for name in varlist:
-            if name in self.discover + ['total'] + op.diskset.keys():
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
-            name = l[3]
-            if not self.diskfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]) )
-            if name in self.vars:
-                self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
-            for diskset in self.vars:
-                if diskset in op.diskset.keys():
-                    for disk in op.diskset[diskset]:
-                        if re.match('^'+disk+'$', name):
-                            self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[6]), self.cn2[diskset][1] + long(l[10]) )
-        for name in self.cn2.keys():
-            self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-            )
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-### FIXME: Needs rework, does anyone care ?
-class dstat_disk24old(dstat):
-    def __init__(self):
-        self.format = ('f', 5, 1024)
-        self.diskfilter = re.compile('(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)')
-        self.open('/proc/stat')
-        self.nick = ('read', 'writ')
-        self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = []
-        for name in self.vars: self.name.append('dsk/' + name)
-        self.init(self.vars + ['total',], 2)
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line, ':')
-            if len(l) &lt; 3: continue
-            name = l[0]
-            if name != 'disk_io': continue
-            for pair in string.split(line)[1:]:
-                m = self.regexp.match(pair)
-                if not m: continue
-                l = m.groups()
-                if len(l) &lt; 4: continue
-                name = dev(int(l[0]), int(l[1]))
-                ret.append(name)
-            break
-        for item in objlist: ret.append(item)
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.disklist:
-            varlist = op.disklist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = []
-            for name in self.discover:
-                if not self.diskfilter.match(name):
-                    varlist.append(name)
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-            varlist.sort()
-        for name in varlist:
-            if name in self.discover + ['total'] + op.diskset.keys():
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
-        for line in self.readlines():
-            l = string.split(line, ':')
-            if len(l) &lt; 3: continue
-            name = l[0]
-            if name != 'disk_io': continue
-            for pair in string.split(line)[1:]:
-                m = self.regexp.match(pair)
-                if not m: continue
-                l = m.groups()
-                if len(l) &lt; 4: continue
-                name = dev(int(l[0]), int(l[1]))
-                if not self.diskfilter.match(name):
-                    self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
-                if name in self.vars and name != 'total':
-                    self.cn2[name] = ( self.cn2[name][0] + long(l[2]), self.cn2[name][1] + long(l[3]) )
-                for diskset in self.vars:
-                    if diskset in op.diskset.keys():
-                        for disk in op.diskset[diskset]:
-                            if re.match('^'+disk+'$', name):
-                                self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[2]), self.cn2[diskset][1] + long(l[3]) )
-            break
-        for name in self.cn2.keys():
-            self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-            )
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_epoch(dstat):
-    def __init__(self):
-        self.name = 'epoch'
-        self.format = ('t', 10, 0)
-        if op.debug:
-            self.format = ('t', 14, 0)
-        self.nick = ('epoch',)
-        self.vars = self.nick
-        self.init(self.vars, 1)
-
-    ### We are now using the starttime instead of the execution time of this plugin
-    def extract(self):
-#        self.val['epoch'] = time.time()
-        self.val['epoch'] = starttime
-
-#   def show(self):
-#       return ansi['reset'] + ( '%10.2f' % self.val['epoch'] )
-
-class dstat_fs(dstat):
-    def __init__(self):
-        self.name = 'filesystem'
-        self.format = ('d', 6, 1000)
-        self.nick = ('files', 'inodes')
-        self.vars = self.nick
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in dopen('/proc/sys/fs/file-nr').readlines():
-            l = string.split(line)
-            if len(l) &lt; 1: continue
-            self.val['files'] = long(l[0])
-        for line in dopen('/proc/sys/fs/inode-nr').readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            self.val['inodes'] = long(l[0]) - long(l[1])
-
-class dstat_int(dstat):
-    def __init__(self):
-        self.name = 'interrupts'
-        self.format = ('d', 5, 1000)
-        self.open('/proc/stat')
-        self.discover = self.discover()
-        self.intmap = self.intmap()
-        self.vars = self.vars()
-        self.nick = self.vars
-        self.init(self.vars + ['total',], 1)
-
-    def intmap(self):
-        ret = {}
-        for line in dopen('/proc/interrupts').readlines():
-            l = string.split(line)
-            if len(l) &lt;= cpunr: continue
-            l1 = string.split(l[0], ':')[0]
-            l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
-            ret[l1] = l1
-            for name in l2:
-                name = string.lower(string.strip(name))
-                ret[name] = l1
-        return ret
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if l[0] != 'intr': continue
-            for name, i in enumerate(l[2:]):
-                if long(i) &gt; 10: ret.append(str(name))
-        return ret
-
-#   def check(self):
-#       if self.fd[0] and self.vars:
-#           self.fd[0].seek(0)
-#           for line in self.fd[0].readlines():
-#               l = string.split(line)
-#               if l[0] != 'intr': continue
-#               return True
-#       return False
-
-    def vars(self):
-        ret = []
-        if op.intlist:
-            varlist = op.intlist
-        else:
-            varlist = self.discover
-            for name in varlist:
-                if name in ('0', '1', '2', '8', 'NMI', 'LOC', 'MIS', 'CPU0'):
-                    varlist.remove(name)
-            if not op.full and len(varlist) &gt; 3: varlist = varlist[-3:]
-        for name in varlist:
-            if name in self.discover + ['total',]:
-                ret.append(name)
-            elif string.lower(name) in self.intmap.keys():
-                ret.append(self.intmap[string.lower(name)])
-        return ret
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if not l or l[0] != 'intr': continue
-            for name in self.vars:
-                if name != 'total':
-                    self.cn2[name] = long(l[int(name) + 2])
-            self.cn2['total'] = long(l[1])
-        for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_int24(dstat):
-    def __init__(self):
-        self.name = 'interrupts'
-        self.format = ('d', 5, 1000)
-        self.open('/proc/interrupts')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.nick = self.vars
-        self.init(self.vars, 1)
-
-    def intmap(self):
-        ret = {}
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt;= cpunr: continue
-            l1 = string.split(l[0], ':')[0]
-            l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
-            ret[l1] = l1
-            for name in l2:
-                name = string.lower(string.strip(name))
-                ret[name] = l1
-        return ret
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; cpunr+1: continue
-            name = string.split(l[0], ':')[0]
-            if long(l[1]) &gt; 10:
-                ret.append(name)
-        return ret
-
-#   def check(self):
-#       if self.fd and self.discover:
-#           self.fd[0].seek(0)
-#           for line in self.fd[0].readlines():
-#               l = string.split(line)
-#               if l[0] != 'intr' or len(l) &gt; 2: continue
-#               return True
-#       return False
-
-    def vars(self):
-        ret = []
-        if op.intlist:
-            varlist = op.intlist
-        else:
-            varlist = self.discover
-            for name in varlist:
-                if name in ('0', '1', '2', '8', 'CPU0', 'ERR', 'LOC', 'MIS', 'NMI'):
-                    varlist.remove(name)
-            if not op.full and len(varlist) &gt; 3: varlist = varlist[-3:]
-        for name in varlist:
-            if name in self.discover:
-                ret.append(name)
-            elif string.lower(name) in self.intmap.keys():
-                ret.append(self.intmap[string.lower(name)])
-        return ret
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; cpunr+1: continue
-            name = string.split(l[0], ':')[0]
-            if name in self.vars:
-                self.cn2[name] = 0
-                for i in l[1:1+cpunr]:
-                    self.cn2[name] = self.cn2[name] + long(i)
-#           elif len(l) &gt; 2 + cpunr:
-#               for hw in self.vars:
-#                   for mod in l[2+cpunr:]:
-#                       self.cn2[mod] = long(l[1])
-        for name in self.cn2.keys():
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_io(dstat):
-    def __init__(self):
-        self.format = ('f', 5, 1000)
-        self.diskfilter = re.compile('(dm-[0-9]+|md[0-9]+|[hs]d[a-z]+[0-9]+)')
-        self.open('/proc/diskstats')
-        self.nick = ('read', 'writ')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = []
-        for name in self.vars: self.name.append('io/'+name)
-        self.init(self.vars + ['total',], 3)
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 13: continue
-            if l[3:] == ['0',] * 11: continue
-            name = l[2]
-            ret.append(name)
-        for item in objlist: ret.append(item)
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.disklist:
-            varlist = op.disklist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = []
-            for name in self.discover:
-                if not self.diskfilter.match(name):
-                    varlist.append(name)
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-            varlist.sort()
-        for name in varlist:
-            if name in self.discover + ['total'] + op.diskset.keys():
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        for name in self.vars: self.cn2[name] = (0, 0)
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 13: continue
-            if l[3] == '0' and l[7] == '0': continue
-            name = l[2]
-            if l[3:] == ['0',] * 11: continue
-            if not self.diskfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[3]), self.cn2['total'][1] + long(l[7]) )
-            if name in self.vars and name != 'total':
-                self.cn2[name] = ( self.cn2[name][0] + long(l[3]), self.cn2[name][1] + long(l[7]) )
-            for diskset in self.vars:
-                if diskset in op.diskset.keys():
-                    for disk in op.diskset[diskset]:
-                        if re.match('^'+disk+'$', name):
-                            self.cn2[diskset] = ( self.cn2[diskset][0] + long(l[3]), self.cn2[diskset][1] + long(l[7]) )
-        for name in self.cn2.keys():
-            self.val[name] = (
-                (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-                (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
-            )
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_ipc(dstat):
-    def __init__(self):
-        self.name = 'sysv ipc'
-        self.format = ('d', 3, 10)
-        self.vars = ('msg', 'sem', 'shm')
-        self.nick = self.vars
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for name in self.vars:
-            self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
-
-class dstat_load(dstat):
-    def __init__(self):
-        self.name = 'load avg'
-        self.format = ('f', 4, 10)
-        self.open('/proc/loadavg')
-        self.nick = ('1m', '5m', '15m')
-        self.vars = ('load1', 'load5', 'load15')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 3: continue
-            self.val['load1'] = float(l[0])
-            self.val['load5'] = float(l[1])
-            self.val['load15'] = float(l[2])
-
-class dstat_lock(dstat):
-    def __init__(self):
-        self.name = 'file locks'
-        self.format = ('f', 3, 10)
-        self.open('/proc/locks')
-        self.nick = ('pos', 'lck', 'rea', 'wri')
-        self.vars = ('posix', 'flock', 'read', 'write')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for name in self.vars: self.val[name] = 0
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 4: continue
-            if l[1] == 'POSIX':
-                self.val['posix'] = self.val['posix'] + 1
-            elif l[1] == 'FLOCK':
-                self.val['flock'] = self.val['flock'] + 1
-            if l[3] == 'READ':
-                self.val['read'] = self.val['read'] + 1
-            elif l[3] == 'WRITE':
-                self.val['write'] = self.val['write'] + 1
-
-class dstat_mem(dstat):
-    def __init__(self):
-        self.name = 'memory usage'
-        self.format = ('f', 5, 1024)
-        self.open('/proc/meminfo')
-        self.nick = ('used', 'buff', 'cach', 'free')
-        self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            name = string.split(l[0], ':')[0]
-            if name in self.vars + ('MemTotal', ):
-                self.val[name] = long(l[1]) * 1024.0
-        self.val['MemUsed'] = self.val['MemTotal'] - self.val['MemFree'] - self.val['Buffers'] - self.val['Cached']
-
-class dstat_net(dstat):
-    def __init__(self):
-        self.format = ('f', 5, 1024)
-        self.open('/proc/net/dev')
-        self.nick = ('recv', 'send')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = []
-        for name in self.vars: self.name.append('net/' + name)
-        self.init(self.vars + ['total',], 2)
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(string.replace(line, ':', ' '))
-            if len(l) &lt; 17: continue
-            if l[2] == '0' and l[10] == '0': continue
-            name = l[0]
-            if name not in ('lo', 'face'):
-                ret.append(name)
-        ret.sort()
-        for item in objlist: ret.append(item)
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.netlist:
-            varlist = op.netlist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = self.discover
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-            varlist.sort()
-        for name in varlist:
-            if name in self.discover + ['total', 'lo']:
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        self.cn2['total'] = [0, 0]
-        for line in self.readlines():
-            l = string.split(string.replace(line, ':', ' '))
-            if len(l) &lt; 17: continue
-            if l[2] == '0' and l[10] == '0': continue
-            name = l[0]
-            if name in self.vars :
-                self.cn2[name] = ( long(l[1]), long(l[9]) )
-            if name not in ('lo','face'):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[9]))
-        if update:
-            for name in self.cn2.keys():
-                self.val[name] = (
-                    (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-                    (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
-                 )
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_page(dstat):
-    def __init__(self):
-        self.name = 'paging'
-        self.format = ('f', 5, 1024)
-        self.open('/proc/vmstat')
-        self.nick = ('in', 'out')
-        self.vars = ('pswpin', 'pswpout')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            name = l[0]
-            if name in self.vars:
-                self.cn2[name] = long(l[1])
-        for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_page24(dstat):
-    def __init__(self):
-        self.name = 'paging'
-        self.format = ('f', 5, 1024)
-        self.open('/proc/stat')
-        self.nick = ('in', 'out')
-        self.vars = ('pswpin', 'pswpout')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 3: continue
-            name = l[0]
-            if name != 'swap': continue
-            self.cn2['pswpin'] = long(l[1])
-            self.cn2['pswpout'] = long(l[2])
-            break
-        for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_proc(dstat):
-    def __init__(self):
-        self.name = 'procs'
-        self.format = ('f', 3, 10)
-        self.open('/proc/stat')
-        self.nick = ('run', 'blk', 'new')
-        self.vars = ('procs_running', 'procs_blocked', 'processes')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            name = l[0]
-            if name == 'processes':
-                self.val['processes'] = 0
-                self.cn2[name] = long(l[1])
-            elif name == 'procs_running':
-                self.cn2[name] = self.cn2[name] + long(l[1]) - 1
-            elif name == 'procs_blocked':
-                self.cn2[name] = self.cn2[name] + long(l[1])
-        self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
-        for name in ('procs_running', 'procs_blocked'):
-            self.val[name] = self.cn2[name] * 1.0 / tick
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-            for name in ('procs_running', 'procs_blocked'):
-                self.cn2[name] = 0
-
-class dstat_raw(dstat):
-    def __init__(self):
-        self.name = 'raw'
-        self.format = ('d', 3, 100)
-        self.open('/proc/net/raw')
-        self.nick = ('raw',)
-        self.vars = ('sockets',)
-        self.init(self.vars, 1)
-
-    def extract(self):
-        lines = -1
-        for line in self.readlines():
-            lines = lines + 1
-        self.val['sockets'] = lines
-        ### Cannot use len() on generator
-#        self.val['sockets'] = len(self.readlines()) - 1
-
-class dstat_socket(dstat):
-    def __init__(self):
-        self.name = 'sockets'
-        self.format = ('d', 3, 100)
-        self.open('/proc/net/sockstat')
-        self.nick = ('tot', 'tcp', 'udp', 'raw', 'frg')
-        self.vars = ('sockets:', 'TCP:', 'UDP:', 'RAW:', 'FRAG:')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 3: continue
-            self.val[l[0]] = long(l[2])
-        self.val['other'] = self.val['sockets:'] - self.val['TCP:'] - self.val['UDP:'] - self.val['RAW:'] - self.val['FRAG:']
-
-class dstat_swap(dstat):
-    def __init__(self):
-        self.name = 'swap'
-        self.format = ('f', 5, 1024)
-        self.open('/proc/swaps')
-        self.nick = ('used', 'free')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = []
-        for name in self.vars: self.name.append('swp/'+improve(name))
-        self.init(self.vars + ['total',], 2)
-
-    def discover(self, *objlist):
-        ret = []
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 5: continue
-            if l[0] == 'Filename': continue
-            try:
-                int(l[2])
-                int(l[3])
-            except:
-                continue
-#           ret.append(improve(l[0]))
-            ret.append(l[0])
-        ret.sort()
-        for item in objlist: ret.append(item)
-        return ret
-
-    def vars(self):
-        ret = []
-        if op.swaplist:
-            varlist = op.swaplist
-        elif not op.full:
-            varlist = ('total',)
-        else:
-            varlist = self.discover
-#           if len(varlist) &gt; 2: varlist = varlist[0:2]
-            varlist.sort()
-        for name in varlist:
-            if name in self.discover + ['total']:
-                ret.append(name)
-        return ret
-
-    def extract(self):
-        self.val['total'] = [0, 0]
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 5 or l[0] == 'Filename': continue
-            name = l[0]
-            self.val[name] = ( long(l[3]) * 1024.0, (long(l[2]) - long(l[3])) * 1024.0 )
-            self.val['total'] = ( self.val['total'][0] + self.val[name][0], self.val['total'][1] + self.val[name][1])
-
-class dstat_swapold(dstat):
-    def __init__(self):
-        self.name = 'swap'
-        self.format = ('f', 5, 1024)
-        self.open('/proc/meminfo')
-        self.nick = ('used', 'free')
-        self.vars = ('SwapUsed', 'SwapFree')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            name = string.split(l[0], ':')[0]
-            if name in self.vars + ('SwapTotal',):
-                self.val[name] = long(l[1]) * 1024.0
-        self.val['SwapUsed'] = self.val['SwapTotal'] - self.val['SwapFree']
-
-class dstat_sys(dstat):
-    def __init__(self):
-        self.name = 'system'
-        self.format = ('d', 5, 1000)
-        self.open('/proc/stat')
-        self.nick = ('int', 'csw')
-        self.vars = ('intr', 'ctxt')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            name = l[0]
-            if name in self.vars:
-                self.cn2[name] = long(l[1])
-        for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-class dstat_tcp(dstat):
-    def __init__(self):
-        self.name = 'tcp sockets'
-        self.format = ('f', 3, 100)
-        self.open('/proc/net/tcp', '/proc/net/tcp6')
-        self.nick = ('lis', 'act', 'syn', 'tim', 'clo')
-        self.vars = ('listen', 'established', 'syn', 'wait', 'close')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for name in self.vars: self.val[name] = 0
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 12: continue
-            ### 01: established, 02: syn_sent,  03: syn_recv, 04: fin_wait1,
-            ### 05: fin_wait2,   06: time_wait, 07: close,    08: close_wait,
-            ### 09: last_ack,    0A: listen,    0B: closing
-            if l[3] in ('0A',): self.val['listen'] = self.val['listen'] + 1
-            elif l[3] in ('01',): self.val['established'] = self.val['established'] + 1
-            elif l[3] in ('02', '03', '09',): self.val['syn'] = self.val['syn'] + 1
-            elif l[3] in ('06',): self.val['wait'] = self.val['wait'] + 1
-            elif l[3] in ('04', '05', '07', '08', '0B',): self.val['close'] = self.val['close'] + 1
-
-### FIXME: If timefmt &lt; len(self.nick) output is fucked up
-class dstat_time(dstat):
-    def __init__(self):
-        self.name = 'time'
-        self.timefmt = getenv('DSTAT_TIMEFMT')
-        if self.timefmt:
-            tmp = time.strftime(self.timefmt, time.localtime())
-            self.format = ('s', len(tmp), 0)
-        elif op.debug:
-            self.format = ('s', 18, 0)
-        else:
-            self.format = ('s', 14, 0)
-        self.nick = ('date/time',)
-        self.vars = ('time',)
-        self.init(self.vars, 1)
-
-    ### We are now using the starttime for this plugin, not the execution time of this plugin
-    def extract(self):
-        if self.timefmt:
-            self.val['time'] = time.strftime(self.timefmt, time.localtime(starttime))
-        elif op.debug:
-            self.val['time'] = time.strftime('%d-%m %H:%M:%S', time.localtime(starttime)) + &quot;.%03d&quot; % (round(starttime * 1000 % 1000 ))
-        else:
-            self.val['time'] = time.strftime('%d-%m %H:%M:%S', time.localtime(starttime))
-
-    def show(self):
-        if step == op.delay:
-            color = 'silver'
-        else:
-            color = 'gray'
-        return ansi[color] + self.val['time']
-
-class dstat_udp(dstat):
-    def __init__(self):
-        self.name = 'udp'
-        self.format = ('d', 3, 100)
-        self.open('/proc/net/udp', '/proc/net/udp6')
-        self.nick = ('lis', 'act')
-        self.vars = ('listen', 'established')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for name in self.vars: self.val[name] = 0
-        for line in self.readlines():
-            l = string.split(line)
-            if l[3] == '07': self.val['listen'] = self.val['listen'] + 1
-            elif l[3] == '01': self.val['established'] = self.val['established'] + 1
-
-class dstat_unix(dstat):
-    def __init__(self):
-        self.name = 'unix sockets'
-        self.format = ('d', 3, 100)
-        self.open('/proc/net/unix')
-        self.nick = ('dgm', 'str', 'lis', 'act')
-        self.vars = ('datagram', 'stream', 'listen', 'established')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for name in self.vars: self.val[name] = 0
-        for line in self.readlines():
-            l = string.split(line)
-            if l[4] == '0002':
-                self.val['datagram'] = self.val['datagram'] + 1
-            elif l[4] == '0001':
-                self.val['stream'] = self.val['stream'] + 1
-                if l[5] == '01':
-                    self.val['listen'] = self.val['listen'] + 1
-                elif l[5] == '03':
-                    self.val['established'] = self.val['established'] + 1
-
-class dstat_vm(dstat):
-    def __init__(self):
-        self.name = 'virtual memory'
-        self.format = ('d', 5, 1000)
-        self.open('/proc/vmstat')
-        self.nick = ('majpf', 'minpf', 'alloc', 'free')
-        self.vars = ('pgmajfault', 'pgfault', 'pgalloc_normal', 'pgfree')
-        self.init(self.vars, 1)
-
-    def extract(self):
-        for line in self.readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            if l[0] not in self.vars: continue
-            self.cn2[l[0]] = long(l[1])
-        for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-        if step == op.delay:
-            self.cn1.update(self.cn2)
-
-### END STATS DEFINITIONS ###
-
-ansi = {
-    'black': '\033[0;30m',
-    'darkred': '\033[0;31m',
-    'darkgreen': '\033[0;32m',
-    'darkyellow': '\033[0;33m',
-    'darkblue': '\033[0;34m',
-    'darkmagenta': '\033[0;35m',
-    'darkcyan': '\033[0;36m',
-    'silver': '\033[0;37m',
-
-    'gray': '\033[1;30m',
-    'red': '\033[1;31m',
-    'green': '\033[1;32m',
-    'yellow': '\033[1;33m',
-    'blue': '\033[1;34m',
-    'magenta': '\033[1;35m',
-    'cyan': '\033[1;36m',
-    'white': '\033[1;37m',
-
-    'blackbg': '\033[40m',
-    'redbg': '\033[41m',
-    'greenbg': '\033[42m',
-    'yellowbg': '\033[43m',
-    'bluebg': '\033[44m',
-    'magentabg': '\033[45m',
-    'cyanbg': '\033[46m',
-    'whitebg': '\033[47m',
-
-    'reset': '\033[0;0m',
-    'bold': '\033[1m',
-    'reverse': '\033[2m',
-    'underline': '\033[4m',
-
-    'clear': '\033[2J',
-#   'clearline': '\033[K',
-    'clearline': '\033[2K',
-#   'save': '\033[s',
-#   'restore': '\033[u',
-    'save': '\0337',
-    'restore': '\0338',
-
-    'up': '\033[1A',
-    'down': '\033[1B',
-    'right': '\033[1C',
-    'left': '\033[1D',
-
-    'default': '\033[0;0m',
-}
-
-char = {
-    'pipe': '|',
-    'colon': ':',
-    'gt': '&gt;',
-    'space': ' ',
-    'dash': '-',
-}
-
-def ticks():
-    &quot;Return the number of 'ticks' since bootup&quot;
-    try:
-        for line in open('/proc/uptime', 'r', 0).readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            return float(l[0])
-    except:
-        for line in dopen('/proc/stat').readlines():
-            l = string.split(line)
-            if len(l) &lt; 2: continue
-            if l[0] == 'btime':
-                return time.time() - long(l[1])
-
-def improve(devname):
-    &quot;Improve a device name&quot;
-    if devname.startswith('/dev/mapper/'):
-        devname = string.split(devname, '/')[3]
-    elif devname.startswith('/dev/'):
-        devname = string.split(devname, '/')[2]
-    return devname
-
-def dopen(filename):
-    &quot;Open a file for reuse, if already opened, return file descriptor&quot;
-    global fds
-    if not os.path.exists(filename): return None
-    if 'fds' not in globals().keys(): fds = {}
-    if filename not in fds.keys():
-        fds[filename] = open(filename, 'r', 0)
-    else:
-        fds[filename].seek(0)
-    return fds[filename]
-
-def dclose(filename):
-    &quot;Close an open file and remove file descriptor from list&quot;
-    global fds
-    if not 'fds' in globals().keys(): fds = {}
-    if filename in fds:
-        fds[filename].close()
-        del(fds[filename])
-
-def dpopen(cmd):
-    &quot;Open a pipe for reuse, if already opened, return pipes&quot;
-    global pipes
-    if 'pipes' not in globals().keys(): pipes = {}
-    if cmd not in pipes.keys():
-        pipes[cmd] = os.popen3(cmd, 't', 0)
-    return pipes[cmd]
-
-def readpipe(fileobj, tmout = 0.001):
-    &quot;Read available data from pipe in a non-blocking fashion&quot;
-    ret = ''
-    while not select.select([fileobj.fileno()], [], [], tmout)[0]:
-        pass
-    while select.select([fileobj.fileno()], [], [], tmout)[0]:
-        ret = ret + fileobj.read(1)
-    return string.split(ret, '\n')
-
-def greppipe(fileobj, str, tmout = 0.001):
-    &quot;Grep available data from pipe in a non-blocking fashion&quot;
-    ret = ''
-    while not select.select([fileobj.fileno()], [], [], tmout)[0]:
-        pass
-    while select.select([fileobj.fileno()], [], [], tmout)[0]:
-        character = fileobj.read(1)
-        if character != '\n':
-            ret = ret + character
-        elif ret.startswith(str):
-            return ret
-        else:
-            ret = ''
-    return None
-
-def matchpipe(fileobj, string, tmout = 0.001):
-    &quot;Match available data from pipe in a non-blocking fashion&quot;
-    ret = ''
-    regexp = re.compile(string)
-    while not select.select([fileobj.fileno()], [], [], tmout)[0]:
-        pass
-    while select.select([fileobj.fileno()], [], [], tmout)[0]:
-        character = fileobj.read(1)
-        if character != '\n':
-            ret = ret + character
-        elif regexp.match(ret):
-            return ret
-        else:
-            ret = ''
-    return None
-
-def dchg(var, maxlen, base):
-    &quot;Convert decimal to string given base and length&quot;
-    c = 0
-    while True:
-        ret = str(int(round(var)))
-        if len(ret) &lt;= maxlen:
-            break
-        var = var / base
-        c = c + 1
-    else:
-        c = -1
-    return ret, c
-
-def fchg(var, maxlen, base):
-    &quot;Convert float to string given base and length&quot;
-    c = 0
-    while True:
-        if var == 0:
-            ret = str('0')
-            break
-#       ret = repr(round(var))
-#       ret = repr(long(round(var,maxlen)))
-        ret = str(long(round(var,maxlen)))
-        if len(ret) &lt;= maxlen:
-            i = maxlen - len(ret)
-            while i &gt; 0:
-                ret = ('%.'+str(i)+'f') % var
-                if len(ret) &lt; maxlen and ret != repr(round(var)):
-                    break
-                i = i - 1
-            else:
-                ret = str(int(round(var)))
-            break
-        var = var / base
-        c = c + 1
-    else:
-        c = -1
-    return ret, c
-
-def cprintlist(varlist, format):
-    ret = sep = ''
-    for var in varlist:
-        ret = ret + sep + cprint(var, format)
-        sep = ' '
-    return ret
-
-def cprint(var, format = ('f', 4, 1000)):
-    vartype = format[0]
-    maxlen = format[1]
-    mp = format[2]
-
-    base = 1000
-    if mp == 1024:
-        base = 1024
-
-    ### Use units when base is exact 1000 or 1024
-    unit = False
-    if mp in (1000, 1024) and maxlen &gt;= len(str(base)):
-        unit = True
-        maxlen = maxlen - 1
-
-    if var &lt; 0:
-        if unit:
-            return ansi['white'] + ansi['redbg'] + string.rjust('-', maxlen) + ' ' + ansi['default']
-        else:
-            return ansi['white'] + ansi['redbg'] + string.rjust('-', maxlen) + ansi['default']
-
-    if base == 1024:
-        units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
-    else:
-        units = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
-
-    if step == op.delay:
-        colors = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
-    else:
-        colors = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
-
-    ### Convert value to string given base and field-length
-    if op.integer and vartype in ('d', 'p', 'f'):
-        ret, c = dchg(var, maxlen, base)
-    elif vartype in ('d', 'p'):
-        ret, c = dchg(var, maxlen, base)
-    elif vartype in ('f'):
-        ret, c = fchg(var, maxlen, base)
-    elif vartype in ('t'):
-        ret, c = fchg(var, maxlen+1, base)
-    else:
-        ret, c = str(var), -1
-
-    ### Set the counter color
-    if ret == '0':
-        color = 'default'
-    elif vartype in ('d', 'p'):
-        color = colors[int(round(var)/mp)%len(colors)]
-    elif vartype in ('f'):
-        color = colors[c%len(colors)]
-    else:
-        color = 'default'
-
-    ### Justify value to left if string
-    if vartype in ('s',):
-        ret = ansi['default'] + string.ljust(ret, maxlen)
-    else:
-        ret = ansi[color] + string.rjust(ret, maxlen)
-
-    ### Add unit to output
-    if unit:
-        if c != -1 and round(var) != 0:
-            ret = ret + ansi['default'] + units[c]
-        else:
-            ret = ret + ' '
-
-    return ret
-
-def showtitle(nr, totlist, vislist, midchar, endchar):
-    line = ''
-    for o in vislist:
-        line = line + o.title(nr)
-        if o is not vislist[-1]:
-            line = line + midchar
-        elif totlist != vislist:
-            line = line + endchar
-    sys.stdout.write(line + '\n')
-
-def showcsvtitle(nr, totlist):
-    line = ''
-    for o in totlist:
-        line = line + o.titlecsv(nr)
-        if o is not totlist[-1]:
-            line = line + ','
-    outputfile.write(line + '\n')
-
-def info(level, str):
-    &quot;Output info message&quot;
-#   if level &lt;= op.verbose:
-    print str
-
-def die(ret, str):
-    &quot;Print error and exit with errorcode&quot;
-    print str
-    exit(ret)
-
-def getenv(key):
-    if os.environ.has_key(key):
-        return os.environ[key]
-    return None
-
-def initterm():
-    &quot;Initialise terminal&quot;
-    global termsize
-
-    ### Unbuffered sys.stdout
-#    sys.stdout = os.fdopen(1, 'w', 0)
-
-    try:
-        global fcntl, struct, termios
-        import fcntl, struct, termios
-        termios.TIOCGWINSZ
-    except:
-        try:
-            curses.setupterm()
-            curses.tigetnum('lines'), curses.tigetnum('cols')
-        except:
-            pass
-        else:
-            termsize = None, 2
-    else:
-        termsize = None, 1
-
-def gettermsize():
-    &quot;Return the dynamic terminal geometry&quot;
-    global termsize
-
-    termsize = None, None
-
-#    if not termsize[0] and not termsize[1]:
-    if not termsize[0]:
-        try:
-            if termsize[1] == 1:
-                s = struct.pack('HHHH', 0, 0, 0, 0)
-                x = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, s)
-                return struct.unpack('HHHH', x)[:2]
-            elif termsize[1] == 2:
-                curses.setupterm()
-                return curses.tigetnum('lines'), curses.tigetnum('cols')
-            else:
-                termsize = (int(getenv('LINES')), int(getenv('COLUMNS')))
-        except:
-            termsize = 25, 80
-    return termsize
-
-def gettermcolor(color=True):
-    if color and sys.stdout.isatty():
-        try:
-            import curses
-            curses.setupterm()
-            if curses.tigetnum('colors') &lt; 0:
-                return False
-        except:
-            print 'Color support is disabled, python-curses is not installed.'
-            return False
-    return color
-
-def getcpunr():
-    &quot;Return the number of CPUs in the system&quot;
-    cpunr = -1
-    for line in dopen('/proc/stat').readlines():
-        if line[0:3] == 'cpu':
-            cpunr = cpunr + 1
-    if cpunr &lt; 0:
-        raise &quot;Problem finding number of CPUs in system.&quot;
-    return cpunr
-
-### FIXME: Add scsi support too and improve
-def sysfs_dev(device):
-    &quot;Convert sysfs device names into device names&quot;
-    m = re.match('ide/host([0-9])/bus([0-9])/target([0-9])/lun([0-9])/disc', device)
-    if m:
-        l = m.groups()
-        # ide/host0/bus0/target0/lun0/disc -&gt; 0 -&gt; hda
-        # ide/host0/bus1/target0/lun0/disc -&gt; 2 -&gt; hdc
-        nr = int(l[1]) * 2 + int(l[3])
-        return 'hd' + chr(ord('a') + nr)
-    m = re.match('placeholder', device)
-    if m:
-        return 'sdX'
-    return device
-
-def dev(maj, min):
-    &quot;Convert major/minor pairs into device names&quot;
-    ram = [1, ]
-    ide = [3, 22, 33, 34, 56, 57, 88, 89, 90, 91]
-    loop = [7, ]
-    scsi = [8, 65, 66, 67, 68, 69, 70, 71, 128, 129, 130, 131, 132, 133, 134, 135]
-    md = [9, ]
-    ida = [72, 73, 74, 75, 76, 77, 78, 79]
-    ubd = [98,]
-    cciss = [104,]
-    dm =  [253,]
-    if maj in scsi:
-        disc = chr(ord('a') + scsi.index(maj) * 16 + min / 16)
-        part = min % 16
-        if not part: return 'sd%s' % disc
-        return 'sd%s%d' % (disc, part)
-    elif maj in ide:
-        disc = chr(ord('a') + ide.index(maj) * 2 + min / 64)
-        part = min % 64
-        if not part: return 'hd%s' % disc
-        return 'hd%s%d' % (disc, part)
-    elif maj in dm:
-        return 'dm-%d' % min
-    elif maj in md:
-        return 'md%d' % min
-    elif maj in loop:
-        return 'loop%d' % min
-    elif maj in ram:
-        return 'ram%d' % min
-    elif maj in cciss:
-        disc = cciss.index(maj) * 16 + min / 16
-        part = min % 16
-        if not part: return 'c0d%d' % disc
-        return 'c0d%dp%d' % (disc, part)
-    elif maj in ida:
-        cont = ida.index(maj)
-        disc = min / 16
-        part = min % 16
-        if not part: return 'ida%d-%d' % (cont, disc)
-        return 'ida%d-%d-%d' % (cont, disc, part)
-    elif maj in ubd:
-        disc = ubd.index(maj) * 16 + min / 16
-        part = min % 16
-        if not part: return 'ubd%d' % disc
-        return 'ubd%d-%d' % (disc, part)
-    else:
-        return 'dev%d-%d' % (maj, min)
-
-#def mountpoint(dev):
-#   &quot;Return the mountpoint of a mounted device/file&quot;
-#   for entry in dopen('/etc/mtab').readlines():
-#       if entry:
-#           devlist = string.split(entry)
-#           if dev == devlist[0]:
-#               return devlist[1]
-
-def readfile(file):
-    ret = ''
-    for line in open(file,'r').readlines():
-        ret = ret + line
-    return ret
-
-def exit(ret):
-    sys.stdout.write(ansi['reset'])
-    sys.exit(ret)
-
-def listmodules():
-    rows, cols = gettermsize()
-    print 'internal:\n\t',
-    remod = re.compile('dstat_(.+)$')
-    modlist = []
-    for filename in globals():
-        if filename.startswith('dstat_'):
-            modlist.append(remod.match(filename).groups()[0])
-    modlist.sort()
-    cols2 = cols - 8
-    for mod in modlist:
-        cols2 = cols2 - len(mod) - 2
-        if cols2 &lt;= 0:
-            print '\n\t',
-            cols2 = cols - len(mod) - 10
-        print mod + ',',
-    print
-    remod = re.compile('.+/dstat_(.+).py$')
-    for path in sys.path:
-        modlist = []
-        for filename in glob.glob(path + '/dstat_*.py'):
-            modlist.append(remod.match(filename).groups()[0])
-        if not modlist: continue
-        modlist.sort()
-        cols2 = cols - 8
-        print '%s:\n\t' % os.path.abspath(path),
-        for mod in modlist:
-            cols2 = cols2 - len(mod) - 2
-            if cols2 &lt;= 0:
-                print '\n\t',
-                cols2 = cols - len(mod) - 10
-            print mod + ',',
-        print
-
-def main():
-    global pagesize, cpunr, ansi, outputfile
-    global totlist, inittime
-    global update, missed
-
-    pagesize = resource.getpagesize()
-    cpunr = getcpunr()
-    interval = 1
-
-    user = getpass.getuser()
-    hostname = string.split(os.uname()[1], '.')[0]
-
-    ### Disable line-wrapping (does not work ?)
-    sys.stdout.write('\033[7l')
-
-    ### Write term-title
-    if sys.stdout.isatty():
-        shell = getenv('XTERM_SHELL')
-        term = getenv('TERM')
-        if shell == '/bin/bash' and term and re.compile('(screen*|xterm*)').match(term):
-            sys.stdout.write('\033]0;(%s@%s) %s %s\007' % (user, hostname, os.path.basename(sys.argv[0]), string.join(op.args, ' ')))
-
-    ### Check terminal capabilities
-    op.color = gettermcolor(op.color)
-
-    ### Prepare CSV output file
-    if op.output:
-        if os.path.exists(op.output):
-            outputfile = open(op.output, 'a', 0)
-            outputfile.write('\n\n')
-        else:
-            outputfile = open(op.output, 'w', 0)
-            outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
-            outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
-
-        outputfile.write('&quot;Host:&quot;,&quot;%s&quot;,,,,&quot;User:&quot;,&quot;%s&quot;\n' % (hostname, user))
-        outputfile.write('&quot;Cmdline:&quot;,&quot;dstat %s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n\n' % (' '.join(op.args), time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
-
-    ### Create pidfile
-    if op.pidfile:
-        try:
-            pidfile = open(op.pidfile, 'w', 0)
-            pidfile.write(str(os.getpid()))
-            pidfile.close()
-        except Exception, e:
-            print 'Failed to create pidfile %s' % op.pidfile, e
-            op.pidfile = False
-
-    ### Empty ansi database if no colors are requested
-    if not op.color:
-        op.update = False
-        for key in ansi.keys():
-            ansi[key] = ''
-#        print ansi['blackbg']
-
-    if not op.update:
-        interval = op.delay
-
-    ### Build list of requested modules
-    linewidth = 0
-    totlist = []
-    for module in op.modlist:
-        if module in ('list', 'help'):
-            listmodules()
-            exit(0)
-        elif module == 'cpu':  mods = ( 'cpu', 'cpu24' )
-        elif module == 'disk': mods = ( 'disk', 'disk24', 'disk24old' )
-        elif module == 'int':  mods = ( 'int', 'int24' )
-        elif module == 'page': mods = ( 'page', 'page24' )
-        elif module == 'swap': mods = ( 'swap', 'swapold' )
-        else: mods = ( module, )
-
-        for mod in mods:
-            try:
-                if 'dstat_'+mod not in globals().keys():
-                    import imp
-                    filename, pathname, description = imp.find_module('dstat_'+mod)
-
-                    ### Try loading python plugin
-                    if description[0] == '.py':
-#                           exec compile(readfile(pathname), pathname, 'exec')
-                            execfile(pathname)
-                            exec 'o = dstat_%s()' % mod
-
-                    ### Try loading C plugin
-                    elif description[0] == '.so':
-                        exec 'import dstat_%s' % mod
-                        exec 'o = dstat_%s.new()' % mod
-#                        exec 'o = dstat_%s.init(dstat)' % mod
-#                        print dir(o)
-#                        print o.__module__
-#                        print o.name
-                    else:
-                        print 'Module %s is of unknown type.' % mod
-
-                    ### Remove defect stat objects and calculate line length
-                    if not o.check():
-                        raise Exception, 'Unknown problem, please report'
-                else:
-                    exec 'o = dstat_%s()' % mod
-#                print o.__module__
-            except Exception, e:
-                if mod == mods[-1]:
-                    print 'Module %s failed to load. (%s)' % (mod, e)
-                elif op.debug:
-                    print 'Module %s failed to load, trying another. (%s)' % (mod, e)
-                if op.debug &gt;= 3:
-                    raise
-#                tb = sys.exc_info()[2]
-                continue
-
-            linewidth = linewidth + o.statwidth() + 1
-            totlist.append(o)
-            break
-
-    if not totlist:
-        die(8, 'None of the stats you selected are available.')
-
-    if op.debug:
-        for o in totlist:
-            print 'Module', string.split(str(o.__class__), '.')[1],
-            if hasattr(o, 'file'): print 'requires', o.file,
-            print
-
-    if op.output:
-        showcsvtitle(1, totlist)
-        showcsvtitle(2, totlist)
-
-    scheduler = sched.scheduler(time.time, time.sleep)
-    inittime = time.time()
-
-    update = 0
-    missed = 0
-
-    ### Let the games begin
-    while update &lt;= op.delay * op.count or op.count == -1:
-        scheduler.enterabs(inittime + update, 1, perform, (update,))
-#        scheduler.enter(1, 1, perform, (update,))
-        scheduler.run()
-        update = update + interval
-
-    if op.update:
-        sys.stdout.write('\n')
-
-def perform(update):
-        global totlist, oldvislist, vislist, showheader, rows, cols
-        global tick, totaltime, starttime
-        global loop, step, missed
-
-        starttime = time.time()
-
-        loop = (update - 1 + op.delay) / op.delay
-        step = ((update - 1) % op.delay) + 1
-
-        ### Get current time (may be different from schedule) for debugging
-        if not op.debug:
-            curwidth = 0
-        else:
-            if step == 1 or loop == 0:
-                totaltime = 0
-            curwidth = 8
-
-        ### FIXME: This is temporary functionality, we should do this better
-        ### If it takes longer than 500ms, than warn !
-        if loop != 0 and starttime - inittime - update &gt; 1:
-            missed = missed + 1
-            return 0
-
-        ### Initialise certain variables
-        if loop == 0:
-            tick = ticks()
-            rows, cols = 0, 0
-            vislist = []
-            oldvislist = []
-            showheader = True
-        else:
-            tick = step
-
-        ### FIXME: Make this part smarter
-        if sys.stdout.isatty():
-            oldcols = cols
-            rows, cols = gettermsize()
-
-            ### Trim object list to what is visible on screen
-            if oldcols != cols:
-                vislist = []
-                for o in totlist:
-                    newwidth = curwidth + o.statwidth() + 1
-                    if newwidth &lt;= cols or ( vislist == totlist[:-1] and newwidth &lt; cols ):
-                        vislist.append(o)
-                        curwidth = newwidth
-
-            ### Check when to display the header
-            if op.header and rows &gt;= 6:
-                if oldvislist != vislist:
-                    showheader = True
-                elif step == 1 and loop % (rows - 1) == 0:
-                    showheader = True
-
-            oldvislist = vislist
-        else:
-            vislist = totlist
-
-        ### The first step is to show the definitive line if necessary
-        if op.update:
-            if step == 1 and update != 0:
-                sys.stdout.write('\n' + ansi['reset'] + ansi['clearline'] + ansi['save'])
-            elif loop != 0:
-                sys.stdout.write(ansi['restore'])
-
-        ### Display header
-        if showheader:
-            if loop == 0 and totlist != vislist:
-                print 'Terminal width too small, trimming output.'
-            showheader = False
-            showtitle(1, totlist, vislist, ansi['darkblue'] + char['space'], ansi['darkblue'] + char['gt'])
-            showtitle(2, totlist, vislist, ansi['gray'] + char['pipe'], ansi['darkblue'] + char['gt'])
-
-        ### Prepare the colors for intermediate updates, last step in a loop is definitive
-        if step == op.delay:
-            ansi['default'] = ansi['reset']
-        else:
-            ansi['default'] = ansi['gray']
-
-        ### Calculate all objects (visible, invisible)
-        line = ''
-        oline = ''
-        for o in totlist:
-            o.extract()
-            if o in vislist:
-                line = line + o.show() + o.showend(totlist, vislist)
-            if op.output and step == op.delay:
-                oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
-
-        ### Print stats
-        sys.stdout.write(line)
-        if op.output and step == op.delay:
-            outputfile.write(oline + '\n')
-
-        ### Print debugging output
-        if op.debug:
-            totaltime = totaltime + (time.time() - starttime) * 1000.0
-            if loop == 0:
-                totaltime = totaltime * step
-            if op.debug == 1:
-                sys.stdout.write('%s%6.2fms%s' % (ansi['darkblue'], totaltime / step, ansi['default']))
-            elif op.debug == 2:
-                sys.stdout.write('%s%6.2f %s%d:%d%s' % (ansi['darkblue'], totaltime / step, ansi['darkred'], loop, step, ansi['default']))
-            elif op.debug &gt; 2:
-                sys.stdout.write('%s%6.2f %s%d:%d:%d%s' % (ansi['darkblue'], totaltime / step, ansi['darkred'], loop, step, update, ansi['default']))
-
-        if missed &gt; 0:
-#            sys.stdout.write(' '+ansi['redbg']+ansi['white']+'= warn =')
-            sys.stdout.write(' '+ansi['redbg']+ansi['white']+'missed '+str(missed+1)+' ticks')
-            missed = 0
-
-        ### Additional input in gray
-        sys.stdout.write(ansi['gray'])
-
-        ### Finish the line
-        if not op.update:
-            sys.stdout.write('\n')
-        sys.stdout.flush()
-
-### Main entrance
-if __name__ == '__main__':
-    try:
-        initterm()
-        op = Options(sys.argv[1:])
-        main()
-    except KeyboardInterrupt, e:
-        print ansi['default']
-
-    if op.pidfile and os.path.exists(op.pidfile):
-        os.remove(op.pidfile)
-
-    exit(0)
-else:
-    op = Options('')
-    step = 1
-
-# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_battery.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_battery.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_battery.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,20 +9,21 @@
         self.type = 'p'
         self.width = 4
         self.scale = 34
-        self.vars = []
+
+    def vars(self):
+        ret = []
         for battery in os.listdir('/proc/acpi/battery/'):
             for line in dopen('/proc/acpi/battery/'+battery+'/state').readlines():
                 l = line.split()
                 if len(l) &lt; 2: continue
                 if l[0] == 'present:' and l[1] == 'yes':
-                    self.vars.append(battery)
-        self.vars.sort()
-#       self.nick = [name.lower() for name in self.vars]
-        self.nick = []
-        for name in self.vars:
-            self.nick.append(name.lower())
-        self.init(self.vars, 1)
+                    ret.append(battery)
+        ret.sort()
+        return ret
 
+    def nick(self):
+        return [name.lower() for name in self.vars]
+
     def extract(self):
         for battery in self.vars:
             for line in dopen('/proc/acpi/battery/'+battery+'/info').readlines():

Modified: trunk/tools/dstat/plugins/dstat_cpufreq.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_cpufreq.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_cpufreq.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -12,25 +12,23 @@
         self.type = 'p'
         self.width = 4
         self.scale = 34
-#       self.vars = os.listdir('/sys/devices/system/cpu/')
-#       self.nick = [name.lower() for name in self.vars]
-        self.vars = []
-        self.nick = []
-        for name in glob.glob('/sys/devices/system/cpu/cpu[0-9]*'):
-            name = os.path.basename(name)
-            self.vars.append(name)
-            self.nick.append(name.lower())
-        self.nick.sort()
-        self.init(self.vars, 1)
 
     def check(self): 
-        if self.vars:
-            for cpu in self.vars:
-                if not os.access('/sys/devices/system/cpu/'+cpu+'/cpufreq/scaling_cur_freq', os.R_OK):
-                    raise Exception, 'Cannot access acpi '+cpu+' frequency information'
-            return True
-        raise Exception, 'No statistics found'
+        for cpu in glob.glob('/sys/devices/system/cpu/cpu[0-9]*'):
+            if not os.access(cpu+'/cpufreq/scaling_cur_freq', os.R_OK):
+                raise Exception, 'Cannot access acpi %s frequency information' % os.path.basename(cpu)
 
+    def vars(self):
+        ret = []
+        for name in glob.glob('/sys/devices/system/cpu/cpu[0-9]*'):
+            ret.append(os.path.basename(name))
+        ret.sort()
+        return ret
+#       return os.listdir('/sys/devices/system/cpu/')
+
+    def nick(self):
+        return [name.lower() for name in self.vars]
+
     def extract(self):
         for cpu in self.vars:
             for line in dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/scaling_max_freq').readlines():
@@ -41,14 +39,14 @@
                 cur = int(l[0])
             ### Need to close because of bug in sysfs (?)
             dclose('/sys/devices/system/cpu/'+cpu+'/cpufreq/scaling_cur_freq')
-            self.cn1[cpu] = self.cn1[cpu] + cur * 100.0 / max
+            self.set1[cpu] = self.set1[cpu] + cur * 100.0 / max
 
             if op.update:
-                self.val[cpu] = self.cn1[cpu] / tick
+                self.val[cpu] = self.set1[cpu] / tick
             else:
-                self.val[cpu] = self.cn1[cpu]
+                self.val[cpu] = self.set1[cpu]
 
             if step == op.delay:
-                self.cn1[cpu] = 0
+                self.set1[cpu] = 0
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_dbus.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_dbus.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_dbus.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -11,7 +11,6 @@
         self.scale = 100
         self.nick = ('sys', 'ses')
         self.vars = ('system', 'session')
-        self.init(self.vars, 1)
 
     def check(self): 
 #       dstat.info(1, 'The dbus module is an EXPERIMENTAL module.')
@@ -26,7 +25,6 @@
                     self.sesbus = None
             except:
                 raise Exception, 'Unable to connect to dbus message bus'
-            return True
         except:
             raise Exception, 'Needs python-dbus module'
 

Modified: trunk/tools/dstat/plugins/dstat_fan.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_fan.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_fan.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -4,15 +4,18 @@
         self.type = 'd'
         self.width = 4
         self.scale = 500
-        if os.path.exists('/proc/acpi/ibm/fan'):
-            for line in dopen('/proc/acpi/ibm/fan'):
-                l = line.split()
-                if l[0] == 'speed:':
-                    self.vars = ('speed',)
-            self.nick = self.vars
-        else:
+
+    def vars(self):
+        ret = None
+        for line in dopen('/proc/acpi/ibm/fan'):
+            l = line.split()
+            if l[0] == 'speed:':
+                ret = ('speed',)
+        return ret
+
+    def check(self):
+        if not os.path.exists('/proc/acpi/ibm/fan'):
             raise Exception, 'Needs kernel IBM-ACPI support'
-        self.init(self.vars, 1)
 
     def extract(self):
         if os.path.exists('/proc/acpi/ibm/fan'):

Modified: trunk/tools/dstat/plugins/dstat_freespace.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_freespace.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_freespace.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -5,17 +5,9 @@
 
 class dstat_freespace(dstat):
     def __init__(self):
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.open('/etc/mtab')
-        self.vars = self.vars()
-#       self.name = ['/' + os.path.basename(name) for name in self.vars]
-        self.name = []
-        for name in self.vars:
-            self.name.append('/' + os.path.basename(name))
         self.nick = ('used', 'free')
-        self.init(self.vars + ['total',], 2)
+        self.cols = 2
 
     def vars(self):
         ret = []
@@ -30,6 +22,9 @@
             ret.append(name)
         return ret
 
+    def name(self):
+        return ['/' + os.path.basename(name) for name in self.vars]
+
     def extract(self):
         self.val['total'] = (0, 0)
         for name in self.vars:

Modified: trunk/tools/dstat/plugins/dstat_gpfs.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_gpfs.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_gpfs.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -1,12 +1,8 @@
 class dstat_gpfs(dstat):
     def __init__(self):
         self.name = 'gpfs i/o'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.vars = ('_br_', '_bw_')
         self.nick = ('read', 'write')
-        self.init(self.vars, 1)
 
     def check(self): 
         if os.access('/usr/lpp/mmfs/bin/mmpmon', os.X_OK):
@@ -27,9 +23,9 @@
                 if not line: continue
                 l = line.split()
                 for name in self.vars:
-                    self.cn2[name] = long(l[l.index(name)+1])
+                    self.set2[name] = long(l[l.index(name)+1])
             for name in self.vars:
-                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         except IOError, e:
             for name in self.vars: self.val[name] = -1
 #           print 'dstat_gpfs: lost pipe to mmpmon,', e
@@ -38,6 +34,6 @@
 #           print 'dstat_gpfs: exception', e
 
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_gpfsop.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_gpfsop.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_gpfsop.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -6,7 +6,6 @@
         self.scale = 1000
         self.vars = ('_oc_', '_cc_', '_rdc_', '_wc_', '_dir_', '_iu_')
         self.nick = ('open', 'clos', 'read', 'writ', 'rdir', 'inod')
-        self.init(self.vars, 1)
 
     def check(self): 
         if os.access('/usr/lpp/mmfs/bin/mmpmon', os.X_OK):
@@ -27,9 +26,9 @@
                 if not line: continue
                 l = line.split()
                 for name in self.vars:
-                    self.cn2[name] = long(l[l.index(name)+1])
+                    self.set2[name] = long(l[l.index(name)+1])
             for name in self.vars:
-                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         except IOError, e:
             for name in self.vars: self.val[name] = -1
 #           print 'dstat_gpfs: lost pipe to mmpmon,', e
@@ -38,6 +37,6 @@
 #           print 'dstat_gpfs: exception', e
 
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_helloworld.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_helloworld.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_helloworld.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -5,13 +5,12 @@
 
 class dstat_helloworld(dstat):
     def __init__(self):
-        self.name = 'plugin title'
         self.type = 's'
         self.width = 12
         self.scale = 0
+        self.name = 'plugin title'
         self.nick = ('counter',)
         self.vars = ('text',)
-        self.init(self.vars, 1)
 
     def extract(self):
         self.val['text'] = 'Hello world!'

Modified: trunk/tools/dstat/plugins/dstat_innodb_buffer.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_innodb_buffer.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_innodb_buffer.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,9 +7,8 @@
         self.type = 'f'
         self.width = 3
         self.scale = 1000
-        self.vars = ('read', 'created', 'written')
+        self.vars = ('created', 'read', 'written')
         self.nick = ('crt', 'rea', 'wri')
-        self.init(self.vars, 1)
 
     def check(self): 
         if os.access('/usr/bin/mysql', os.X_OK):
@@ -27,15 +26,15 @@
 
             if line:
                 l = line.split()
-                self.cn2['read'] = int(l[2].rstrip(','))
-                self.cn2['created'] = int(l[4].rstrip(','))
-                self.cn2['written'] = int(l[6])
+                self.set2['read'] = int(l[2].rstrip(','))
+                self.set2['created'] = int(l[4].rstrip(','))
+                self.set2['written'] = int(l[6])
 
             for name in self.vars:
-                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except IOError, e:
             if op.debug: print 'dstat_innodb_buffer: lost pipe to mysql,', e

Modified: trunk/tools/dstat/plugins/dstat_innodb_io.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_innodb_io.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_innodb_io.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,9 +7,8 @@
         self.type = 'f'
         self.width = 3
         self.scale = 1000
-        self.vars = ('rea', 'wri', 'syn')
-        self.nick = self.vars
-        self.init(self.vars, 1)
+        self.vars = ('read', 'write', 'sync')
+        self.nick = ('rea', 'wri', 'syn')
 
     def check(self): 
         if os.access('/usr/bin/mysql', os.X_OK):
@@ -27,15 +26,15 @@
 
             if line:
                 l = line.split()
-                self.cn2['read'] = l[0].rstrip(',')
-                self.cn2['write'] = l[4].rstrip(',')
-                self.cn2['sync'] = l[8]
+                self.set2['read'] = l[0].rstrip(',')
+                self.set2['write'] = l[4].rstrip(',')
+                self.set2['sync'] = l[8]
 
             for name in self.vars:
-                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except IOError, e:
             if op.debug: print 'dstat_innodb_buffer: lost pipe to mysql,', e

Modified: trunk/tools/dstat/plugins/dstat_innodb_ops.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_innodb_ops.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_innodb_ops.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,7 +9,6 @@
         self.scale = 1000
         self.vars = ('inserted', 'updated', 'deleted', 'read')
         self.nick = ('ins', 'upd', 'del', 'rea')
-        self.init(self.vars, 1)
 
     def check(self): 
         if os.access('/usr/bin/mysql', os.X_OK):
@@ -27,16 +26,16 @@
 
             if line:
                 l = line.split()
-                self.cn2['inserted'] = l[4].rstrip(',')
-                self.cn2['updated'] = l[6].rstrip(',')
-                self.cn2['deleted'] = l[8].rstrip(',')
-                self.cn2['read'] = l[10]
+                self.set2['inserted'] = l[4].rstrip(',')
+                self.set2['updated'] = l[6].rstrip(',')
+                self.set2['deleted'] = l[8].rstrip(',')
+                self.set2['read'] = l[10]
 
             for name in self.vars:
-                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except IOError, e:
             if op.debug: print 'dstat_innodb_buffer: lost pipe to mysql,', e

Modified: trunk/tools/dstat/plugins/dstat_lustre.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_lustre.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_lustre.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -3,19 +3,25 @@
 
 class dstat_lustre(dstat):
     def __init__(self):
-        self.name = []
-        self.vars = []
-        if os.path.exists('/proc/fs/lustre/llite'):
-            for mount in os.listdir('/proc/fs/lustre/llite'):
-                self.vars.append(mount)
-                self.name.append(mount[:mount.rfind('-')])
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.nick = ('read', 'write')
-        self.init(self.vars, 2)
         info(1, 'Module dstat_lustre is still experimental.')
 
+    def name(self):
+        ret = []
+        for mount in os.listdir('/proc/fs/lustre/llite'):
+            ret.append(mount[:mount.rfind('-')])
+        return ret
+
+    def vars(self):
+        ret = []
+        for mount in os.listdir('/proc/fs/lustre/llite'):
+            ret.append(mount)
+        return ret
+
+    def check(self):
+        if not os.path.exists('/proc/fs/lustre/llite'):
+            raise Exception, 'Lustre filesystem not found'
+
     def extract(self):
         for name in self.vars:
             f = open('/'.join(['/proc/fs/lustre/llite',name,'stats']))
@@ -28,11 +34,11 @@
                 l = line.split()
                 if not l or l[0] != 'write_bytes': continue
                 write = long(l[6])
-            self.cn2[name] = (read, write)
-            self.val[name] = ( (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,\
-                               (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick ) 
+            self.set2[name] = (read, write)
+            self.val[name] = ( (self.set2[name][0] - self.set1[name][0]) * 1.0 / tick,\
+                               (self.set2[name][1] - self.set1[name][1]) * 1.0 / tick ) 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
 # vim:ts=4:sw=4
 # Authors

Modified: trunk/tools/dstat/plugins/dstat_memcache_hits.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_memcache_hits.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_memcache_hits.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -13,15 +13,12 @@
         self.vars = ('get_hits', 'get_misses')
         self.mc = memcache.Client(['127.0.0.1:11211'], debug=0)
 
-        self.init(self.vars, 1)
-
     def check(self):
         try:
             global memcache
             import memcache
         except:
             raise Exception, 'Plugin needs the memcache module.'
-        return True
 
     def extract(self):
         stats = self.mc.get_stats()

Modified: trunk/tools/dstat/plugins/dstat_mysql5_com.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_mysql5_com.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_mysql5_com.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -16,14 +16,12 @@
         self.scale = 1
         self.vars = ('Com_select', 'Com_insert','Com_update','Com_delete')
         self.nick = ('sel', 'ins','upd','del')
-        self.init(self.vars, 1)
 
     def check(self): 
-            try:
-                self.db=MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
-            except:
-                raise Exception, 'Cannot interface with MySQL server'
-            return True
+        try:
+            self.db = MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
+        except:
+            raise Exception, 'Cannot interface with MySQL server'
 
     def extract(self):
         try:
@@ -32,13 +30,13 @@
               c.execute(&quot;&quot;&quot;show global status like '%s';&quot;&quot;&quot; % name)
               line = c.fetchone()
               if line[0] in self.vars:
-                    self.cn2[line[0]] = int(line[1])
+                    self.set2[line[0]] = int(line[1])
 
             for name in self.vars:
-                self.val[name] = self.cn2[name] * 1.0 / tick
+                self.val[name] = self.set2[name] * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except Exception, e:
             for name in self.vars:

Modified: trunk/tools/dstat/plugins/dstat_mysql5_conn.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_mysql5_conn.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_mysql5_conn.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -16,14 +16,12 @@
         self.scale = 1
         self.vars = ('Threads_connected', 'Threads')
         self.nick = ('ThCon', '%Con')
-        self.init(self.vars, 1)
 
     def check(self): 
-            try:
-                self.db=MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
-            except:
-                raise Exception, 'Cannot interface with MySQL server'
-            return True
+        try:
+            self.db = MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
+        except:
+            raise Exception, 'Cannot interface with MySQL server'
 
     def extract(self):
         try:
@@ -33,14 +31,14 @@
             c.execute(&quot;&quot;&quot;show global status like 'Threads_connected';&quot;&quot;&quot;)
             thread = c.fetchone()
             if thread[0] in self.vars:
-                    self.cn2[thread[0]] = float(thread[1])
-                    self.cn2['Threads'] = (float(thread[1]) / float(max[1]) * float(100)) 
+                    self.set2[thread[0]] = float(thread[1])
+                    self.set2['Threads'] = (float(thread[1]) / float(max[1]) * float(100)) 
 
             for name in self.vars:
-                self.val[name] = self.cn2[name] * 1.0 /tick
+                self.val[name] = self.set2[name] * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except Exception, e:
             for name in self.vars:

Modified: trunk/tools/dstat/plugins/dstat_mysql5_io.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_mysql5_io.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_mysql5_io.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -11,19 +11,14 @@
 class dstat_mysql5_io(dstat):
     def __init__(self):
         self.name = 'mysql5 io'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.vars = ('Bytes_received', 'Bytes_sent')
         self.nick = ('recv', 'sent')
-        self.init(self.vars, 1)
 
     def check(self): 
-            try:
-                self.db=MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
-            except:
-                raise Exception, 'Cannot interface with MySQL server'
-            return True
+        try:
+            self.db = MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
+        except:
+            raise Exception, 'Cannot interface with MySQL server'
 
     def extract(self):
         try:
@@ -33,13 +28,13 @@
             for line in lines:
                 if len(line[1]) &lt; 2: continue
                 if line[0] in self.vars:
-                    self.cn2[line[0]] = float(line[1])
+                    self.set2[line[0]] = float(line[1])
 
             for name in self.vars:
-                self.val[name] = self.cn2[name] * 1.0 / tick
+                self.val[name] = self.set2[name] * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except Exception, e:
             for name in self.vars:

Modified: trunk/tools/dstat/plugins/dstat_mysql5_keys.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_mysql5_keys.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_mysql5_keys.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -16,14 +16,12 @@
         self.scale = 1000
         self.vars = ('Key_blocks_used', 'Key_reads', 'Key_writes', 'Key_read_requests', 'Key_write_requests')
         self.nick = ('used', 'read', 'writ', 'rreq', 'wreq')
-        self.init(self.vars, 1)
 
     def check(self): 
-            try:
-                self.db=MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
-            except:
-                raise Exception, 'Cannot interface with MySQL server'
-            return True
+        try:
+            self.db = MySQLdb.connect(user=mysql_user, passwd=mysql_pwd)
+        except:
+            raise Exception, 'Cannot interface with MySQL server'
 
     def extract(self):
         try:
@@ -33,13 +31,13 @@
             for line in lines:
                 if len(line[1]) &lt; 2: continue
                 if line[0] in self.vars:
-                    self.cn2[line[0]] = float(line[1])
+                    self.set2[line[0]] = float(line[1])
 
             for name in self.vars:
-                self.val[name] = self.cn2[name] * 1.0 / tick
+                self.val[name] = self.set2[name] * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except Exception, e:
             for name in self.vars:

Modified: trunk/tools/dstat/plugins/dstat_mysql_io.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_mysql_io.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_mysql_io.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -4,21 +4,16 @@
 class dstat_mysql_io(dstat):
     def __init__(self):
         self.name = 'mysql io'
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.vars = ('Bytes_received', 'Bytes_sent')
         self.nick = ('recv', 'sent')
-        self.init(self.vars, 1)
 
     def check(self): 
-        if os.access('/usr/bin/mysql', os.X_OK):
-            try:
-                self.stdin, self.stdout, self.stderr = dpopen('/usr/bin/mysql -n %s' % mysql_options)
-            except IOError:
-                raise Exception, 'Cannot interface with MySQL binary'
-            return True
-        raise Exception, 'Needs MySQL binary'
+        if not os.access('/usr/bin/mysql', os.X_OK):
+            raise Exception, 'Needs MySQL binary'
+        try:
+            self.stdin, self.stdout, self.stderr = dpopen('/usr/bin/mysql -n %s' % mysql_options)
+        except IOError:
+            raise Exception, 'Cannot interface with MySQL binary'
 
     def extract(self):
         try:
@@ -27,13 +22,13 @@
                 l = line.split()
                 if len(l) &lt; 2: continue
                 if l[0] in self.vars:
-                    self.cn2[l[0]] = float(l[1])
+                    self.set2[l[0]] = float(l[1])
 
             for name in self.vars:
-                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except IOError, e:
             if op.debug: print 'dstat_innodb_buffer: lost pipe to mysql,', e

Modified: trunk/tools/dstat/plugins/dstat_mysql_keys.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_mysql_keys.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_mysql_keys.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,16 +9,14 @@
         self.scale = 1000
         self.vars = ('Key_blocks_used', 'Key_reads', 'Key_writes', 'Key_read_requests', 'Key_write_requests')
         self.nick = ('used', 'read', 'writ', 'rreq', 'wreq')
-        self.init(self.vars, 1)
 
     def check(self): 
-        if os.access('/usr/bin/mysql', os.X_OK):
-            try:
-                self.stdin, self.stdout, self.stderr = dpopen('/usr/bin/mysql -n %s' % mysql_options)
-            except IOError:
-                raise Exception, 'Cannot interface with MySQL binary'
-            return True
-        raise Exception, 'Needs MySQL binary'
+        if not os.access('/usr/bin/mysql', os.X_OK):
+            raise Exception, 'Needs MySQL binary'
+        try:
+            self.stdin, self.stdout, self.stderr = dpopen('/usr/bin/mysql -n %s' % mysql_options)
+        except IOError:
+            raise Exception, 'Cannot interface with MySQL binary'
 
     def extract(self):
         try:
@@ -27,13 +25,13 @@
                 l = line.split()
                 if len(l) &lt; 2: continue
                 if l[0] in self.vars:
-                    self.cn2[l[0]] = float(l[1])
+                    self.set2[l[0]] = float(l[1])
 
             for name in self.vars:
-                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
 
             if step == op.delay:
-                self.cn1.update(self.cn2)
+                self.set1.update(self.set2)
 
         except IOError, e:
             if op.debug: print 'dstat_innodb_buffer: lost pipe to mysql,', e

Modified: trunk/tools/dstat/plugins/dstat_net_packets.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_net_packets.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_net_packets.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -6,10 +6,7 @@
         self.open('/proc/net/dev')
         self.nick = ('#recv', '#send')
         self.totalfilter = re.compile('^(lo|bond[0-9]+|face|.+\.[0-9]+)$')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = ['pkt/'+name for name in self.vars]
-        self.init(self.vars + ['total',], 2)
+        self.cols = 2
 
     def discover(self, *objlist):
         ret = []
@@ -40,21 +37,24 @@
             raise Exception, &quot;No suitable network interfaces found to monitor&quot;
         return ret
 
+    def name(self):
+        return ['pkt/'+name for name in self.vars]
+
     def extract(self):
-        self.cn2['total'] = [0, 0]
+        self.set2['total'] = [0, 0]
         for l in self.splitlines(replace=':'):
             if len(l) &lt; 17: continue
             if l[2] == '0' and l[10] == '0': continue
             name = l[0]
             if name in self.vars :
-                self.cn2[name] = ( long(l[2]), long(l[10]) )
+                self.set2[name] = ( long(l[2]), long(l[10]) )
             if not self.totalfilter.match(name):
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[10]))
+                self.set2['total'] = ( self.set2['total'][0] + long(l[2]), self.set2['total'][1] + long(l[10]))
         if update:
-            for name in self.cn2.keys():
+            for name in self.set2.keys():
                 self.val[name] = (
-                    (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-                    (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
+                    (self.set2[name][0] - self.set1[name][0]) * 1.0 / tick,
+                    (self.set2[name][1] - self.set1[name][1]) * 1.0 / tick,
                  )
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)

Modified: trunk/tools/dstat/plugins/dstat_nfs3.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfs3.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_nfs3.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,21 +7,20 @@
         self.open('/proc/net/rpc/nfs')
         self.vars = ('read', 'write', 'readdir', 'inode', 'filesystem', 'commit')
         self.nick = ('read', 'writ', 'rdir', 'inod', 'fs', 'cmmt')
-        self.init(self.vars, 1)
         info(1, 'Module dstat_nfs3 is still experimental.')
 
     def extract(self):
         for l in self.splitlines():
             if not l or l[0] != 'proc3': continue
-            self.cn2['read'] = long(l[8])
-            self.cn2['write'] = long(l[9])
-            self.cn2['readdir'] = long(l[17]) + long(l[18])
-            self.cn2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16])
-            self.cn2['filesystem'] = long(l[19]) + long(l[20]) + long(l[21])
-            self.cn2['commit'] = long(l[22])
+            self.set2['read'] = long(l[8])
+            self.set2['write'] = long(l[9])
+            self.set2['readdir'] = long(l[17]) + long(l[18])
+            self.set2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16])
+            self.set2['filesystem'] = long(l[19]) + long(l[20]) + long(l[21])
+            self.set2['commit'] = long(l[22])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_nfs3op.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfs3op.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_nfs3op.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,17 +7,16 @@
         self.open('/proc/net/rpc/nfs')
         self.vars = ('null', 'getattr', 'setattr', 'lookup', 'access', 'readlink', 'read', 'write', 'create', 'mkdir', 'symlink', 'mknod', 'remove', 'rmdir', 'rename', 'link', 'readdir', 'readdirplus', 'fsstat', 'fsinfo', 'pathconf', 'commit')
         self.nick = ('null', 'gatr', 'satr', 'look', 'aces', 'rdln', 'read', 'writ', 'crea', 'mkdr', 'syml', 'mknd', 'rm', 'rmdr', 'ren', 'link', 'rdir', 'rdr+', 'fstt', 'fsnf', 'path', 'cmmt')
-        self.init(self.vars, 1)
         info(1, 'Module dstat_nfs3op is still experimental.')
 
     def extract(self):
         for l in self.splitlines():
             if not l or l[0] != 'proc3': continue
             for i, name in enumerate(self.vars):
-                self.cn2[name] = long(l[i+2])
+                self.set2[name] = long(l[i+2])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_nfsd3.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfsd3.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_nfsd3.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,21 +7,20 @@
         self.open('/proc/net/rpc/nfsd')
         self.vars = ('read', 'write', 'readdir', 'inode', 'filesystem', 'commit')
         self.nick = ('read', 'writ', 'rdir', 'inod', 'fs', 'cmmt')
-        self.init(self.vars, 1)
         info(1, 'Module dstat_nfsd3 is still experimental.')
 
     def extract(self):
         for l in self.splitlines():
             if not l or l[0] != 'proc3': continue
-            self.cn2['read'] = long(l[8])
-            self.cn2['write'] = long(l[9])
-            self.cn2['readdir'] = long(l[18]) + long(l[19])
-            self.cn2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16]) + long(l[17])
-            self.cn2['filesystem'] = long(l[20]) + long(l[21]) + long(l[22])
-            self.cn2['commit'] = long(l[23])
+            self.set2['read'] = long(l[8])
+            self.set2['write'] = long(l[9])
+            self.set2['readdir'] = long(l[18]) + long(l[19])
+            self.set2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16]) + long(l[17])
+            self.set2['filesystem'] = long(l[20]) + long(l[21]) + long(l[22])
+            self.set2['commit'] = long(l[23])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_nfsd3op.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfsd3op.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_nfsd3op.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,17 +7,16 @@
         self.open('/proc/net/rpc/nfsd')
         self.vars = ('null', 'getattr', 'setattr', 'lookup', 'access', 'readlink', 'read', 'write', 'create', 'mkdir', 'symlink', 'mknod', 'remove', 'rmdir', 'rename', 'link', 'readdir', 'readdirplus', 'fsstat', 'fsinfo', 'pathconf', 'commit')
         self.nick = ('null', 'gatr', 'satr', 'look', 'aces', 'rdln', 'read', 'writ', 'crea', 'mkdr', 'syml', 'mknd', 'rm', 'rmdr', 'ren', 'link', 'rdir', 'rdr+', 'fstt', 'fsnf', 'path', 'cmmt')
-        self.init(self.vars, 1)
         info(1, 'Module dstat_nfsd3op is still experimental.')
 
     def extract(self):
         for l in self.splitlines():
             if not l or l[0] != 'proc3': continue
             for i, name in enumerate(self.vars):
-                self.cn2[name] = long(l[i+2])
+                self.set2[name] = long(l[i+2])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_ntp.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_ntp.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_ntp.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -31,7 +31,6 @@
 #        socket.setdefaulttimeout(0.25)
         self.socket = socket.socket( socket.AF_INET, socket.SOCK_DGRAM )
         self.socket.settimeout(0.25)
-        self.init(self.vars, 1)
 
     def gettime(self):
         try:
@@ -48,7 +47,6 @@
             raise Exception, 'Failed to connect to NTP server %s.' % self.ntpserver
         except socket.error:
             raise Exception, 'Error connecting to NTP server %s.' % self.ntpserver
-        return True
 
     def extract(self):
         self.val['time'] = self.gettime()

Modified: trunk/tools/dstat/plugins/dstat_postfix.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_postfix.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_postfix.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,12 +9,10 @@
         self.scale = 100
         self.vars = ('incoming', 'active', 'deferred', 'bounce', 'defer')
         self.nick = ('inco', 'actv', 'dfrd', 'bnce', 'defr')
-        self.init(self.vars, 1)
 
     def check(self):
         if not os.access('/var/spool/postfix/active', os.R_OK):
             raise Exception, 'Cannot access postfix queues'
-        return True
 
     def extract(self):
         for item in self.vars:

Modified: trunk/tools/dstat/plugins/dstat_power.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_power.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_power.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -11,20 +11,18 @@
         self.scale = 1
         self.vars = ( 'rate', )
         self.nick = ( 'usage', )
-        self.batteries = []
         self.rate = 0
+        self.batteries = []
         for battery in os.listdir('/proc/acpi/battery/'):
             for line in dopen('/proc/acpi/battery/'+battery+'/state').readlines():
                 l = line.split()
                 if len(l) &lt; 2: continue
                 self.batteries.append(battery)
                 break
-        self.init(self.vars, 1)
 
     def check(self):
         if not self.batteries:
             raise Exception, 'No battery information found, no power usage statistics'
-        return True
 
     def extract(self):
         amperes_drawn = 0

Modified: trunk/tools/dstat/plugins/dstat_rpc.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_rpc.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_rpc.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,16 +7,15 @@
         self.open('/proc/net/rpc/nfs')
         self.vars = ('calls', 'retransmits', 'autorefreshes')
         self.nick = ('call', 'retr', 'refr')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
             if not l or l[0] != 'rpc': continue
             for i, name in enumerate(self.vars):
-                self.cn2[name] = long(l[i+1])
+                self.set2[name] = long(l[i+1])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_rpcd.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_rpcd.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_rpcd.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -7,16 +7,15 @@
         self.open('/proc/net/rpc/nfsd')
         self.vars = ('calls', 'badcalls', 'badauth', 'badclnt', 'xdrcall')
         self.nick = ('call', 'erca', 'erau', 'ercl', 'xdrc')
-        self.init(self.vars, 1)
 
     def extract(self):
         for l in self.splitlines():
             if not l or l[0] != 'rpc': continue
             for i, name in enumerate(self.vars):
-                self.cn2[name] = long(l[i+1])
+                self.set2[name] = long(l[i+1])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_sendmail.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_sendmail.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_sendmail.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -10,12 +10,10 @@
         self.scale = 100
         self.vars = ('queue',)
         self.nick = ('queu',)
-        self.init(self.vars, 1)
 
     def check(self):
         if not os.access('/var/spool/mqueue', os.R_OK):
             raise Exception, 'Cannot access sendmail queue'
-        return True
 
     def extract(self):
         self.val['queue'] = len(glob.glob('/var/spool/mqueue/qf*'))

Modified: trunk/tools/dstat/plugins/dstat_snooze.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_snooze.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_snooze.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -4,10 +4,8 @@
         self.type = 's'
         self.width = 6
         self.scale = 0
-        self.nick = ('snooze',)
-        self.vars = self.nick
+        self.vars = ('snooze',)
         self.before = time.time()
-        self.init(self.vars, 1)
 
     def extract(self):
         now = time.time()

Modified: trunk/tools/dstat/plugins/dstat_thermal.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_thermal.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_thermal.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -21,7 +21,6 @@
                 self.nick.append(name.lower())
         else:
             raise Exception, 'Needs kernel ACPI or IBM-ACPI support'
-        self.init(self.vars, 1)
 
     def extract(self):
         if os.path.exists('/proc/acpi/ibm/thermal'):

Modified: trunk/tools/dstat/plugins/dstat_topbio.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_topbio.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_topbio.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -12,12 +12,11 @@
         self.nick = ('block i/o process',)
         self.vars = self.nick
         self.pid = str(os.getpid())
-        self.cn1 = {}; self.cn2 = {}; self.val = {}
+        self.pidset1 = {}; self.pidset2 = {}
 
     def check(self):
         if not os.access('/proc/self/io', os.R_OK):
             raise Exception, 'Kernel has no I/O accounting, use at least 2.6.20'
-        return True
 
     def extract(self):
         self.val['usage'] = 0.0
@@ -30,10 +29,10 @@
                 if pid == self.pid: continue
 
                 ### Reset values
-                if not self.cn2.has_key(pid):
-                    self.cn2[pid] = {'read_bytes:': 0, 'write_bytes:': 0}
-                if not self.cn1.has_key(pid):
-                    self.cn1[pid] = {'read_bytes:': 0, 'write_bytes:': 0}
+                if not self.pidset2.has_key(pid):
+                    self.pidset2[pid] = {'read_bytes:': 0, 'write_bytes:': 0}
+                if not self.pidset1.has_key(pid):
+                    self.pidset1[pid] = {'read_bytes:': 0, 'write_bytes:': 0}
 
                 ### Extract name
                 name = open('/proc/%s/stat' % pid).read().split()[1][1:-1]
@@ -42,15 +41,15 @@
                 for line in open('/proc/%s/io' % pid).readlines():
                     l = line.split()
                     if len(l) != 2: continue
-                    self.cn2[pid][l[0]] = int(l[1])
+                    self.pidset2[pid][l[0]] = int(l[1])
 
             except ValueError:
                 continue
             except IOError:
                 continue
 
-            read_usage = (self.cn2[pid]['read_bytes:'] - self.cn1[pid]['read_bytes:']) * 1.0 / tick
-            write_usage = (self.cn2[pid]['write_bytes:'] - self.cn1[pid]['write_bytes:']) * 1.0 / tick
+            read_usage = (self.pidset2[pid]['read_bytes:'] - self.pidset1[pid]['read_bytes:']) * 1.0 / tick
+            write_usage = (self.pidset2[pid]['write_bytes:'] - self.pidset1[pid]['write_bytes:']) * 1.0 / tick
             usage = read_usage + write_usage
 
             ### Get the process that spends the most jiffies
@@ -60,19 +59,19 @@
                 self.val['write_usage'] = write_usage
                 self.val['pid'] = pid
                 self.val['name'] = name
-                st = os.stat(&quot;/proc/%s&quot; % pid)
+#                st = os.stat(&quot;/proc/%s&quot; % pid)
 
         if self.val['usage'] == 0.0:
             self.val['process'] = ''
         else:
             self.val['process'] = os.path.basename(self.val['name'])
 
-            ### Debug (show PID)
-#           self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
+        ### Debug (show PID)
+#       self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
 
         if step == op.delay:
-            for pid in self.cn2.keys():
-                self.cn1[pid].update(self.cn2[pid])
+            for pid in self.pidset2.keys():
+                self.pidset1[pid].update(self.pidset2[pid])
 
     def show(self):
         if self.val['usage'] == 0.0:

Modified: trunk/tools/dstat/plugins/dstat_topcpu.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_topcpu.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_topcpu.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -11,10 +11,9 @@
         self.type = 's'
         self.width = 16
         self.scale = 0
-        self.nick = ('cpu process',)
-        self.vars = self.nick
+        self.vars = ('cpu process',)
         self.pid = str(os.getpid())
-        self.cn1 = {}; self.cn2 = {}; self.val = {}
+        self.pidset1 = {}; self.pidset2 = {}
 
     def extract(self):
         self.val['max'] = 0.0
@@ -31,11 +30,11 @@
                 if len(l) &lt; 15: continue
 
                 ### Reset previous value if it doesn't exist
-                if not self.cn1.has_key(pid):
-                    self.cn1[pid] = 0
+                if not self.pidset1.has_key(pid):
+                    self.pidset1[pid] = 0
 
-                self.cn2[pid] = int(l[13]) + int(l[14])
-                usage = (self.cn2[pid] - self.cn1[pid]) * 1.0 / tick / cpunr
+                self.pidset2[pid] = int(l[13]) + int(l[14])
+                usage = (self.pidset2[pid] - self.pidset1[pid]) * 1.0 / tick / cpunr
 
                 ### Is it a new topper ?
                 if usage &lt; self.val['max']: continue
@@ -73,11 +72,11 @@
 #                       self.val['name'] = os.path.basename(x)
 #                       break
 
-            ### Debug (show PID)
-#           self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
+        ### Debug (show PID)
+#       self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
 
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.pidset1.update(self.pidset2)
 
     def show(self):
         if self.val['max'] == 0.0:

Modified: trunk/tools/dstat/plugins/dstat_topio.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_topio.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_topio.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,15 +9,13 @@
         self.type = 's'
         self.width = 22
         self.scale = 0
-        self.nick = ('i/o process',)
-        self.vars = self.nick
+        self.vars = ('i/o process',)
         self.pid = str(os.getpid())
-        self.cn1 = {}; self.cn2 = {}; self.val = {}
+        self.pidset1 = {}; self.pidset2 = {}
 
     def check(self):
         if not os.access('/proc/self/io', os.R_OK):
             raise Exception, 'Kernel has no I/O accounting, use at least 2.6.20'
-        return True
 
     def extract(self):
         self.val['usage'] = 0.0
@@ -30,10 +28,10 @@
                 if pid == self.pid: continue
 
                 ### Reset values
-                if not self.cn2.has_key(pid):
-                    self.cn2[pid] = {'rchar:': 0, 'wchar:': 0}
-                if not self.cn1.has_key(pid):
-                    self.cn1[pid] = {'rchar:': 0, 'wchar:': 0}
+                if not self.pidset2.has_key(pid):
+                    self.pidset2[pid] = {'rchar:': 0, 'wchar:': 0}
+                if not self.pidset1.has_key(pid):
+                    self.pidset1[pid] = {'rchar:': 0, 'wchar:': 0}
 
                 ### Extract name
                 name = open('/proc/%s/stat' % pid).read().split()[1][1:-1]
@@ -42,15 +40,15 @@
                 for line in open('/proc/%s/io' % pid).readlines():
                     l = line.split()
                     if len(l) != 2: continue
-                    self.cn2[pid][l[0]] = int(l[1])
+                    self.pidset2[pid][l[0]] = int(l[1])
 
             except ValueError:
                 continue
             except IOError:
                 continue
 
-            read_usage = (self.cn2[pid]['rchar:'] - self.cn1[pid]['rchar:']) * 1.0 / tick
-            write_usage = (self.cn2[pid]['wchar:'] - self.cn1[pid]['wchar:']) * 1.0 / tick
+            read_usage = (self.pidset2[pid]['rchar:'] - self.pidset1[pid]['rchar:']) * 1.0 / tick
+            write_usage = (self.pidset2[pid]['wchar:'] - self.pidset1[pid]['wchar:']) * 1.0 / tick
             usage = read_usage + write_usage
 #            if usage &gt; 0.0:
 #                print '%s %s:%s' % (pid, read_usage, write_usage)
@@ -62,19 +60,19 @@
                 self.val['write_usage'] = write_usage
                 self.val['pid'] = pid
                 self.val['name'] = name
-                st = os.stat(&quot;/proc/%s&quot; % pid)
+#                st = os.stat(&quot;/proc/%s&quot; % pid)
 
         if self.val['usage'] == 0.0:
             self.val['process'] = ''
         else:
             self.val['process'] = os.path.basename(self.val['name'])
 
-            ### Debug (show PID)
-#           self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
+        ### Debug (show PID)
+#       self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
 
         if step == op.delay:
-            for pid in self.cn2.keys():
-                self.cn1[pid].update(self.cn2[pid])
+            for pid in self.pidset2.keys():
+                self.pidset1[pid].update(self.pidset2[pid])
 
     def show(self):
         if self.val['usage'] == 0.0:

Modified: trunk/tools/dstat/plugins/dstat_topmem.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_topmem.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_topmem.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,10 +9,8 @@
         self.type = 's'
         self.width = 16
         self.scale = 0
-        self.nick = ('memory process',)
-        self.vars = self.nick
+        self.vars = ('memory process',)
         self.pid = str(os.getpid())
-        self.cn1 = {}; self.cn2 = {}; self.val = {}
 
     def extract(self):
         self.val['max'] = 0.0
@@ -56,8 +54,8 @@
 #                       self.val['name'] = os.path.basename(x)
 #                       break
 
-            ### Debug (show PID)
-#           self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
+        ### Debug (show PID)
+#       self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
 
     def show(self):
         return '%s%-*s%s' % (ansi['default'], self.width-5, self.val['process'][0:self.width-5], cprint(self.val['max'], 'f', 5, 1024))

Modified: trunk/tools/dstat/plugins/dstat_topoom.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_topoom.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_topoom.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,15 +9,12 @@
         self.type = 's'
         self.width = 18
         self.scale = 0
-        self.nick = ('kill score',)
-        self.vars = self.nick
+        self.vars = ('kill score',)
         self.pid = str(os.getpid())
-        self.cn1 = {}; self.cn2 = {}; self.val = {}
 
     def check(self):
         if not os.access('/proc/self/oom_score', os.R_OK):
             raise Exception, 'Kernel does not support /proc/pid/oom_score, use at least 2.6.11.'
-        return True
 
     def extract(self):
         self.val['max'] = 0.0
@@ -55,8 +52,8 @@
         else:
             self.val['process'] = self.val['name']
 
-            ### Debug (show PID)
-#           self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
+        ### Debug (show PID)
+#       self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.width-6, self.val['name'])
 
     def show(self):
         if self.val['max'] == 0.0:

Modified: trunk/tools/dstat/plugins/dstat_utmp.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_utmp.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_utmp.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -6,13 +6,11 @@
         self.scale = 10
         self.nick = ('ses', 'usr', 'adm' )
         self.vars = ('sessions', 'users', 'root')
-        self.init(self.vars, 1)
 
     def check(self): 
         try:
             global utmp
             import utmp
-            return True
         except:
             raise Exception, 'Needs python-utmp module'
 

Modified: trunk/tools/dstat/plugins/dstat_vmkhba.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vmkhba.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_vmkhba.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -16,13 +16,9 @@
     def __init__(self):
         self.name = 'vmkhba'
         self.discover = self.discover()
-        self.type = 'f'
-        self.width = 5
-        self.scale = 1024
         self.nick = ('read', 'writ')
-        self.vars = self.vars()
-        self.name = self.vars
-        self.init(self.vars + ['total'], 2)
+        self.cols = 2
+        info(1, 'The vmkhba module is an EXPERIMENTAL module.')
 
     def discover(self, *list):
     # discover will list all vmhba's found.
@@ -57,18 +53,15 @@
         return ret
 
     def check(self): 
-        info(1, 'The vmkhba module is an EXPERIMENTAL module.')
-        ret = True
         try:
             os.listdir('/proc/vmware')
         except:
             raise Exception, 'Needs VMware ESX'
-        return ret
 
     def extract(self):
-        self.cn2['total'] = (0, 0)
+        self.set2['total'] = (0, 0)
         for name in self.vars:
-            self.cn2[name] = (0, 0)
+            self.set2[name] = (0, 0)
         for name in os.listdir('/proc/vmware/scsi/'):
             for line in dopen('/proc/vmware/scsi/%s/stats' % name).readlines():
                 l = line.split()
@@ -76,13 +69,13 @@
                 if l[0] == 'cmds': continue
                 if l[2] == '0' and l[4] == '0': continue
                 if l == ['0', ] * 13: continue
-                self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[4]) )
+                self.set2['total'] = ( self.set2['total'][0] + long(l[2]), self.set2['total'][1] + long(l[4]) )
                 if name in self.vars and name != 'total':
-                    self.cn2[name] = ( long(l[2]), long(l[4]) )
-            for name in self.cn2.keys():
+                    self.set2[name] = ( long(l[2]), long(l[4]) )
+            for name in self.set2.keys():
                 self.val[name] = (
-                    (self.cn2[name][0] - self.cn1[name][0]) * 1024.0 / tick,
-                    (self.cn2[name][1] - self.cn1[name][1]) * 1024.0 / tick
+                    (self.set2[name][0] - self.set1[name][0]) * 1024.0 / tick,
+                    (self.set2[name][1] - self.set1[name][1]) * 1024.0 / tick
                 )
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)

Modified: trunk/tools/dstat/plugins/dstat_vmkint.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vmkint.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_vmkint.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -20,9 +20,7 @@
         self.width = 4
         self.scale = 1000
 #       self.intmap = self.intmap()
-        self.vars = self.vars()
-        self.nick = self.vars
-        self.init(self.vars, 1)
+        info(1, 'The vmkint module is an EXPERIMENTAL module.')
 
 #   def intmap(self):
 #       ret = {}
@@ -76,14 +74,10 @@
         return ret
 
     def check(self): 
-        info(1, 'The vmkint module is an EXPERIMENTAL module.')
-        ret = True
         try:
             os.listdir('/proc/vmware')
         except:
-            ret = False
             raise Exception, 'Needs VMware ESX'
-        return ret
 
     def extract(self):
         self.fd[0].seek(0)
@@ -92,12 +86,12 @@
             if len(l) &lt; self.vmkcpunr()+1: continue
             name = l[0].split(':')[0]
             if name in self.vars:
-                self.cn2[name] = 0
+                self.set2[name] = 0
                 for i in l[1:1+self.vmkcpunr()]:
-                    self.cn2[name] = self.cn2[name] + long(i)
-        for name in self.cn2.keys():
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+                    self.set2[name] = self.set2[name] + long(i)
+        for name in self.set2.keys():
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/plugins/dstat_vmknic.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vmknic.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_vmknic.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -12,73 +12,67 @@
 # NB Data comes from /proc/vmware/net/tcpip/ifconfig
 
 class dstat_vmknic(dstat):
-	def __init__(self):
-		self.name = 'vmknic'
-		self.type = 'f'
-        self.width = 5
-        self.scale = 1024
-		self.open('/proc/vmware/net/tcpip/ifconfig')
-		self.nick = ('recv', 'send')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = ['net/'+name for name in self.vars]
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.name = 'vmknic'
+        self.open('/proc/vmware/net/tcpip/ifconfig')
+        self.nick = ('recv', 'send')
+        self.cols = 2
+        info(1, 'The vmknic module is an EXPERIMENTAL module.')
 
-	def discover(self, *list):
-		ret = []
-		for l in self.fd[0].splitlines(replace=' /', delim='/'):
-			if len(l) != 12: continue
-			if l[2][:5] == '&lt;Link': continue
-			if ','.join(l) == 'Name,Mtu/TSO,Network,Address,Ipkts,Ierrs,Ibytes,Opkts,Oerrs,Obytes,Coll,Time': continue
-			if l[0] == 'lo0': continue
-			if l[0] == 'Usage:': continue
-			ret.append(l[0])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for l in self.fd[0].splitlines(replace=' /', delim='/'):
+            if len(l) != 12: continue
+            if l[2][:5] == '&lt;Link': continue
+            if ','.join(l) == 'Name,Mtu/TSO,Network,Address,Ipkts,Ierrs,Ibytes,Opkts,Oerrs,Obytes,Coll,Time': continue
+            if l[0] == 'lo0': continue
+            if l[0] == 'Usage:': continue
+            ret.append(l[0])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.netlist:
-			list = op.netlist
-		else:
-			list = self.discover
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.netlist:
+            list = op.netlist
+        else:
+            list = self.discover
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def check(self): 
-		info(1, 'The vmknic module is an EXPERIMENTAL module.')
-		ret = True
-		try:
-			os.listdir('/proc/vmware')
-		except:
-			ret = False
-			raise Exception, 'Needs VMware ESX'
-		return ret
+    def name(self):
+        return ['net/'+name for name in self.vars]
 
-	def extract(self):
-		self.cn2['total'] = [0, 0]
-		for line in self.readlines():
-			l = line.replace(' /','/').split()
-			if len(l) != 12: continue
-			if l[2][:5] == '&lt;Link': continue
-			if ','.join(l) == 'Name,Mtu/TSO,Network,Address,Ipkts,Ierrs,Ibytes,Opkts,Oerrs,Obytes,Coll,Time': continue
-			if l[0] == 'Usage:': continue
-			name = l[0]
-			if name in self.vars:
-				self.cn2[name] = ( long(l[6]), long(l[9]) )
-			if name != 'lo0':
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[9]) )
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = (
-					(self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-					(self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
-				)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def check(self): 
+        try:
+            os.listdir('/proc/vmware')
+        except:
+            raise Exception, 'Needs VMware ESX'
 
+    def extract(self):
+        self.set2['total'] = [0, 0]
+        for line in self.readlines():
+            l = line.replace(' /','/').split()
+            if len(l) != 12: continue
+            if l[2][:5] == '&lt;Link': continue
+            if ','.join(l) == 'Name,Mtu/TSO,Network,Address,Ipkts,Ierrs,Ibytes,Opkts,Oerrs,Obytes,Coll,Time': continue
+            if l[0] == 'Usage:': continue
+            name = l[0]
+            if name in self.vars:
+                self.set2[name] = ( long(l[6]), long(l[9]) )
+            if name != 'lo0':
+                self.set2['total'] = ( self.set2['total'][0] + long(l[6]), self.set2['total'][1] + long(l[9]) )
+        if update:
+            for name in self.set2.keys():
+                self.val[name] = (
+                    (self.set2[name][0] - self.set1[name][0]) * 1.0 / tick,
+                    (self.set2[name][1] - self.set1[name][1]) * 1.0 / tick,
+                )
+        if step == op.delay:
+            self.set1.update(self.set2)
+
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/plugins/dstat_vmmemctl.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vmmemctl.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_vmmemctl.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -8,27 +8,26 @@
 # NB Data comes from /proc/vmmemctl
 
 class dstat_vmmemctl(dstat):
-	def __init__(self):
-		self.name = 'memctl'
-		self.type = 'f'
+    def __init__(self):
+        self.name = 'memctl'
+        self.type = 'f'
         self.width = 6
         self.scale = 1024
-		self.open('/proc/vmmemctl')
-		self.nick = ('size',)
-		self.vars = ('balloon',)
-		self.init(self.vars, 1)
+        self.open('/proc/vmmemctl')
+        self.nick = ('size',)
+        self.vars = ('balloon',)
 
-	def check(self): 
-		try:
-			os.stat('/proc/vmmemctl')
-		except:
-			raise Exception, 'Needs VMware Tools (modprobe vmmemctl)'
+    def check(self): 
+        try:
+            os.stat('/proc/vmmemctl')
+        except:
+            raise Exception, 'Needs VMware Tools (modprobe vmmemctl)'
 
-	def extract(self):
-		for l in self.splitlines():
-			if len(l) &lt; 3: continue
-			if l[0] != 'current:': continue
-			if l[2] != 'pages': continue
-			self.val['balloon'] = int(l[1]) * 4096.0
-			break
+    def extract(self):
+        for l in self.splitlines():
+            if len(l) &lt; 3: continue
+            if l[0] != 'current:': continue
+            if l[2] != 'pages': continue
+            self.val['balloon'] = int(l[1]) * 4096.0
+            break
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/plugins/dstat_vzcpu.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vzcpu.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_vzcpu.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -11,10 +11,7 @@
         self.scale = 34
         self.open('/proc/vz/vestat')
         self.nick = ('usr', 'sys', 'idl', 'nic')
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = self.name()
-        self.init(self.vars + ['total'], 4)
+        self.cols = 4
         info(1, 'Module dstat_vzcpu is still experimental.')
 
     def discover(self, *list):
@@ -47,16 +44,16 @@
         return ret
 
     def extract(self):
-        self.cn2['total'] = [0, 0, 0, 0]
+        self.set2['total'] = [0, 0, 0, 0]
         for line in self.splitlines():
             if len(l) &lt; 6 or l[0] == 'VEID': continue
             name = l[0]
-            self.cn2[name] = ( long(l[1]), long(l[3]), long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), long(l[2]) )
-            self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[3]), self.cn2['total'][2] + long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), self.cn2['total'][3] + long(l[2]) )
+            self.set2[name] = ( long(l[1]), long(l[3]), long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), long(l[2]) )
+            self.set2['total'] = ( self.set2['total'][0] + long(l[1]), self.set2['total'][1] + long(l[3]), self.set2['total'][2] + long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), self.set2['total'][3] + long(l[2]) )
         for name in self.vars:
             for i in range(4):
-                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+                self.val[name][i] = 100.0 * (self.set2[name][i] - self.set1[name][i]) / (sum(self.set2[name]) - sum(self.set1[name]))
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_vzubc.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vzubc.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_vzubc.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -5,10 +5,7 @@
         self.scale = 1000
         self.open('/proc/user_beancounters')
         self.nick = ('fcnt', )
-        self.discover = self.discover()
-        self.vars = self.vars()
-        self.name = self.name()
-        self.init(self.vars + ['total'], 1)
+        self.cols = 1 ### Is this correct ?
         info(1, 'Module dstat_vzubc is still experimental.')
 
     def discover(self, *list):
@@ -42,24 +39,24 @@
 
     def extract(self):
         for name in self.vars + ['total']:
-            self.cn2[name] = 0
+            self.set2[name] = 0
         for l in self.splitlines():
             if len(l) &lt; 6 or l[0] == 'uid':
                 continue
             elif len(l) == 7:
                 name = l[0][0:-1]
                 if name in self.vars:
-                    self.cn2[name] = self.cn2[name] + long(l[6])
-                self.cn2['total'] = self.cn2['total'] + long(l[6])
+                    self.set2[name] = self.set2[name] + long(l[6])
+                self.set2['total'] = self.set2['total'] + long(l[6])
             elif name == '0':
                 continue
             else:
                 if name in self.vars:
-                    self.cn2[name] = self.cn2[name] + long(l[5])
-                self.cn2['total'] = self.cn2['total'] + long(l[5])
+                    self.set2[name] = self.set2[name] + long(l[5])
+                self.set2['total'] = self.set2['total'] + long(l[5])
         for name in self.vars:
-            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+            self.val[name] = (self.set2[name] - self.set1[name]) * 1.0 / tick
         if step == op.delay:
-            self.cn1.update(self.cn2)
+            self.set1.update(self.set2)
 
 # vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_wifi.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_wifi.py	2009-10-30 18:53:13 UTC (rev 7973)
+++ trunk/tools/dstat/plugins/dstat_wifi.py	2009-11-01 00:25:38 UTC (rev 7974)
@@ -9,9 +9,8 @@
         self.scale = 33
         self.check()
         self.vars = iwlibs.getNICnames()
-        self.name = self.vars
         self.nick = ('lnk', 's/n')
-        self.init(self.vars, 2)
+        self.cols = 2
 
     def check(self): 
         global iwlibs
@@ -19,7 +18,6 @@
             from pythonwifi import iwlibs
         except:
             raise Exception, 'Needs python-wifi module'
-        return True
 
     def extract(self):
         for name in self.vars:


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="006771.html">[svn] r7975 - in trunk/tools/dstat: . docs plugins
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6770">[ date ]</a>
              <a href="thread.html#6770">[ thread ]</a>
              <a href="subject.html#6770">[ subject ]</a>
              <a href="author.html#6770">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
