<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r6434 - in trunk/rpms: alpine collectd perl-Algorithm-Cluster	perl-Algorithm-MedianSelect-XS perl-Alien-wxWidgets testdisk
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r6434%20-%20in%20trunk/rpms%3A%20alpine%20collectd%20perl-Algorithm-Cluster%0A%09perl-Algorithm-MedianSelect-XS%20perl-Alien-wxWidgets%20testdisk&In-Reply-To=%3C200807310054.m6V0sIhY022553%40surya.karan.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005232.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r6434 - in trunk/rpms: alpine collectd perl-Algorithm-Cluster	perl-Algorithm-MedianSelect-XS perl-Alien-wxWidgets testdisk</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r6434%20-%20in%20trunk/rpms%3A%20alpine%20collectd%20perl-Algorithm-Cluster%0A%09perl-Algorithm-MedianSelect-XS%20perl-Alien-wxWidgets%20testdisk&In-Reply-To=%3C200807310054.m6V0sIhY022553%40surya.karan.org%3E"
       TITLE="[svn] r6434 - in trunk/rpms: alpine collectd perl-Algorithm-Cluster	perl-Algorithm-MedianSelect-XS perl-Alien-wxWidgets testdisk">packagers at lists.rpmforge.net
       </A><BR>
    <I>Thu Jul 31 02:54:18 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="005232.html">[svn] r6433 - in trunk/rpms: fuse-unionfs	perl-Algorithm-Evolutionary perl-SOAP-Lite subversion txt2tags zvbi
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5233">[ date ]</a>
              <a href="thread.html#5233">[ thread ]</a>
              <a href="subject.html#5233">[ subject ]</a>
              <a href="author.html#5233">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2008-07-31 01:54:17 +0100 (Thu, 31 Jul 2008)
New Revision: 6434

Added:
   trunk/rpms/alpine/alpine-1.10-fillpara.patch
   trunk/rpms/alpine/alpine-1.10-maildir.patch
   trunk/rpms/alpine/alpine-1.10-rules.patch
   trunk/rpms/alpine/alpine-1.10-select-bold-x.patch
Modified:
   trunk/rpms/alpine/alpine.spec
   trunk/rpms/collectd/collectd.spec
   trunk/rpms/perl-Algorithm-Cluster/perl-Algorithm-Cluster.spec
   trunk/rpms/perl-Algorithm-MedianSelect-XS/perl-Algorithm-MedianSelect-XS.spec
   trunk/rpms/perl-Alien-wxWidgets/perl-Alien-wxWidgets.spec
   trunk/rpms/testdisk/testdisk.spec
Log:
Updates

Added: trunk/rpms/alpine/alpine-1.10-fillpara.patch
===================================================================
--- trunk/rpms/alpine/alpine-1.10-fillpara.patch	                        (rev 0)
+++ trunk/rpms/alpine/alpine-1.10-fillpara.patch	2008-07-31 00:54:17 UTC (rev 6434)
@@ -0,0 +1,3930 @@
+diff -rc alpine-1.10/alpine/mailview.c alpine-1.10.fillpara/alpine/mailview.c
+*** alpine-1.10/alpine/mailview.c	2008-03-03 13:37:30.000000000 -0800
+--- alpine-1.10.fillpara/alpine/mailview.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 205,211 ****
+--- 205,219 ----
+  int	    pcpine_view_cursor(int, long);
+  #endif
+  
++ static char *prefix;
++ #define NO_FLOWED  0x0000
++ #define IS_FLOWED  0x0001
++ #define DELETEQUO  0x0010
++ #define COLORAQUO  0x0100
++ #define RAWSTRING  0x1000
+  
++ int         is_word (char *, int, int);
++ int         is_mailbox(char *, int, int);
+  
+  /*----------------------------------------------------------------------
+       Format a buffer with the text of the current message for browser
+***************
+*** 296,301 ****
+--- 304,320 ----
+  	else
+  	  ps-&gt;unseen_in_view = !mc-&gt;seen;
+  
++ 	prefix = reply_quote_str(env);
++ 	/* Make sure the prefix is not only made of spaces, so that we do not
++ 	 * paint the screen incorrectly
++ 	 */
++ 	if (prefix &amp;&amp; *prefix){
++ 	   int i;
++ 	   for (i = 0; isspace((unsigned char) prefix[i]); i++);
++ 	   if (i == strlen(prefix))
++ 	     fs_give((void **)&amp;prefix);
++ 	}
++ 
+  	init_handles(&amp;handles);
+  
+  	store = so_get(src, NULL, EDIT_ACCESS);
+***************
+*** 459,464 ****
+--- 478,485 ----
+      }
+      while(ps-&gt;next_screen == SCREEN_FUN_NULL);
+  
++     if (prefix &amp;&amp; *prefix)
++        fs_give((void **)&amp;prefix);
+      if(we_cancel)
+        cancel_busy_cue(-1);
+  
+diff -rc alpine-1.10/pico/basic.c alpine-1.10.fillpara/pico/basic.c
+*** alpine-1.10/pico/basic.c	2007-11-26 15:45:22.000000000 -0800
+--- alpine-1.10.fillpara/pico/basic.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 25,33 ****
+   * framing, are hard.
+   */
+  #include        &quot;headers.h&quot;
+! 
+  #include &quot;osdep/terminal.h&quot;
+  
+  
+  /*
+   * Move the cursor to the
+--- 25,34 ----
+   * framing, are hard.
+   */
+  #include        &quot;headers.h&quot;
+! #include	&quot;../pith/osdep/color.h&quot;
+  #include &quot;osdep/terminal.h&quot;
+  
++ int	indent_match(char *, LINE *, char *, int, int);
+  
+  /*
+   * Move the cursor to the
+***************
+*** 284,290 ****
+  gotobop(int f, int n)
+  {
+      int quoted, qlen;
+!     UCS qstr[NLINE], qstr2[NLINE];
+  
+      if (n &lt; 0)	/* the other way...*/
+        return(gotoeop(f, -n));
+--- 285,291 ----
+  gotobop(int f, int n)
+  {
+      int quoted, qlen;
+!     char qstr[NLINE], qstr2[NLINE], ind_str[NLINE], pqstr[NLINE];;
+  
+      if (n &lt; 0)	/* the other way...*/
+        return(gotoeop(f, -n));
+***************
+*** 296,301 ****
+--- 297,310 ----
+  	    curwp-&gt;w_dotp = lback(curwp-&gt;w_dotp);
+  	    curwp-&gt;w_doto = 0;
+  	}
++ 
++ 	if (indent_match(default_qstr(), curwp-&gt;w_dotp,ind_str, NLINE, 0)){
++ 	   if (n){ /* look for another paragraph ? */
++ 	      curwp-&gt;w_dotp = lback(curwp-&gt;w_dotp);
++ 	      continue;
++ 	   }
++ 	   break;
++ 	}
+  	
+  	/* scan line by line until we come to a line ending with
+  	 * a &lt;NL&gt;&lt;NL&gt; or &lt;NL&gt;&lt;TAB&gt; or &lt;NL&gt;&lt;SPACE&gt;
+***************
+*** 303,322 ****
+  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
+  	 *	 line transition.
+  	 */
+! 	quoted = glo_quote_str ? quote_match(glo_quote_str, curwp-&gt;w_dotp, qstr, NLINE) : 0;
+! 	qlen   = quoted ? ucs4_strlen(qstr) : 0;
+  	while(lback(curwp-&gt;w_dotp) != curbp-&gt;b_linep
+  	      &amp;&amp; llength(lback(curwp-&gt;w_dotp)) &gt; qlen
+! 	      &amp;&amp; (glo_quote_str
+! 		  ? (quoted == quote_match(glo_quote_str,
+! 					   lback(curwp-&gt;w_dotp),
+! 					   qstr2, NLINE)
+! 		     &amp;&amp; !ucs4_strcmp(qstr, qstr2))
+! 		  : 1)
+  	      &amp;&amp; lgetc(curwp-&gt;w_dotp, qlen).c != TAB
+  	      &amp;&amp; lgetc(curwp-&gt;w_dotp, qlen).c != ' ')
+  	  curwp-&gt;w_dotp = lback(curwp-&gt;w_dotp);
+  
+  	if(n){
+  	    /* keep looking */
+  	    if(lback(curwp-&gt;w_dotp) == curbp-&gt;b_linep)
+--- 312,371 ----
+  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
+  	 *	 line transition.
+  	 */
+! 	quoted = quote_match(default_qstr(), curwp-&gt;w_dotp, qstr, NLINE, 0);
+! 	qlen   = quoted ? strlen(qstr) : 0;
+  	while(lback(curwp-&gt;w_dotp) != curbp-&gt;b_linep
+  	      &amp;&amp; llength(lback(curwp-&gt;w_dotp)) &gt; qlen
+! 	      &amp;&amp; (quoted == quote_match(default_qstr(),
+! 			lback(curwp-&gt;w_dotp), qstr2, NLINE, 0))
+! 	      &amp;&amp; !strcmp(qstr, qstr2)   /* processed string */
+! 	      &amp;&amp; (quoted == quote_match(default_qstr(),
+! 			lback(curwp-&gt;w_dotp), qstr2, NLINE, 1))
+! 	      &amp;&amp; !strcmp(qstr, qstr2)   /* raw string */
+! 	      &amp;&amp; !indent_match(default_qstr(),
+! 			lback(curwp-&gt;w_dotp),ind_str, NLINE, 0)
+  	      &amp;&amp; lgetc(curwp-&gt;w_dotp, qlen).c != TAB
+  	      &amp;&amp; lgetc(curwp-&gt;w_dotp, qlen).c != ' ')
+  	  curwp-&gt;w_dotp = lback(curwp-&gt;w_dotp);
+  
++ 	 /*
++ 	  * Ok, we made it here and we assume that we are at the begining
++ 	  * of the paragraph. Let's double check this now. In order to do
++ 	  * so we shell check if the first line was indented in a special
++ 	  * way.
++ 	  */
++ 	if(lback(curwp-&gt;w_dotp) == curbp-&gt;b_linep)
++ 	    break;
++ 	else{
++ 	     int i, j;
++ 
++ 	   /*
++ 	    * First we test if the preceding line is indented.
++ 	    * for the following test we need to have the raw values,
++ 	    * not the processed values
++ 	    */
++ 	   quote_match(default_qstr(), curwp-&gt;w_dotp, qstr, NLINE, 1);
++ 	   quote_match(default_qstr(), lback(curwp-&gt;w_dotp), qstr2, NLINE, 1);
++ 	   for (i = 0, j = 0;
++ 	        qstr[i] &amp;&amp; qstr2[i] &amp;&amp; (qstr[i] == qstr2[i]); i++, j++);
++ 	   for (; ISspace(qstr2[i]); i++);
++ 	   for (; ISspace(qstr[j]); j++);
++ 	   if ((indent_match(default_qstr(), lback(curwp-&gt;w_dotp),
++ 						ind_str, NLINE, 1)
++ 	       &amp;&amp; (strlenis(qstr2) 
++ 			+ strlenis(ind_str) &gt;= strlenis(qstr)))
++ 	      || (lback(curwp-&gt;w_dotp) != curbp-&gt;b_linep
++ 	         &amp;&amp; llength(lback(curwp-&gt;w_dotp)) &gt; qlen
++ 	         &amp;&amp; (quoted == quote_match(default_qstr(),
++ 				lback(curwp-&gt;w_dotp), pqstr, NLINE, 0))
++ 		 &amp;&amp; !strcmp(qstr, pqstr)
++ 		 &amp;&amp; lgetc(curwp-&gt;w_dotp, qlen).c != TAB
++ 		 &amp;&amp; lgetc(curwp-&gt;w_dotp, qlen).c != ' '
++ 		 &amp;&amp; (strlenis(qstr2) &gt; strlenis(qstr)))
++ 	         &amp;&amp; !qstr2[i] &amp;&amp; !qstr[j])
++ 		curwp-&gt;w_dotp = lback(curwp-&gt;w_dotp);
++ 	}
++ 
+  	if(n){
+  	    /* keep looking */
+  	    if(lback(curwp-&gt;w_dotp) == curbp-&gt;b_linep)
+***************
+*** 329,335 ****
+  	else{
+  	  /* leave cursor on first word in para */
+  	    curwp-&gt;w_doto = 0;
+! 	    while(ucs4_isspace(lgetc(curwp-&gt;w_dotp, curwp-&gt;w_doto).c))
+  	      if(++curwp-&gt;w_doto &gt;= llength(curwp-&gt;w_dotp)){
+  		  curwp-&gt;w_doto = 0;
+  		  curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp);
+--- 378,384 ----
+  	else{
+  	  /* leave cursor on first word in para */
+  	    curwp-&gt;w_doto = 0;
+! 	    while(ISspace(lgetc(curwp-&gt;w_dotp, curwp-&gt;w_doto).c))
+  	      if(++curwp-&gt;w_doto &gt;= llength(curwp-&gt;w_dotp)){
+  		  curwp-&gt;w_doto = 0;
+  		  curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp);
+***************
+*** 352,359 ****
+  int
+  gotoeop(int f, int n)
+  {
+!     int quoted, qlen;
+!     UCS qstr[NLINE], qstr2[NLINE];
+  
+      if (n &lt; 0)	/* the other way...*/
+        return(gotobop(f, -n));
+--- 401,409 ----
+  int
+  gotoeop(int f, int n)
+  {
+!     int quoted, qlen, indented, changeqstr = 0;
+!     int i,j, fli = 0; /* fli = first line indented a boolean variable */
+!     char qstr[NLINE], qstr2[NLINE], ind_str[NLINE];
+  
+      if (n &lt; 0)	/* the other way...*/
+        return(gotobop(f, -n));
+***************
+*** 366,390 ****
+  	      break;
+  	}
+  
+  	/* scan line by line until we come to a line ending with
+  	 * a &lt;NL&gt;&lt;NL&gt; or &lt;NL&gt;&lt;TAB&gt; or &lt;NL&gt;&lt;SPACE&gt;
+  	 *
+  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
+  	 *	 line transition.
+  	 */
+! 	quoted = glo_quote_str
+! 	  ? quote_match(glo_quote_str,
+! 			curwp-&gt;w_dotp, qstr, NLINE) : 0;
+! 	qlen   = quoted ? ucs4_strlen(qstr) : 0;
+  	
+  	while(curwp-&gt;w_dotp != curbp-&gt;b_linep
+  	      &amp;&amp; llength(lforw(curwp-&gt;w_dotp)) &gt; qlen
+! 	      &amp;&amp; (glo_quote_str
+! 		  ? (quoted == quote_match(glo_quote_str,
+! 					   lforw(curwp-&gt;w_dotp),
+! 					   qstr2, NLINE)
+! 		     &amp;&amp; !ucs4_strcmp(qstr, qstr2))
+! 		  : 1)
+  	      &amp;&amp; lgetc(lforw(curwp-&gt;w_dotp), qlen).c != TAB
+  	      &amp;&amp; lgetc(lforw(curwp-&gt;w_dotp), qlen).c != ' ')
+  	  curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp);
+--- 416,484 ----
+  	      break;
+  	}
+  
++ 	/*
++ 	 * We need to figure out if this line is the first line of
++ 	 * a paragraph that has been indented in a special way. If this
++ 	 * is the case, we advance one more line before we use the
++ 	 * algorithm below
++ 	 */
++ 
++ 	if(curwp-&gt;w_dotp != curbp-&gt;b_linep){
++ 	   quote_match(default_qstr(), curwp-&gt;w_dotp, qstr, NLINE, 1);
++ 	   quote_match(default_qstr(), lforw(curwp-&gt;w_dotp), qstr2, NLINE, 1);
++ 	   indented = indent_match(default_qstr(), curwp-&gt;w_dotp, ind_str,
++ 							NLINE, 1);
++ 	   if (strlenis(qstr) 
++ 		+ strlenis(ind_str) &lt; strlenis(qstr2)){
++ 		curwp-&gt;w_doto = llength(curwp-&gt;w_dotp);
++ 		if(n){    /* this line is a paragraph by itself */
++ 		   curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp);
++ 		   continue;
++ 		}
++ 		break;
++ 	   }
++ 	   for (i=0,j=0; qstr[i] &amp;&amp; qstr2[i] &amp;&amp; (qstr[i] == qstr2[i]);i++,j++);
++ 	   for (; ISspace(qstr[i]); i++);
++ 	   for (; ISspace(qstr2[j]); j++);
++ 	   if (!qstr[i] &amp;&amp; !qstr2[j] &amp;&amp; indented){
++ 		fli++;
++ 		if (indent_match(default_qstr(), lforw(curwp-&gt;w_dotp),
++ 					ind_str, NLINE, 0)){
++ 		    if (n){ /* look for another paragraph ? */
++ 		      curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp);
++ 		      continue;
++ 		    }
++ 		}
++ 		else{
++ 		  if (!lisblank(lforw(curwp-&gt;w_dotp)))
++ 		     curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp);
++ 		}
++ 	   }
++ 	}
++ 
+  	/* scan line by line until we come to a line ending with
+  	 * a &lt;NL&gt;&lt;NL&gt; or &lt;NL&gt;&lt;TAB&gt; or &lt;NL&gt;&lt;SPACE&gt;
+  	 *
+  	 * PLUS: if there's a quote string, a quoted-to-non-quoted
+  	 *	 line transition.
+  	 */
+! 	/* if the first line is indented (fli == 1), then the test below
+! 	   is on the second line, and in that case we will need the raw
+! 	   string, not the processed string
+! 	 */
+! 	quoted = quote_match(default_qstr(), curwp-&gt;w_dotp, qstr, NLINE, fli);
+! 	qlen   = quoted ? strlen(qstr) : 0;
+  	
+  	while(curwp-&gt;w_dotp != curbp-&gt;b_linep
+  	      &amp;&amp; llength(lforw(curwp-&gt;w_dotp)) &gt; qlen
+! 	      &amp;&amp; (quoted == quote_match(default_qstr(),
+! 				lforw(curwp-&gt;w_dotp), qstr2, NLINE, fli))
+! 	      &amp;&amp; !strcmp(qstr, qstr2)
+! 	      &amp;&amp; (quoted == quote_match(default_qstr(),
+! 				lforw(curwp-&gt;w_dotp), qstr2, NLINE, 1))
+! 	      &amp;&amp; !strcmp(qstr, qstr2)
+! 	      &amp;&amp; !indent_match(default_qstr(),
+! 				lforw(curwp-&gt;w_dotp), ind_str, NLINE, 0)
+  	      &amp;&amp; lgetc(lforw(curwp-&gt;w_dotp), qlen).c != TAB
+  	      &amp;&amp; lgetc(lforw(curwp-&gt;w_dotp), qlen).c != ' ')
+  	  curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp);
+diff -rc alpine-1.10/pico/efunc.h alpine-1.10.fillpara/pico/efunc.h
+*** alpine-1.10/pico/efunc.h	2007-11-06 15:51:13.000000000 -0800
+--- alpine-1.10.fillpara/pico/efunc.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 248,257 ****
+  extern	int fillpara(int, int);
+  extern	int fillbuf(int, int);
+  extern	int inword(void);
+! extern	int quote_match(UCS *, LINE *, UCS *, size_t);
+  extern	int ucs4_isalnum(UCS);
+  extern	int ucs4_isalpha(UCS);
+  extern	int ucs4_isspace(UCS);
+  extern	int ucs4_ispunct(UCS);
+  
+  #endif	/* EFUNC_H */
+--- 248,264 ----
+  extern	int fillpara(int, int);
+  extern	int fillbuf(int, int);
+  extern	int inword(void);
+! extern	int quote_match(char *, LINE *, char *, size_t, int);
+! extern	char *default_qstr(void);
+! extern	void flatten_qstring(QSTRING_S *, char *, int);
+! extern	void free_qs(QSTRING_S **);
+! extern	QSTRING_S *do_quote_match (char *, char *, char *, char *, char *, int, int);
+! extern	QSTRING_S *do_raw_quote_match(char *, char *, char *, char *, QSTRING_S **, QSTRING_S **);
+! extern  int indent_match(char *, LINE *, char *, int, int);
+  extern	int ucs4_isalnum(UCS);
+  extern	int ucs4_isalpha(UCS);
+  extern	int ucs4_isspace(UCS);
+  extern	int ucs4_ispunct(UCS);
+  
+  #endif	/* EFUNC_H */
++ 
+diff -rc alpine-1.10/pico/line.c alpine-1.10.fillpara/pico/line.c
+*** alpine-1.10/pico/line.c	2007-08-15 16:07:18.000000000 -0700
+--- alpine-1.10.fillpara/pico/line.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 607,620 ****
+  lisblank(LINE *line)
+  {
+      int n = 0;
+!     UCS qstr[NLINE];
+  
+!     n = (glo_quote_str
+! 	 &amp;&amp; quote_match(glo_quote_str, line, qstr, NLINE))
+! 	  ? ucs4_strlen(qstr) : 0;
+  
+      for(; n &lt; llength(line); n++)
+!       if(!ucs4_isspace(lgetc(line, n).c))
+  	return(FALSE);
+  
+      return(TRUE);
+--- 607,618 ----
+  lisblank(LINE *line)
+  {
+      int n = 0;
+!     char qstr[NLINE];
+  
+!     n = quote_match(default_qstr(), line, qstr, NLINE, 1);
+  
+      for(; n &lt; llength(line); n++)
+!       if(!ISspace(lgetc(line, n).c))
+  	return(FALSE);
+  
+      return(TRUE);
+diff -rc alpine-1.10/pico/search.c alpine-1.10.fillpara/pico/search.c
+*** alpine-1.10/pico/search.c	2008-01-04 14:49:15.000000000 -0800
+--- alpine-1.10.fillpara/pico/search.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 35,41 ****
+  int     readpattern(char *, int);
+  int     replace_pat(UCS *, int *);
+  int     replace_all(UCS *, UCS *);
+! 
+  
+  #define	FWS_RETURN(RV)	{				\
+  			    thisflag |= CFSRCH;		\
+--- 35,41 ----
+  int     readpattern(char *, int);
+  int     replace_pat(UCS *, int *);
+  int     replace_all(UCS *, UCS *);
+! int	deletepara(int, int);
+  
+  #define	FWS_RETURN(RV)	{				\
+  			    thisflag |= CFSRCH;		\
+***************
+*** 231,236 ****
+--- 231,241 ----
+  	    mlerase();
+  	    FWS_RETURN(TRUE);
+  
++ 	  case (CTRL|'P'):
++ 	    deletepara(0, 1);
++ 	    mlerase();
++ 	    FWS_RETURN(TRUE);
++ 
+  	  case  (CTRL|'R'):        /* toggle replacement option */
+  	    repl_mode = !repl_mode;
+  	    break;
+***************
+*** 597,603 ****
+  	UCS         *b;
+  	UCS	     prompt[NPMT];
+  	UCS         *promptp;
+! 	EXTRAKEYS    menu_pat[8];
+  
+  	menu_pat[i = 0].name = &quot;^Y&quot;;
+  	menu_pat[i].label    = N_(&quot;FirstLine&quot;);
+--- 602,608 ----
+  	UCS         *b;
+  	UCS	     prompt[NPMT];
+  	UCS         *promptp;
+! 	EXTRAKEYS    menu_pat[9];
+  
+  	menu_pat[i = 0].name = &quot;^Y&quot;;
+  	menu_pat[i].label    = N_(&quot;FirstLine&quot;);
+***************
+*** 631,636 ****
+--- 636,646 ----
+  	    menu_pat[i].key    = (CTRL|'O');
+  	    KS_OSDATASET(&amp;menu_pat[i], KS_NONE);
+  
++ 	    menu_pat[++i].name = &quot;^P&quot;;
++ 	    menu_pat[i].label  = N_(&quot;Delete Para&quot;);
++ 	    menu_pat[i].key    = (CTRL|'P');
++ 	    KS_OSDATASET(&amp;menu_pat[i], KS_NONE);
++ 
+  	    menu_pat[++i].name = &quot;^U&quot;;
+  	    /* TRANSLATORS: Instead of justifying (formatting) just a
+  	       single paragraph, Full Justify justifies the entire
+***************
+*** 766,772 ****
+  	UCS         *b;
+  	UCS	     tpat[NPAT+20];
+  	UCS         *tpatp;
+! 	EXTRAKEYS    menu_pat[7];
+  
+  	menu_pat[i = 0].name = &quot;^Y&quot;;
+  	menu_pat[i].label    = N_(&quot;FirstLine&quot;);
+--- 776,782 ----
+  	UCS         *b;
+  	UCS	     tpat[NPAT+20];
+  	UCS         *tpatp;
+! 	EXTRAKEYS    menu_pat[8];
+  
+  	menu_pat[i = 0].name = &quot;^Y&quot;;
+  	menu_pat[i].label    = N_(&quot;FirstLine&quot;);
+***************
+*** 794,799 ****
+--- 804,814 ----
+  	    menu_pat[i].key    = (CTRL|'O');
+  	    KS_OSDATASET(&amp;menu_pat[i], KS_NONE);
+  
++ 	    menu_pat[++i].name = &quot;^P&quot;;
++ 	    menu_pat[i].label  = N_(&quot;Delete Para&quot;);
++ 	    menu_pat[i].key    = (CTRL|'P');
++ 	    KS_OSDATASET(&amp;menu_pat[i], KS_NONE);
++ 
+  	    menu_pat[++i].name = &quot;^U&quot;;
+  	    menu_pat[i].label  = N_(&quot;FullJustify&quot;);
+  	    menu_pat[i].key    = (CTRL|'U');
+***************
+*** 1032,1034 ****
+--- 1047,1071 ----
+  
+      curwp-&gt;w_flag |= WFEDIT;
+  }
++ 
++ int
++ deletepara(int f, int n) /* Delete the current paragraph */
++ {
++    if(curbp-&gt;b_mode&amp;MDVIEW)           /* don't allow this command if  */ 
++      return(rdonly());               /* we are in read only mode     */
++    
++    if(!lisblank(curwp-&gt;w_dotp))
++      gotobop(FALSE, 1);
++ 
++    curwp-&gt;w_markp = curwp-&gt;w_dotp;
++    curwp-&gt;w_marko = 0;
++ 
++    gotoeop(FALSE, 1);
++    if (curwp-&gt;w_dotp != curbp-&gt;b_linep){ /* if we are not at the end of buffer */
++      curwp-&gt;w_dotp = lforw(curwp-&gt;w_dotp); /* get one more line */
++        curwp-&gt;w_doto = 0; /* but only the beginning */
++    }
++    killregion(f,n);
++    return(TRUE);
++ }
++ 
+diff -rc alpine-1.10/pico/word.c alpine-1.10.fillpara/pico/word.c
+*** alpine-1.10/pico/word.c	2007-08-20 12:46:37.000000000 -0700
+--- alpine-1.10.fillpara/pico/word.c	2008-05-19 16:33:00.000000000 -0700
+***************
+*** 24,33 ****
+   */
+  
+  #include	&quot;headers.h&quot;
+! 
+  
+  int fpnewline(UCS *quote);
+! int fillregion(UCS *qstr, REGION *addedregion);
+  int setquotelevelinregion(int quotelevel, REGION *addedregion);
+  int is_user_separator(UCS c);
+  
+--- 24,33 ----
+   */
+  
+  #include	&quot;headers.h&quot;
+! #include	&quot;../pith/osdep/color.h&quot;
+  
+  int fpnewline(UCS *quote);
+! int fillregion(UCS *qstr, UCS *istr, REGION *addedregion);
+  int setquotelevelinregion(int quotelevel, REGION *addedregion);
+  int is_user_separator(UCS c);
+  
+***************
+*** 430,471 ****
+      return 0;
+  }
+  
+  
+  /*
+   * Return number of quotes if whatever starts the line matches the quote string
+   */
+  int
+! quote_match(UCS *q, LINE *l, UCS *buf, size_t buflen)
+  {
+!     register int i, n, j, qb;
+  
+!     *buf = '\0';
+!     if(*q == '\0')
+!       return(1);
+! 
+!     qb = (ucs4_strlen(q) &gt; 1 &amp;&amp; q[ucs4_strlen(q)-1] == ' ') ? 1 : 0;
+!     for(n = 0, j = 0; ;){
+! 	for(i = 0; j &lt;= llength(l) &amp;&amp; qb ? q[i+1] : q[i]; i++, j++)
+! 	  if(q[i] != lgetc(l, j).c)
+! 	    return(n);
+! 
+! 	n++;
+! 	if((!qb &amp;&amp; q[i] == '\0') || (qb &amp;&amp; q[i+1] == '\0')){
+! 	    if(ucs4_strlen(buf) + ucs4_strlen(q) + 1 &lt; buflen){
+! 		ucs4_strncat(buf, q, buflen-ucs4_strlen(q)-1);
+! 		buf[buflen-1] = '\0';
+! 		if(qb &amp;&amp; (j &gt; llength(l) || lgetc(l, j).c != ' '))
+! 		  buf[ucs4_strlen(buf)-1] = '\0';
+! 	    }
+! 	}
+! 	if(j &gt; llength(l))
+! 	  return(n);
+! 	else if(qb &amp;&amp; lgetc(l, j).c == ' ')
+! 	  j++;
+      }
+!     return(n);  /* never reached */
+  }
+  
+  
+  /* Justify the entire buffer instead of just a paragraph */
+  int
+--- 430,600 ----
+      return 0;
+  }
+  
++ /* Support of indentation of paragraphs */
++ #define is_indent_char(c)  (((c) == '.' || (c) == '}' || (c) == RPAREN || \
++ 			     (c) == '*' || (c) == '+' || is_a_digit(c) || \
++ 			     ISspace(c) || (c) == '-' || \
++ 			     (c) == ']') ? 1 : 0)
++ #define allowed_after_digit(c,word,k)  ((((c) == '.' &amp;&amp; \
++ 			     allowed_after_period(next((word),(k))))  ||\
++ 				(c) == RPAREN || (c) == '}' || (c) == ']' ||\
++ 				  ISspace(c) ||  is_a_digit(c) || \
++ 				  ((c) == '-' ) &amp;&amp; \
++ 				    allowed_after_dash(next((word),(k)))) \
++ 				? 1 : 0)
++ #define allowed_after_period(c)	 (((c) == RPAREN || (c) == '}' || (c) == ']' ||\
++ 				   ISspace(c) || (c) == '-' || \
++ 				   is_a_digit(c)) ? 1 : 0)
++ #define allowed_after_parenth(c)  (ISspace(c) ? 1 : 0)
++ #define allowed_after_space(c)	  (ISspace(c) ? 1 : 0)
++ #define allowed_after_braces(c)	  (ISspace(c) ? 1 : 0)
++ #define allowed_after_star(c)	 ((ISspace(c) || (c) == RPAREN ||\
++                                        (c) == ']' || (c) == '}') ? 1 : 0)
++ #define allowed_after_dash(c)	  ((ISspace(c) || is_a_digit(c)) ? 1 : 0)
++ #define EOLchar(c)		  (((c) == '.' || (c) == ':' || (c) == '?' ||\
++ 					(c) == '!') ? 1 : 0)
++ 
++ int indent_match(char *, LINE *, char *, int, int);
++ 
++ /* Extended justification support */
++ #define is_cquote(c) ((c) == '&gt;' || (c) == '|' || (c) == ']' || (c) == ':')
++ #define is_cword(c)  ((((c) &gt;= 'a') &amp;&amp; ((c) &lt;= 'z')) ||  \
++                      (((c) &gt;= 'A') &amp;&amp; ((c) &lt;= 'Z')) || \
++                      (((c) &gt;= '0') &amp;&amp; ((c) &lt;= '9')) || \
++                       ((c) == ' ') || ((c) == '?') || \
++                       ((c) == '@') || ((c) == '.') || \
++                       ((c) == '!') || ((c) == '\'') || \
++                       ((c) == ',') || ((c) == '\&quot;') ? 1 : 0)
++ #define isaquote(c)   ((c) == '\&quot;' || (c) == '\'')
++ #define is8bit(c)     ((((int) (c)) &amp; 0x80) ? 1 : 0)
++ #define iscontrol(c)  (iscntrl(((int) (c)) &amp; 0x7f) ? 1 : 0)
++ #define forbidden(c)  (((c) == '\&quot;') || ((c) == '\'') || ((c) == '$') ||\
++                        ((c) == ',')  || ((c) == '.')  || ((c) == '-') ||\
++                        ((c) == LPAREN) || ((c) == '/')|| ((c) == '`') ||\
++                        ((c) == '{') || ((c) == '\\') || (iscontrol((c))) ||\
++                        (((c) &gt;= '0')  &amp;&amp; ((c) &lt;= '9')) || ((c) == '?'))
++ #define is_cletter(c)  ((((c) &gt;= 'a') &amp;&amp; ((c) &lt;= 'z'))) ||\
++                        ((((c) &gt;= 'A') &amp;&amp; ((c) &lt;= 'Z'))||\
++                       is8bit(c))
++ #define is_cnumber(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
++ #define allwd_after_word(c) (((c) == ' ') || ((c) == '&gt;') || is_cletter(c))
++ #define allwd_after_qsword(c)  (((c) != '\\') &amp;&amp; ((c) != RPAREN))
++ #define before(word,i) (((i) &gt; 0) ? (word)[(i) - 1] : 0)
++ #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
++ #define now(w,i)  ((w)[(i)])
++ #define is_qsword(c)  (((c) == ':') || ((c) == RPAREN) ? 1 : 0)
++ #define is_colon(c)   (((c) == ':') ? 1 : 0)
++ #define is_rarrow(c)  (((c) == '&gt;') ? 1 : 0)
++ #define is_tilde(c)   (((c) == '~') ? 1 : 0)
++ #define is_dash(c)    (((c) == '-') ? 1 : 0)
++ #define is_pound(c)   (((c) == '#') ? 1 : 0)
++ #define is_a_digit(c) ((((c) &gt;= '0') &amp;&amp; ((c) &lt;= '9')) ? 1 : 0)
++ #define is_allowed(c)  (is_cquote(c) || is_cword(c) || is_dash(c) || \
++                        is_pound(c))
++ #define qs_allowed(a)  (((a)-&gt;qstype != qsGdb) &amp;&amp; ((a)-&gt;qstype != qsProg))
++ 
++ /* Internal justification functions */
++ QSTRING_S *qs_quote_match(char *, LINE *, char *, int);
++ int      ucs4_strlenis(UCS *);
++ void     linencpy(char *, LINE *, int);
++ 
++ 
++ char *
++ default_qstr(void)
++ {
++   char *default_qs;
++   static char ucs_def[NSTRING] = {'\0'};
++ 
++   if(ucs_def[0] == '\0'){
++      default_qs = ucs4_to_utf8_cpystr(glo_quote_str);
++      strncpy(ucs_def, (default_qs ? default_qs : &quot;&quot;), NSTRING);
++      fs_give((void **)&amp;default_qs);
++   }
++ 
++   return glo_quote_str ? ucs_def : &quot;&quot;;
++ }
++ 
++ void
++ linencpy(word, l, buflen)
++  char word[NSTRING];
++  LINE *l;
++  int buflen;
++ {
++   int i;
++   UCS ucs_word[NSTRING];
++   char *utf_word;
++ 
++   word[0] = '\0';
++   if(l){
++     for (i = 0; i &lt; buflen &amp;&amp; i &lt; llength(l)
++                &amp;&amp; (ucs_word[i] = lgetc(l,i).c); i++);
++     ucs_word[i == buflen ? i-1 : i] = '\0';
++     utf_word = ucs4_to_utf8_cpystr(ucs_word);
++     strncpy(word, utf_word, (NSTRING &lt; buflen ? NSTRING : buflen));
++     word[NSTRING-1] = '\0';
++     if(utf_word) fs_give((void **)&amp;utf_word);
++   }
++ }
++ 
++  /*
++   * This function returns the quote string as a structure. In this way we
++   * have two ways to get the quote string: as a char * or as a QSTRING_S *
++   * directly.
++   */
++ QSTRING_S *
++ qs_quote_match(char *q, LINE *l, char *rqstr, int rqstrlen)
++ {
++     char GLine[NSTRING], NLine[NSTRING], PLine[NSTRING];
++     LINE *nl = l != curbp-&gt;b_linep ? lforw(l) : NULL;
++     LINE *pl = lback(l) != curbp-&gt;b_linep ? lback(l) : NULL;
++     int plb = 1;
++ 
++    linencpy(GLine, l, NSTRING);
++    linencpy(NLine, nl, NSTRING);
++ 
++    if (pl){
++       linencpy(PLine, pl, NSTRING);
++       if(lback(pl) != curbp-&gt;b_linep){
++ 	char PPLine[NSTRING];
++ 
++ 	linencpy(PPLine, lback(pl), NSTRING);
++ 	plb = line_isblank(q, PLine, GLine, PPLine, NSTRING);
++       }
++     }
++     return do_quote_match(q, GLine, NLine, PLine, rqstr, rqstrlen, plb);
++ }
+  
+  /*
+   * Return number of quotes if whatever starts the line matches the quote string
++  * rqstring is  pointer to raw qstring, buf points to processed qstring
+   */
+  int
+! quote_match(char *q, LINE *l, char *buf, size_t buflen, int raw)
+  {
+!     QSTRING_S *qs;
+!     char rqstr[NSTRING];
+  
+!     qs = qs_quote_match(q, l, rqstr, NSTRING);
+!     flatten_qstring(qs, buf, buflen);
+!     if (qs)
+!         free_qs(&amp;qs);
+! 
+!     if(raw){
+!       strncpy(buf, rqstr, buflen &lt; NSTRING ? buflen : NSTRING);
+!       buf[buflen-1] = '\0';
+      }
+! 
+!     return  buf &amp;&amp; buf[0] ? strlen(buf) : 0;
+  }
+  
++ int ucs4_strlenis(UCS *ucs_qstr)
++ {
++   char *str = ucs4_to_utf8_cpystr(ucs_qstr);
++   int i = (int) strlenis(str);
++ 
++   if(str) fs_give((void **)&amp;str);
++   return i;
++ }
+  
+  /* Justify the entire buffer instead of just a paragraph */
+  int
+***************
+*** 720,725 ****
+--- 849,855 ----
+      }
+  
+      if(action == 'R' &amp;&amp; curwp-&gt;w_markp){
++ 	char qstrfl[NSTRING];
+  	/* let yank() know that it may be restoring a paragraph */
+  	thisflag |= CFFILL;
+  
+***************
+*** 732,752 ****
+  
+  	/* determine if we're justifying quoted text or not */
+  	qstr = (glo_quote_str
+! 		&amp;&amp; quote_match(glo_quote_str, 
+! 			       curwp-&gt;w_doto &gt; 0 ? curwp-&gt;w_dotp-&gt;l_fp : curwp-&gt;w_dotp,
+! 			       qstr2, NSTRING)
+! 		&amp;&amp; *qstr2) ? qstr2 : NULL;
+! 
+  
+  	/*
+  	 * Fillregion moves dot to the end of the filled region.
+  	 */
+! 	if(!fillregion(qstr, &amp;addedregion))
+  	  return(FALSE);
+  
+  	set_last_region_added(&amp;addedregion);
+      }
+      else if(action == 'P'){
+  
+  	/*
+  	 * Justfiy the current paragraph.
+--- 862,886 ----
+  
+  	/* determine if we're justifying quoted text or not */
+  	qstr = (glo_quote_str
+! 		&amp;&amp; quote_match(default_qstr(), 
+! 			       (curwp-&gt;w_doto &gt; 0 ? curwp-&gt;w_dotp-&gt;l_fp : curwp-&gt;w_dotp),
+! 			       qstrfl, NSTRING, 0)
+! 		&amp;&amp; *qstrfl) ? utf8_to_ucs4_cpystr(qstrfl) : NULL;
+  
+  	/*
+  	 * Fillregion moves dot to the end of the filled region.
+  	 */
+! 	if(!fillregion(qstr, NULL, &amp;addedregion))
+  	  return(FALSE);
+  
+  	set_last_region_added(&amp;addedregion);
++ 
++ 	if(qstr)
++ 	  fs_give((void **)&amp;qstr);
+      }
+      else if(action == 'P'){
++ 	char ind_str[NSTRING], qstrfl[NSTRING];
++ 	UCS *istr;
+  
+  	/*
+  	 * Justfiy the current paragraph.
+***************
+*** 758,774 ****
+  	if(gotoeop(FALSE, 1) == FALSE)
+  	  return(FALSE);
+  
+- 	/* determine if we're justifying quoted text or not */
+- 	qstr = (glo_quote_str
+- 		&amp;&amp; quote_match(glo_quote_str, 
+- 			       curwp-&gt;w_dotp, qstr2, NSTRING)
+- 		&amp;&amp; *qstr2) ? qstr2 : NULL;
+- 
+  	setmark(0,0);			/* mark last line of para */
+  
+  	/* jump back to the beginning of the paragraph */
+  	gotobop(FALSE, 1);
+  
+  	/* let yank() know that it may be restoring a paragraph */
+  	thisflag |= (CFFILL | CFFLPA);
+  
+--- 892,907 ----
+  	if(gotoeop(FALSE, 1) == FALSE)
+  	  return(FALSE);
+  
+  	setmark(0,0);			/* mark last line of para */
+  
+  	/* jump back to the beginning of the paragraph */
+  	gotobop(FALSE, 1);
+  
++ 	istr = indent_match(default_qstr(), curwp-&gt;w_dotp, ind_str, NSTRING, 0)
++ 	   &amp;&amp; *ind_str  ? utf8_to_ucs4_cpystr(ind_str) : NULL;
++ 	qstr = (quote_match(default_qstr(), curwp-&gt;w_dotp, qstrfl, NSTRING, 0)
++             &amp;&amp; *qstrfl) ? utf8_to_ucs4_cpystr(qstrfl) : NULL;
++ 
+  	/* let yank() know that it may be restoring a paragraph */
+  	thisflag |= (CFFILL | CFFLPA);
+  
+***************
+*** 782,790 ****
+  	/*
+  	 * Fillregion moves dot to the end of the filled region.
+  	 */
+! 	if(!fillregion(qstr, &amp;addedregion))
+  	  return(FALSE);
+  
+  	set_last_region_added(&amp;addedregion);
+  
+  	/* Leave cursor on first char of first line after justified region */
+--- 915,929 ----
+  	/*
+  	 * Fillregion moves dot to the end of the filled region.
+  	 */
+! 	if(!fillregion(qstr, istr, &amp;addedregion))
+  	  return(FALSE);
+  
++ 	if(qstr)
++ 	  fs_give((void **)&amp;qstr);
++ 
++ 	if(istr)
++ 	  fs_give((void **)&amp;istr);
++ 
+  	set_last_region_added(&amp;addedregion);
+  
+  	/* Leave cursor on first char of first line after justified region */
+***************
+*** 826,841 ****
+   * can delete it and restore the saved part.
+   */
+  int
+! fillregion(UCS *qstr, REGION *addedregion)
+  {
+      long    c, sz, last_char = 0;
+!     int	    i, j, qlen, same_word,
+  	    spaces, word_len, word_ind, line_len, ww;
+      int     starts_midline = 0;
+      int     ends_midline = 0;
+      int     offset_into_start;
+      LINE   *line_before_start, *lp;
+!     UCS     line_last, word[NSTRING];
+      REGION  region;
+  
+      /* if region starts midline insert a newline */
+--- 965,980 ----
+   * can delete it and restore the saved part.
+   */
+  int
+! fillregion(UCS *qstr, UCS *istr, REGION *addedregion)
+  {
+      long    c, sz, last_char = 0;
+!     int	    i, j, qlen, same_word, qi, pqi, qlenis,
+  	    spaces, word_len, word_ind, line_len, ww;
+      int     starts_midline = 0;
+      int     ends_midline = 0;
+      int     offset_into_start;
+      LINE   *line_before_start, *lp;
+!     UCS     line_last, word[NSTRING], quoid[NSTRING], qstr2[NSTRING];
+      REGION  region;
+  
+      /* if region starts midline insert a newline */
+***************
+*** 846,851 ****
+--- 985,1020 ----
+      if(curwp-&gt;w_marko &gt; 0 &amp;&amp; curwp-&gt;w_marko &lt; llength(curwp-&gt;w_markp))
+        ends_midline++;
+  
++     for (i = 0; (i &lt; NSTRING) &amp;&amp; qstr &amp;&amp; (quoid[i] = qstr[i]); i++);
++     for (j = 0; ((i + j) &lt; NSTRING) &amp;&amp; istr &amp;&amp; (quoid[i] = istr[j]); i++,j++);
++     quoid[i] = '\0';
++     qi = ucs4_strlen(quoid);
++     if (istr)			/* strip trailing spaces */
++        for (;ISspace(quoid[qi - 1]); qi--);
++     quoid[qi] = '\0';     /* we have closed quoid at &quot;X&quot; in the first line */
++ 
++     if (ucs4_strlenis(quoid) &gt; fillcol)
++ 	return FALSE;		/* Too wide, we can't justify this! */
++ 
++     if (qstr &amp;&amp; istr){
++ 	for (i = ucs4_strlen(qstr) - 1; ISspace(qstr[i]); i--);
++ 	qstr[i + 1] = '\0';	/* qstrfl */
++     }
++     qlen   = ucs4_strlen(qstr);	/* qstrfl*/
++     qlenis = ucs4_strlenis(qstr);
++ 
++     for(i = 0, qstr2[0] = '\0'; qstr &amp;&amp; qstr[i] &amp;&amp; (qstr2[i] = qstr[i]); i++);
++ 
++     if (istr &amp;&amp; ((j = ucs4_strlenis(quoid) - ucs4_strlenis(qstr)) &gt; 0)){
++ 	pqi = ucs4_strlen(qstr);
++ 	for (i = 0; (i &lt; j) &amp;&amp; (qstr2[pqi + i] = ' '); i++);
++ 	if (ISspace(istr[ucs4_strlen(istr) - 1]))
++ 	   qstr2[pqi + i++] = ' ';
++ 	qstr2[pqi + i] = '\0';
++ /*	if (!qstr)*/
++ 	   qstr = qstr2;
++     }
++ 
+      /* cut the paragraph into our fill buffer */
+      fdelete();
+      if(!getregion(&amp;region, curwp-&gt;w_markp, curwp-&gt;w_marko))
+***************
+*** 862,886 ****
+  
+      /* Now insert it back wrapped */
+      spaces = word_len = word_ind = line_len = same_word = 0;
+-     qlen = qstr ? ucs4_strlen(qstr) : 0;
+  
+      /* Beginning with leading quoting... */
+!     if(qstr){
+  	i = 0;
+! 	while(qstr[i]){
+! 	  ww = wcellwidth(qstr[i]);
+  	  line_len += (ww &gt;= 0 ? ww : 1);
+! 	  linsert(1, qstr[i++]);
+  	}
+  
+  	line_last = ' ';			/* no word-flush space! */
+      }
+  
+      /* remove first leading quotes if any */
+      if(starts_midline)
+        i = 0;
+      else
+!       for(i = qlen; (c = fremove(i)) == ' ' || c == TAB; i++){
+  	  linsert(1, line_last = (UCS) c);
+  	  line_len += ((c == TAB) ? (~line_len &amp; 0x07) + 1 : 1);
+        }
+--- 1031,1055 ----
+  
+      /* Now insert it back wrapped */
+      spaces = word_len = word_ind = line_len = same_word = 0;
+  
+      /* Beginning with leading quoting... */
+!     if(qstr || istr){
+  	i = 0;
+! 	while(quoid[i]){
+! 	  ww = wcellwidth(quoid[i]);
+  	  line_len += (ww &gt;= 0 ? ww : 1);
+! 	  linsert(1, quoid[i++]);
+  	}
+  
+  	line_last = ' ';			/* no word-flush space! */
++         line_len = ucs4_strlenis(quoid);         /* we demand a recount! */
+      }
+  
+      /* remove first leading quotes if any */
+      if(starts_midline)
+        i = 0;
+      else
+!       for(i = ucs4_strlen(quoid); (c = fremove(i)) == ' ' || c == TAB; i++){
+  	  linsert(1, line_last = (UCS) c);
+  	  line_len += ((c == TAB) ? (~line_len &amp; 0x07) + 1 : 1);
+        }
+***************
+*** 911,925 ****
+  
+  	  default :
+  	    if(spaces){				/* flush word? */
+! 		if((line_len - qlen &gt; 0)
+  		   &amp;&amp; line_len + word_len + 1 &gt; fillcol
+! 		   &amp;&amp; ((ucs4_isspace(line_last))
+  		       || (linsert(1, ' ')))
+  		   &amp;&amp; (line_len = fpnewline(qstr)))
+  		  line_last = ' ';	/* no word-flush space! */
+  
+  		if(word_len){			/* word to write? */
+! 		    if(line_len &amp;&amp; !ucs4_isspace(line_last)){
+  			linsert(1, ' ');	/* need padding? */
+  			line_len++;
+  		    }
+--- 1080,1094 ----
+  
+  	  default :
+  	    if(spaces){				/* flush word? */
+! 		if((line_len - qlenis &gt; 0)
+  		   &amp;&amp; line_len + word_len + 1 &gt; fillcol
+! 		   &amp;&amp; ((ISspace(line_last))
+  		       || (linsert(1, ' ')))
+  		   &amp;&amp; (line_len = fpnewline(qstr)))
+  		  line_last = ' ';	/* no word-flush space! */
+  
+  		if(word_len){			/* word to write? */
+! 		    if(line_len &amp;&amp; !ISspace(line_last)){
+  			linsert(1, ' ');	/* need padding? */
+  			line_len++;
+  		    }
+***************
+*** 941,948 ****
+  
+  	    if(word_ind + 1 &gt;= NSTRING){
+  		/* Magic!  Fake that we output a wrapped word */
+! 		if((line_len - qlen &gt; 0) &amp;&amp; !same_word++){
+! 		    if(!ucs4_isspace(line_last))
+  		      linsert(1, ' ');
+  		    line_len = fpnewline(qstr);
+  		}
+--- 1110,1117 ----
+  
+  	    if(word_ind + 1 &gt;= NSTRING){
+  		/* Magic!  Fake that we output a wrapped word */
+! 		if((line_len - qlenis &gt; 0) &amp;&amp; !same_word++){
+! 		    if(!ISspace(line_last))
+  		      linsert(1, ' ');
+  		    line_len = fpnewline(qstr);
+  		}
+***************
+*** 964,975 ****
+      }
+  
+      if(word_len){
+! 	if((line_len - qlen &gt; 0) &amp;&amp; (line_len + word_len + 1 &gt; fillcol)){
+! 	    if(!ucs4_isspace(line_last))
+  	      linsert(1, ' ');
+  	    (void) fpnewline(qstr);
+  	}
+! 	else if(line_len &amp;&amp; !ucs4_isspace(line_last))
+  	  linsert(1, ' ');
+  
+  	for(j = 0; j &lt; word_ind; j++)
+--- 1133,1144 ----
+      }
+  
+      if(word_len){
+! 	if((line_len - qlenis &gt; 0) &amp;&amp; (line_len + word_len + 1 &gt; fillcol)){
+! 	    if(!ISspace(line_last))
+  	      linsert(1, ' ');
+  	    (void) fpnewline(qstr);
+  	}
+! 	else if(line_len &amp;&amp; !ISspace(line_last))
+  	  linsert(1, ' ');
+  
+  	for(j = 0; j &lt; word_ind; j++)
+***************
+*** 1027,1037 ****
+      int len;
+  
+      lnewline();
+!     for(len = 0; quote &amp;&amp; *quote; quote++){
+  	int ww;
+  
+! 	ww = wcellwidth(*quote);
+! 	len += (ww &gt;= 0 ? ww : 1);
+  	linsert(1, *quote);
+      }
+  
+--- 1196,1206 ----
+      int len;
+  
+      lnewline();
+!     for(len = ucs4_strlenis(quote); quote &amp;&amp; *quote; quote++){
+  	int ww;
+  
+! /*	ww = wcellwidth(*quote);
+! 	len += (ww &gt;= 0 ? ww : 1);*/
+  	linsert(1, *quote);
+      }
+  
+***************
+*** 1175,1179 ****
+--- 1344,1388 ----
+  	markregion(1);
+      }
+  
++     /*
++      * This puts us at the end of the quoted region instead
++      * of on the following line. This makes it convenient
++      * for the user to follow a quotelevel adjustment with
++      * a Justify if desired.
++      */
++     if(backuptoprevline){
++ 	curwp-&gt;w_doto = 0;
++ 	backchar(0, 1);
++     }
++ 
++     if(ends_midline){	/* doesn't need fixing otherwise */
++ 	unmarkbuffer();
++ 	markregion(1);
++     }
++ 
+      return (TRUE);
+  }
++ 
++ /*
++  * If there is an indent string this function returns
++  * its length
++  */ 
++ int
++ indent_match(char *q, LINE *l, char *buf, int buflen, int raw)
++ {
++      char GLine[NSTRING];
++      int  i, k, plb;
++        
++      k = quote_match(q,l, buf, buflen, raw);
++      linencpy(GLine, l, NSTRING);
++      plb = (lback(l) != curbp-&gt;b_linep) ? lisblank(lback(l)) : 1;
++      if (!plb){
++         i = llength(lback(l)) - 1;
++         for (; i &gt;= 0 &amp;&amp; ISspace(lgetc(lback(l), i).c); i--);
++         if (EOLchar(lgetc(lback(l), i).c))
++           plb++;
++      }      
++     
++      return get_indent_raw_line(q, GLine, buf, buflen, k, plb);
++ }
++ 
+diff -rc alpine-1.10/pith/charconv/utf8.c alpine-1.10.fillpara/pith/charconv/utf8.c
+*** alpine-1.10/pith/charconv/utf8.c	2008-01-08 09:04:58.000000000 -0800
+--- alpine-1.10.fillpara/pith/charconv/utf8.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 1048,1053 ****
+--- 1048,1103 ----
+  
+  
+  /*
++  * Returns the screen cells width of the UTF-8 string argument, treating tabs
++  * in a special way.
++  */
++ unsigned
++ utf8_widthis(char *str)
++ {
++     unsigned width = 0;
++     int this_width;
++     UCS ucs;
++     unsigned long remaining_octets;
++     char *readptr;
++ 
++     if(!(str &amp;&amp; *str))
++       return(width);
++ 
++     readptr = str;
++     remaining_octets = readptr ? strlen(readptr) : 0;
++ 
++     while(remaining_octets &gt; 0 &amp;&amp; *readptr){
++ 
++ 	ucs = (UCS) utf8_get((unsigned char **) &amp;readptr, &amp;remaining_octets);
++ 
++ 	if(ucs &amp; U8G_ERROR){
++ 	    /*
++ 	     * This should not happen, but do something to handle it anyway.
++ 	     * Treat each character as a single width character, which is what should
++ 	     * probably happen when we actually go to write it out.
++ 	     */
++ 	    remaining_octets--;
++ 	    readptr++;
++ 	    this_width = 1;
++ 	}
++ 	else{
++ 	    this_width = (ucs == TAB) ? ((~width &amp; 0x07) + 1) : wcellwidth(ucs);
++ 
++ 	    /*
++ 	     * If this_width is -1 that means we can't print this character
++ 	     * with our current locale. Writechar will print a '?'.
++ 	     */
++ 	    if(this_width &lt; 0)
++ 	      this_width = 1;
++ 	}
++ 
++ 	width += (unsigned) this_width;
++     }
++ 
++     return(width);
++ }
++ 
++ /*
+   * Copy UTF-8 characters from src into dst.
+   * This is intended to be used if you want to truncate a string at
+   * the start instead of the end. For example, you have a long string
+diff -rc alpine-1.10/pith/charconv/utf8.h alpine-1.10.fillpara/pith/charconv/utf8.h
+*** alpine-1.10/pith/charconv/utf8.h	2008-01-08 09:04:58.000000000 -0800
+--- alpine-1.10.fillpara/pith/charconv/utf8.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 80,85 ****
+--- 80,86 ----
+  UCS           *ucs4_strchr(UCS *s, UCS c);
+  UCS           *ucs4_strrchr(UCS *s, UCS c);
+  unsigned       utf8_width(char *);
++ unsigned       utf8_widthis(char *);
+  size_t         utf8_to_width_rhs(char *, char *, size_t, unsigned);
+  int            utf8_snprintf(char *, size_t, char *, ...);
+  size_t         utf8_to_width(char *, char *, size_t, unsigned, unsigned *);
+diff -rc alpine-1.10/pith/color.c alpine-1.10.fillpara/pith/color.c
+*** alpine-1.10/pith/color.c	2007-08-15 13:28:09.000000000 -0700
+--- alpine-1.10.fillpara/pith/color.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 20,26 ****
+  #include &quot;../pith/state.h&quot;
+  #include &quot;../pith/conf.h&quot;
+  #include &quot;../pith/filter.h&quot;
+! 
+  
+  char *
+  color_embed(char *fg, char *bg)
+--- 20,27 ----
+  #include &quot;../pith/state.h&quot;
+  #include &quot;../pith/conf.h&quot;
+  #include &quot;../pith/filter.h&quot;
+! #include &quot;../pith/mailview.h&quot;
+! #include &quot;../pico/estruct.h&quot;
+  
+  char *
+  color_embed(char *fg, char *bg)
+***************
+*** 69,91 ****
+      struct quote_colors *next;
+  };
+  
+  
+  int
+  color_a_quote(long int linenum, char *line, LT_INS_S **ins, void *is_flowed_msg)
+  {
+!     int countem = 0;
+      struct variable *vars = ps_global-&gt;vars;
+!     char *p;
+      struct quote_colors *colors = NULL, *cp, *next;
+      COLOR_PAIR *col = NULL;
+      int is_flowed = is_flowed_msg ? *((int *)is_flowed_msg) : 0;
+  
+      p = line;
+!     if(!is_flowed)
+!       while(isspace((unsigned char)*p))
+! 	p++;
+  
+!     if(p[0] == '&gt;'){
+  	struct quote_colors *c;
+  
+  	/*
+--- 70,179 ----
+      struct quote_colors *next;
+  };
+  
++ int
++ is_word (buf, i, j)
++  char buf[NSTRING];
++  int i, j;
++ {
++  return i &lt;= j &amp;&amp; is_letter(buf[i]) ?
++          (i &lt; j ? is_word(buf,i+1,j) : 1) : 0;
++ }
++ 
++ int
++ is_mailbox(buf,i,j)
++ char buf[NSTRING];
++  int i, j;
++ {
++   return i &lt;= j &amp;&amp; (is_letter(buf[i]) || is_digit(buf[i]) || buf[i] == '.')
++          ? (i &lt; j ? is_mailbox(buf,i+1,j) : 1) : 0;
++ }
++ 
++ int
++ next_level_quote(buf, line, i, is_flowed)
++    char *buf;
++    char **line;
++    int i;
++    int is_flowed;
++ {
++    int j;
++ 
++    if (!single_level(buf[i])){
++         if(is_mailbox(buf,i,i)){
++           for (j = i; buf[j] &amp;&amp; !isspace(buf[j]); j++);
++           if (is_word(buf,i,j-1) || is_mailbox(buf,i,j-1))
++            j += isspace(buf[j]) ? 2 : 1;
++         }
++         else{
++            switch(buf[i]){
++              case ':' :
++                       if (next(buf,i) != RPAREN)
++                            j = i + 1;
++                       else
++                            j = i + 2;
++                     break;
++ 
++              case '-' :
++                      if (next(buf,i) != '-')
++                         j = i + 2;
++                      else
++                         j = i + 3;
++                     break;
++ 
++              case '+' :
++              case '*' :
++                     if (next(buf,i) != ' ')
++                        j = i + 2;
++                     else
++                        j = i + 3;
++                     break;
++ 
++              default  :
++                    for (j = i; buf[j] &amp;&amp; !isspace(buf[j])
++                          &amp;&amp; (!single_level(buf[i]) &amp;&amp; !is_letter(buf[j])); j++);
++ 
++                    j += isspace(buf[j]) ? 1 : 0;
++                    break;
++              }
++         }
++         if (line &amp;&amp; *line)
++            (*line) += j - i;
++     }
++     else{
++        j = i+1;
++        if (line &amp;&amp; *line)
++           (*line)++;
++     }
++     if(!is_flowed){
++         if(line &amp;&amp; *line)
++           for(; isspace((unsigned char)*(*line)); (*line)++);
++         for (i = j; isspace((unsigned char) buf[i]); i++);
++     }
++     else i = j;
++     if (is_flowed &amp;&amp; i != j)
++        buf[i] = '\0';
++    return i;
++ }
+  
+  int
+  color_a_quote(long int linenum, char *line, LT_INS_S **ins, void *is_flowed_msg)
+  {
+!     int countem = 0, i, j = 0;
+      struct variable *vars = ps_global-&gt;vars;
+!     char *p, buf[NSTRING] = {'\0'};
+      struct quote_colors *colors = NULL, *cp, *next;
+      COLOR_PAIR *col = NULL;
+      int is_flowed = is_flowed_msg ? *((int *)is_flowed_msg) : 0;
++     int code;
++ 
++     code = (is_flowed ? IS_FLOWED : NO_FLOWED) | COLORAQUO;
++     select_quote(linenum, line, ins, (void *) &amp;code);
++     strncpy(buf, tmp_20k_buf, NSTRING &lt; SIZEOF_20KBUF ? NSTRING : SIZEOF_20KBUF);
++     buf[sizeof(buf)-1] = '\0';
+  
+      p = line;
+!     for(i = 0; isspace((unsigned char)buf[i]); i++, p++);
+  
+!     if(buf[i]){
+  	struct quote_colors *c;
+  
+  	/*
+***************
+*** 134,140 ****
+        free_color_pair(&amp;col);
+  
+      cp = NULL;
+!     while(*p == '&gt;'){
+  	cp = (cp &amp;&amp; cp-&gt;next) ? cp-&gt;next : colors;
+  
+  	if(countem &gt; 0)
+--- 222,228 ----
+        free_color_pair(&amp;col);
+  
+      cp = NULL;
+!     while(buf[i]){
+  	cp = (cp &amp;&amp; cp-&gt;next) ? cp-&gt;next : colors;
+  
+  	if(countem &gt; 0)
+***************
+*** 144,153 ****
+  
+  	countem = (countem == 1) ? 0 : countem;
+  
+! 	p++;
+! 	if(!is_flowed)
+! 	  for(; isspace((unsigned char)*p); p++)
+! 	    ;
+      }
+  
+      if(colors){
+--- 232,240 ----
+  
+  	countem = (countem == 1) ? 0 : countem;
+  
+!        i = next_level_quote(buf, &amp;p, i, is_flowed);
+!        for (; isspace((unsigned char)*p); p++);
+!        for (; isspace((unsigned char)buf[i]); i++);
+      }
+  
+      if(colors){
+***************
+*** 210,216 ****
+  	}
+      }
+  
+!     return(0);
+  }
+  
+  
+--- 297,303 ----
+  	}
+      }
+  
+!     return(1);
+  }
+  
+  
+diff -rc alpine-1.10/pith/color.h alpine-1.10.fillpara/pith/color.h
+*** alpine-1.10/pith/color.h	2007-05-08 16:38:08.000000000 -0700
+--- alpine-1.10.fillpara/pith/color.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 21,26 ****
+--- 21,44 ----
+  #include &quot;../pith/pattern.h&quot;
+  #include &quot;../pith/osdep/color.h&quot;
+  
++ #define NO_FLOWED  0x0000
++ #define IS_FLOWED  0x0001
++ #define DELETEQUO  0x0010
++ #define COLORAQUO  0x0100
++ #define RAWSTRING  0x1000
++ 
++ /* This is needed for justification, I will move it to a better place later
++  * or maybe not
++  */
++ #define is_digit(c) ((((c) &gt;= '0') &amp;&amp; ((c) &lt;= '9')) ? 1 : 0)
++ 
++ #define is_letter(c) (((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') || \
++                          ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z'))
++ 
++ #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
++ 
++ #define single_level(c) (((c) == '&gt;') || ((c) == '|') || ((c) == '~') || \
++                           ((c) == ']'))
+  
+  typedef struct spec_color_s {
+      int   inherit;	/* this isn't a color, it is INHERIT */
+***************
+*** 80,85 ****
+--- 98,104 ----
+  /* exported protoypes */
+  char	*color_embed(char *, char *);
+  int	 colorcmp(char *, char *);
++ int	 next_level_quote(char *, char **, int, int);
+  int	 color_a_quote(long, char *, LT_INS_S **, void *);
+  void	 free_spec_colors(SPEC_COLOR_S **);
+  
+diff -rc alpine-1.10/pith/filter.c alpine-1.10.fillpara/pith/filter.c
+*** alpine-1.10/pith/filter.c	2008-03-07 11:30:14.000000000 -0800
+--- alpine-1.10.fillpara/pith/filter.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 45,50 ****
+--- 45,51 ----
+  #include &quot;../pith/conf.h&quot;
+  #include &quot;../pith/store.h&quot;
+  #include &quot;../pith/color.h&quot;
++ #include &quot;../pith/osdep/color.h&quot;
+  #include &quot;../pith/escapes.h&quot;
+  #include &quot;../pith/pipe.h&quot;
+  #include &quot;../pith/status.h&quot;
+***************
+*** 8705,8710 ****
+--- 8706,8716 ----
+  		margin_r,
+  		indent;
+      char	special[256];
++     long	curlinenum;	/* current line number */
++     int		curqstrpos;	/* current position in quote string */
++     long	linenum;	/* line number */
++     long	qstrlen;	/* multiples of 100 */
++     char      **qstrln;		/* qstrln[i] = quote string line i - 1 */
+  } WRAP_S;
+  
+  #define	WRAP_MARG_L(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;margin_l)
+***************
+*** 8746,8751 ****
+--- 8752,8763 ----
+  #define	WRAP_COLOR(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;color)
+  #define	WRAP_COLOR_SET(F)  ((WRAP_COLOR(F)) &amp;&amp; (WRAP_COLOR(F)-&gt;fg[0]))
+  #define	WRAP_SPACES(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;spaces)
++ #define	WRAP_CURLINE(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;curlinenum)
++ #define	WRAP_CURPOS(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;curqstrpos)
++ #define	WRAP_LINENUM(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;linenum)
++ #define	WRAP_QSTRLEN(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;qstrlen)
++ #define	WRAP_QSTRN(F)	(((WRAP_S *)(F)-&gt;opt)-&gt;qstrln)
++ #define	WRAP_QSTR(F, N)	(((WRAP_S *)(F)-&gt;opt)-&gt;qstrln[(N)])
+  #define	WRAP_PUTC(F,C,W) {						\
+  			    if((F)-&gt;linep == WRAP_LASTC(F)){		\
+  				size_t offset = (F)-&gt;linep - (F)-&gt;line;	\
+***************
+*** 8823,8828 ****
+--- 8835,8842 ----
+  	      case CCR :				/* CRLF or CR in text ? */
+  		state = BOL;				/* either way, handle start */
+  
++ 		WRAP_CURLINE(f)++;
++ 		WRAP_CURPOS(f) = 0;
+  		if(WRAP_FLOW(f)){
+  		    /* wrapped line? */
+  		    if(f-&gt;f2 == 0 &amp;&amp; WRAP_SPC_LEN(f) &amp;&amp; WRAP_TRL_SPC(f)){
+***************
+*** 8916,8922 ****
+  
+  	      case BOL :
+  		if(WRAP_FLOW(f)){
+! 		    if(c == '&gt;'){
+  			WRAP_FL_QC(f) = 1;		/* init it */
+  			state = FL_QLEV;		/* go collect it */
+  		    }
+--- 8930,8940 ----
+  
+  	      case BOL :
+  		if(WRAP_FLOW(f)){
+! 		    if(WRAP_CURLINE(f) &lt; WRAP_QSTRLEN(f) 
+! 			&amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f)) 
+! 			&amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)]
+! 			&amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)] == c){
+! 			WRAP_CURPOS(f)++;
+  			WRAP_FL_QC(f) = 1;		/* init it */
+  			state = FL_QLEV;		/* go collect it */
+  		    }
+***************
+*** 8930,8936 ****
+  			}
+  
+  			/* quote level change implies new paragraph */
+! 			if(WRAP_FL_QD(f)){
+  			    WRAP_FL_QD(f) = 0;
+  			    if(WRAP_HARD(f) == 0){
+  				WRAP_HARD(f) = 1;
+--- 8948,8963 ----
+  			}
+  
+  			/* quote level change implies new paragraph */
+! 			if (WRAP_CURLINE(f) &gt; 0 
+! 			&amp;&amp; WRAP_CURLINE(f) &lt; WRAP_QSTRLEN(f)
+! 			&amp;&amp; (WRAP_QSTR(f, WRAP_CURLINE(f)) != NULL
+! 			     || WRAP_QSTR(f, WRAP_CURLINE(f) - 1) != NULL)
+! 			&amp;&amp; ((WRAP_QSTR(f, WRAP_CURLINE(f)) != NULL &amp;&amp; 
+! 			     WRAP_QSTR(f, WRAP_CURLINE(f) - 1) == NULL)
+! 			   || (WRAP_QSTR(f, WRAP_CURLINE(f)) == NULL &amp;&amp; 
+! 			       WRAP_QSTR(f, WRAP_CURLINE(f) - 1) != NULL)
+! 			   || strcmp(WRAP_QSTR(f, WRAP_CURLINE(f)),
+! 				     WRAP_QSTR(f, WRAP_CURLINE(f) - 1)))){
+  			    WRAP_FL_QD(f) = 0;
+  			    if(WRAP_HARD(f) == 0){
+  				WRAP_HARD(f) = 1;
+***************
+*** 8982,8989 ****
+  		break;
+  
+  	      case  FL_QLEV :
+! 		if(c == '&gt;'){				/* another level */
+! 		    WRAP_FL_QC(f)++;
+  		}
+  		else {
+  		    /* if EMBEDed, process it and return here */
+--- 9009,9020 ----
+  		break;
+  
+  	      case  FL_QLEV :
+! 		if(WRAP_CURLINE(f) &lt; WRAP_QSTRLEN(f)
+! 		   &amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f)) 
+! 		   &amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)]
+! 		   &amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f))[WRAP_CURPOS(f)] == c){
+! 		    WRAP_CURPOS(f)++;
+! 		    WRAP_FL_QC(f)++; 			/* another level */
+  		}
+  		else {
+  		    /* if EMBEDed, process it and return here */
+***************
+*** 8995,9001 ****
+  		    }
+  
+  		    /* quote level change signals new paragraph */
+! 		    if(WRAP_FL_QC(f) != WRAP_FL_QD(f)){
+  			WRAP_FL_QD(f) = WRAP_FL_QC(f);
+  			if(WRAP_HARD(f) == 0){		/* add hard newline */ 
+  			    WRAP_HARD(f) = 1;		/* hard newline */
+--- 9026,9041 ----
+  		    }
+  
+  		    /* quote level change signals new paragraph */
+! 		    if (WRAP_CURLINE(f) &gt; 0 
+! 			&amp;&amp; WRAP_CURLINE(f) &lt; WRAP_QSTRLEN(f)
+! 			&amp;&amp; (WRAP_QSTR(f, WRAP_CURLINE(f))
+! 			     || WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
+! 			&amp;&amp; ((WRAP_QSTR(f, WRAP_CURLINE(f)) &amp;&amp; 
+! 			     !WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
+! 			   || (!WRAP_QSTR(f, WRAP_CURLINE(f)) &amp;&amp; 
+! 			       WRAP_QSTR(f, WRAP_CURLINE(f) - 1))
+! 			   || strcmp(WRAP_QSTR(f, WRAP_CURLINE(f)),
+! 				      WRAP_QSTR(f, WRAP_CURLINE(f) - 1)))){
+  			WRAP_FL_QD(f) = WRAP_FL_QC(f);
+  			if(WRAP_HARD(f) == 0){		/* add hard newline */ 
+  			    WRAP_HARD(f) = 1;		/* hard newline */
+***************
+*** 9052,9057 ****
+--- 9092,9104 ----
+  		    state = FL_SIG;
+  		    break;
+  
++ 		  case ' ' :				/* what? */
++ 		   if (WRAP_CURLINE(f) &lt; WRAP_QSTRLEN(f) 
++ 			&amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f))){
++ 			WRAP_SPC_LEN(f)++;
++ 			so_writec(' ', WRAP_SPACES(f));
++ 		   }
++ 
+  		  default :				/* something else */
+  		    state = DFL;
+  		    goto case_dfl;			/* handle c like DFL */
+***************
+*** 9068,9074 ****
+  					     &amp;eob);      /* note any embedded*/
+  			    wrap_eol(f, 1, &amp;ip, &amp;eib,
+  				     &amp;op, &amp;eob);       /* plunk down newline */
+! 			    wrap_bol(f, 1, 1, &amp;ip, &amp;eib,
+  				     &amp;op, &amp;eob);         /* write any prefix */
+  			}
+  
+--- 9115,9121 ----
+  					     &amp;eob);      /* note any embedded*/
+  			    wrap_eol(f, 1, &amp;ip, &amp;eib,
+  				     &amp;op, &amp;eob);       /* plunk down newline */
+! 			    wrap_bol(f, 1, WRAP_FLOW(f), &amp;ip, &amp;eib,
+  				     &amp;op, &amp;eob);         /* write any prefix */
+  			}
+  
+***************
+*** 9565,9571 ****
+  		    wrap_flush_embed(f, &amp;ip, &amp;eib, &amp;op, &amp;eob);
+  		    wrap_eol(f, 1, &amp;ip, &amp;eib, &amp;op,
+  			     &amp;eob);	    /* plunk down newline */
+! 		    wrap_bol(f,1,1, &amp;ip, &amp;eib, &amp;op,
+  			     &amp;eob);	      /* write any prefix */
+  		}
+  
+--- 9612,9618 ----
+  		    wrap_flush_embed(f, &amp;ip, &amp;eib, &amp;op, &amp;eob);
+  		    wrap_eol(f, 1, &amp;ip, &amp;eib, &amp;op,
+  			     &amp;eob);	    /* plunk down newline */
+! 		    wrap_bol(f,1,WRAP_FLOW(f), &amp;ip, &amp;eib, &amp;op,
+  			     &amp;eob);	      /* write any prefix */
+  		}
+  
+***************
+*** 9638,9643 ****
+--- 9685,9697 ----
+  	if(WRAP_COLOR(f))
+  	  free_color_pair(&amp;WRAP_COLOR(f));
+  
++ 	{ long i;
++ 	  for (i = 0L; i &lt; WRAP_QSTRLEN(f); i++)
++ 	      if (WRAP_QSTR(f,i))
++ 		fs_give((void **) &amp;(WRAP_QSTR(f,i)));
++ 	  fs_give((void **)&amp;WRAP_QSTRN(f));
++ 	}
++ 
+  	fs_give((void **) &amp;f-&gt;line);	/* free temp line buffer */
+  	so_give(&amp;WRAP_SPACES(f));
+  	fs_give((void **) &amp;f-&gt;opt);	/* free wrap widths struct */
+***************
+*** 9988,9994 ****
+  {
+      int j, i;
+      COLOR_PAIR *col = NULL;
+!     char *prefix = NULL, *last_prefix = NULL;
+  
+      if(ps_global-&gt;VAR_QUOTE_REPLACE_STRING){
+  	get_pair(ps_global-&gt;VAR_QUOTE_REPLACE_STRING, &amp;prefix, &amp;last_prefix, 0, 0);
+--- 10042,10049 ----
+  {
+      int j, i;
+      COLOR_PAIR *col = NULL;
+!     char *prefix = NULL, *last_prefix = NULL, *wrap_qstr = NULL;
+!     int level = 0, oldj, len;
+  
+      if(ps_global-&gt;VAR_QUOTE_REPLACE_STRING){
+  	get_pair(ps_global-&gt;VAR_QUOTE_REPLACE_STRING, &amp;prefix, &amp;last_prefix, 0, 0);
+***************
+*** 9997,10006 ****
+  	    last_prefix = NULL;
+  	}
+      }
+! 
+!     for(j = 0; j &lt; WRAP_FL_QD(f); j++){
+  	if(WRAP_USE_CLR(f)){
+! 	    if((j % 3) == 0
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_FORE_COLOR
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_BACK_COLOR
+  	       &amp;&amp; (col = new_color_pair(ps_global-&gt;VAR_QUOTE1_FORE_COLOR,
+--- 10052,10073 ----
+  	    last_prefix = NULL;
+  	}
+      }
+!     
+!     if(WRAP_CURLINE(f) &lt; WRAP_QSTRLEN(f) &amp;&amp; WRAP_QSTR(f, WRAP_CURLINE(f)))
+!        wrap_qstr = cpystr(WRAP_QSTR(f, WRAP_CURLINE(f)));
+!     len = wrap_qstr ? strlen(wrap_qstr) : 0;
+! 
+!     for (j = wrap_qstr &amp;&amp; *wrap_qstr == ' ' ? 1 : 0;
+! 		 j &lt; len &amp;&amp; isspace((unsigned char)wrap_qstr[j]); j++){
+! 	GF_PUTC_GLO(f-&gt;next, wrap_qstr[j]);
+!         f-&gt;n += ((wrap_qstr[j] == TAB) ? (~f-&gt;n &amp; 0x07) + 1 : 1);
+!     }
+!     
+!     for(; j &lt; len &amp;&amp; level &lt; len; level++){
+!         oldj = j;
+!         j = next_level_quote(wrap_qstr, (char **)NULL, j, WRAP_FLOW(f));
+  	if(WRAP_USE_CLR(f)){
+! 	    if((level % 3) == 0
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_FORE_COLOR
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_BACK_COLOR
+  	       &amp;&amp; (col = new_color_pair(ps_global-&gt;VAR_QUOTE1_FORE_COLOR,
+***************
+*** 10008,10014 ****
+  	       &amp;&amp; pico_is_good_colorpair(col)){
+                  GF_COLOR_PUTC(f, col);
+              }
+! 	    else if((j % 3) == 1
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE2_FORE_COLOR
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE2_BACK_COLOR
+  		    &amp;&amp; (col = new_color_pair(ps_global-&gt;VAR_QUOTE2_FORE_COLOR,
+--- 10075,10081 ----
+  	       &amp;&amp; pico_is_good_colorpair(col)){
+                  GF_COLOR_PUTC(f, col);
+              }
+! 	    else if((level % 3) == 1
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE2_FORE_COLOR
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE2_BACK_COLOR
+  		    &amp;&amp; (col = new_color_pair(ps_global-&gt;VAR_QUOTE2_FORE_COLOR,
+***************
+*** 10016,10022 ****
+  		    &amp;&amp; pico_is_good_colorpair(col)){
+  	        GF_COLOR_PUTC(f, col);
+              }
+! 	    else if((j % 3) == 2
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE3_FORE_COLOR
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE3_BACK_COLOR
+  		    &amp;&amp; (col = new_color_pair(ps_global-&gt;VAR_QUOTE3_FORE_COLOR,
+--- 10083,10089 ----
+  		    &amp;&amp; pico_is_good_colorpair(col)){
+  	        GF_COLOR_PUTC(f, col);
+              }
+! 	    else if((level % 3) == 2
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE3_FORE_COLOR
+  		    &amp;&amp; ps_global-&gt;VAR_QUOTE3_BACK_COLOR
+  		    &amp;&amp; (col = new_color_pair(ps_global-&gt;VAR_QUOTE3_FORE_COLOR,
+***************
+*** 10030,10072 ****
+  	    }
+  	}
+  
+  	if(!WRAP_LV_FLD(f)){
+  	    if(!WRAP_FOR_CMPS(f) &amp;&amp; ps_global-&gt;VAR_QUOTE_REPLACE_STRING &amp;&amp; prefix){
+  		for(i = 0; prefix[i]; i++)
+  		  GF_PUTC_GLO(f-&gt;next, prefix[i]);
+! 		f-&gt;n += utf8_width(prefix);
+! 	    }
+! 	    else if(ps_global-&gt;VAR_REPLY_STRING
+! 		    &amp;&amp; (!strcmp(ps_global-&gt;VAR_REPLY_STRING, &quot;&gt;&quot;)
+! 			|| !strcmp(ps_global-&gt;VAR_REPLY_STRING, &quot;\&quot;&gt;\&quot;&quot;))){
+! 		GF_PUTC_GLO(f-&gt;next, '&gt;');
+! 		f-&gt;n += 1;
+  	    }
+  	    else{
+! 		GF_PUTC_GLO(f-&gt;next, '&gt;');
+! 		GF_PUTC_GLO(f-&gt;next, ' ');
+! 		f-&gt;n += 2;
+  	    }
+  	}
+  	else{
+! 	    GF_PUTC_GLO(f-&gt;next, '&gt;');
+! 	    f-&gt;n += 1;
+  	}
+      }
+      if(j &amp;&amp; WRAP_LV_FLD(f)){
+  	GF_PUTC_GLO(f-&gt;next, ' ');
+  	f-&gt;n++;
+      }
+!     else if(j &amp;&amp; last_prefix){
+  	for(i = 0; last_prefix[i]; i++)
+  	  GF_PUTC_GLO(f-&gt;next, last_prefix[i]);
+! 	f-&gt;n += utf8_width(last_prefix);	
+      }
+  
+      if(prefix)
+        fs_give((void **)&amp;prefix);
+      if(last_prefix)
+        fs_give((void **)&amp;last_prefix);
+  
+      return 0;
+  }
+--- 10097,10156 ----
+  	    }
+  	}
+  
++ 	if (j &gt; 1 &amp;&amp; wrap_qstr[j-1] == ' ')
++ 	   j -= 1; 
++ 
+  	if(!WRAP_LV_FLD(f)){
+  	    if(!WRAP_FOR_CMPS(f) &amp;&amp; ps_global-&gt;VAR_QUOTE_REPLACE_STRING &amp;&amp; prefix){
+  		for(i = 0; prefix[i]; i++)
+  		  GF_PUTC_GLO(f-&gt;next, prefix[i]);
+! 		f-&gt;n += utf8_widthis(prefix);
+  	    }
+  	    else{
+! 	      for (i = oldj; i &lt; j; i++)   
+! 		GF_PUTC_GLO(f-&gt;next, wrap_qstr[i]);
+! 	      f-&gt;n += j - oldj;
+  	    }
+  	}
+  	else{
+! 	    for (i = oldj; i &lt; j; i++)   
+! 		GF_PUTC_GLO(f-&gt;next, wrap_qstr[i]);
+! 	    f-&gt;n += j - oldj;
+! 	}
+! 	for (i = j; isspace((unsigned char)wrap_qstr[i]); i++);
+! 	if(!wrap_qstr[i]){
+! 	  f-&gt;n += i - j;
+! 	  for (; j &lt; i; j++)
+! 		GF_PUTC_GLO(f-&gt;next, ' '); 
+! 	}
+!         else{
+! 	   if((WRAP_LV_FLD(f)
+! 		|| !ps_global-&gt;VAR_QUOTE_REPLACE_STRING || !prefix)
+! 		|| !ps_global-&gt;VAR_REPLY_STRING
+! 			|| (strcmp(ps_global-&gt;VAR_REPLY_STRING, &quot;&gt;&quot;)
+! 			  &amp;&amp; strcmp(ps_global-&gt;VAR_REPLY_STRING, &quot;\&quot;&gt;\&quot;&quot;))){
+! 		  GF_PUTC_GLO(f-&gt;next, ' ');
+! 		  f-&gt;n += 1;
+! 	   }
+  	}
++ 	for (; isspace((unsigned char)wrap_qstr[j]); j++);
+      }
+      if(j &amp;&amp; WRAP_LV_FLD(f)){
+  	GF_PUTC_GLO(f-&gt;next, ' ');
+  	f-&gt;n++;
+      }
+!     else if(j &amp;&amp; !value_is_space(wrap_qstr) &amp;&amp; last_prefix){
+  	for(i = 0; last_prefix[i]; i++)
+  	  GF_PUTC_GLO(f-&gt;next, last_prefix[i]);
+! 	f-&gt;n += utf8_widthis(last_prefix);	
+      }
+  
+      if(prefix)
+        fs_give((void **)&amp;prefix);
+      if(last_prefix)
+        fs_give((void **)&amp;last_prefix);
++     if (wrap_qstr)
++       fs_give((void **)&amp;wrap_qstr);  
+  
+      return 0;
+  }
+***************
+*** 10098,10103 ****
+--- 10182,10193 ----
+      wrap-&gt;hdr_color    = (GFW_HDRCOLOR &amp; flags) == GFW_HDRCOLOR;
+      wrap-&gt;for_compose  = (GFW_FORCOMPOSE &amp; flags) == GFW_FORCOMPOSE;
+      wrap-&gt;handle_soft_hyphen = (GFW_SOFTHYPHEN &amp; flags) == GFW_SOFTHYPHEN;
++     wrap-&gt;curlinenum   = 0L;
++     wrap-&gt;curqstrpos   = 0;
++     wrap-&gt;linenum      = 0L;
++     wrap-&gt;qstrlen      = 100L;
++     wrap-&gt;qstrln       = (char **) fs_get(100*sizeof(char *));
++     memset(wrap-&gt;qstrln, 0, 100*sizeof(char *));
+  
+      return((void *) wrap);
+  }
+***************
+*** 10541,10547 ****
+--- 10631,10839 ----
+  			    } \
+  			}
+  
++ #define ADD_QUOTE_STRING(F) {						\
++ 	int len = tmp_20k_buf[0] ? strlen(tmp_20k_buf) + 1 : 0;		\
++ 	FILTER_S *fltr;							\
++ 									\
++ 	for(fltr = (F); fltr &amp;&amp; fltr-&gt;f != gf_wrap; fltr = fltr-&gt;next); \
++ 	if (fltr){							\
++ 	   if (WRAP_LINENUM(fltr) &gt;= WRAP_QSTRLEN(fltr)){		\
++ 	      fs_resize((void **)&amp;WRAP_QSTRN(fltr),			\
++ 			(WRAP_QSTRLEN(fltr) + 100) * sizeof(char *));	\
++ 	      memset(WRAP_QSTRN(fltr)+WRAP_QSTRLEN(fltr), 0, 		\
++ 						100*sizeof(char*));	\
++ 	      WRAP_QSTRLEN(fltr) += 100L;				\
++ 	   }								\
++ 	   if (len){							\
++ 	      WRAP_QSTR(fltr, WRAP_LINENUM(fltr)) = 			\
++ 				(char *) fs_get(len*sizeof(char));	\
++ 	      WRAP_QSTR(fltr, WRAP_LINENUM(fltr)) = cpystr(tmp_20k_buf);\
++ 	   }								\
++ 	   WRAP_LINENUM(fltr)++;					\
++ 	}								\
++ }
++ 
++ /* This macro is used in gf_quote_test. It receives a return code
++    from a filter. All filters that will print something must send
++    return code 0, except color_a_quote which must send return code
++    1
++  */
++ 
++ #define GF_ADD_QUOTED_LINE(F, line) \
++ { \
++     LT_INS_S *ins = NULL, *insp; \
++     int done; \
++     char *gline, *cline;\
++     unsigned char  ch;\
++     register char *cp;\
++     register int   l;\
++ 	\
++     for (gline = cline = line; gline &amp;&amp; cline; ){\
++ 	if(cline = strchr(gline,'\012'))\
++ 	  *cline = '\0';\
++ 	done = (*((LINETEST_S *) (F)-&gt;opt)-&gt;f)((F)-&gt;n++, gline, &amp;ins,\
++ 			   ((LINETEST_S *) (F)-&gt;opt)-&gt;local);\
++ 	if (done &lt; 2){ \
++ 	   if(done == 1)\
++ 	     ADD_QUOTE_STRING((F));\
++ 	   for(insp = ins,  cp = gline; *cp ; ){\
++ 	       if(insp &amp;&amp; cp == insp-&gt;where){\
++ 		if(insp-&gt;len &gt; 0){ \
++ 	          for(l = 0; l &lt; insp-&gt;len; l++){\
++ 			  ch =  (unsigned char) insp-&gt;text[l];\
++ 		     GF_PUTC((F)-&gt;next, ch);\
++ 	          }\
++ 	          insp = insp-&gt;next;\
++ 		  continue; \
++ 		} else if(insp-&gt;len &lt; 0){ \
++ 		  cp -= insp-&gt;len; \
++ 		  insp = insp-&gt;next; \
++ 		  continue; \
++ 		} \
++ 	       }\
++ 	       GF_PUTC((F)-&gt;next, *cp);\
++ 	       cp++;\
++ 	   }\
++ 	   while(insp){\
++ 	       for(l = 0; l &lt; insp-&gt;len; l++){\
++ 	          ch = (unsigned char) insp-&gt;text[l];\
++ 	          GF_PUTC((F)-&gt;next, ch);\
++ 	       }\
++ 	       insp = insp-&gt;next;\
++ 	   }\
++ 	   gf_line_test_free_ins(&amp;ins);\
++ 	   if(cline){ \
++ 	     *cline = '\012';\
++ 	     gline += cline - gline + 1;\
++ 	   }\
++ 	   GF_PUTC((F)-&gt;next, '\015');\
++ 	   GF_PUTC((F)-&gt;next, '\012');\
++ 	}\
++    }\
++ }
++ /* test second line of old line first */
++ #define SECOND_LINE_QUOTE_TEST(line, F) \
++ {\
++ 	*p = '\0';\
++ 	for (i = 0; ((F)-&gt;oldline)[i] &amp;&amp; ((F)-&gt;oldline)[i] != '\015'; i++);	\
++ 	if (((F)-&gt;oldline)[i]){\
++ 	   i += (((F)-&gt;oldline)[i+1] == '\012') ? 2 : 1;\
++ 	   line = (F)-&gt;oldline + i;\
++ 	}\
++ 	for (i = 0; ((F)-&gt;line) \
++ 		&amp;&amp; (i &lt; LINE_TEST_BLOCK) \
++ 		&amp;&amp; (i &lt; SIZEOF_20KBUF)\
++ 		&amp;&amp; ((F)-&gt;line)[i] \
++ 		&amp;&amp; (((F)-&gt;line)[i] != '\015')\
++ 		&amp;&amp; (((F)-&gt;line)[i] != '\012')\
++ 		&amp;&amp; (tmp_20k_buf[i] = ((F)-&gt;line)[i]); i++);\
++ 	tmp_20k_buf[i] = '\0';\
++ 	GF_ADD_QUOTED_LINE((F), line);\
++ }
++ 
++ #define FIRST_LINE_QUOTE_TEST(line, F)\
++ {\
++ 	*p = '\0';\
++ 	line = (F)-&gt;line;\
++ 	if ((F)-&gt;oldline)\
++ 	   fs_give((void **)&amp;(F)-&gt;oldline);\
++ 	(F)-&gt;oldline = cpystr(line);\
++ 	for (i = 0; line[i] &amp;&amp; line[i] != '\015' &amp;&amp; line[i] != '\012'; i++); \
++ 	if ((line[i] == '\012') &amp;&amp; ((i == 0) || ((i &gt; 0) &amp;&amp; line[i-1] != '\015'))){\
++ 	   i++;\
++ 	  for (; line[i] &amp;&amp; line[i] != '\015' &amp;&amp; line[i] != '\012'; i++); \
++ 	}\
++ 	if (line[i]){\
++ 	   (line[i]) = '\0';\
++ 	   i+= (line[i+1] == '\012') ? 2 : 1;\
++ 	}\
++ 	for (j = 0; ((F)-&gt;line) \
++ 		&amp;&amp; ((i + j) &lt; LINE_TEST_BLOCK) \
++ 		&amp;&amp; (j &lt; SIZEOF_20KBUF) \
++ 		&amp;&amp; ((F)-&gt;line)[i + j] \
++ 		&amp;&amp; (((F)-&gt;line)[i + j] != '\015')\
++ 		&amp;&amp; (((F)-&gt;line)[i + j] != '\012')\
++ 		&amp;&amp; (tmp_20k_buf[j] = ((F)-&gt;line)[i + j]); j++);\
++ 	tmp_20k_buf[j] = '\0';\
++ 	GF_ADD_QUOTED_LINE((F), line);\
++ }
++ 
++ 
++ void
++ gf_quote_test(f, flg)
++     FILTER_S *f;
++     int	      flg;
++ {
++     register char *p = f-&gt;linep;
++     register char *eobuf = GF_LINE_TEST_EOB(f);
++     char *line = NULL; 
++     int i, j;
++     GF_INIT(f, f-&gt;next);
++ 
++     if(flg == GF_DATA){
++ 	register unsigned char c;
++ 	register int state = f-&gt;f1;
++ 
++ 	while(GF_GETC(f, c)){
++ 
++ 	    if(state == 2){		/* two full lines read */
++ 		state = 0;
++ 
++ 		/* first process the second line of an old line */
++ 		if (f-&gt;oldline &amp;&amp; f-&gt;oldline[0])
++ 		    SECOND_LINE_QUOTE_TEST(line, f);
++ 
++ 		/* now we process the first line */
++ 		FIRST_LINE_QUOTE_TEST(line, f);
++ 
++ 		p = f-&gt;line;
++ 		continue;
++ 	    }
++ 	    if(c == '\015'){
++ 	      state++;
++ 	      if (state == 1)
++ 		 GF_LINE_TEST_ADD(f, c);
++ 	    }
++ 	    else
++ 	      GF_LINE_TEST_ADD(f, c);
++ 	}
++ 
++ 	f-&gt;f1 = state;
++ 	GF_END(f, f-&gt;next);
++     }
++     else if(flg == GF_EOD){
++         /* first process the second line of an old line */
++ 	if (f-&gt;oldline &amp;&amp; f-&gt;oldline[0])
++ 	    SECOND_LINE_QUOTE_TEST(line, f);
++ 
++ 	/* now we process the first line */
++ 	FIRST_LINE_QUOTE_TEST(line, f);
++ 
++ 	/* We are out of data. In this case we have processed the second
++ 	 * line of an oldline, then the first line of a line, but we need
++ 	 * to process the second line of the given line. We do this by
++ 	 * processing it now!.
++ 	 */
++ 	if (line[i]){
++ 	   tmp_20k_buf[0] = '\0';	/* No next line */
++ 	   GF_ADD_QUOTED_LINE(f, line+i);
++ 	}
+  
++ 	fs_give((void **) &amp;f-&gt;oldline); /* free old line buffer */
++ 	fs_give((void **) &amp;f-&gt;line);	/* free line buffer */
++ 	fs_give((void **) &amp;f-&gt;opt);	/* free test struct */
++ 	GF_FLUSH(f-&gt;next);
++ 	(*f-&gt;next-&gt;f)(f-&gt;next, GF_EOD);
++     }
++     else if(flg == GF_RESET){
++ 	f-&gt;f1 = 0;			/* state */
++ 	f-&gt;n  = 0L;			/* line number */
++ 	f-&gt;f2 = LINE_TEST_BLOCK;	/* size of alloc'd line */
++ 	f-&gt;line = p = (char *) fs_get(f-&gt;f2 * sizeof(char));
++     }
++ 
++     f-&gt;linep = p;
++ }
+  
+  /*
+   * this simple filter accumulates characters until a newline, offers it
+diff -rc alpine-1.10/pith/filter.h alpine-1.10.fillpara/pith/filter.h
+*** alpine-1.10/pith/filter.h	2008-03-05 10:56:28.000000000 -0800
+--- alpine-1.10.fillpara/pith/filter.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 194,199 ****
+--- 194,200 ----
+  void	   *gf_prepend_editorial_opt(prepedtest_t, char *);
+  void	    gf_nvtnl_local(FILTER_S *, int);
+  void	    gf_local_nvtnl(FILTER_S *, int);
++ void	    gf_quote_test(FILTER_S *, int);
+  void	   *gf_url_hilite_opt(URL_HILITE_S *, HANDLE_S **, int);
+  
+  
+diff -rc alpine-1.10/pith/filttype.h alpine-1.10.fillpara/pith/filttype.h
+*** alpine-1.10/pith/filttype.h	2007-04-25 21:06:02.000000000 -0700
+--- alpine-1.10.fillpara/pith/filttype.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 35,40 ****
+--- 35,42 ----
+      unsigned char t;		/* temporary char                        */
+      char     *line;		/* place for temporary storage           */
+      char     *linep;		/* pointer into storage space            */
++     char     *oldline;		/* the previous line to &quot;line&quot;		 */
++     char     *oldlinep;		/* the previous line to &quot;line&quot;		 */
+      void     *opt;		/* optional per instance data		 */
+      void     *data;		/* misc internal data pointer		 */
+      unsigned char queue[1 + GF_MAXBUF];
+diff -rc alpine-1.10/pith/mailview.c alpine-1.10.fillpara/pith/mailview.c
+*** alpine-1.10/pith/mailview.c	2008-03-05 10:56:28.000000000 -0800
+--- alpine-1.10.fillpara/pith/mailview.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 50,56 ****
+  #include &quot;../pith/ablookup.h&quot;
+  #include &quot;../pith/escapes.h&quot;
+  #include &quot;../pith/keyword.h&quot;
+! 
+  
+  #define FBUF_LEN	(50)
+  
+--- 50,59 ----
+  #include &quot;../pith/ablookup.h&quot;
+  #include &quot;../pith/escapes.h&quot;
+  #include &quot;../pith/keyword.h&quot;
+! #include &quot;../pith/osdep/color.h&quot;
+! #include &quot;../pico/estruct.h&quot;
+! #include &quot;../pico/pico.h&quot;
+! #include &quot;../pico/efunc.h&quot;
+  
+  #define FBUF_LEN	(50)
+  
+***************
+*** 282,288 ****
+  	       &amp;&amp; pico_usingcolor()
+  	       &amp;&amp; ps_global-&gt;VAR_SIGNATURE_FORE_COLOR
+  	       &amp;&amp; ps_global-&gt;VAR_SIGNATURE_BACK_COLOR){
+! 		gf_link_filter(gf_line_test, gf_line_test_opt(color_signature, &amp;is_in_sig));
+  	    }
+  
+  	    if((flgs &amp; FM_DISPLAY)
+--- 285,291 ----
+  	       &amp;&amp; pico_usingcolor()
+  	       &amp;&amp; ps_global-&gt;VAR_SIGNATURE_FORE_COLOR
+  	       &amp;&amp; ps_global-&gt;VAR_SIGNATURE_BACK_COLOR){
+! 		gf_link_filter(gf_quote_test, gf_line_test_opt(color_signature, &amp;is_in_sig));
+  	    }
+  
+  	    if((flgs &amp; FM_DISPLAY)
+***************
+*** 290,297 ****
+  	       &amp;&amp; pico_usingcolor()
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_FORE_COLOR
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_BACK_COLOR){
+! 		gf_link_filter(gf_line_test, gf_line_test_opt(color_a_quote, NULL));
+  	    }
+  
+  	    if(!(flgs &amp; FM_NOWRAP)){
+  		wrapflags = (flgs &amp; FM_DISPLAY) ? (GFW_HANDLES|GFW_SOFTHYPHEN) : GFW_NONE;
+--- 293,302 ----
+  	       &amp;&amp; pico_usingcolor()
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_FORE_COLOR
+  	       &amp;&amp; ps_global-&gt;VAR_QUOTE1_BACK_COLOR){
+! 		gf_link_filter(gf_quote_test, gf_line_test_opt(color_a_quote, NULL));
+  	    }
++ 	    else
++ 		gf_link_filter(gf_quote_test,gf_line_test_opt(select_quote, NULL));
+  
+  	    if(!(flgs &amp; FM_NOWRAP)){
+  		wrapflags = (flgs &amp; FM_DISPLAY) ? (GFW_HANDLES|GFW_SOFTHYPHEN) : GFW_NONE;
+***************
+*** 1071,1097 ****
+  color_signature(long int linenum, char *line, LT_INS_S **ins, void *is_in_sig)
+  {
+      struct variable *vars = ps_global-&gt;vars;
+!     int             *in_sig_block;
+      COLOR_PAIR      *col = NULL;
+  
+      if(is_in_sig == NULL)
+        return 0;
+  
+      in_sig_block = (int *) is_in_sig;
+      
+!     if(!strcmp(line, SIGDASHES))
+!       *in_sig_block = START_SIG_BLOCK; 
+!     else if(*line == '\0')
+        /* 
+         * Suggested by Eduardo: allow for a blank line right after 
+         * the sigdashes. 
+         */
+        *in_sig_block = (*in_sig_block == START_SIG_BLOCK)
+  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
+      else
+        *in_sig_block = (*in_sig_block != OUT_SIG_BLOCK)
+  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
+  
+      if(*in_sig_block != OUT_SIG_BLOCK
+         &amp;&amp; VAR_SIGNATURE_FORE_COLOR &amp;&amp; VAR_SIGNATURE_BACK_COLOR
+         &amp;&amp; (col = new_color_pair(VAR_SIGNATURE_FORE_COLOR,
+--- 1076,1164 ----
+  color_signature(long int linenum, char *line, LT_INS_S **ins, void *is_in_sig)
+  {
+      struct variable *vars = ps_global-&gt;vars;
+!     int             *in_sig_block, i, j,same_qstr = 0, plb;
+      COLOR_PAIR      *col = NULL;
++     static char GLine[NSTRING] = {'\0'};
++     static char PLine[NSTRING] = {'\0'};
++     static char PPLine[NSTRING] = {'\0'};
++     char NLine[NSTRING] = {'\0'};
++     char rqstr[NSTRING] = {'\0'};
++     char *p;
++     static char *buf, buf2[NSTRING] = {'\0'};
++     QSTRING_S *qs;
++     static int qstrlen = 0;
+  
+      if(is_in_sig == NULL)
+        return 0;
+  
++     if (linenum &gt; 0){
++ 	strncpy(PLine, GLine, sizeof(PLine));
++ 	PLine[sizeof(PLine)-1] = '\0';
++     }
++ 
++     if(p = strchr(tmp_20k_buf, '\015')) *p = '\0';
++     strncpy(NLine, tmp_20k_buf, sizeof(NLine));
++     NLine[sizeof(NLine) - 1] = '\0';
++     if (p) *p = '\015';
++ 
++     strncpy(GLine, line, sizeof(GLine));
++     GLine[sizeof(GLine) - 1] = '\0';
++ 
++     plb = line_isblank((ps_global-&gt;prefix &amp;&amp; *ps_global-&gt;prefix 
++ 			? ps_global-&gt;prefix : &quot;&gt;&quot;), PLine, GLine, PPLine, NSTRING);
++     qs = do_quote_match((ps_global-&gt;prefix &amp;&amp; *ps_global-&gt;prefix 
++ 			? ps_global-&gt;prefix : &quot;&gt;&quot;),
++                        GLine, NLine, PLine, rqstr, NSTRING, plb);
++     if(linenum &gt; 0)
++        strncpy(PPLine, PLine, NSTRING);
++     strncpy(buf2, rqstr, NSTRING);
++     i = buf2 &amp;&amp; buf2[0] ? strlen(buf2) : 0;
++     free_qs(&amp;qs);
++ 
++     /* determine if buf and buf2 are the same quote string */
++     if (!struncmp(buf, buf2, qstrlen)){
++       for (j = qstrlen; buf2[j] &amp;&amp; isspace((unsigned char)buf2[j]); j++);
++       if (!buf2[j] || buf2[j] == '|' || (buf2[j] == '*' &amp;&amp; buf2[j+1] != '&gt;'))
++          same_qstr++;
++     }
++ 
+      in_sig_block = (int *) is_in_sig;
+      
+!     if (*in_sig_block != OUT_SIG_BLOCK){
+!       if (line &amp;&amp; *line &amp;&amp; (strlen(line) &gt;= qstrlen) &amp;&amp; same_qstr)
+!          line += qstrlen;
+!         else if (strlen(line) &lt; qstrlen)
+!          line += i;
+!       else if (!same_qstr)
+!          *in_sig_block = OUT_SIG_BLOCK;
+!     }
+!     else
+!       line += i;
+! 
+!     if(!strcmp(line, SIGDASHES) || !strcmp(line, &quot;--&quot;)){
+!       *in_sig_block = START_SIG_BLOCK;
+!        buf = (char *) fs_get((i + 1)*sizeof(char));
+!        buf = cpystr(buf2);
+!        qstrlen = i;
+!     }
+!     else if(*line == '\0'){
+        /* 
+         * Suggested by Eduardo: allow for a blank line right after 
+         * the sigdashes. 
+         */
+        *in_sig_block = (*in_sig_block == START_SIG_BLOCK)
+  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
++     }
+      else
+        *in_sig_block = (*in_sig_block != OUT_SIG_BLOCK)
+  			  ? IN_SIG_BLOCK : OUT_SIG_BLOCK;
+  
++     if (*in_sig_block == OUT_SIG_BLOCK){
++       qstrlen = 0;    /* reset back in case there's another paragraph */
++       if (buf)
++          fs_give((void **)&amp;buf);
++     }
++ 
+      if(*in_sig_block != OUT_SIG_BLOCK
+         &amp;&amp; VAR_SIGNATURE_FORE_COLOR &amp;&amp; VAR_SIGNATURE_BACK_COLOR
+         &amp;&amp; (col = new_color_pair(VAR_SIGNATURE_FORE_COLOR,
+***************
+*** 1651,1656 ****
+--- 1718,1794 ----
+  }
+  
+  
++ /* This filter gives a quote string of a line. It sends its reply back to the
++    calling filter in the tmp_20k_buf variable. This filter replies with
++    the full quote string including tailing spaces if any. It is the
++    responsibility of the calling filter to figure out if thos spaces are
++    useful for that filter or if they should be removed before doing any
++    useful work. For example, color_a_quote does not require the trailing
++    spaces, but gf_wrap does.
++  */
++ int
++ select_quote(long linenum, char *line, LT_INS_S **ins, void *local)
++ {
++      int i, plb, *code;
++      char rqstr[NSTRING] = {'\0'}, buf[NSTRING] = {'\0'};
++      char GLine[NSTRING] = {'\0'}, PLine[NSTRING] = {'\0'};
++      char PPLine[NSTRING] = {'\0'}, NLine[NSTRING] = {'\0'};
++      static char GLine1[NSTRING] = {'\0'};
++      static char PLine1[NSTRING] = {'\0'};
++      static char PPLine1[NSTRING] = {'\0'};
++      static char GLine2[NSTRING] = {'\0'};
++      static char PLine2[NSTRING] = {'\0'};
++      static char PPLine2[NSTRING] = {'\0'};
++      QSTRING_S *qs;
++      int buflen = NSTRING &lt; SIZEOF_20KBUF ? NSTRING - 1: SIZEOF_20KBUF - 1;
++      int who, raw;
++ 
++      code = (int *)local;
++      who = code ? (*code &amp; COLORAQUO) : 0; /* may I ask who is calling? */
++      raw = code ? (*code &amp; RAWSTRING) : 0; /* return raw string */
++      strncpy(GLine, (who ? GLine1 : GLine2), buflen);
++      strncpy(PLine, (who ? PLine1 : PLine2), buflen);
++      strncpy(PPLine, (who ? PPLine1 : PPLine2), buflen);
++ 
++      if (linenum &gt; 0)
++         strncpy(PLine, GLine, buflen);
++ 
++      strncpy(NLine, tmp_20k_buf, buflen);
++ 
++      if (line)
++         strncpy(GLine, line, buflen);
++      else
++         GLine[0] = '\0';
++ 
++ 
++      plb = line_isblank((ps_global-&gt;prefix &amp;&amp; *ps_global-&gt;prefix 
++ 		? ps_global-&gt;prefix : &quot;&gt;&quot;), PLine, GLine, PPLine, NSTRING);
++ 
++      qs = do_quote_match((ps_global-&gt;prefix &amp;&amp; *ps_global-&gt;prefix 
++ 		? ps_global-&gt;prefix : &quot;&gt;&quot;), GLine, NLine, PLine, 
++ 							rqstr, NSTRING, plb);
++      if (raw)
++         strncpy(buf, rqstr, NSTRING);
++      else
++         flatten_qstring(qs, buf, NSTRING);
++      free_qs(&amp;qs);
++ 
++      /* do not paint an extra level for a line with a &gt;From string at the
++       * begining of it
++       */
++      if (buf[0]){
++        i = strlen(buf);
++        if (strlen(line) &gt;= i + 6 &amp;&amp; !strncmp(line+i-1,&quot;&gt;From &quot;, 6))
++            buf[i - 1] = '\0';
++      }
++      strncpy(tmp_20k_buf, buf, buflen);
++      if (linenum &gt; 0)
++        strncpy((who ? PPLine1 : PPLine2), PLine, buflen);
++      strncpy((who ? GLine1 : GLine2), GLine, buflen);
++      strncpy((who ? PLine1 : PLine2), PLine, buflen);
++      return 1;
++ }
++ 
+  
+  #define	UES_LEN	12
+  #define	UES_MAX	32
+diff -rc alpine-1.10/pith/mailview.h alpine-1.10.fillpara/pith/mailview.h
+*** alpine-1.10/pith/mailview.h	2008-03-05 10:56:28.000000000 -0800
+--- alpine-1.10.fillpara/pith/mailview.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 141,146 ****
+--- 141,147 ----
+  char	   *display_parameters(PARAMETER *);
+  char	   *pine_fetch_header(MAILSTREAM *, long, char *, char **, long);
+  int         color_signature(long, char *, LT_INS_S **, void *);
++ int	    select_quote(long, char *, LT_INS_S **, void *);
+  int	    scroll_handle_start_color(char *, size_t, int *);
+  int	    scroll_handle_end_color(char *, size_t, int *, int);
+  int         width_at_this_position(unsigned char *, unsigned long);
+diff -rc alpine-1.10/pith/osdep/color.c alpine-1.10.fillpara/pith/osdep/color.c
+*** alpine-1.10/pith/osdep/color.c	2006-09-26 12:30:49.000000000 -0700
+--- alpine-1.10.fillpara/pith/osdep/color.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 31,37 ****
+  
+  #include &lt;system.h&gt;
+  #include &quot;./color.h&quot;
+! 
+  
+  
+  /*
+--- 31,37 ----
+  
+  #include &lt;system.h&gt;
+  #include &quot;./color.h&quot;
+! #include &quot;./collate.h&quot;
+  
+  
+  /*
+***************
+*** 91,93 ****
+--- 91,1268 ----
+  {
+      return(pico_set_colors(col ? col-&gt;fg : NULL, col ? col-&gt;bg : NULL, flags));
+  }
++ 
++ 
++   /* 
++    * Extended Justification support also does not belong here
++    * but otherwise webpine will not build, so we move everything
++    * here. Hopefully this will be the permanent place for these
++    * routines. This routines used to be in pico/word.c
++    */
++ #define NSTRING 256
++ #include &quot;../../include/general.h&quot;
++ 
++ /* Support of indentation of paragraphs */
++ #define is_indent_char(c)  (((c) == '.' || (c) == '}' || (c) == RPAREN || \
++ 			     (c) == '*' || (c) == '+' || is_a_digit(c) || \
++ 			     ISspace(c) || (c) == '-' || \
++ 			     (c) == ']') ? 1 : 0)
++ #define allowed_after_digit(c,word,k)  ((((c) == '.' &amp;&amp; \
++ 			     allowed_after_period(next((word),(k))))  ||\
++ 				(c) == RPAREN || (c) == '}' || (c) == ']' ||\
++ 				  ISspace(c) ||  is_a_digit(c) || \
++ 				  ((c) == '-' ) &amp;&amp; \
++ 				    allowed_after_dash(next((word),(k)))) \
++ 				? 1 : 0)
++ #define allowed_after_period(c)	 (((c) == RPAREN || (c) == '}' || (c) == ']' ||\
++ 				   ISspace(c) || (c) == '-' || \
++ 				   is_a_digit(c)) ? 1 : 0)
++ #define allowed_after_parenth(c)  (ISspace(c) ? 1 : 0)
++ #define allowed_after_space(c)	  (ISspace(c) ? 1 : 0)
++ #define allowed_after_braces(c)	  (ISspace(c) ? 1 : 0)
++ #define allowed_after_star(c)	 ((ISspace(c) || (c) == RPAREN ||\
++                                        (c) == ']' || (c) == '}') ? 1 : 0)
++ #define allowed_after_dash(c)	  ((ISspace(c) || is_a_digit(c)) ? 1 : 0)
++ #define EOLchar(c)		  (((c) == '.' || (c) == ':' || (c) == '?' ||\
++ 					(c) == '!') ? 1 : 0)
++ 
++ 
++ /* Extended justification support */
++ #define is_cquote(c) ((c) == '&gt;' || (c) == '|' || (c) == ']' || (c) == ':')
++ #define is_cword(c)  ((((c) &gt;= 'a') &amp;&amp; ((c) &lt;= 'z')) ||  \
++                      (((c) &gt;= 'A') &amp;&amp; ((c) &lt;= 'Z')) || \
++                      (((c) &gt;= '0') &amp;&amp; ((c) &lt;= '9')) || \
++                       ((c) == ' ') || ((c) == '?') || \
++                       ((c) == '@') || ((c) == '.') || \
++                       ((c) == '!') || ((c) == '\'') || \
++                       ((c) == ',') || ((c) == '\&quot;') ? 1 : 0)
++ #define isaquote(c)   ((c) == '\&quot;' || (c) == '\'')
++ #define is8bit(c)     ((((int) (c)) &amp; 0x80) ? 1 : 0)
++ #define iscontrol(c)  (iscntrl(((int) (c)) &amp; 0x7f) ? 1 : 0)
++ #define forbidden(c)  (((c) == '\&quot;') || ((c) == '\'') || ((c) == '$') ||\
++                        ((c) == ',')  || ((c) == '.')  || ((c) == '-') ||\
++                        ((c) == LPAREN) || ((c) == '/')|| ((c) == '`') ||\
++                        ((c) == '{') || ((c) == '\\') || (iscontrol((c))) ||\
++                        (((c) &gt;= '0')  &amp;&amp; ((c) &lt;= '9')) || ((c) == '?'))
++ #define is_cletter(c)  ((((c) &gt;= 'a') &amp;&amp; ((c) &lt;= 'z'))) ||\
++                        ((((c) &gt;= 'A') &amp;&amp; ((c) &lt;= 'Z'))||\
++                       is8bit(c))
++ #define is_cnumber(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
++ #define allwd_after_word(c) (((c) == ' ') || ((c) == '&gt;') || is_cletter(c))
++ #define allwd_after_qsword(c)  (((c) != '\\') &amp;&amp; ((c) != RPAREN))
++ #define before(word,i) (((i) &gt; 0) ? (word)[(i) - 1] : 0)
++ #define next(w,i) ((((w)[(i)]) != 0) ? ((w)[(i) + 1]) : 0)
++ #define now(w,i)  ((w)[(i)])
++ #define is_qsword(c)  (((c) == ':') || ((c) == RPAREN) ? 1 : 0)
++ #define is_colon(c)   (((c) == ':') ? 1 : 0)
++ #define is_rarrow(c)  (((c) == '&gt;') ? 1 : 0)
++ #define is_tilde(c)   (((c) == '~') ? 1 : 0)
++ #define is_dash(c)    (((c) == '-') ? 1 : 0)
++ #define is_pound(c)   (((c) == '#') ? 1 : 0)
++ #define is_a_digit(c) ((((c) &gt;= '0') &amp;&amp; ((c) &lt;= '9')) ? 1 : 0)
++ #define is_allowed(c)  (is_cquote(c) || is_cword(c) || is_dash(c) || \
++                        is_pound(c))
++ #define qs_allowed(a)  (((a)-&gt;qstype != qsGdb) &amp;&amp; ((a)-&gt;qstype != qsProg))
++ 
++ /* Internal justification functions */
++ QSTRING_S *is_quote(char *, char *, int);
++ QSTRING_S *qs_normal_part(QSTRING_S *);
++ QSTRING_S *qs_remove_trailing_spaces(QSTRING_S *);
++ QSTRING_S *trim_qs_from_cl(QSTRING_S *, QSTRING_S *, QSTRING_S *);
++ QSTRING_S *fix_qstring(QSTRING_S *, QSTRING_S *, QSTRING_S *);
++ QSTRING_S *fix_qstring_allowed(QSTRING_S *, QSTRING_S *, QSTRING_S *);
++ QSTRING_S *qs_add(char *, char *, QStrType, int, int, int, int);
++ QSTRING_S *remove_qsword(QSTRING_S *);
++ QSTRING_S *do_raw_quote_match(char *, char *, char *, char *, QSTRING_S **, QSTRING_S **);
++ void	 free_qs(QSTRING_S **);
++ int      word_is_prog(char *);
++ int      qstring_is_normal(QSTRING_S *);
++ int      exists_good_part(QSTRING_S *);
++ int      strcmp_qs(char *, char *);
++ int      count_levels_qstring(QSTRING_S *);
++ int      same_qstring(QSTRING_S *, QSTRING_S *);
++ int      advance_quote_string(char *, char *, int);
++ int	 isaword(char *,int ,int);
++ int	 isamailbox(char *,int ,int);
++ 
++ 
++ int
++ word_is_prog(char *word)
++ {
++    static char *list1[] = {&quot;#include&quot;,
++                         &quot;#define&quot;,
++                         &quot;#ifdef&quot;,
++                         &quot;#ifndef&quot;,
++                         &quot;#elif&quot;,
++                         &quot;#if&quot;,
++ 			NULL};
++   static char *list2[] = {&quot;#else&quot;,
++                         &quot;#endif&quot;,
++                          NULL};
++   int i, j = strlen(word), k, rv = 0;
++ 
++   for(i = 0; rv == 0 &amp;&amp; list1[i] &amp;&amp; (k = strlen(list1[i])) &amp;&amp; k &lt; j; i++)
++      if(!strncmp(list1[i], word, k) &amp;&amp; ISspace(word[k]))
++        rv++;
++ 
++      if(rv)
++        return rv;
++ 
++    for(i = 0; rv == 0 &amp;&amp; list2[i] &amp;&amp; (k = strlen(list2[i])) &amp;&amp; k &lt;= j; i++)
++      if(!strncmp(list2[i], word, k) &amp;&amp; (!word[k] || ISspace(word[k])))
++        rv++;
++ 
++    return rv;
++ }
++ 
++ /*
++  * This function creates a qstring pointer with the information that
++  * is_quote handles to it.
++  * Parameters:
++  * qs         - User supplied quote string
++  * word               - The line of text that the user is trying to read/justify
++  * beginw     - Where we need to start copying from
++  * endw               - Where we end copying
++  * offset     - Any offset in endw that we need to account for
++  * typeqs     - type of the string to be created
++  * neednext   - boolean, indicating if we need to compute the next field
++  *              of leave it NULL 
++  * 
++  * It is a mistake to call this function if beginw &gt;= endw + offset.
++  * Please note the equality sign in the above inequality (this is because
++  * we always assume that qstring-&gt;value != &quot;&quot;).
++  */ 
++ QSTRING_S *
++ qs_add(qs, word, typeqs, beginw, endw, offset, neednext)
++    char *qs;
++    char word[NSTRING];
++    QStrType   typeqs;
++    int beginw, endw, offset, neednext;
++ {
++     QSTRING_S *qstring, *nextqs;
++     int i;
++  
++     qstring = (QSTRING_S *) malloc (sizeof(QSTRING_S));
++     memset (qstring, 0, sizeof(QSTRING_S));
++     qstring-&gt;qstype = qsNormal;
++ 
++     if (beginw == 0){
++ 	beginw = endw + offset;
++ 	qstring-&gt;qstype = typeqs;
++     }
++ 
++     nextqs = neednext ? is_quote(qs, word+beginw, 1) : NULL;
++ 
++     qstring-&gt;value = (char *) malloc((beginw+1)*sizeof(char));
++     strncpy(qstring-&gt;value, word, beginw);
++     qstring-&gt;value[beginw] = '\0';
++ 
++     qstring-&gt;next = nextqs;
++ 
++     return qstring;
++ }
++ 
++ int
++ qstring_is_normal(cl)
++   QSTRING_S *cl;
++ { 
++    for (;cl &amp;&amp; (cl-&gt;qstype == qsNormal); cl = cl-&gt;next);
++    return cl ? 0 : 1;
++ }
++ 
++ /*
++  * Given a quote string, this function returns the part that is the leading
++  * normal part of it. (the normal part is the part that is tagged qsNormal,
++  * that is to say, the one that is not controversial at all (like qsString
++  * for example).
++  */
++ QSTRING_S *
++ qs_normal_part(cl)
++   QSTRING_S *cl;
++ {
++ 
++   if (!cl)            /* nothing in, nothing out */
++      return cl;
++ 
++   if (cl-&gt;qstype != qsNormal)
++      free_qs(&amp;cl);
++ 
++   if (cl)
++      cl-&gt;next = qs_normal_part(cl-&gt;next);
++ 
++   return cl;
++ }
++ 
++ /*
++  * this function removes trailing spaces from a quote string, but leaves the
++  * last one if there are trailing spaces
++  */ 
++ QSTRING_S *
++ qs_remove_trailing_spaces(cl)
++     QSTRING_S *cl;
++ {
++   QSTRING_S *rl = cl;
++   if (!cl)            /* nothing in, nothing out */
++      return cl;
++ 
++   if (cl-&gt;next)
++      cl-&gt;next = qs_remove_trailing_spaces(cl-&gt;next);
++   else{
++     if (value_is_space(cl-&gt;value))
++        free_qs(&amp;cl);
++     else{
++        int i, l;
++        i = l = strlen(cl-&gt;value) - 1;
++        while (cl-&gt;value &amp;&amp; cl-&gt;value[i]
++         &amp;&amp; ISspace(cl-&gt;value[i]))
++            i--;
++         i += (i &lt; l) ? 2 : 1;
++         cl-&gt;value[i] = '\0';
++     }
++   }
++   return cl;
++ }
++ 
++ /*
++  * This function returns if two strings are the same quote string.
++  * The call is not symmetric. cl must preceed the line nl. This function
++  * should be called for comparing the last part of cl and nl.
++  */
++ int
++ strcmp_qs(char *valuecl, char *valuenl)
++ {
++    int j;
++ 
++    for (j = 0; valuecl[j] &amp;&amp; (valuecl[j] == valuenl[j]); j++);
++    return !strcmp(valuecl, valuenl)
++ 	 || (valuenl[j] &amp;&amp; value_is_space(valuenl+j)
++ 			&amp;&amp; value_is_space(valuecl+j)
++ 			&amp;&amp; strlenis(valuecl+j) &gt;= strlenis(valuenl+j))
++ 	 || (!valuenl[j] &amp;&amp; value_is_space(valuecl+j));
++ }
++ 
++ int
++ count_levels_qstring(cl)
++   QSTRING_S *cl;
++ {
++   int count;
++   for (count = 0; cl ; count++, cl = cl-&gt;next);
++ 
++   return count;
++ }
++ 
++ int
++ value_is_space(char *value)
++ {
++   for (; value &amp;&amp; *value &amp;&amp; ISspace(*value); value++);
++ 
++   return value &amp;&amp; *value ? 0 : 1;
++ }
++ 
++ void
++ free_qs(QSTRING_S **cl)
++ {
++   if (!(*cl))
++     return;
++ 
++   if ((*cl)-&gt;next)
++     free_qs(&amp;((*cl)-&gt;next));
++ 
++   (*cl)-&gt;next = (QSTRING_S *) NULL;
++ 
++   if ((*cl)-&gt;value)
++      free((void *)(*cl)-&gt;value);
++    (*cl)-&gt;value = (char *) NULL;
++    free((void *)(*cl));
++    *cl = (QSTRING_S *) NULL;
++ }
++ 
++ /*
++  * This function returns the number of agreements between
++  * cl and nl. The call is not symmetric. cl must be the line
++  * preceding nl.
++  */
++ int
++ same_qstring(QSTRING_S *cl, QSTRING_S *nl)
++ {
++    int same = 0, done = 0;
++ 
++    for (;cl &amp;&amp; nl &amp;&amp; !done; cl = cl-&gt;next, nl = nl-&gt;next)
++        if (cl-&gt;qstype == nl-&gt;qstype
++          &amp;&amp; (!strcmp(cl-&gt;value, nl-&gt;value)
++            || (!cl-&gt;next &amp;&amp; strcmp_qs(cl-&gt;value, nl-&gt;value))))
++ 	same++;
++       else
++ 	done++;
++    return same;
++ }
++ 
++ QSTRING_S *
++ trim_qs_from_cl(QSTRING_S *cl, QSTRING_S *nl, QSTRING_S *pl)
++ {
++     QSTRING_S *cqstring = pl ? pl : nl;
++     QSTRING_S *tl = pl ? pl : nl;
++     int p, c;
++ 
++     if (qstring_is_normal(tl))
++ 	return tl;
++ 
++     p = same_qstring(pl ? pl : cl, pl ? cl : nl);
++ 
++     for (c = 1; c &lt; p; c++, cl = cl-&gt;next, tl = tl-&gt;next);
++ 
++     /*
++      * cl-&gt;next and tl-&gt;next differ, it may be because cl-&gt;next does not
++      * exist or tl-&gt;next does not exist or simply both exist but are
++      * different. In this last case, it may be that cl-&gt;next-&gt;value is made
++      * of spaces. If this is the case, tl advances once more.
++      */
++ 
++     if (tl-&gt;next){
++ 	if (cl &amp;&amp; cl-&gt;next &amp;&amp; value_is_space(cl-&gt;next-&gt;value))
++ 	   tl = tl-&gt;next;
++ 	if (tl-&gt;next)
++ 	   free_qs(&amp;(tl-&gt;next));
++     }
++ 
++     if (!p)
++        free_qs(&amp;cqstring);
++ 
++     return cqstring;
++ }
++ 
++ /* This function trims cl so that it returns a real quote string based
++  * on information gathered from the previous and next lines. pl and cl are
++  * also trimmed, but that is done in another function, not here.
++  */
++ QSTRING_S *
++ fix_qstring(QSTRING_S *cl, QSTRING_S *nl, QSTRING_S *pl)
++ {
++    QSTRING_S *cqstring = cl, *nqstring = nl, *pqstring = pl;
++    int c, n;
++ 
++    if (qstring_is_normal(cl))
++      return cl;
++ 
++    c = count_levels_qstring(cl);
++    n = same_qstring(cl,nl);
++ 
++    if (!n){  /* no next line or no agreement with next line */
++       int p = same_qstring(pl, cl); /* number of agreements between pl and cl */
++       QSTRING_S *tl;              /* test line */
++ 
++       /*
++        * Here p &lt;= c, so either p &lt; c or p == c. If p == c, we are done,
++        * and return cl. If not, there are two cases, either p == 0 or
++        * 0 &lt; p &lt; c. In the first case, we do not have enough evidence
++        * to return anything other than the normal part of cl, in the second
++        * case we can only return p levels of cl.
++        */
++ 
++    if (p == c)
++ 	tl = cqstring;
++    else{
++       if (p){
++ 	   for (c = 1; c &lt; p; c++)
++ 	      cl = cl-&gt;next;
++ 	   free_qs(&amp;(cl-&gt;next));
++ 	   tl = cqstring;
++       }
++       else{
++ 	   int done = 0;
++ 	   QSTRING_S *al = cl;  /* another line */ 
++ 	/*
++ 	 * Ok, we reaelly don't have enough evidence to return anything,
++ 	 * different from the normal part of cl, but it could be possible
++ 	 * that we may want to accept the not-normal part, so we better
++ 	 * make an extra test to determine what needs to be freed
++ 	 */
++ 	  while (pl &amp;&amp; cl &amp;&amp; cl-&gt;qstype == pl-&gt;qstype
++ 		    &amp;&amp; !strucmp(cl-&gt;value, pl-&gt;value)){
++ 		cl = cl-&gt;next;
++ 		pl = pl-&gt;next;
++ 	  }
++           if (pl &amp;&amp; cl &amp;&amp; cl-&gt;qstype == pl-&gt;qstype
++                        &amp;&amp; strcmp_qs(pl-&gt;value, cl-&gt;value))
++                cl = cl-&gt;next;  /* next level differs only in spaces */
++           while (!done){
++                while (cl &amp;&amp; cl-&gt;qstype == qsNormal)
++                    cl = cl-&gt;next;
++                if (cl){
++                   if ((cl-&gt;qstype == qsString)
++                       &amp;&amp; (cl-&gt;value[strlen(cl-&gt;value) - 1] == '&gt;'))
++                      cl = cl-&gt;next;
++                   else done++;
++                }
++                else done++;
++           }
++           if (al == cl){
++              free_qs(&amp;(cl));
++              tl = cl;
++           }
++           else {
++              while (al &amp;&amp; (al-&gt;next != cl))
++                 al = al-&gt;next;
++              cl = al;
++              if (cl &amp;&amp; cl-&gt;next)
++                 free_qs(&amp;(cl-&gt;next));
++              tl = cqstring;
++           }
++        }
++       }
++       return tl;
++    }
++    if (n + 1 &lt; c){  /* if there are not enough agreements */
++       int p = same_qstring(pl, cl); /* number of agreement between pl and cl */
++       QSTRING_S *tl; /* test line */
++        /*
++         * There's no way we can use cl in this case, but we can use
++         * part of cl, this is if pl does not have more agreements
++         * with cl.
++         */ 
++       if (p == c)
++        tl = cqstring;
++       else{
++        int m = p &lt; n ? n : p;
++        for (c = 1; c &lt; m; c++){
++          pl = pl ? pl-&gt;next : (QSTRING_S *) NULL;
++          nl = nl ? nl-&gt;next : (QSTRING_S *) NULL;
++          cl = cl-&gt;next;
++        }
++        if (p == n &amp;&amp; pl &amp;&amp; pl-&gt;next &amp;&amp; nl &amp;&amp; nl-&gt;next
++           &amp;&amp; ((cl-&gt;next-&gt;qstype == pl-&gt;next-&gt;qstype)
++              || (cl-&gt;next-&gt;qstype == nl-&gt;next-&gt;qstype))
++           &amp;&amp; (strcmp_qs(cl-&gt;next-&gt;value, pl-&gt;next-&gt;value)
++              || strcmp_qs(pl-&gt;next-&gt;value, cl-&gt;next-&gt;value)
++              || strcmp_qs(cl-&gt;next-&gt;value, nl-&gt;next-&gt;value)
++              || strcmp_qs(nl-&gt;next-&gt;value, cl-&gt;next-&gt;value)))
++          cl = cl-&gt;next;        /* next level differs only in spaces */
++        if (cl-&gt;next)
++           free_qs(&amp;(cl-&gt;next));
++        tl = cqstring;
++       }
++       return tl;
++    }
++    if (n + 1 == c){
++       int p = same_qstring(pl, cl);
++       QSTRING_S *tl; /* test line */
++ 
++       /*
++        * p &lt;= c, so p &lt;= n+1, which means p &lt; n + 1 or p == n + 1.
++        * If p &lt; n + 1, then p &lt;= n.
++        * so we have three possibilities:
++        *       p == n + 1 or p == n or p &lt; n.
++        * In the first case we copy p == n + 1 == c levels, in the second
++        * and third case we copy n levels, and check if we can copy the
++        * n + 1 == c level.
++        */
++       if (p == n + 1)      /* p == c, in the above sense of c */
++        tl = cl;          /* use cl, this is enough evidence */
++       else{
++        for (c = 1; c &lt; n; c++)
++          cl = cl-&gt;next;
++        /*
++         * Here c == n, we only have one more level of cl, and at least one
++         * more level of nl
++         */
++        if (cl-&gt;next-&gt;qstype == qsNormal)
++           cl = cl-&gt;next;
++        if (cl-&gt;next)
++           free_qs(&amp;(cl-&gt;next));
++        tl = cqstring;
++       }
++       return tl;
++    }
++    if (n == c)  /* Yeah!!! */
++      return cqstring;
++ }
++ 
++ QSTRING_S *
++ fix_qstring_allowed(QSTRING_S *cl, QSTRING_S *nl, QSTRING_S *pl)
++ {
++   if(!cl)
++     return (QSTRING_S *) NULL;
++ 
++   if (qs_allowed(cl))
++       cl-&gt;next = fix_qstring_allowed(cl-&gt;next, (nl ? nl-&gt;next : NULL),
++                        (pl ? pl-&gt;next : NULL));
++   else
++      if((nl &amp;&amp; cl-&gt;qstype == nl-&gt;qstype) || (pl &amp;&amp; cl-&gt;qstype == pl-&gt;qstype)
++       || (!nl &amp;&amp; !pl))
++       free_qs(&amp;cl);
++   return cl;
++ }
++ 
++ /*
++  * This function flattens the quote string returned to us by is_quote. A
++  * crash in this function implies a bug elsewhere.
++  */
++ void
++ flatten_qstring(QSTRING_S *qs, char *buff, int bufflen)
++ { 
++     int i, j; 
++    if(!buff || bufflen &lt;= 0)
++      return;
++ 
++    for (i = 0; qs; qs = qs-&gt;next)
++      for (j = 0; i &lt; bufflen - 1
++                &amp;&amp;  (qs-&gt;value[j]) &amp;&amp; (buff[i++] = qs-&gt;value[j]); j++);
++   buff[i] = '\0';
++ }
++ 
++ /*
++  * Given a string, we return the position where the function thinks that
++  * the quote string is over, if you are ever thinking of fixing something,
++  * you got to the right place. Memory freed by caller. Experience shows
++  * that it only makes sense to initialize memory when we need it, not at
++  * the start of this function.
++  */
++ QSTRING_S *
++  is_quote (char *qs,char *word, int been_here)
++ {
++    int i = 0, j, nxt, prev, finished = 0, offset;
++    unsigned char c;
++    QSTRING_S *qstring = (QSTRING_S *) NULL;
++ 
++    if (!word || !word[0])
++       return (QSTRING_S *) NULL;
++ 
++    while (!finished){
++        /*
++         * Before we apply our rules, let's advance past the quote string
++         * given by the user, this will avoid not recognition of the
++         * user's indent string and application of the arbitrary rules
++         * below. Notice that this step may bring bugs into this
++         * procedure, but these bugs will only appear if the indent string
++         * is really really strange and the text to be justified
++         * cooperates a lot too, so in general this will not be a problem.
++         * If you are concerned about this bug, simply remove the
++         * following lines after this comment and before the &quot;switch&quot;
++         * command below and use a more normal quote string!.
++         */
++        i += advance_quote_string(qs, word, i);
++        if (!word[i]) /* went too far? */
++           return qs_add(qs, word, qsNormal, 0, i, 0, 0);
++ 
++       switch (c = (unsigned char) now(word,i)){
++        case NBSP:
++        case TAB :
++        case ' ' : { QSTRING_S *nextqs, *d;
++ 
++                    for (; ISspace(word[i]); i++); /* FIX ME */
++                    nextqs = is_quote(qs,word+i, 1);
++                  /*
++                   * Merge qstring and nextqs, since this is an artificial
++                   * separation, unless nextqs is of different type.
++                   * What this means in practice is that if
++                   * qs-&gt;qstype == qsNormal and qs-&gt;next != NULL, then
++                   * qs-&gt;next-&gt;qstype != qsNormal.
++                   *
++                   * Can't use qs_add to merge because it could lead
++                   * to an infinite loop (e.g a line &quot;^ ^&quot;).
++                   */
++                    i += nextqs &amp;&amp; nextqs-&gt;qstype == qsNormal
++                        ? strlen(nextqs-&gt;value) : 0;
++                    qstring = (QSTRING_S *) malloc (sizeof(QSTRING_S));
++                    memset (qstring, 0, sizeof(QSTRING_S));
++                    qstring-&gt;value = (char *) malloc((i+1)*sizeof(char));
++                    strncpy(qstring-&gt;value, word, i);
++                    qstring-&gt;value[i] = '\0';
++                    qstring-&gt;qstype   = qsNormal;
++ 		   if(nextqs &amp;&amp; nextqs-&gt;qstype == qsNormal){
++ 			d = nextqs-&gt;next;
++ 			nextqs-&gt;next = NULL;
++ 			qstring-&gt;next = d;
++ 			free_qs(&amp;nextqs);
++ 		   }
++ 		   else
++ 		      qstring-&gt;next     = nextqs;
++ 
++                    return qstring;
++                  }
++                 break;
++        case RPAREN:            /* parenthesis ')' */
++                     if ((i != 0) || ((i == 0) &amp;&amp; been_here))
++                        i++;
++                     else
++                        if (i == 0)
++                           return qs_add(qs, word, qsChar, i, i, 1, 1);
++                        else
++                           finished++;
++                    break;
++ 
++        case ':':                       /* colon */
++        case '~': nxt = next(word,i);
++                  if ((is_tilde(c) &amp;&amp; (nxt == '/'))
++                        || (is_colon(c) &amp;&amp; !is_cquote(nxt)
++                                        &amp;&amp; !is_cword(nxt) &amp;&amp; nxt != RPAREN))
++                     finished++;
++                  else if (is_cquote(c)
++                        || is_cquote(nxt)
++                        || (c != '~' &amp;&amp; nxt == RPAREN)
++                        || (i != 0 &amp;&amp; ISspace(nxt))
++                        || is_cquote(prev = before(word,i))
++                        || (ISspace(prev) &amp;&amp; !is_tilde(c))
++                        || (is_tilde(c) &amp;&amp; nxt != '/'))
++                      i++;
++                  else if (i == 0 &amp;&amp; been_here)
++                       return qs_add(qs, word, qsChar, i, i, 1, 1);
++                  else
++                       finished++;
++                 break;
++ 
++        case '&lt;' :
++        case '=' :
++        case '-' : offset = is_cquote(nxt = next(word,i)) ? 2
++                             : (nxt == c &amp;&amp; is_cquote(next(word,i+1))) ? 3 : -1;
++ 
++                   if (offset &gt; 0)
++                       return qs_add(qs, word, qsString, i, i, offset, 1);
++                   else
++                       finished++;
++                 break;
++ 
++        case '[' :
++        case '+' :      /* accept +&gt;, *&gt; */
++        case '*' :  if (is_rarrow(nxt = next(word, i)) || /* stars */
++                      (ISspace(nxt) &amp;&amp; is_rarrow(next(word,i+1))))
++                         i++;
++                    else
++                       finished++;
++                 break;
++ 
++        case '^' :
++        case '!' :
++        case '%' : if (next(word,i) != c)
++                      return qs_add(qs, word, qsChar, i, i+1, 0, 1);
++                   else
++                      finished++;
++                 break;
++ 
++        case '_' : if(ISspace(next(word, i)))
++                        return qs_add(qs, word, qsChar, i, i+1, 0, 1);
++                   else
++                      finished++;
++                   break;
++ 
++        case '#' : { QStrType qstype = qsChar;
++                     if((nxt = next(word, i)) != c){
++                        if(isdigit((int) nxt))
++                          qstype = qsGdb;
++                        else
++                          if(word_is_prog(word))
++                             qstype = qsProg;
++                        return qs_add(qs, word, qstype, i, i+1, 0, 1);
++                     }
++                     else
++                        finished++;
++                     break;
++                   }
++ 
++          default:
++            if (is_cquote(c))
++               i++;
++            else if (is_cletter(c)){
++                for (j = i; (is_cletter(nxt = next(word,j)) || is_cnumber(nxt))
++                            &amp;&amp; !(ISspace(nxt));j++);
++                  /*
++                   * The whole reason why we are splitting the quote
++                   * string is so that we will be able to accept quote
++                   * strings that are strange in some way. Here we got to
++                   * a point in which a quote string might exist, but it
++                   * could be strange, so we need to create a &quot;next&quot; field
++                   * for the quote string to warn us that something
++                   * strange is coming. We need to confirm if this is a
++                   * good choice later. For now we will let it pass.
++                   */
++                  if (isaword(word,i,j) || isamailbox(word,i,j)){
++                    int offset;
++                    QStrType qstype;
++ 
++                    offset = (is_cquote(c = next(word,j))
++                             || (c == RPAREN)) ? 2
++                                : ((ISspace(c)
++                                     &amp;&amp; is_cquote(next(word,j+1))) ? 3 : -1);
++ 
++                    qstype = (is_cquote(c) || (c == RPAREN))
++                      ? (is_qsword(c) ? qsWord : qsString)
++                      : ((ISspace(c) &amp;&amp; is_cquote(next(word,j+1)))
++                         ? (is_qsword(next(word,j+1))
++                            ? qsWord : qsString)
++                                  : qsString);
++ 
++                    /*
++                     * qsWords are valid quote strings only when
++                     * they are followed by text.
++                     */
++                    if (offset &gt; 0 &amp;&amp; qstype == qsWord &amp;&amp;
++                        !allwd_after_qsword(now(word,j + offset)))
++                        offset = -1;
++ 
++                    if (offset &gt; 0)
++                        return qs_add(qs, word, qstype, i, j, offset, 1);
++                  }
++                  finished++;
++            }
++            else{
++ 	       if(i &gt; 0)
++ 		return qs_add(qs, word, qsNormal, 0, i, 0, 1);
++ 	       else if(!forbidden(c))
++                   return qs_add(qs, word, qsChar, 0, 1, 0, 1);
++                else    /* chao pescao */
++                   finished++;
++            }
++        break;
++       }  /* End Switch */
++     }  /* End while */
++     if (i &gt; 0)
++        qstring = qs_add(qs, word, qsNormal, 0, i, 0, 0);
++     return qstring;
++ }
++ 
++ int
++ isaword(word,i,j)
++  char word[NSTRING];
++  int i;
++  int j;
++ {
++   return i &lt;= j &amp;&amp; is_cletter(word[i]) ?
++           (i &lt; j ? isaword(word,i+1,j) : 1) : 0;
++ }
++ 
++ int
++ isamailbox(word,i,j)
++ char word[NSTRING];
++ int i, j;
++ {
++   return i &lt;= j &amp;&amp; (is_cletter(word[i]) || is_a_digit(word[i])
++                  || word[i] == '.')
++        ? (i &lt; j ? isamailbox(word,i+1,j) : 1) : 0;
++ }
++ 
++ /*
++    This routine removes the last part that is qsword or qschar that is not
++    followed by a normal part. This means that if a qsword or qschar is
++    followed by a qsnormal (or qsstring), we accept the qsword (or qschar)
++    as part of a quote string.
++  */
++ QSTRING_S *
++ remove_qsword(cl)
++   QSTRING_S *cl;
++ {
++      QSTRING_S *np = cl;
++      QSTRING_S *cp = np;               /* this variable trails cl */
++ 
++      while(1){
++         while (cl &amp;&amp; cl-&gt;qstype == qsNormal)
++             cl = cl-&gt;next;
++ 
++         if (cl){
++          if (((cl-&gt;qstype == qsWord) || (cl-&gt;qstype == qsChar))
++                &amp;&amp; !exists_good_part(cl)){
++              if (np == cl)     /* qsword or qschar at the beginning */
++                 free_qs(&amp;cp);
++              else{
++                 while (np-&gt;next != cl)
++                     np = np-&gt;next;
++                 free_qs(&amp;(np-&gt;next));
++             }
++             break;
++          }
++          else
++             cl = cl-&gt;next;
++         }
++         else
++          break;
++     }
++     return cp;
++ }
++ 
++ int
++ exists_good_part (cl)
++   QSTRING_S *cl;
++ {
++    return (cl ? (((cl-&gt;qstype != qsWord) &amp;&amp; (cl-&gt;qstype != qsChar)
++                  &amp;&amp; qs_allowed(cl) &amp;&amp; !value_is_space(cl-&gt;value))
++               ? 1 : exists_good_part(cl-&gt;next))
++ 	      : 0);
++ }
++ 
++ int
++ line_isblank(char *q, char *GLine, char *NLine, char *PLine, int buflen)
++ {
++     int n = 0;
++     QSTRING_S *cl;
++     char qstr[NSTRING];
++ 
++     cl = do_raw_quote_match(q, GLine, NLine, PLine, NULL, NULL);
++ 
++     flatten_qstring(cl, qstr, NSTRING);
++ 
++     free_qs(&amp;cl);
++ 
++     for(n = strlen(qstr); n &lt; buflen &amp;&amp; GLine[n]; n++)
++        if(!ISspace((unsigned char) GLine[n]))
++          return(FALSE);
++ 
++     return(TRUE);
++ }
++ 
++ QSTRING_S *
++ do_raw_quote_match(char *q, char *GLine, char *NLine, char *PLine, QSTRING_S **nlp, QSTRING_S **plp)
++ {
++    QSTRING_S *cl, *nl = NULL, *pl = NULL;
++    char nbuf[NSTRING], pbuf[NSTRING], buf[NSTRING];
++    int emptypl = 0, emptynl = 0;
++ 
++    if (!(cl = is_quote(q, GLine, 0)))  /* if nothing in, nothing out */
++       return cl;
++ 
++    nl = is_quote(q, NLine, 0);         /* Next Line     */
++    if (nlp) *nlp = nl;
++    pl = is_quote(q, PLine, 0);         /* Previous Line */
++    if (plp) *plp = pl;
++    /*
++     * If there's nothing in the preceeding or following line
++     * there is not enough information to accept it or discard it. In this
++     * case it's likely to be an isolated line, so we better accept it
++     * if it does not look like a word.
++     */ 
++    flatten_qstring(pl, pbuf, NSTRING);
++    emptypl = (!PLine || !PLine[0] ||
++                (pl &amp;&amp; value_is_space(pbuf)) &amp;&amp; !PLine[strlen(pbuf)]) ? 1 : 0;
++    if (emptypl){
++       flatten_qstring(nl, nbuf, NSTRING);
++       emptynl = (!NLine || !NLine[0] ||
++                (nl &amp;&amp; value_is_space(nbuf) &amp;&amp; !NLine[strlen(nbuf)])) ? 1 : 0;
++       if (emptynl){
++        cl = remove_qsword(cl);
++        if((cl = fix_qstring_allowed(cl, NULL, NULL)) != NULL)
++           cl = qs_remove_trailing_spaces(cl);
++        free_qs(&amp;nl);
++        free_qs(&amp;pl);
++        if(nlp) *nlp = NULL;
++        if(plp) *plp = NULL;
++ 
++        return cl;
++       }
++    }
++ 
++    /*
++     * If either cl, nl or pl contain suspicious characters that may make
++     * them (or not) be quote strings, we need to fix them, so that the
++     * next pass will be done correctly.
++     */
++ 
++    cl = fix_qstring(cl, nl, pl);
++    nl = trim_qs_from_cl(cl, nl, NULL);
++    pl = trim_qs_from_cl(cl, NULL, pl);
++    if((cl = fix_qstring_allowed(cl, nl, pl)) != NULL){
++      nl = trim_qs_from_cl(cl, nl, NULL);
++      pl = trim_qs_from_cl(cl, NULL, pl);
++    }
++    else{
++      free_qs(&amp;nl);
++      free_qs(&amp;pl);
++    }
++    if(nlp) 
++       *nlp = nl;
++    else
++      free_qs(&amp;nl);
++    if(plp)
++      *plp = pl;
++    else
++      free_qs(&amp;pl);
++    return cl;
++ }
++ 
++ QSTRING_S *
++ do_quote_match(q, GLine, NLine, PLine, rqstr, rqstrlen, plb)
++   char *q,  *GLine, *NLine, *PLine, *rqstr;
++   int   rqstrlen, plb;
++ {
++     QSTRING_S *cl, *nl = NULL, *pl = NULL;
++     int c, n, p,i, j, NewP, NewC, NewN, clength, same = 0;
++     char nbuf[NSTRING], pbuf[NSTRING], buf[NSTRING];
++ 
++     if(rqstr)
++       *rqstr = '\0';
++ 
++     /* if nothing in, nothing out */
++     cl = do_raw_quote_match(q, GLine, NLine, PLine, &amp;nl, &amp;pl);
++     if(cl == NULL){
++       free_qs(&amp;nl);
++       free_qs(&amp;pl);
++       return cl;
++     }
++ 
++     flatten_qstring(cl, rqstr, rqstrlen);
++     flatten_qstring(cl,  buf, NSTRING);
++     flatten_qstring(nl, nbuf, NSTRING);
++     flatten_qstring(pl, pbuf, NSTRING);
++ 
++     /*
++      * Once upon a time, is_quote used to return the length of the quote
++      * string that it had found. One day, not long ago, black hand came
++      * and changed all that, and made is_quote return a quote string
++      * divided in several fields, making the algorithm much more
++      * complicated. Fortunately black hand left a few comments in the
++      * source code to make it more understandable. Because of this change
++      * we need to compute the lengths of the quote strings separately
++      */
++      c =  buf &amp;&amp;  buf[0] ? strlen(buf)  : 0;
++      n = nbuf &amp;&amp; nbuf[0] ? strlen(nbuf) : 0;
++      p = pbuf &amp;&amp; pbuf[0] ? strlen(pbuf) : 0;
++      /*
++       * When quote strings contain only blank spaces (ascii code 32) the
++       * above count is equal to the length of the quote string, but if
++       * there are TABS, the length of the quote string as seen by the user
++       * is different than the number that was just computed.  Because of
++       * this we demand a recount (hmm.. unless you are in Florida, where
++       * recounts are forbidden)
++       */
++      NewP = strlenis(pbuf);
++      NewC = strlenis(buf);
++      NewN = strlenis(nbuf);
++ 
++      /*
++       * For paragraphs with spaces in the first line, but no space in the
++       * quote string of the second line, we make sure we choose the quote
++       * string without a space at the end of it.
++       */
++      if ((NLine &amp;&amp; !NLine[0])
++        &amp;&amp; ((PLine &amp;&amp; !PLine[0])
++             || (((same = same_qstring(pl, cl)) != 0)
++                        &amp;&amp; (same != count_levels_qstring(cl)))))
++        cl = qs_remove_trailing_spaces(cl);
++      else
++        if (NewC &gt; NewN){
++        int agree = 0;
++          for (j = 0; (j &lt; n) &amp;&amp; (GLine[j] == NLine[j]); j++);
++        clength = j;
++        /* clength is the common length in which Gline and Nline agree */
++        /* j &lt; n means that they do not agree fully */
++        /* GLine = &quot;   \tText&quot;
++           NLine = &quot;   Text&quot; */
++        if(j == n)
++           agree++;
++        if (clength &lt; n){ /* see if buf and nbuf are padded with spaces and tabs */
++           for (i = clength; i &lt; n &amp;&amp; ISspace(NLine[i]); i++);
++           if (i == n){/* padded NLine until the end of spaces? */
++              for (i = clength; i &lt; c &amp;&amp; ISspace(GLine[i]); i++);
++                if (i == c) /* Padded CLine until the end of spaces? */
++                   agree++;
++           }
++        }
++          if (agree){
++             for (j = clength; j &lt; c &amp;&amp; ISspace(GLine[j]); j++);
++             if (j == c){
++       /*
++        * If we get here, it means that the current line has the same
++        * quote string (visually) than the next line, but both of them
++        * are padded with different amount of TABS or spaces at the end.
++        * The current line (GLine) has more spaces/TABs than the next
++        * line. This is the typical situation that is found at the
++        * begining of a paragraph. We need to check this, however, by
++        * checking the previous line. This avoids that we confuse
++        * ourselves with being in the last line of a paragraph.
++        * Example when it should not free_qs(cl)
++        * &quot;    Text in Paragraph 1&quot; (PLine)
++        * &quot;    Text in Paragraph 1&quot; (GLine)
++        * &quot;  Other Paragraph Number 2&quot; (NLine)
++        *
++        * Example when it should free_qs(cl):
++        * &quot;:) &quot;                (PLine) p = 3, j = 3
++        * &quot;:)   Text&quot;          (GLine) c = 5
++        * &quot;:) More text&quot;       (NLine) n = 3
++        *
++        * Example when it should free_qs(cl):
++        * &quot;:) &quot;                (PLine) p =  3, j = 3
++        * &quot;:) &gt; &gt; &gt;   Text&quot;    (GLine) c = 11
++        * &quot;:) &gt; &gt; &gt; More text&quot; (NLine) n =  9
++        *
++        * Example when it should free_qs(cl):
++        * &quot;:) :) &quot;             (PLine) p =  6, j = 3
++        * &quot;:) &gt; &gt; &gt;   Text&quot;    (GLine) c = 11
++        * &quot;:) &gt; &gt; &gt; More text&quot; (NLine) n =  9
++        *
++        * Example when it should free_qs(cl):
++        * &quot;:) &gt; &gt; &gt;     &quot;      (PLine) p = 13, j = 11
++        * &quot;:) &gt; &gt; &gt;   Text&quot;    (GLine) c = 11
++        * &quot;:) &gt; &gt; &gt; More text&quot; (NLine) n =  9
++        *
++        * The following example is very interesting. The &quot;Other Text&quot;
++        * line below should free the quote string an make it equal to the
++        * quote string of the line below it, but any algorithm trying
++        * to advance past that line should make it stop there, so
++        * we need one more check, to check the raw quote string and the
++        * processed quote string at the same time.
++        * FREE qs in this example.
++        * &quot;   Some Text&quot;       (PLine) p = 3, j = 0
++        * &quot;\tOther Text&quot;       (GLine) c = 1
++        * &quot;   More Text&quot;       (NLine) n = 3
++        *
++        */
++            for (j = 0; (j &lt; p) &amp;&amp; (GLine[j] == PLine[j]); j++);
++             if ((p != c || j != p) &amp;&amp; NLine[n])
++                if(!get_indent_raw_line(q, PLine, nbuf, NSTRING, p, plb)
++                  || NewP + strlenis(nbuf) != NewC){
++                  free_qs(&amp;cl);
++                  free_qs(&amp;pl);
++                  return nl;
++                }
++             }
++          }
++        }
++ 
++      free_qs(&amp;nl);
++      free_qs(&amp;pl);
++ 
++      return cl;
++ }
++ 
++ /*
++  * Given a line, an initial position, and a quote string, we advance the
++  * current line past the quote string, including arbitraty spaces
++  * contained in the line, except that it removes trailing spaces. We do
++  * not handle TABs, if any, contained in the quote string. At least not
++  * yet.
++  *
++  * Arguments: q - quote string
++  *          l - a line to process
++  *          i - position in the line to start processing. i = 0 is the
++  *              begining of that line.
++  */
++ int
++ advance_quote_string(q, l, i)
++    char *q;
++    char l[NSTRING];
++    int   i;
++ {
++     int n = 0, j = 0, is = 0, es = 0;
++     int k, m, p, adv;
++     char qs[NSTRING] = {'\0'};
++     if(!q || !*q)
++       return(0);
++     for (p = strlen(q); (p &gt; 0) &amp;&amp; (q[p - 1] == ' '); p--, es++);
++     if (!p){  /* string contains only spaces */
++        for (k = 0; ISspace(l[i + k]); k++);
++        k -= k % es;
++        return k;
++     }
++     for (is = 0; ISspace(q[is]); is++); /* count initial spaces */
++     for (m = 0 ; is + m &lt; p ; m++)
++       qs[m] = q[is + m];   /* qs = quote string without any space at the end */
++                      /* advance as many spaces as there are at the begining */
++     for (k = 0; ISspace(l[i + j]); k++, j++);
++                       /* now find the visible string in the line */
++     for (m = 0; qs[m] &amp;&amp; l[i + j] == qs[m]; m++, j++);
++     if (!qs[m]){      /* no match */
++       /*
++        * So far we have advanced at least &quot;is&quot; spaces, plus the visible
++        * string &quot;qs&quot;. Now we need to advance the trailing number of
++        * spaces &quot;es&quot;. If we can do that, we have found the quote string.
++        */
++       for (p = 0; ISspace(l[i + j + p]); p++);
++       adv = advance_quote_string(q, l, i + j + ((p &lt; es) ? p : es));
++       n = ((p &lt; es) ? 0 : es) + k + m + adv;
++     }
++     return n;
++ }
++ 
++ /*
++  * This function returns the effective length in screen of the quote
++  * string. If the string contains a TAB character, it is added here, if
++  * not, the length returned is the length of the string
++  */
++ int strlenis(char *qstr)
++ {
++   int i, rv = 0; 
++   for (i = 0; qstr &amp;&amp; qstr[i]; i++)
++        rv += ((qstr[i] == TAB) ? (~rv &amp; 0x07) + 1 : 1);
++   return rv;
++ }
++ 
++ int
++ is_indent (word, plb)
++  char word[NSTRING];
++   int  plb;
++ {
++   int i = 0, finished = 0, c, nxt, j, k, digit = 0, bdigits = -1, alpha = 0;
++ 
++    if (!word || !word[0])
++       return i;
++ 
++    for (i = 0, j = 0; ISspace(word[i]); i++, j++);
++    while ((i &lt; NSTRING - 2) &amp;&amp; !finished){
++       switch (c = now(word,i)){
++           case NBSP:
++           case TAB :
++           case ' ' : for (; ISspace(word[i]); i++);
++                      if (!is_indent_char(now(word,i)))
++                        finished++;
++                   break;
++ 
++            case '+' :
++            case '.' :
++            case ']' :
++            case '*' :
++            case '}' :
++            case '-' :
++            case RPAREN:
++                   nxt = next(word,i);
++                   if ((c == '.' &amp;&amp; allowed_after_period(nxt) &amp;&amp; alpha)
++                        || (c == '*' &amp;&amp; allowed_after_star(nxt))
++                        || (c == '}' &amp;&amp; allowed_after_braces(nxt))
++                        || (c == '-' &amp;&amp; allowed_after_dash(nxt))
++                        || (c == '+' &amp;&amp; allowed_after_dash(nxt))
++                        || (c == RPAREN &amp;&amp; allowed_after_parenth(nxt))
++                        || (c == ']' &amp;&amp; allowed_after_parenth(nxt)))
++                      i++;
++                   else
++                      finished++;
++                   break;
++ 
++             default : if (is_a_digit(c) &amp;&amp; plb){
++                         if (bdigits &lt; 0)
++                            bdigits = i;  /* first digit */
++                         for (k = i; is_a_digit(now(word,k)); k++);
++                         if (k - bdigits &gt; 2){ /* more than 2 digits? */
++                            i = bdigits; /* too many! */
++                            finished++;
++                         }
++                         else{
++                            if(allowed_after_digit(now(word,k),word,k)){
++                              alpha++;
++                              i = k;
++                            }
++                            else{
++                              i = bdigits;
++                              finished++;
++                            }
++                         }
++                       }
++                       else
++                         finished++;
++                    break;
++ 
++       }
++    }
++    if (i == j)
++       i = 0;  /* there must be something more than spaces in an indent string */
++    return i;
++ }
++ 
++ int
++ get_indent_raw_line(char *q, char *GLine, char *buf, int buflen, int k, int plb)
++ {
++      int i, j;
++ 
++      i = is_indent(GLine+k, plb);
++ 
++      for (j = 0; j &lt; i &amp;&amp; j &lt; buflen &amp;&amp; (buf[j] = GLine[j + k]); j++);
++      buf[j] = '\0';
++ 
++      return i;
++ }
++ 
+diff -rc alpine-1.10/pith/osdep/color.h alpine-1.10.fillpara/pith/osdep/color.h
+*** alpine-1.10/pith/osdep/color.h	2007-05-08 16:38:08.000000000 -0700
+--- alpine-1.10.fillpara/pith/osdep/color.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 43,48 ****
+--- 43,69 ----
+  #define PSC_REV		0x2
+  #define PSC_RET		0x4	/* return an allocated copy of previous color */
+  
++ /*
++  * struct that will help us determine what the quote string of a line
++  * is. The &quot;next&quot; field indicates the presence of a possible continuation.
++  * The idea is that if a continuation fails, we free it and check for the
++  * remaining structure left
++  */
++ 
++ typedef enum {qsNormal, qsString, qsWord, qsChar,
++               qsGdb, qsProg, qsText} QStrType;
++ 
++ typedef struct QSTRING {
++         char            *value;                 /* possible quote string */
++         QStrType         qstype;                /* type of quote string  */
++         struct QSTRING  *next;                  /* possible continuation */
++ } QSTRING_S;
++ 
++ #define UCH(c) ((unsigned char) (c))
++ #define NBSP UCH('\240')
++ #define ISspace(c) (UCH(c) == ' ' || UCH(c) == TAB || UCH(c) == NBSP)
++ 
++ 
+  
+  /*
+   * MATCH_NORM_COLOR means that the color that is set to this value
+***************
+*** 95,100 ****
+--- 116,126 ----
+  char	   *pico_get_last_bg_color(void);
+  char	   *color_to_canonical_name(char *);
+  int	    pico_count_in_color_table(void);
++ int 	    is_indent(char *, int);
++ int	    get_indent_raw_line (char *, char *, char *, int, int, int);
++ int  	    line_isblank(char *, char *, char *, char *, int);
++ int	    strlenis(char *);
++ int	    value_is_space(char *);
+  
+  
+  #endif /* PITH_OSDEP_COLOR_INCLUDED */
+diff -rc alpine-1.10/pith/pine.hlp alpine-1.10.fillpara/pith/pine.hlp
+*** alpine-1.10/pith/pine.hlp	2008-03-14 11:34:08.000000000 -0700
+--- alpine-1.10.fillpara/pith/pine.hlp	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 6408,6413 ****
+--- 6408,6453 ----
+  &amp;quot;type the character ^&amp;quot;.
+  
+  &lt;P&gt;
++ This version of Alpine contains an enhanced algorithm for justification,
++ which allows you to justify text that contains more complicated quote
++ strings. This algorithm is based on pragmatics, rather than on a theory,
++ and seems to work well with most messages. Below you will find technical
++ information on how this algorithm works.
++ 
++ &lt;P&gt;
++ When justifying, Alpine goes through each line of the text and tries to
++ determine for each line what the quote string of that line is. The quote
++ string you provided is always recognized. Among other characters 
++ recognized is &amp;quot;&amp;gt;&amp;quot;.
++ 
++ &lt;P&gt;
++ Some other constructions of quote strings are recognized only if they
++ appear enough in the text. For example &amp;quot;Peter :&amp;quot; is only
++ recognized if it appears in two consecutive lines.
++ 
++ &lt;P&gt; 
++ Additionaly, Alpine recognizes indent-strings and justifies text in a
++ paragraph to the right of indent-string, padding with spaces if necessary.
++ An indent string is one which you use to delimit elements of a list. For
++ example, if you were to write a list of groceries, one may write:
++ 
++ &lt;UL&gt;
++ &lt;LI&gt; Fruit
++ &lt;LI&gt; Bread
++ &lt;LI&gt; Eggs
++ &lt;/UL&gt;
++ 
++ &lt;P&gt; 
++ In this case the character &amp;quot;*&amp;quot; is the indent-string. Aline
++ recognizes numbers (0, 1, 2.5, etc) also as indent-strings, and certain
++ combinations of spaces, periods, and parenthesis. In any case, numbers are
++ recognized &lt;B&gt;ONLY&lt;/B&gt; if the line preceeding the given line is empty or
++ ends in one of the characters &amp;quot;.&amp;quot; or &amp;quot;:&amp;quot;.
++ In addition to the explanation of what constitutes a paragraph above, a
++ new paragraph is recognized when an indent-string is found in it (and
++ validated according to the above stated rules).
++ 
++ &lt;P&gt;
+  &amp;lt;End of help on this topic&amp;gt;
+  &lt;/BODY&gt;
+  &lt;/HTML&gt;
+diff -rc alpine-1.10/pith/reply.c alpine-1.10.fillpara/pith/reply.c
+*** alpine-1.10/pith/reply.c	2008-03-06 12:54:01.000000000 -0800
+--- alpine-1.10.fillpara/pith/reply.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 2619,2624 ****
+--- 2619,2627 ----
+   		if(flow_res)
+  		  wrapflags |= GFW_FLOW_RESULT;
+  
++ 		filters[filtcnt].filter = gf_quote_test;
++ 		filters[filtcnt++].data = gf_line_test_opt(select_quote, NULL);
++ 
+  		filters[filtcnt].filter = gf_wrap;
+  		/* 
+  		 * The 80 will cause longer lines than what is likely
+***************
+*** 2711,2717 ****
+  	dq.do_color   = 0;
+  	dq.delete_all = 1;
+  
+! 	filters[filtcnt].filter = gf_line_test;
+  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &amp;dq);
+      }
+  
+--- 2714,2720 ----
+  	dq.do_color   = 0;
+  	dq.delete_all = 1;
+  
+! 	filters[filtcnt].filter = gf_quote_test;
+  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &amp;dq);
+      }
+  
+diff -rc alpine-1.10/pith/state.h alpine-1.10.fillpara/pith/state.h
+*** alpine-1.10/pith/state.h	2008-02-27 17:04:46.000000000 -0800
+--- alpine-1.10.fillpara/pith/state.h	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 240,245 ****
+--- 240,246 ----
+  
+      SPEC_COLOR_S *hdr_colors;		/* list of configed colors for view */
+  
++     char	*prefix;		/* prefix for fillpara */
+      short	 init_context;
+  
+      int         *initial_cmds;         /* cmds to execute on startup */
+diff -rc alpine-1.10/pith/text.c alpine-1.10.fillpara/pith/text.c
+*** alpine-1.10/pith/text.c	2008-03-05 10:56:28.000000000 -0800
+--- alpine-1.10.fillpara/pith/text.c	2008-05-19 16:31:06.000000000 -0700
+***************
+*** 91,97 ****
+      char       *err, *charset;
+      int		filtcnt = 0, error_found = 0, column, wrapit;
+      int         is_in_sig = OUT_SIG_BLOCK;
+!     int         is_flowed_msg = 0;
+      int         is_delsp_yes = 0;
+      int         filt_only_c0 = 0;
+      char       *parmval;
+--- 91,97 ----
+      char       *err, *charset;
+      int		filtcnt = 0, error_found = 0, column, wrapit;
+      int         is_in_sig = OUT_SIG_BLOCK;
+!     int         is_flowed_msg = 0, add_me = 1, doraw = RAWSTRING;
+      int         is_delsp_yes = 0;
+      int         filt_only_c0 = 0;
+      char       *parmval;
+***************
+*** 181,187 ****
+  	   &amp;&amp; pico_usingcolor()
+  	   &amp;&amp; VAR_SIGNATURE_FORE_COLOR
+  	   &amp;&amp; VAR_SIGNATURE_BACK_COLOR){
+! 	    filters[filtcnt].filter = gf_line_test;
+  	    filters[filtcnt++].data = gf_line_test_opt(color_signature,
+  						       &amp;is_in_sig);
+  	}
+--- 181,187 ----
+  	   &amp;&amp; pico_usingcolor()
+  	   &amp;&amp; VAR_SIGNATURE_FORE_COLOR
+  	   &amp;&amp; VAR_SIGNATURE_BACK_COLOR){
+! 	    filters[filtcnt].filter = gf_quote_test;
+  	    filters[filtcnt++].data = gf_line_test_opt(color_signature,
+  						       &amp;is_in_sig);
+  	}
+***************
+*** 199,207 ****
+  	   &amp;&amp; pico_usingcolor()
+  	   &amp;&amp; VAR_QUOTE1_FORE_COLOR
+  	   &amp;&amp; VAR_QUOTE1_BACK_COLOR){
+! 	    filters[filtcnt].filter = gf_line_test;
+! 	    filters[filtcnt++].data = gf_line_test_opt(color_a_quote,
+! 						       &amp;is_flowed_msg);
+  	}
+      }
+      else if(!strucmp(att-&gt;body-&gt;subtype, &quot;richtext&quot;)){
+--- 199,207 ----
+  	   &amp;&amp; pico_usingcolor()
+  	   &amp;&amp; VAR_QUOTE1_FORE_COLOR
+  	   &amp;&amp; VAR_QUOTE1_BACK_COLOR){
+! 	    add_me = 0;
+! 	    filters[filtcnt].filter = gf_quote_test;
+! 	    filters[filtcnt++].data = gf_line_test_opt(color_a_quote, &amp;is_flowed_msg);
+  	}
+      }
+      else if(!strucmp(att-&gt;body-&gt;subtype, &quot;richtext&quot;)){
+***************
+*** 282,287 ****
+--- 282,292 ----
+  	}
+      }
+  
++     if (add_me){
++       filters[filtcnt].filter = gf_quote_test;
++       filters[filtcnt++].data = gf_line_test_opt(select_quote, &amp;doraw);
++     }
++ 
+      /*
+       * If the message is not flowed, we do the quote suppression before
+       * the wrapping, because the wrapping does not preserve the quote
+***************
+*** 306,312 ****
+  	    dq.handlesp   = handlesp;
+  	    dq.do_color   = (!(flags &amp; FM_NOCOLOR) &amp;&amp; pico_usingcolor());
+  
+! 	    filters[filtcnt].filter = gf_line_test;
+  	    filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &amp;dq);
+  	}
+  	if(ps_global-&gt;VAR_QUOTE_REPLACE_STRING
+--- 311,317 ----
+  	    dq.handlesp   = handlesp;
+  	    dq.do_color   = (!(flags &amp; FM_NOCOLOR) &amp;&amp; pico_usingcolor());
+  
+! 	    filters[filtcnt].filter = gf_quote_test;
+  	    filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &amp;dq);
+  	}
+  	if(ps_global-&gt;VAR_QUOTE_REPLACE_STRING
+***************
+*** 365,371 ****
+  	dq.handlesp   = handlesp;
+  	dq.do_color   = (!(flags &amp; FM_NOCOLOR) &amp;&amp; pico_usingcolor());
+  
+! 	filters[filtcnt].filter = gf_line_test;
+  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &amp;dq);
+      }
+  
+--- 370,376 ----
+  	dq.handlesp   = handlesp;
+  	dq.do_color   = (!(flags &amp; FM_NOCOLOR) &amp;&amp; pico_usingcolor());
+  
+! 	filters[filtcnt].filter = gf_quote_test;
+  	filters[filtcnt++].data = gf_line_test_opt(delete_quotes, &amp;dq);
+      }
+  
+***************
+*** 570,576 ****
+  {
+      DELQ_S *dq;
+      char   *lp;
+!     int     i, lines, not_a_quote = 0;
+      size_t  len;
+  
+      dq = (DELQ_S *) local;
+--- 575,581 ----
+  {
+      DELQ_S *dq;
+      char   *lp;
+!     int     i, lines, not_a_quote = 0, code;
+      size_t  len;
+  
+      dq = (DELQ_S *) local;
+***************
+*** 590,595 ****
+--- 595,602 ----
+  	for(i = dq-&gt;indent_length; i &gt; 0 &amp;&amp; !not_a_quote &amp;&amp; *lp; i--)
+  	  if(*lp++ != SPACE)
+  	    not_a_quote++;
++ 	while(isspace((unsigned char) *lp))
++ 	   lp++;
+  	
+  	/* skip over leading tags */
+  	while(!not_a_quote
+***************
+*** 629,641 ****
+  	    }
+  	}
+  
+! 	/* skip over whitespace */
+! 	if(!dq-&gt;is_flowed)
+! 	  while(isspace((unsigned char) *lp))
+! 	    lp++;
+! 
+! 	/* check first character to see if it is a quote */
+! 	if(!not_a_quote &amp;&amp; *lp != '&gt;')
+  	  not_a_quote++;
+  
+  	if(not_a_quote){
+--- 636,647 ----
+  	    }
+  	}
+  
+! 	len = lp - line;
+! 	if(strlen(tmp_20k_buf) &gt; len)
+! 	  strcpy(tmp_20k_buf, tmp_20k_buf+len);
+!         code =  (dq-&gt;is_flowed ? IS_FLOWED : NO_FLOWED) | DELETEQUO;
+! 	select_quote(linenum, lp, ins,  &amp;code);
+! 	if (!not_a_quote &amp;&amp; !tmp_20k_buf[0])
+  	  not_a_quote++;
+  
+  	if(not_a_quote){

Added: trunk/rpms/alpine/alpine-1.10-maildir.patch
===================================================================
--- trunk/rpms/alpine/alpine-1.10-maildir.patch	                        (rev 0)
+++ trunk/rpms/alpine/alpine-1.10-maildir.patch	2008-07-31 00:54:17 UTC (rev 6434)
@@ -0,0 +1,3624 @@
+diff -rc alpine-1.10/alpine/alpine.c alpine-1.10.maildir/alpine/alpine.c
+*** alpine-1.10/alpine/alpine.c	2008-02-29 10:18:49.000000000 -0800
+--- alpine-1.10.maildir/alpine/alpine.c	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 539,544 ****
+--- 539,549 ----
+      if(F_ON(F_MAILDROPS_PRESERVE_STATE, ps_global))
+        mail_parameters(NULL, SET_SNARFPRESERVE, (void *) TRUE);
+  
++ #ifndef _WINDOWS
++     mail_parameters(NULL,SET_COURIERSTYLE,
++                (void *)(F_ON(F_COURIER_FOLDER_LIST, ps_global) ? 1 : 0));
++ #endif
++ 
+      rvl = 0L;
+      if(pine_state-&gt;VAR_NNTPRANGE){
+  	if(!SVAR_NNTPRANGE(pine_state, rvl, tmp_20k_buf, SIZEOF_20KBUF))
+diff -rc alpine-1.10/alpine/confscroll.c alpine-1.10.maildir/alpine/confscroll.c
+*** alpine-1.10/alpine/confscroll.c	2008-01-04 14:49:15.000000000 -0800
+--- alpine-1.10.maildir/alpine/confscroll.c	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 5473,5478 ****
+--- 5473,5484 ----
+  			  (void *)var-&gt;current_val.p);
+      }
+  #endif
++ #ifndef _WINDOWS
++     else if(var == &amp;ps-&gt;vars[V_MAILDIR_LOCATION]){
++       if(var-&gt;current_val.p &amp;&amp; var-&gt;current_val.p[0])
++ 	mail_parameters(NULL, SET_MDINBOXPATH, (void *)var-&gt;current_val.p);
++     }
++ #endif
+      else if(revert &amp;&amp; standard_radio_var(ps, var)){
+  
+  	cur_rule_value(var, TRUE, FALSE);
+diff -rc alpine-1.10/imap/src/c-client/mail.c alpine-1.10.maildir/imap/src/c-client/mail.c
+*** alpine-1.10/imap/src/c-client/mail.c	2008-03-13 10:45:01.000000000 -0700
+--- alpine-1.10.maildir/imap/src/c-client/mail.c	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 993,999 ****
+    MAILSTREAM *ts;
+    char *s,*t,tmp[MAILTMPLEN];
+    size_t i;
+!   DRIVER *d;
+  				/* never allow names with newlines */
+    if (s = strpbrk (mailbox,&quot;\015\012&quot;)) {
+      MM_LOG (&quot;Can't create mailbox with such a name&quot;,ERROR);
+--- 993,999 ----
+    MAILSTREAM *ts;
+    char *s,*t,tmp[MAILTMPLEN];
+    size_t i;
+!   DRIVER *d, *md;
+  				/* never allow names with newlines */
+    if (s = strpbrk (mailbox,&quot;\015\012&quot;)) {
+      MM_LOG (&quot;Can't create mailbox with such a name&quot;,ERROR);
+***************
+*** 1017,1022 ****
+--- 1017,1024 ----
+      return NIL;
+    }
+  
++   /* Hack, we should do this better, but it works */
++     for (md = maildrivers; md &amp;&amp; strcmp (md-&gt;name, &quot;md&quot;); md = md-&gt;next);
+  				/* see if special driver hack */
+    if ((mailbox[0] == '#') &amp;&amp; ((mailbox[1] == 'd') || (mailbox[1] == 'D')) &amp;&amp;
+        ((mailbox[2] == 'r') || (mailbox[2] == 'R')) &amp;&amp;
+***************
+*** 1047,1052 ****
+--- 1049,1061 ----
+  	   (((*mailbox == '{') || (*mailbox == '#')) &amp;&amp;
+  	    (stream = mail_open (NIL,mailbox,OP_PROTOTYPE | OP_SILENT))))
+      d = stream-&gt;dtb;
++   else if(mailbox[0] == '#'
++ 	&amp;&amp; (mailbox[1] == 'm' || mailbox[1] == 'M')
++ 	&amp;&amp; (mailbox[2] == 'd' || mailbox[2] == 'D'
++ 	    || mailbox[2] == 'c' || mailbox[2] == 'C')
++ 	&amp;&amp; mailbox[3] == '/'
++ 	&amp;&amp; mailbox[4] != '\0')
++      return (*md-&gt;create)(stream, mailbox);
+    else if ((*mailbox != '{') &amp;&amp; (ts = default_proto (NIL))) d = ts-&gt;dtb;
+    else {			/* failed utterly */
+      sprintf (tmp,&quot;Can't create mailbox %.80s: indeterminate format&quot;,mailbox);
+diff -rc alpine-1.10/imap/src/c-client/mail.h alpine-1.10.maildir/imap/src/c-client/mail.h
+*** alpine-1.10/imap/src/c-client/mail.h	2008-02-15 11:04:45.000000000 -0800
+--- alpine-1.10.maildir/imap/src/c-client/mail.h	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 353,358 ****
+--- 353,362 ----
+  #define SET_SCANCONTENTS (long) 573
+  #define GET_MHALLOWINBOX (long) 574
+  #define SET_MHALLOWINBOX (long) 575
++ #define GET_COURIERSTYLE (long) 576
++ #define SET_COURIERSTYLE (long) 577
++ #define SET_MDINBOXPATH  (long) 578
++ #define GET_MDINBOXPATH  (long) 579
+  
+  /* Driver flags */
+  
+diff -rc alpine-1.10/imap/src/osdep/unix/dummy.c alpine-1.10.maildir/imap/src/osdep/unix/dummy.c
+*** alpine-1.10/imap/src/osdep/unix/dummy.c	2007-06-01 17:06:58.000000000 -0700
+--- alpine-1.10.maildir/imap/src/osdep/unix/dummy.c	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 106,116 ****
+   * Accepts: mailbox name
+   * Returns: our driver if name is valid, NIL otherwise
+   */
+! 
+  DRIVER *dummy_valid (char *name)
+  {
+    char *s,tmp[MAILTMPLEN];
+    struct stat sbuf;
+  				/* must be valid local mailbox */
+    if (name &amp;&amp; *name &amp;&amp; (*name != '{') &amp;&amp; (s = mailboxfile (tmp,name))) {
+  				/* indeterminate clearbox INBOX */
+--- 106,118 ----
+   * Accepts: mailbox name
+   * Returns: our driver if name is valid, NIL otherwise
+   */
+! char * maildir_remove_root(char *);
+  DRIVER *dummy_valid (char *name)
+  {
+    char *s,tmp[MAILTMPLEN];
+    struct stat sbuf;
++   strcpy(tmp, name);
++   name = maildir_remove_root(tmp);
+  				/* must be valid local mailbox */
+    if (name &amp;&amp; *name &amp;&amp; (*name != '{') &amp;&amp; (s = mailboxfile (tmp,name))) {
+  				/* indeterminate clearbox INBOX */
+***************
+*** 454,459 ****
+--- 456,463 ----
+  {
+    char *s,tmp[MAILTMPLEN];
+    long ret = NIL;
++   if(!strncmp(mailbox,&quot;#md/&quot;,4) || !strncmp(mailbox,&quot;#mc/&quot;, 4))
++     return maildir_create(stream, mailbox);
+  				/* validate name */
+    if (!(compare_cstring (mailbox,&quot;INBOX&quot;) &amp;&amp; (s = dummy_file (tmp,mailbox)))) {
+      sprintf (tmp,&quot;Can't create %.80s: invalid name&quot;,mailbox);
+***************
+*** 519,524 ****
+--- 523,536 ----
+  {
+    struct stat sbuf;
+    char *s,tmp[MAILTMPLEN];
++   if (!strncmp(mailbox,&quot;#md/&quot;,4) || !strncmp(mailbox,&quot;#mc/&quot;, 4) 
++ 	|| is_valid_maildir(&amp;mailbox)){
++     char tmp[MAILTMPLEN] = {'\0'};
++     strcpy(tmp, mailbox);
++     if(tmp[strlen(tmp) - 1] != '/')
++        tmp[strlen(tmp)] = '/';
++      return maildir_delete(stream, tmp);
++   }
+    if (!(s = dummy_file (tmp,mailbox))) {
+      sprintf (tmp,&quot;Can't delete - invalid name: %.80s&quot;,s);
+      MM_LOG (tmp,ERROR);
+***************
+*** 545,550 ****
+--- 557,567 ----
+  {
+    struct stat sbuf;
+    char c,*s,tmp[MAILTMPLEN],mbx[MAILTMPLEN],oldname[MAILTMPLEN];
++ 
++   strcpy(tmp, old);
++   old = maildir_remove_root(tmp);
++   strcpy(tmp, newname);
++   newname = maildir_remove_root(tmp);
+  				/* no trailing / allowed */
+    if (!dummy_file (oldname,old) || !(s = dummy_file (mbx,newname)) ||
+        stat (oldname,&amp;sbuf) || ((s = strrchr (s,'/')) &amp;&amp; !s[1] &amp;&amp;
+diff -rc alpine-1.10/imap/src/osdep/unix/maildir.c alpine-1.10.maildir/imap/src/osdep/unix/maildir.c
+*** alpine-1.10/imap/src/osdep/unix/maildir.c	2008-05-16 16:19:12.000000000 -0700
+--- alpine-1.10.maildir/imap/src/osdep/unix/maildir.c	2008-05-16 12:54:33.000000000 -0700
+***************
+*** 0 ****
+--- 1,2583 ----
++ /*
++  * Maildir driver for Alpine 1.10
++  * 
++  * Written by Eduardo Chappa &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">chappa at washington.edu</A>&gt;
++  * Last Update: May 16, 2008
++  *
++  */
++ 
++ #include &lt;stdio.h&gt;
++ #include &lt;ctype.h&gt;
++ #include &lt;errno.h&gt;
++ extern int errno;		/* just in case */
++ #include &quot;mail.h&quot;
++ #include &quot;osdep.h&quot;
++ #include &lt;pwd.h&gt;
++ #include &lt;sys/stat.h&gt;
++ #include &lt;sys/time.h&gt;
++ #include &quot;maildir.h&quot;
++ #include &quot;rfc822.h&quot;
++ #include &quot;fdstring.h&quot;
++ #include &quot;misc.h&quot;
++ #include &quot;dummy.h&quot;
++ 
++ /* Driver dispatch used by MAIL */
++ DRIVER maildirdriver = {
++   &quot;md&quot;,			/* driver name, yes it's md, not maildir */
++ 				/* driver flags */
++   DR_MAIL|DR_LOCAL|DR_NAMESPACE|DR_DIRFMT,
++   (DRIVER *) NIL,		/* next driver 				*/
++   maildir_valid,		/* mailbox is valid for us 		*/
++   maildir_parameters,		/* manipulate parameters		*/
++   NIL,				/* scan mailboxes 			*/
++   maildir_list,			/* find mailboxes 			*/
++   maildir_lsub,			/* find subscribed mailboxes 		*/
++   maildir_sub,			/* subscribe to mailbox 		*/
++   maildir_unsub,		/* unsubscribe from mailbox 		*/
++   maildir_create,		/* create mailbox 			*/
++   maildir_delete,		/* delete mailbox 			*/
++   maildir_rename,		/* rename mailbox 			*/
++   mail_status_default,		/* status of mailbox 			*/
++   maildir_open,			/* open mailbox				*/
++   maildir_close,		/* close mailbox 			*/
++   maildir_fast,			/* fetch message &quot;fast&quot; attributes	*/
++   NIL,				/* fetch message flags 			*/
++   NIL,				/* fetch overview 			*/
++   NIL,				/* fetch message structure 		*/
++   maildir_header,		/* fetch message header 		*/
++   maildir_text,			/* fetch message body 			*/
++   NIL,				/* fetch partial message text 		*/
++   NIL,				/* unique identifier 			*/
++   NIL,				/* message number 			*/
++   NIL,				/* modify flags 			*/
++   maildir_flagmsg,		/* per-message modify flags 		*/
++   NIL,				/* search for message based on criteria */
++   NIL,				/* sort messages 			*/
++   NIL,				/* thread messages 			*/
++   maildir_ping,			/* ping mailbox to see if still alive 	*/
++   maildir_check,		/* check for new messages		*/
++   maildir_expunge,		/* expunge deleted messages 		*/
++   maildir_copy,			/* copy messages to another mailbox 	*/
++   maildir_append,		/* append string message to mailbox 	*/
++   NIL				/* garbage collect stream 		*/
++ };
++ 
++ 
++ DRIVER courierdriver = {
++   &quot;mc&quot;,				/* Why a separate driver? So that
++ 				   createproto will work		*/
++ 				/* driver flags */
++   DR_MAIL|DR_LOCAL|DR_NAMESPACE|DR_DIRFMT,
++   (DRIVER *) NIL,		/* next driver 				*/
++   maildir_valid,		/* mailbox is valid for us 		*/
++   maildir_parameters,		/* manipulate parameters		*/
++   NIL,				/* scan mailboxes 			*/
++   courier_list,			/* find mailboxes 			*/
++   maildir_lsub,			/* find subscribed mailboxes 		*/
++   maildir_sub,			/* subscribe to mailbox 		*/
++   maildir_unsub,		/* unsubscribe from mailbox 		*/
++   maildir_create,		/* create mailbox 			*/
++   maildir_delete,		/* delete mailbox 			*/
++   maildir_rename,		/* rename mailbox 			*/
++   mail_status_default,		/* status of mailbox 			*/
++   maildir_open,			/* open mailbox				*/
++   maildir_close,		/* close mailbox 			*/
++   maildir_fast,			/* fetch message &quot;fast&quot; attributes	*/
++   NIL,				/* fetch message flags 			*/
++   NIL,				/* fetch overview 			*/
++   NIL,				/* fetch message structure 		*/
++   maildir_header,		/* fetch message header 		*/
++   maildir_text,			/* fetch message body 			*/
++   NIL,				/* fetch partial message text 		*/
++   NIL,				/* unique identifier 			*/
++   NIL,				/* message number 			*/
++   NIL,				/* modify flags 			*/
++   maildir_flagmsg,		/* per-message modify flags 		*/
++   NIL,				/* search for message based on criteria */
++   NIL,				/* sort messages 			*/
++   NIL,				/* thread messages 			*/
++   maildir_ping,			/* ping mailbox to see if still alive 	*/
++   maildir_check,		/* check for new messages		*/
++   maildir_expunge,		/* expunge deleted messages 		*/
++   maildir_copy,			/* copy messages to another mailbox 	*/
++   maildir_append,		/* append string message to mailbox 	*/
++   NIL				/* garbage collect stream 		*/
++ };
++ 
++ MAILSTREAM maildirproto = {&amp;maildirdriver};	/* prototype stream */
++ MAILSTREAM courierproto = {&amp;courierdriver};	/* prototype stream */
++ 
++ long maildir_dirfmttest (char *name)
++ {
++   int i;
++   for (i = 0; mdstruct[i] &amp;&amp; strcmp(name, mdstruct[i]); i++);
++   return (i &lt; EndDir) || !strcmp(name, MDDIR) 
++ 	|| !strncmp(name, MDUIDLAST, strlen(MDUIDLAST))
++ 	|| !strncmp(name, MDUIDTEMP, strlen(MDUIDTEMP)) ? LONGT : NIL;
++ }
++ 
++ void 
++ md_domain_name(void)
++ {
++    int i;
++ 
++    strcpy(mdlocaldomain,mylocalhost ());
++    for (i = 0; mdlocaldomain[i] ; i++)
++       if(mdlocaldomain[i] == '/')
++ 	 mdlocaldomain[i] = '\057';
++       else if (mdlocaldomain[i] == ':')
++ 	 mdlocaldomain[i] =  '\072';
++ }
++ 
++ char *
++ myrootdir(char *name)
++ {
++ return myhomedir();
++ }
++ 
++ char *
++ mdirpath(void)
++ {
++   char *path = maildir_parameters(GET_MDINBOXPATH,NIL);
++   return path ? (*path ? path : &quot;.&quot;) : &quot;Maildir&quot;;
++ }
++ 
++ /* remove the &quot;#md/&quot; or &quot;#mc/&quot; part from a folder name */
++ char *
++ maildir_remove_root (char *name)
++ {
++   int courier = IS_COURIER(name), offset;
++   char realname[MAILTMPLEN];
++ 
++   offset = maildir_valid_name(name) ? (name[3] == '/' ? 4 : 3) : 0;
++   if(courier)
++      courier_realname(name+offset, realname);
++   else
++      strcpy(realname, name+offset);
++   return cpystr(realname);
++ }
++ 
++ 
++ /* Check validity of the name, we accept:
++  *	a) #md/directory/folder
++  *	b) #md/inbox
++  * A few considerations: We can only accept as valid
++  *  a) names that start with #md/ and the directory exists or
++  *  b) names that do not start with #md/ but are maildir directories (have
++  *     the /cur, /tmp and /new structure)
++  */
++ int maildir_valid_name (char *name)
++ {
++   char tmpname[MAILTMPLEN] = {'\0'};
++ 
++    if (mdfpath)
++       fs_give((void **)&amp;mdfpath);
++    if (name &amp;&amp; (name[0] != '#'))
++ 	sprintf(tmpname,&quot;%s%s&quot;,MDPREFIX(CCLIENT), name);
++    mdfpath = cpystr(tmpname[0] ? tmpname : name);
++ 
++   return IS_CCLIENT(name) || IS_COURIER(name);
++ }
++ 
++ /* Check if the directory whose path is given by name is a valid maildir
++  *  directory (contains /cur, /tmp and /new)
++  */
++ int maildir_valid_dir (char *name)
++ {
++  int len;
++  DirNamesType i;
++  struct stat sbuf;
++  char tmp[MAILTMPLEN];
++ 
++    if(name[strlen(name) - 1] == '/')
++       name[strlen(name) - 1] = '\0';
++    len = strlen(name);
++    for (i = Cur; i != EndDir; i++){
++       MDFLD(tmp, name, i);
++       if (stat(tmp, &amp;sbuf) &lt; 0 || !S_ISDIR(sbuf.st_mode))
++ 	  break;
++    }
++    name[len] = '\0';
++    return (i == EndDir) ? T : NIL;
++ }
++ 
++ void courier_realname(char *name, char *realname)
++ {
++   int i,j;
++ 
++   if(!name)
++     return;
++ 
++   for (i = 0, j = 0; i &lt; MAILTMPLEN &amp;&amp; j &lt; strlen(name); j++, i++){
++       realname[i] = name[j];
++       if(name[j] == '/' &amp;&amp; name[j+1] != '.' &amp;&amp; name[j+1] != '%' 
++ 		&amp;&amp; name[j+1] != '*') 
++ 	realname[++i] = '.';
++   }
++   if(realname[i-1] == '.')
++     i--; 
++   realname[i] = '\0';
++ }
++ 
++ 
++ /* given a maildir folder, return its path. Memory freed by caller. Directory
++  * does not contain the trailing slash &quot;/&quot;. On error NULL is returned.
++  */
++ int maildir_file_path (char *name, char *tmp)
++ {
++    char *maildirpath = mdirpath();
++    int courier = IS_COURIER(name);
++ 
++    /* There are several ways in which the path can come, so we will handle 
++       them here. First we deal with #mc/ or #md/ prefix by removing the 
++       prefix, if any */
++ 
++     if(strlen(name) &gt;= MAILTMPLEN)
++       name[MAILTMPLEN] = '\0';
++     strcpy(tmp, name);
++     name = maildir_remove_root(tmp);
++     tmp[0] = '\0';	/* just in case something fails */
++ 
++     if (strlen(myrootdir(name)) + 
++ 		max(strlen(name), strlen(maildirpath)) &gt; MAILTMPLEN){
++ 	errno = ENAMETOOLONG;
++ 	sprintf(tmp,&quot;Error opening \&quot;%s\&quot;: %s&quot;, name, strerror (errno));
++ 	mm_log(tmp,ERROR);
++ 	return NIL;
++     }
++ 
++     /* There are two ways in which the name can come here, either as a 
++        full path or not. If it is not a full path it can come in two ways, 
++        either as a file system path (Maildir/.Drafts) or as a maildir path 
++        (INBOX.Drafts)
++      */
++ 
++      if(*name == '/')	/* full path */
++ 	strcpy(tmp, name); /* do nothing */
++      else{
++ 	sprintf (tmp,&quot;%s/%s%s%s&quot;, myrootdir (name),
++ 	    strncmp (ucase (strcpy (tmp, name)), &quot;INBOX&quot;, 5) 
++ 		? name : maildirpath,
++ 	    strncmp (ucase (strcpy (tmp, name)), &quot;INBOX&quot;, 5) 
++ 		? &quot;&quot; : (courier ? &quot;/&quot; : &quot;&quot;),
++ 	    strncmp (ucase (strcpy (tmp, name)), &quot;INBOX&quot;, 5) 
++ 		? &quot;&quot; : (*(name+5) == MDSEPARATOR(courier) ? name+5 : &quot;&quot;));
++      }
++ 
++     return tmp[0] ? T : NIL;
++ }
++ 
++ /* This function is given a full path for a mailbox and returns
++  * if it is a valid maildir transformed to canonical notation
++  */
++ int
++ is_valid_maildir (char **name)
++ {
++   if (!strncmp(*name, myrootdir (*name), strlen(myrootdir(*name)))){
++      (*name) += strlen(myrootdir(*name));
++      if (**name == '/') (*name)++;
++   }
++   return maildir_valid(*name) ? T :  NIL;
++ }
++ 
++ /* Check validity of mailbox. This routine does not send errors to log, other
++  *  routines calling this one may do so, though
++  */ 
++ 
++ DRIVER *maildir_valid (char *name)
++ {
++    char tmpname[MAILTMPLEN];
++ 
++    maildir_file_path(name, tmpname);
++    
++    return maildir_valid_dir(tmpname) 
++ 		? (IS_COURIER(name) ? &amp;courierdriver : &amp;maildirdriver) : NIL;
++ }
++ 
++ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags)
++ {
++   unsigned long i;
++   MESSAGECACHE *elt;
++                                 /* get sequence */
++   if (stream &amp;&amp; LOCAL &amp;&amp; ((flags &amp; FT_UID) ?
++                           mail_uid_sequence (stream,sequence) :
++                           mail_sequence (stream,sequence)))
++     for (i = 1L; i &lt;= stream-&gt;nmsgs; i++) {
++       if ((elt = mail_elt (stream,i))-&gt;sequence &amp;&amp; (elt-&gt;valid = T) &amp;&amp;
++           !(elt-&gt;day &amp;&amp; elt-&gt;rfc822_size)) {
++         ENVELOPE **env = NIL;
++         ENVELOPE *e = NIL;
++         if (!stream-&gt;scache) env = &amp;elt-&gt;private.msg.env;
++         else if (stream-&gt;msgno == i) env = &amp;stream-&gt;env;
++         else env = &amp;e;
++         if (!*env || !elt-&gt;rfc822_size) {
++           STRING bs;
++           unsigned long hs;
++           char *ht = (*stream-&gt;dtb-&gt;header) (stream,i,&amp;hs,NIL);
++ 
++           if (!*env) rfc822_parse_msg (env,NIL,ht,hs,NIL,BADHOST,
++                                        stream-&gt;dtb-&gt;flags);
++           if (!elt-&gt;rfc822_size) {
++             (*stream-&gt;dtb-&gt;text) (stream,i,&amp;bs,FT_PEEK);
++             elt-&gt;rfc822_size = hs + SIZE (&amp;bs) - GETPOS (&amp;bs);
++           }
++         }
++ 
++         if (!elt-&gt;day &amp;&amp; *env &amp;&amp; (*env)-&gt;date)
++           mail_parse_date (elt,(*env)-&gt;date);
++ 
++         if (!elt-&gt;day) elt-&gt;day = elt-&gt;month = 1;
++         mail_free_envelope (&amp;e);
++       }
++     }
++ }
++ 
++ int
++ maildir_eliminate_duplicate (char *name, struct direct ***flist, unsigned long *nfiles)
++ {
++    int i, j, k, error = 0, scanr;
++    char new[MAILTMPLEN], old[MAILTMPLEN], tmp[MAILTMPLEN], *str;
++    struct direct **names = NIL;
++ 
++    if((scanr = maildir_doscandir(name, &amp;names, CCLIENT)) &lt; 0)
++      return -1;
++ 
++    if(nfiles) *nfiles = scanr;
++    for(i = 0, j = 1, k = 0;  j &lt; scanr; i++, j++){
++       if(k)
++ 	names[i] = names[i+k];
++       if(same_maildir_file(names[i]-&gt;d_name, names[j]-&gt;d_name)){
++ 	int d, f, r, s;
++ 	maildir_getflag(names[i]-&gt;d_name, &amp;d, &amp;f, &amp;r, &amp;s, NIL);
++ 	sprintf(old,&quot;%s/%s&quot;, name, names[i]-&gt;d_name);
++ 	sprintf(new,&quot;%s/.%s&quot;, name, names[i]-&gt;d_name);
++ 	if(rename(old, new) &lt; 0 &amp;&amp; errno != EEXIST)
++ 	  error++;
++ 	if(!error){
++ 	  for(; j &lt; scanr
++ 		&amp;&amp; same_maildir_file(names[i]-&gt;d_name, names[j]-&gt;d_name)
++ 	      ; j++, k++){
++ 	      maildir_getflag(names[j]-&gt;d_name, (d ? NIL : &amp;d), 
++ 			(f ? NIL : &amp;f), (r ? NIL : &amp;r), (s ? NIL : &amp;s), NIL);
++ 	      sprintf(tmp,&quot;%s/%s&quot;, name, names[j]-&gt;d_name);
++ 	      if(unlink(tmp) &lt; 0){	/* Hmmm... a problem, let's see */
++ 		struct stat sbuf;
++ 		if (stat(tmp, &amp;sbuf) == 0 &amp;&amp; (sbuf.st_mode &amp; S_IFMT) == S_IFREG)
++ 		   error++;
++ 	      }
++ 	  }
++ 	  if((str = strrchr(names[i]-&gt;d_name,FLAGSEP)) != NULL) *str = '\0';
++ 	  sprintf (old,&quot;%s/%s%s%s%s%s%s&quot;, name, names[i]-&gt;d_name, MDSEP(2),
++ 		MDFLAG(Draft, d), MDFLAG(Flagged, f), MDFLAG(Replied, r), 
++ 		MDFLAG(Seen, s));
++ 	  if(rename(new, old) &lt; 0)
++ 	     error++;
++ 	}
++       }
++ 
++    }
++    if(k &gt; 0)
++      fs_give((void **)&amp;names);
++    else
++      *flist = names;
++    return error ? -1 : k;
++ }
++ 
++ int
++ maildir_doscandir(char *name, struct direct ***flist, int flag)
++ {
++ return scandir(name, flist, 
++ 		(flag == CCLIENT ? maildir_select : courier_dir_select), 
++ 		(flag == CCLIENT ? maildir_namesort : courier_dir_sort));
++ }
++ 
++ /* 
++  * return all files in a given directory. This is a separate call
++  * so that if there are warnings during compilation this only appears once.
++  */
++ unsigned long
++ maildir_scandir (char *name, struct direct ***flist, 
++ 			unsigned long *nfiles, int *scand, int flag)
++ {
++   struct stat sbuf;
++   int rv = -2;	/* impossible value */
++ 
++   if (scand)
++      *scand = -1;	/* assume error for safety */
++   *nfiles = 0;
++   if((stat(name,&amp;sbuf) &lt; 0) 
++ 	|| (flag == CCLIENT
++ 	 &amp;&amp; ((rv = maildir_eliminate_duplicate(name, flist, nfiles)) &lt; 0)))
++      return 0L;
++ 
++   if (scand &amp;&amp; (rv &gt; 0 || rv == -2))
++      *nfiles = maildir_doscandir(name, flist, flag);
++ 
++   if(scand) *scand = *nfiles;
++ 
++   return (unsigned long) sbuf.st_ctime;
++ }
++ 
++ /* Does a message with given name exists (or was it removed)?
++  * Returns: 1 - yes, such message exist,
++  *	    0 - No, that message does not exist anymore
++  *
++  * Parameters: stream, name of mailbox, new name if his message does not
++  *		exist.
++  */
++ 
++ int maildir_message_exists(MAILSTREAM *stream, char *name, char *newfile)
++ {
++   char tmp[MAILTMPLEN];
++   int gotit = NIL;
++   DIR *dir;
++   struct direct *d;
++   struct stat sbuf;
++ 
++   /* First check directly if it exists, if not there, look for it */
++   sprintf(tmp,&quot;%s/%s&quot;, LOCAL-&gt;curdir, name);
++   if ((stat(tmp, &amp;sbuf) == 0) &amp;&amp; ((sbuf.st_mode &amp; S_IFMT) == S_IFREG))
++     return T;
++ 
++   if (!(dir = opendir (LOCAL-&gt;curdir)))
++      return NIL;
++ 
++   while ((d = readdir(dir)) &amp;&amp; gotit == NIL){
++     if (d-&gt;d_name[0] == '.')
++       continue;
++     if (same_maildir_file(d-&gt;d_name, name)){
++ 	  gotit = T;
++ 	  strcpy(newfile, d-&gt;d_name);
++     }
++   }
++   closedir(dir);
++   return gotit;
++ }
++ 
++ /* Maildir open */
++  
++ MAILSTREAM *maildir_open (MAILSTREAM *stream)
++ {
++   char tmp[MAILTMPLEN];
++   struct stat sbuf;
++ 
++   if (!stream) return &amp;maildirproto;
++   if (stream-&gt;local) fatal (&quot;maildir recycle stream&quot;);
++   md_domain_name();    /* get domain name for maildir files in mdlocaldomain */
++   if (!stream-&gt;rdonly){
++      stream-&gt;perm_seen = stream-&gt;perm_deleted = stream-&gt;perm_flagged = 
++ 	stream-&gt;perm_answered = stream-&gt;perm_draft = T;
++   }
++   stream-&gt;local = (MAILDIRLOCAL *) fs_get (sizeof (MAILDIRLOCAL));
++   memset(LOCAL, 0, sizeof(MAILDIRLOCAL));
++   LOCAL-&gt;fd = -1;
++ 
++   LOCAL-&gt;courier = IS_COURIER(stream-&gt;mailbox);
++   strcpy(tmp, stream-&gt;mailbox);
++   if (maildir_file_path (stream-&gt;mailbox, tmp))
++      LOCAL-&gt;dir = cpystr (tmp);
++   LOCAL-&gt;candouid = maildir_can_assign_uid(stream);
++   maildir_read_uid(stream, &amp;stream-&gt;uid_last, &amp;stream-&gt;uid_validity);
++   if (LOCAL-&gt;dir){
++      MDFLD(tmp, LOCAL-&gt;dir, Cur);
++      LOCAL-&gt;curdir = cpystr (tmp);
++      if (stat (LOCAL-&gt;curdir,&amp;sbuf) &lt; 0) {
++          sprintf (tmp,&quot;Can't open folder %s: %s&quot;,
++ 				stream-&gt;mailbox,strerror (errno));
++          mm_log (tmp,ERROR);
++ 	 maildir_close(stream, 0);
++         return NIL;
++      }
++   }
++ 
++   if(maildir_file_path (stream-&gt;mailbox, tmp)){
++     fs_give ((void **) &amp;stream-&gt;mailbox);
++     stream-&gt;mailbox = cpystr(tmp);
++   }
++ 
++   LOCAL-&gt;buf = (char *) fs_get ((LOCAL-&gt;buflen = SENDBUFLEN) + 1);
++   stream-&gt;sequence++;
++   stream-&gt;nmsgs = stream-&gt;recent = 0L;
++ 
++   maildir_parse_folder(stream, 1);
++ 
++   return stream;
++ }
++ 
++ /* Maildir initial parsing of the folder */
++ void
++ maildir_parse_folder (MAILSTREAM *stream, int full)
++ {
++    char tmp[MAILTMPLEN], tmp2[MAILTMPLEN];
++    struct direct **namescur = NIL, **namesnew = NIL;
++    unsigned long i, nfilescur = 0L, nfilesnew = 0L, oldpos, newpos, total;
++    int scan_err, rescan, loop = 0;
++ 
++    if (!stream)		/* what??? */
++       return;
++ 
++    MM_CRITICAL(stream);
++ 
++    MDFLD(tmp, LOCAL-&gt;dir, New);
++    maildir_scandir (tmp, &amp;namesnew, &amp;nfilesnew, &amp;scan_err, CCLIENT);
++    if (scan_err &lt; 0)
++       maildir_abort(stream);
++ 
++    /* Scan old messages first, escoba! */
++    if(stream-&gt;rdonly ||
++       (LOCAL &amp;&amp; ((maildir_initial_check(stream, Cur) == 0)
++ 							|| nfilesnew &gt; 0L))){
++       MDFLD(tmp, LOCAL-&gt;dir, Cur);
++       LOCAL-&gt;scantime =  maildir_scandir (tmp, &amp;namescur, &amp;nfilescur, 
++ 					&amp;scan_err, CCLIENT);
++       if (scan_err &lt; 0){
++ 	if(namesnew){
++ 	  for(i = 0L; i &lt; nfilesnew; i++)
++ 	    fs_give((void **)&amp;namesnew[i]);
++ 	  fs_give((void **) &amp;namesnew);
++ 	}
++ 	 maildir_abort(stream);
++       }
++    }
++    if(LOCAL &amp;&amp; (maildir_initial_check(stream, New) == 0)
++ 	&amp;&amp; (nfilescur &gt; 0L)){
++       MDFLD(tmp, LOCAL-&gt;dir, New);
++       while(LOCAL &amp;&amp; loop &lt; 10){
++ 	 if(nfilesnew == 0L)
++ 	   maildir_scandir (tmp, &amp;namesnew, &amp;nfilesnew, &amp;scan_err, CCLIENT);
++          if (scan_err &lt; 0){
++ 	    if(namesnew){
++ 	      for(i = 0L; i &lt; nfilesnew; i++)
++ 		fs_give((void **)&amp;namesnew[i]);
++ 	      fs_give((void **) &amp;namesnew);
++ 	    }
++ 	    maildir_abort(stream);
++ 	    break;
++ 	 }
++ 	 for(i = 0L, rescan = 0, newpos = oldpos = 0L; 
++ 		newpos &lt; nfilescur &amp;&amp; i &lt; nfilesnew; i++){
++ 	    if(maildir_message_in_list(namesnew[i]-&gt;d_name, namescur, oldpos, 
++ 						nfilescur - 1L, &amp;newpos)){
++ 	       oldpos = newpos;
++ 	       sprintf(tmp2,&quot;%s/%s&quot;,tmp,namesnew[i]-&gt;d_name);
++ 	       if(unlink(tmp2) &lt; 0)
++ 		 scan_err = -1;
++ 	       rescan++;
++ 	    }
++ 	    else
++ 	      newpos = oldpos;
++ 	 }
++ 	 if(scan_err &lt; 0)
++ 	    maildir_abort(stream);
++ 	 if(rescan == 0)
++ 	   break;
++ 	 else{ /* restart */
++ 	   if(namesnew){
++ 	     for(i = 0L; i &lt; nfilesnew; i++)
++ 		fs_give((void **)&amp;namesnew[i]);
++ 	     fs_give((void **) &amp;namesnew);
++ 	   }
++ 	   nfilesnew = 0L;
++ 	   loop++;
++ 	 }
++       }
++    }
++    if(loop == 10)
++      maildir_abort(stream);
++    if(LOCAL){
++      if(stream-&gt;rdonly)
++ 	stream-&gt;recent = 0L;
++      total = namescur || stream-&gt;rdonly 
++ 		? maildir_parse_dir(stream, 0L, Cur, namescur, 
++ 					      nfilescur, full) : stream-&gt;nmsgs;
++      stream-&gt;nmsgs = maildir_parse_dir(stream, total, New, namesnew, 
++ 						nfilesnew, full);
++    }
++    if(namesnew){
++      for(i = 0L; i &lt; nfilesnew; i++)
++ 	fs_give((void **)&amp;namesnew[i]);
++      fs_give((void **) &amp;namesnew);
++    }
++    if(namescur){
++      for(i = 0L; i &lt; nfilescur; i++)
++ 	fs_give((void **)&amp;namescur[i]);
++      fs_give((void **) &amp;namescur);
++    }
++    MM_NOCRITICAL(stream);
++ }
++ 
++ int
++ maildir_initial_check (MAILSTREAM *stream, DirNamesType dirtype)
++ {
++    char tmp[MAILTMPLEN];
++    struct stat sbuf;
++ 
++    MDFLD(tmp, LOCAL-&gt;dir, dirtype);
++    if (access (tmp, R_OK|W_OK|X_OK) != 0){
++       maildir_abort(stream);
++       return -1;
++    }
++ 
++    MDFLD(tmp, LOCAL-&gt;dir, Cur);
++    if (dirtype != New &amp;&amp; 
++ 	(stat(tmp, &amp;sbuf) &lt; 0 || sbuf.st_ctime == LOCAL-&gt;scantime))
++       return -1;
++    return 0;
++ }
++ 
++ 
++ /* Return the number of messages in the directory, while filling the
++  * elt structure.
++  */
++ 
++ unsigned long
++ maildir_parse_dir(MAILSTREAM *stream, unsigned long nmsgs,
++ 		  DirNamesType dirtype, struct direct **names, 
++ 		  unsigned long nfiles, int full)
++ {
++    char tmp[MAILTMPLEN], tmp2[MAILTMPLEN], file[MAILTMPLEN], 
++ 	newfile[MAILTMPLEN], *mdstr;
++    struct stat sbuf;
++    unsigned long i, new = 0L, l, uid_last;
++    unsigned long recent = stream ? stream-&gt;recent : 0L;
++    int d = 0, f = 0, r = 0, s = 0, t = 0;
++    int we_compute, in_list;
++    int silent = stream ? stream-&gt;silent : NIL;
++    MESSAGECACHE *elt;
++ 
++    MDFLD(tmp, LOCAL-&gt;dir, dirtype);
++    if (dirtype == Cur &amp;&amp; !stream-&gt;rdonly)
++       for (i = 1L; i &lt;= stream-&gt;nmsgs;){
++ 	elt = mail_elt(stream,  i);
++ 	in_list = elt &amp;&amp; elt-&gt;private.spare.ptr &amp;&amp; nfiles &gt; 0L
++ 		  ? (MDPOS(elt) &lt; nfiles 
++ 		    ? same_maildir_file(MDFILE(elt), names[MDPOS(elt)]-&gt;d_name)
++ 		    : NIL)
++ 		    || maildir_message_in_list(MDFILE(elt), names, 0L, 
++ 						nfiles - 1L, &amp;MDPOS(elt))
++ 		  : NIL;
++ 	if (!in_list){
++ 	   if (elt-&gt;private.spare.ptr)
++ 	      maildir_free_file ((void **) &amp;elt-&gt;private.spare.ptr);
++ 
++ 	   if (elt-&gt;recent) --recent;
++ 	   mail_expunged(stream,i);
++ 	}
++ 	else i++;
++       }
++ 
++    stream-&gt;silent = T;
++    uid_last = 0L;
++    for (we_compute = 0, i = l = 1L; l &lt;= nfiles; l++){
++       unsigned long pos, uid;
++       if (dirtype == New &amp;&amp; !stream-&gt;rdonly){ /* move new messages to cur */
++ 	pos = l - 1L;
++ 	sprintf (file,&quot;%s/%s&quot;, tmp, names[pos]-&gt;d_name);
++ 	if(lstat(file,&amp;sbuf) == 0)
++ 	   switch(sbuf.st_mode &amp; S_IFMT){
++ 	    case S_IFREG:
++ 		strcpy(tmp2, names[pos]-&gt;d_name);
++ 		if((mdstr = strstr(tmp2,MDSEP(3))) 
++ 		   || (mdstr = strstr(tmp2,MDSEP(2))))
++ 		   *(mdstr+1) = '2';
++ 		else
++ 		   strcat(tmp2, MDSEP(2));
++ 		sprintf(newfile, &quot;%s/%s&quot;,LOCAL-&gt;curdir, tmp2);
++ 		if(link(file,newfile) != 0){
++ 		   mm_log(&quot;Unable to read new mail!&quot;, WARN);
++ 		   continue;
++ 		}
++ 		unlink (file);
++ 		new++;
++ 	        break;
++ 	    case S_IFLNK:  /* clean up, clean up, everybody, everywhere */
++ 		if(unlink(file) &lt; 0){
++ 		   if(LOCAL-&gt;link == NIL){ 
++ 		      mm_log(&quot;Unable to remove symbolic link&quot;, WARN);
++ 		      LOCAL-&gt;link = T;
++ 		   }
++ 		}
++ 		continue;
++ 		break;
++ 	    default: 
++ 		if(LOCAL &amp;&amp; LOCAL-&gt;link == NIL){
++ 		  mm_log(&quot;Unrecognized file or link in folder&quot;, WARN);
++ 		  LOCAL-&gt;link = T;
++ 		}
++ 		continue;
++ 		break;
++ 	   }
++       }
++       mail_exists(stream, i + nmsgs);
++       elt = mail_elt(stream, i + nmsgs);
++       pos = (elt &amp;&amp; elt-&gt;private.spare.ptr) ? MDPOS(elt) : l - 1L;
++       if (dirtype == New) elt-&gt;recent = T;
++       maildir_getflag(names[pos]-&gt;d_name, &amp;d, &amp;f, &amp;r ,&amp;s, &amp;t);
++       if (elt-&gt;private.spare.ptr)
++ 	 maildir_free_file_only ((void **)&amp;elt-&gt;private.spare.ptr);
++       else{
++ 	 maildir_get_file((MAILDIRFILE **)&amp;elt-&gt;private.spare.ptr);
++ 	 we_compute++;
++       }
++       MDFILE(elt) = cpystr(names[pos]-&gt;d_name);
++       MDPOS(elt)  = pos;
++       MDLOC(elt)  = dirtype;
++       if (dirtype == Cur){	/* deal with UIDs */
++ 	if(elt-&gt;private.uid == 0L)
++ 	  elt-&gt;private.uid = maildir_get_uid(MDFILE(elt));
++ 	if(elt-&gt;private.uid &lt;= uid_last){
++ 	  uid = (we_compute ? uid_last : stream-&gt;uid_last) + 1L;
++ 	  if(LOCAL-&gt;candouid)
++ 	    maildir_assign_uid(stream, i + nmsgs, uid);
++ 	  else
++ 	    elt-&gt;private.uid = uid;
++ 	}
++ 	else
++ 	  uid = elt-&gt;private.uid;
++ 	uid_last = uid;
++ 	if(uid_last &gt; stream-&gt;uid_last)
++ 	  stream-&gt;uid_last = uid_last;
++       }
++       if(dirtype == New &amp;&amp; !stream-&gt;rdonly){
++ 	maildir_free_file_only((void **)&amp;elt-&gt;private.spare.ptr);
++ 	MDFILE(elt)  = cpystr(tmp2);
++ 	MDSIZE(elt)  = sbuf.st_size;
++ 	MDMTIME(elt) = sbuf.st_mtime;
++ 	MDLOC(elt)   = Cur;
++       }
++       if (elt-&gt;draft != d || elt-&gt;flagged != f || 
++ 	elt-&gt;answered != r || elt-&gt;seen != s || elt-&gt;deleted != t){
++ 	   elt-&gt;draft = d; elt-&gt;flagged = f; elt-&gt;answered = r;
++ 	   elt-&gt;seen  = s; elt-&gt;deleted = t;
++ 	   if (!we_compute &amp;&amp; !stream-&gt;rdonly)
++ 	      MM_FLAGS(stream, i+nmsgs);
++       }
++       maildir_get_date(stream, i+nmsgs);
++       elt-&gt;valid = T;
++       i++;
++    }
++    stream-&gt;silent = silent;
++    if(LOCAL-&gt;candouid &amp;&amp; dirtype == Cur)
++       maildir_read_uid(stream, NULL, &amp;stream-&gt;uid_validity);
++    if (dirtype == New &amp;&amp; stream-&gt;rdonly)
++       new = nfiles;
++    mail_exists(stream, nmsgs  + ((dirtype == New) ? new : nfiles));
++    mail_recent(stream, recent + ((dirtype == New) ? new : 0L));
++ 
++    return (nmsgs  + (dirtype == New ? new : nfiles));
++ }
++ 
++ long maildir_ping (MAILSTREAM *stream)
++ {
++   maildir_parse_folder(stream, 0);
++   if(stream &amp;&amp; LOCAL){
++      if(LOCAL-&gt;candouid)
++         maildir_uid_renew_tempfile(stream);
++      else	 /* try again to get uids */
++ 	LOCAL-&gt;candouid = maildir_can_assign_uid(stream);
++   }
++   return stream &amp;&amp; LOCAL ? LONGT : NIL;
++ }
++ 
++ int maildir_select (const struct direct *name)
++ {
++  return (name-&gt;d_name[0] != '.');
++ }
++ 
++ /*
++  * Unfortunately, there is no way to sort by arrival in this driver, this
++  * means that opening a folder in this driver using the scandir function
++  * will always make this driver slower than any driver that has a natural
++  * way of sorting by arrival (like a flat file format, &quot;mbox&quot;, &quot;mbx&quot;, etc).
++  */
++ int maildir_namesort (const void *d1,const  void *d2)
++ {
++   const struct direct **e1, **e2;
++ 
++   e1 = (const struct direct **)d1;
++   e2 = (const struct direct **)d2;
++ 
++   return comp_maildir_file((char*)(*e1)-&gt;d_name, (char *)(*e2)-&gt;d_name);
++ }
++ 
++ /* Maildir close */
++ 
++ void maildir_close (MAILSTREAM *stream, long options)
++ {
++   MESSAGECACHE *elt;
++   unsigned long i;
++   int silent = stream ? stream-&gt;silent : 0;
++   mailcache_t mc = (mailcache_t) mail_parameters (NIL,GET_CACHE,NIL);
++ 
++   if (!stream) return;
++ 
++   for (i = 1L; i &lt;= stream-&gt;nmsgs; i++)
++     if((elt = (MESSAGECACHE *) (*mc)(stream,i,CH_ELT)) &amp;&amp; elt-&gt;private.spare.ptr)
++       maildir_free_file ((void **) &amp;elt-&gt;private.spare.ptr);
++   stream-&gt;silent = T;
++   if (options &amp; CL_EXPUNGE) maildir_expunge (stream, NIL, NIL);
++   maildir_abort(stream);
++   if (mdfpath) fs_give((void **)&amp;mdfpath);
++   stream-&gt;silent = silent;
++ }
++ 
++ void maildir_check (MAILSTREAM *stream)
++ {
++   if (maildir_ping (stream)) mm_log (&quot;Check completed&quot;,(long) NIL);   
++ }
++ 
++ long maildir_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs, long flags)
++ {
++   char tmp[MAILTMPLEN];
++   unsigned long i;
++   MESSAGECACHE *elt;
++   char *s;
++                                 /* UID call &quot;impossible&quot; */
++   if (flags &amp; FT_UID || !LOCAL) return NIL;
++   elt = mail_elt (stream, msgno);
++ 
++   if (!(flags &amp; FT_PEEK) &amp;&amp; !elt-&gt;seen){
++     elt-&gt;seen = T;
++     maildir_flagmsg (stream, elt);
++     MM_FLAGS(stream, elt-&gt;msgno);
++   }
++ 
++   MSGPATH(tmp, LOCAL-&gt;dir, MDFILE(elt), MDLOC(elt));
++   if (LOCAL-&gt;fd &lt; 0)	/* if file closed ? */
++      LOCAL-&gt;fd = open(tmp,O_RDONLY,NIL);
++ 
++   if (LOCAL-&gt;fd &lt; 0 &amp;&amp; (errno == EACCES || errno == ENOENT)){
++      INIT (bs, mail_string, &quot;&quot;, 0);
++      elt-&gt;rfc822_size = 0L;
++      return NIL;
++   }
++ 
++   s = maildir_text_work(stream, elt, &amp;i, flags);
++   INIT (bs, mail_string, s, i);
++   return LONGT;
++ }
++ 
++ char *maildir_text_work (MAILSTREAM *stream,MESSAGECACHE *elt,
++                       unsigned long *length,long flags)
++ {
++   FDDATA d;
++   STRING bs;
++   char *s,tmp[CHUNK];
++   unsigned long msgno = elt-&gt;msgno;
++   static int try = 0;
++ 
++   if (length)
++      *length = 0L;
++   LOCAL-&gt;buf[0] = '\0';
++ 
++   MSGPATH(tmp, LOCAL-&gt;dir, MDFILE(elt), MDLOC(elt));
++   if (LOCAL-&gt;fd &lt; 0)	/* if file closed ? */
++      LOCAL-&gt;fd = open(tmp,O_RDONLY,NIL);
++ 
++   if (LOCAL-&gt;fd &lt; 0){		/* flag change? */
++       if (try &lt; 5){
++ 	try++;
++ 	if (maildir_update_elt_maildirp(stream, msgno) &gt; 0)
++ 	  try = 0;
++ 	return maildir_text_work(stream, mail_elt(stream, msgno),length, flags);
++       }
++       try = 0;
++       return NULL;
++   }
++ 
++   lseek (LOCAL-&gt;fd, elt-&gt;private.msg.text.offset,L_SET);
++ 
++   if (flags &amp; FT_INTERNAL) {    /* initial data OK? */
++     if (elt-&gt;private.msg.text.text.size &gt; LOCAL-&gt;buflen) {
++       fs_give ((void **) &amp;LOCAL-&gt;buf);
++       LOCAL-&gt;buf = (char *) fs_get ((LOCAL-&gt;buflen =
++                                      elt-&gt;private.msg.text.text.size) + 1);
++     }
++     read (LOCAL-&gt;fd,LOCAL-&gt;buf,elt-&gt;private.msg.text.text.size);
++     LOCAL-&gt;buf[*length = elt-&gt;private.msg.text.text.size] = '\0';
++   }
++   else {
++     if (elt-&gt;rfc822_size &gt; LOCAL-&gt;buflen) {
++       fs_give ((void **) &amp;LOCAL-&gt;buf);
++       LOCAL-&gt;buf = (char *) fs_get ((LOCAL-&gt;buflen = elt-&gt;rfc822_size) + 1);
++     }
++     d.fd = LOCAL-&gt;fd;           /* yes, set up file descriptor */
++     d.pos = elt-&gt;private.msg.text.offset;
++     d.chunk = tmp;              /* initial buffer chunk */
++     d.chunksize = CHUNK;
++     INIT (&amp;bs,fd_string,&amp;d,elt-&gt;private.msg.text.text.size);
++     for (s = LOCAL-&gt;buf; SIZE (&amp;bs);) switch (CHR (&amp;bs)) {
++     case '\r':                  /* carriage return seen */
++       *s++ = SNX (&amp;bs);         /* copy it and any succeeding LF */
++       if (SIZE (&amp;bs) &amp;&amp; (CHR (&amp;bs) == '\n')) *s++ = SNX (&amp;bs);
++       break;
++     case '\n':
++       *s++ = '\r';              /* insert a CR */
++     default:
++       *s++ = SNX (&amp;bs);         /* copy characters */
++     }
++     *s = '\0';                  /* tie off buffer */
++     *length = s - (char *) LOCAL-&gt;buf;   /* calculate length */
++   }
++   close(LOCAL-&gt;fd); LOCAL-&gt;fd = -1;
++   return LOCAL-&gt;buf;
++ }
++ 
++ /* maildir parse, fill the elt structure... well not all of it... */
++ unsigned long maildir_parse_message(MAILSTREAM *stream, unsigned long msgno,
++ 				    DirNamesType dirtype)
++ {
++   char *b, *s, *t, c;
++   char tmp[MAILTMPLEN];
++   struct stat sbuf;
++   unsigned long i, len;
++   int d, f, r, se, dt;
++   MESSAGECACHE *elt;
++ 
++   elt = mail_elt (stream,msgno);
++   MSGPATH(tmp, LOCAL-&gt;dir, MDFILE(elt), dirtype);
++   if(stat(tmp, &amp;sbuf) == 0)
++      MDSIZE(elt) = sbuf.st_size;
++ 
++   maildir_get_date(stream, msgno);
++   maildir_getflag(MDFILE(elt), &amp;d, &amp;f, &amp;r ,&amp;se, &amp;dt);
++   elt-&gt;draft = d; elt-&gt;flagged = f; elt-&gt;answered = r; elt-&gt;seen = se;
++   elt-&gt;deleted = dt; elt-&gt;valid  = T;
++   if (LOCAL-&gt;fd &lt; 0)	/* if file closed ? */
++      LOCAL-&gt;fd = open(tmp,O_RDONLY,NIL);
++ 
++   if (LOCAL-&gt;fd &gt;= 0){
++ 	s = (char *) fs_get (MDSIZE(elt) + 1);
++ 	read (LOCAL-&gt;fd,s,MDSIZE(elt));
++ 	s[MDSIZE(elt)] = '\0';
++ 	t = s + strlen(s);	/* make t point to the end of s */
++ 	for (i = 0L, b = s; b &lt; t &amp;&amp; !(i &amp;&amp; (*b == '\n')); i = (*b++ == '\n'));
++ 	len = (*b ? ++b : b) - s;
++ 	elt-&gt;private.msg.header.text.size = 
++ 		elt-&gt;private.msg.text.offset = len;
++ 	elt-&gt;private.msg.text.text.size = MDSIZE(elt) - len;
++ 	for (i = 0L, b = s, c = *b; b &amp;&amp;
++ 	    ((c &lt; '\016' &amp;&amp; ((c == '\012' &amp;&amp; ++i) 
++ 			 ||(c == '\015' &amp;&amp; *(b+1) == '\012' &amp;&amp; ++b &amp;&amp; (i +=2))))
++ 	    || b &lt; t); i++, c= *++b);
++ 	elt-&gt;rfc822_size = i;
++ 	fs_give ((void **) &amp;s);
++ 	close(LOCAL-&gt;fd); LOCAL-&gt;fd = -1;
++   }
++   return elt-&gt;rfc822_size;
++ }
++ 
++ int
++ maildir_update_elt_maildirp(MAILSTREAM *stream, unsigned long msgno)
++ {
++      char tmp[MAILTMPLEN];
++      struct direct **names = NIL;
++      unsigned long i, nfiles, pos;
++      int d = 0, f = 0 , r = 0, s = 0, t = 0, in_list, scan_err;
++      MESSAGECACHE *elt;
++ 
++      MDFLD(tmp, LOCAL-&gt;dir, Cur);
++ 
++      maildir_scandir (tmp, &amp;names, &amp;nfiles, &amp;scan_err, CCLIENT);
++ 
++      elt = mail_elt (stream,msgno);
++ 
++      in_list = nfiles &gt; 0L
++ 	    ? maildir_message_in_list(MDFILE(elt), names, 0L, nfiles - 1L, &amp;pos)
++ 	    : NIL;
++ 
++      if (in_list &amp;&amp; pos &gt;= 0L &amp;&amp; pos &lt; nfiles
++ 	 &amp;&amp; !strcmp(MDFILE(elt), names[pos]-&gt;d_name)){
++ 	in_list = NIL;
++ 	maildir_abort(stream);
++      }
++ 
++      if (in_list &amp;&amp; pos &gt;= 0L &amp;&amp; pos &lt; nfiles){
++ 	maildir_free_file_only((void **)&amp;elt-&gt;private.spare.ptr);
++ 	MDFILE(elt) = cpystr(names[pos]-&gt;d_name);
++ 	maildir_getflag(MDFILE(elt), &amp;d, &amp;f, &amp;r ,&amp;s, &amp;t);
++ 	if (elt-&gt;draft != d || elt-&gt;flagged != f || 
++ 	   elt-&gt;answered != r || elt-&gt;seen != s || elt-&gt;deleted != t){
++ 	   elt-&gt;draft = d; elt-&gt;flagged = f; elt-&gt;answered = r;
++ 	   elt-&gt;seen  = s; elt-&gt;deleted = t;
++ 	   MM_FLAGS(stream, msgno);
++         }
++      }
++      for (i = 0L; i &lt; nfiles; i++)
++ 	fs_give((void **) &amp;names[i]);
++      if (names)
++ 	fs_give((void **) &amp;names);
++      return in_list ? 1 : -1;
++ }
++ 
++ /* Maildir fetch message header */
++ 
++ char *maildir_header (MAILSTREAM *stream,unsigned long msgno,
++ 		unsigned long *length, long flags)
++ {
++   char tmp[MAILTMPLEN], *s;
++   MESSAGECACHE *elt;
++   static int try = 0;
++ 
++   if (length) *length = 0;
++   if (flags &amp; FT_UID || !LOCAL) return &quot;&quot;;	/* UID call &quot;impossible&quot; */
++   elt = mail_elt (stream,msgno);
++   if(elt-&gt;private.msg.header.text.size == 0)
++      maildir_parse_message(stream, msgno, MDLOC(elt));
++ 
++   MSGPATH(tmp, LOCAL-&gt;dir, MDFILE(elt), MDLOC(elt));
++   if (LOCAL-&gt;fd &lt; 0)
++      LOCAL-&gt;fd = open (tmp,O_RDONLY,NIL);
++ 
++   if (LOCAL-&gt;fd &lt; 0 &amp;&amp; errno == EACCES){
++      mm_log (&quot;Message exists but can not be read. Envelope and body lost!&quot;,ERROR);
++      return NULL;
++   }
++ 
++   if (LOCAL-&gt;fd &lt; 0){			/* flag change? */
++       if (try &lt; 5){
++ 	try++;
++ 	if (maildir_update_elt_maildirp(stream, msgno) &gt; 0)
++ 	  try = 0;
++ 	return maildir_header(stream, msgno, length, flags);
++       }
++       try = 0;
++       return NULL;
++   }
++ 
++   if ((flags &amp; FT_INTERNAL) &amp;&amp;
++         (elt-&gt;private.msg.header.text.size &gt; LOCAL-&gt;buflen)){
++          fs_give ((void **) &amp;LOCAL-&gt;buf);
++          LOCAL-&gt;buf = (char *) fs_get ((LOCAL-&gt;buflen =
++                                  elt-&gt;private.msg.header.text.size) + 1);
++   }
++   else
++       s = (char *) fs_get(elt-&gt;private.msg.header.text.size+1);
++   if (LOCAL-&gt;fd &gt;= 0){
++      read (LOCAL-&gt;fd, ((flags &amp; FT_INTERNAL) ? (void *)LOCAL-&gt;buf : (void *)s),
++                                       elt-&gt;private.msg.header.text.size);
++      if (flags &amp; FT_INTERNAL)
++         LOCAL-&gt;buf[*length = elt-&gt;private.msg.header.text.size] = '\0';
++      else{
++         s[*length = elt-&gt;private.msg.header.text.size] = '\0';
++         *length = strcrlfcpy (&amp;LOCAL-&gt;buf,&amp;LOCAL-&gt;buflen,s,
++                           elt-&gt;private.msg.header.text.size);
++         fs_give ((void **) &amp;s);
++      }
++   }
++   elt-&gt;private.msg.text.offset = elt-&gt;private.msg.header.text.size;
++   elt-&gt;private.msg.text.text.size = MDSIZE(elt) - elt-&gt;private.msg.text.offset;
++   if(s) fs_give((void **)&amp;s);
++   close(LOCAL-&gt;fd); LOCAL-&gt;fd = -1;
++   return LOCAL-&gt;buf;
++ }
++ 
++ /* Maildir find list of subscribed mailboxes
++  * Accepts: mail stream
++  *	    pattern to search
++  */
++ 
++ void maildir_list (MAILSTREAM *stream,char *ref, char *pat)
++ {
++   char *s,test[MAILTMPLEN],file[MAILTMPLEN];
++   long i = 0L;
++ 
++   if((!pat || !*pat) &amp;&amp; maildir_canonicalize (test,ref,&quot;*&quot;)
++ 	&amp;&amp; maildir_valid_name(test)){	/* there is a #md/ leading here */
++     for (i = 3L; test[i] &amp;&amp; test[i] != '/'; i++);
++     if ((s = strchr (test+i+1,'/')) != NULL) *++s = '\0';
++     else test[0] = '\0';
++     mm_list (stream,'/',test, LATT_NOSELECT);
++   }
++   else if (maildir_canonicalize (test,ref,pat)) {
++     if (test[3] == '/') {       /* looking down levels? */
++                                 /* yes, found any wildcards? */
++       if ((s = strpbrk (test,&quot;%*&quot;)) != NULL){
++                                 /* yes, copy name up to that point */
++         strncpy (file,test+4,i = s - (test+4));
++         file[i] = '\0';         /* tie off */
++       }
++       else strcpy (file,test+4);/* use just that name then */
++                                 /* find directory name */
++       if ((s = strrchr (file, '/')) != NULL){
++         *s = '\0';              /* found, tie off at that point */
++         s = file;
++       }
++                                 /* do the work */
++       if(IS_COURIER(test))
++ 	courier_list_work (stream,s,test,0);
++       else
++ 	maildir_list_work (stream,s,test,0);
++     }
++                                 /* always an INBOX */
++     if (!compare_cstring (test,&quot;#MD/INBOX&quot;))
++       mm_list (stream,NIL,&quot;#MD/INBOX&quot;,LATT_NOINFERIORS);
++     if (!compare_cstring (test,&quot;#MC/INBOX&quot;))
++       mm_list (stream,NIL,&quot;#MC/INBOX&quot;,LATT_NOINFERIORS);
++   }
++ }
++ 
++ void courier_list (MAILSTREAM *stream,char *ref, char *pat)
++ {
++ /* I am too lazy to do anything. Do you care to ask maildir list, please?
++    The real reason why this is a dummy function is because we do not want to
++    see the same folder listed twice. 
++ */
++ }
++ 
++ /* For those that want to hide things, we give them a chance to do so */
++ void *maildir_parameters (long function, void *value)
++ {
++   void *ret = NIL;
++   switch ((int) function) {
++   case SET_MDINBOXPATH:
++     if (myMdInboxDir) fs_give ((void **) &amp;myMdInboxDir);
++     myMdInboxDir = cpystr ((char *) value);
++   case GET_MDINBOXPATH:
++     if (!myMdInboxDir) myMdInboxDir = cpystr(&quot;Maildir&quot;);
++     ret = (void *) myMdInboxDir;
++     break;
++   case SET_COURIERSTYLE:
++     CourierStyle = (long) value;
++   case GET_COURIERSTYLE:
++     ret = (void *) CourierStyle;
++     break;
++   case GET_DIRFMTTEST:
++     ret = (void *) maildir_dirfmttest;
++     break;
++   default:
++     break;
++   }
++   return ret;
++ }
++ 
++ int maildir_create_folder(char *mailbox)
++ {
++   char tmp[MAILTMPLEN], err[MAILTMPLEN];
++   int i;
++ 
++   for (i = Cur; i != EndDir; i++){
++ 	MDFLD(tmp, mailbox, i);
++ 	if (mkdir(tmp, 0700) &amp;&amp; errno != EEXIST){ /* try to make new dir */
++ 	    sprintf (err, &quot;Can't create %s: %s&quot;, tmp, strerror(errno));
++ 	    mm_log (err,ERROR);
++ 	    return NIL;
++ 	}
++   }
++   return T;
++ }
++ 
++ int maildir_create_work(char *mailbox, int loop)
++ {
++   char *s, c, err[MAILTMPLEN], tmp[MAILTMPLEN], tmp2[MAILTMPLEN], mbx[MAILTMPLEN];
++   int fnlen, create_dir = 0, courier, mv;
++   struct stat sbuf;
++   long style = (long) maildir_parameters(GET_COURIERSTYLE, NIL);
++ 
++   courier = IS_COURIER(mailbox);
++   strcpy(mbx, mailbox);
++   mv = maildir_valid(mbx) ? 1 : 0;
++   maildir_file_path(mailbox, tmp);
++   if (mailbox[strlen(mailbox) - 1] == MDSEPARATOR(courier)){
++       create_dir++;
++       mailbox[strlen(mailbox) - 1] = '\0';
++   }
++ 
++   if(!loop &amp;&amp; courier){
++     if(mv){
++        if(create_dir){
++ 	  if(style == CCLIENT)
++ 	   strcpy (err,&quot;Can not create directory: folder exists. Create subfolder&quot;);
++ 	  else
++ 	   strcpy(err,&quot;Folder and Directory already exist&quot;);
++        }
++        else
++           strcpy (err, &quot;Can't create mailbox: mailbox already exists&quot;);
++     }
++     else{
++ 	if(create_dir)
++ 	   strcpy(err, &quot;Can not create directory. Cread folder instead&quot;);
++ 	else
++ 	  err[0] = '\0';
++     }
++     if(err[0]){
++        mm_log (err,ERROR);
++        return NIL;
++     }
++   }
++ 
++   fnlen = strlen(tmp);
++   if ((s = strrchr(mailbox,MDSEPARATOR(courier))) != NULL){
++      c = *++s;
++     *s = '\0';
++     if ((stat(tmp,&amp;sbuf) || ((sbuf.st_mode &amp; S_IFMT) != S_IFDIR)) &amp;&amp;
++         !maildir_create_work (mailbox, ++loop))
++       return NIL;
++     *s = c;
++   }
++   tmp[fnlen] = '\0';
++ 
++   if (mkdir(tmp,0700) &amp;&amp; errno != EEXIST)
++      return NIL;
++ 
++   if (create_dir)
++      mailbox[fnlen] = '/';
++ 
++   if (create_dir){
++      if(style == CCLIENT){
++ 	if(!courier){
++ 	   FILE *fp = NULL;
++ 	   sprintf(tmp2,&quot;%s%s&quot;, tmp, MDDIR);
++ 	   if ((fp = fopen(tmp2,&quot;w&quot;)) == NULL){
++ 	      sprintf (err,&quot;Problem creating %s: %s&quot;, tmp2, strerror(errno));
++               mm_log (err,ERROR);
++               return NIL;
++ 	   }
++ 	   fclose(fp);
++ 	}
++      }
++      return T;
++   }
++   else
++      return maildir_create_folder(tmp);
++ }
++ 
++ long maildir_create (MAILSTREAM *stream,char *mailbox)
++ {
++   char tmp[MAILTMPLEN], err[MAILTMPLEN];
++   int rv, create_dir;
++ 
++   create_dir = mailbox ? 
++ 		(mailbox[strlen(mailbox) - 1] == 
++ 					MDSEPARATOR(IS_COURIER(mailbox))) : 0;
++   maildir_file_path(mailbox, tmp);
++   strcpy(tmp, mailbox);
++   rv = maildir_create_work(mailbox, 0);
++   strcpy(mailbox, tmp);
++   if (rv == 0){
++      sprintf (err,&quot;Can't create %s %s&quot;,
++ 		   (create_dir ? &quot;directory&quot; : &quot;mailbox&quot;), mailbox);
++      mm_log (err,ERROR);
++   }
++   return rv ? LONGT : NIL;
++ }
++ 
++ #define MAXTRY 10000
++ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt)
++ {
++   char oldfile[MAILTMPLEN],newfile[MAILTMPLEN],fn[MAILTMPLEN];
++   char *s;
++   int ren, try = 0;
++ 
++   if (elt-&gt;valid){
++      for (try = 1; try &gt; 0 &amp;&amp; try &lt; MAXTRY; try++){
++                                 /* build the new filename */
++ 	sprintf (oldfile,&quot;%s/%s&quot;,LOCAL-&gt;curdir, MDFILE(elt));
++ 	fn[0] = '\0';
++ 	if ((ren = maildir_message_exists(stream, MDFILE(elt), fn)) == 0){
++ 	    errno = ENOENT;
++ 	    try = MAXTRY;
++ 	}
++ 	if (*fn)	/* new oldfile! */
++ 	   sprintf (oldfile,&quot;%s/%s&quot;,LOCAL-&gt;curdir,fn);
++         if ((s = strrchr (MDFILE(elt), FLAGSEP))) *s = '\0';
++ 	sprintf (fn,&quot;%s%s%s%s%s%s%s&quot;, MDFILE(elt), MDSEP(2),
++ 		MDFLAG(Draft, elt-&gt;draft), MDFLAG(Flagged, elt-&gt;flagged),
++ 		MDFLAG(Replied, elt-&gt;answered), MDFLAG(Seen, elt-&gt;seen),
++ 		MDFLAG(Trashed, elt-&gt;deleted));
++ 	sprintf (newfile,&quot;%s/%s&quot;,LOCAL-&gt;curdir,fn);
++         if (ren != 0 &amp;&amp; rename (oldfile,newfile) &gt;= 0)
++ 	    try = -1;
++      }
++ 
++      if (try &gt; 0){
++        sprintf(oldfile,&quot;Unable to write flags to disk: %s&quot;,
++ 		(errno == ENOENT) ? &quot;message is gone!&quot; : strerror (errno));
++        mm_log(oldfile,ERROR);
++        return;
++      }
++ #ifdef __CYGWIN__
++      utime(LOCAL-&gt;curdir, NIL);	/* make sure next scan will catch the change */
++ #endif
++      maildir_free_file_only ((void **) &amp;elt-&gt;private.spare.ptr);
++      MDFILE(elt) = cpystr (fn);
++   }
++ }
++ 
++ long maildir_expunge (MAILSTREAM *stream, char *sequence, long options)
++ {
++   long ret;
++   MESSAGECACHE *elt;
++   unsigned long i, n = 0L;
++   unsigned long recent = stream-&gt;recent;
++   char tmp[MAILTMPLEN];
++ 
++   mm_critical (stream);               /* go critical */
++   ret = sequence ? ((options &amp; EX_UID) ?
++                          mail_uid_sequence (stream,sequence) :
++                          mail_sequence (stream,sequence)) : LONGT;
++   if(ret == 0L)
++      return 0L;
++   for (i = 1L; i &lt;= stream-&gt;nmsgs;){
++     elt = mail_elt (stream,i);
++     if (elt-&gt;deleted &amp;&amp; (sequence ? elt-&gt;sequence : T)){
++       sprintf (tmp,&quot;%s/%s&quot;,LOCAL-&gt;curdir, MDFILE(elt));
++       if (unlink (tmp) &lt; 0) {/* try to delete the message */
++       sprintf (tmp,&quot;Expunge of message %ld failed, aborted: %s&quot;,i,
++               strerror (errno));
++       if (!stream-&gt;silent)
++          mm_log (tmp,WARN);
++       break;
++       }
++       if (elt-&gt;private.spare.ptr)
++        maildir_free_file ((void **) &amp;elt-&gt;private.spare.ptr);
++       if (elt-&gt;recent) --recent;/* if recent, note one less recent message */
++       mail_expunged (stream,i);       /* notify upper levels */
++        n++;                    /* count up one more expunged message */
++     }
++     else i++;
++   }
++   if(n){                      /* output the news if any expunged */
++     sprintf (tmp,&quot;Expunged %ld messages&quot;,n);
++     if (!stream-&gt;silent)
++        mm_log (tmp,(long) NIL);
++   }
++   else
++     if (!stream-&gt;silent)
++       mm_log (&quot;No messages deleted, so no update needed&quot;,(long) NIL);
++   mm_nocritical (stream);     /* release critical */
++                             /* notify upper level of new mailbox size */
++   mail_exists (stream,stream-&gt;nmsgs);
++   mail_recent (stream,recent);
++   return ret;
++ }
++ 
++ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options)
++ {
++   STRING st;
++   MESSAGECACHE *elt;
++   unsigned long len;
++   int fd;
++   unsigned long i;
++   struct stat sbuf;
++   char tmp[MAILTMPLEN], flags[MAILTMPLEN], path[MAILTMPLEN], *s;
++ 				/* copy the messages */
++   if ((options &amp; CP_UID) ? mail_uid_sequence (stream, sequence) : 
++   	mail_sequence (stream,sequence)) 
++   for (i = 1L; i &lt;= stream-&gt;nmsgs; i++)
++     if ((elt = mail_elt (stream,i))-&gt;sequence){
++       MSGPATH(path, LOCAL-&gt;dir, MDFILE(elt), MDLOC(elt));
++       if (((fd = open (path,O_RDONLY,NIL)) &lt; 0)	 
++ 	  ||((!elt-&gt;rfc822_size &amp;&amp; 
++ 		((stat(path, &amp;sbuf) &lt; 0) || !S_ISREG (sbuf.st_mode)))))
++ 	return NIL;
++ 	if(!elt-&gt;rfc822_size)
++ 	  MDSIZE(elt) = sbuf.st_size;
++         s = (char *) fs_get(MDSIZE(elt) + 1);
++         read (fd,s,MDSIZE(elt));
++         s[MDSIZE(elt)] = '\0';
++         close (fd);
++ 	len = strcrlfcpy (&amp;LOCAL-&gt;buf,&amp;LOCAL-&gt;buflen, s, MDSIZE(elt));
++         INIT (&amp;st,mail_string, LOCAL-&gt;buf, len);
++ 	elt-&gt;rfc822_size = len;
++ 	fs_give ((void **)&amp;s);
++ 
++       flags[0] = flags[1] = '\0';
++       if (elt-&gt;seen) strcat (flags,&quot; \\Seen&quot;);
++       if (elt-&gt;draft) strcat (flags,&quot; \\Draft&quot;);
++       if (elt-&gt;deleted) strcat (flags,&quot; \\Deleted&quot;);
++       if (elt-&gt;flagged) strcat (flags,&quot; \\Flagged&quot;);
++       if (elt-&gt;answered) strcat (flags,&quot; \\Answered&quot;);
++       flags[0] = '(';         /* open list */
++       strcat (flags,&quot;)&quot;);     /* close list */
++       mail_date (tmp,elt);	/* generate internal date */
++       if (!mail_append_full (NIL,mailbox,flags,tmp,&amp;st))
++         return NIL;
++       if (options &amp; CP_MOVE) elt-&gt;deleted = T;
++     }
++   return LONGT;			/* return success */
++ }
++ 
++ long maildir_append (MAILSTREAM *stream,char *mailbox,append_t af,void *data)
++ {
++   int fd, k;
++   STRING *message;
++   char c,*s, *flags, *date;
++   char tmp[MAILTMPLEN],file[MAILTMPLEN],path1[MAILTMPLEN],path2[MAILTMPLEN];
++   MESSAGECACHE elt;
++   long i, size = 0L, ret = LONGT, f;
++   unsigned long uf;
++   static unsigned int transact = 0;
++ 
++   if (!maildir_valid(mailbox)) {
++     sprintf (tmp,&quot;Not a valid Maildir mailbox: %s&quot;,mailbox);
++     mm_log (tmp,ERROR);
++     return NIL;
++   }
++ 
++  if (!*mdlocaldomain)
++      md_domain_name();    /* get domain name for maildir files in mdlocaldomain now! */
++ 
++  if (!stream){
++     stream = &amp;maildirproto;
++   
++     for (k = 0; k &lt; NUSERFLAGS &amp;&amp; stream-&gt;user_flags[k]; ++k)
++        fs_give ((void **) &amp;stream-&gt;user_flags[k]);
++  }
++ 
++   if (!(*af) (stream,data,&amp;flags,&amp;date,&amp;message)) return NIL;
++ 
++   mm_critical (stream);		/* go critical */
++   do {
++     if (!SIZE (message)) {      /* guard against zero-length */
++       mm_log (&quot;Append of zero-length message&quot;,ERROR);
++       ret = NIL;
++       break;
++     }
++     if (date &amp;&amp; !mail_parse_date(&amp;elt,date)){
++         sprintf (tmp,&quot;Bad date in append: %.80s&quot;,date);
++         mm_log (tmp,ERROR);
++         ret = NIL;
++         break;
++     }
++     f = mail_parse_flags (stream,flags,&amp;uf);
++ 				/* build file name we will use */
++     sprintf (file,&quot;%lu.%d_%09u.%s%s%s%s%s%s&quot;,
++ 	   time (0),getpid (),transact++,mdlocaldomain, (f ? MDSEP(2) : &quot;&quot;),
++ 		MDFLAG(Draft, f&amp;fDRAFT), MDFLAG(Flagged, f&amp;fFLAGGED),
++ 		MDFLAG(Replied, f&amp;fANSWERED), MDFLAG(Seen, f&amp;fSEEN));
++ 				/* build tmp file name */
++     if (maildir_file_path(mailbox, tmp))
++        MSGPATH(path1, tmp, file, Tmp);
++ 
++     if ((fd = open (path1,O_WRONLY|O_CREAT|O_EXCL,S_IREAD|S_IWRITE)) &lt; 0) {
++        sprintf (tmp,&quot;Can't open append mailbox: %s&quot;,strerror (errno));
++        mm_log (tmp,ERROR);
++        return NIL;
++     }
++     for (size = 0,i = SIZE (message),s = (char *) fs_get (i + 1); i; --i)
++       if ((c = SNX (message)) != '\015') s[size++] = c;
++     if ((write (fd,s,size) &lt; 0) || fsync (fd)) {
++ 	unlink (path1);		/* delete message */
++ 	sprintf (tmp,&quot;Message append failed: %s&quot;,strerror (errno));
++ 	mm_log (tmp,ERROR);
++ 	ret = NIL;
++     }
++     fs_give ((void **) &amp;s);	/* flush the buffer */
++     close (fd);			/* close the file */
++ 				/* build final filename to use */
++     if (maildir_file_path(mailbox, tmp))
++ 	MSGPATH(path2, tmp, file, New);
++     if (link (path1,path2) &lt; 0) {
++        sprintf (tmp,&quot;Message append failed: %s&quot;,strerror (errno));
++        mm_log (tmp,ERROR);
++        ret = NIL;
++     }
++     unlink (path1);
++ 
++     if (ret)
++      if (!(*af) (stream,data,&amp;flags,&amp;date,&amp;message)) ret = NIL;
++ 
++   } while (ret &amp;&amp; message);	/* write the data */
++   
++   mm_nocritical (stream);	/* release critical */
++   return ret;
++ }
++ 
++ long maildir_delete (MAILSTREAM *stream,char *mailbox)
++ {
++   DIR *dirp;
++   struct direct *d;
++   int i, remove_dir = 0, mddir = 0, rv, error = 0;
++   char tmp[MAILTMPLEN],tmp2[MAILTMPLEN], realname[MAILTMPLEN];
++   struct stat sbuf;
++   int courier = IS_COURIER(mailbox);
++ 
++   if (mailbox[strlen(mailbox) - 1] == MDSEPARATOR(courier)){
++       remove_dir++;
++       mailbox[strlen(mailbox) -1] = '\0';
++   }
++ 
++   if (!maildir_valid(mailbox)){
++       maildir_file_path(mailbox, tmp);
++       if (stat(tmp, &amp;sbuf) &lt; 0 || !S_ISDIR(sbuf.st_mode)){
++         sprintf(tmp,&quot;Can not remove %s&quot;, mailbox);
++ 	error++;
++       }
++   }
++ 
++   if (!error &amp;&amp; remove_dir &amp;&amp; !maildir_dir_is_empty(mailbox)){
++      sprintf(tmp,&quot;Can not remove directory %s/: directory not empty&quot;, mailbox);
++      error++;
++   }
++ 
++   if(error){
++      mm_log (tmp,ERROR);
++      return NIL;
++   }
++ 
++   maildir_close(stream,0);	/* even if stream was NULL */
++ 
++   maildir_file_path(mailbox, realname);
++ 
++   if (remove_dir){
++      sprintf(tmp,&quot;%s/%s&quot;, realname, MDDIR);
++      if ((rv = stat (tmp,&amp;sbuf)) == 0 &amp;&amp; S_ISREG(sbuf.st_mode))
++ 	rv = unlink(tmp);
++      else if (errno == ENOENT)
++ 	rv = 0;
++      if (rv != 0){
++ 	sprintf(tmp,&quot;Can not remove %s/%s: %s&quot;, tmp2, MDDIR, strerror(errno));
++ 	mm_log (tmp,ERROR);
++ 	return NIL;
++      }
++      if (!maildir_valid(realname) &amp;&amp; rmdir(realname) != 0){
++ 	sprintf(tmp,&quot;Can not remove %s/: %s&quot;, mailbox, strerror(errno));
++ 	mm_log (tmp,ERROR);
++ 	return NIL;
++      }
++      return LONGT;
++   }
++   /* else remove just the folder. Remove all hidden files, except MDDIR */
++   for (i = Cur; i != EndDir; i++){
++       MDFLD(tmp, realname, i);
++ 
++       if (!(dirp = opendir (tmp))){
++ 	  sprintf(tmp,&quot;Can not read %s/: %s&quot;, mailbox, strerror(errno));
++ 	  mm_log (tmp,ERROR);
++ 	  return NIL;
++       }
++ 
++       while ((d = readdir(dirp)) != NULL){
++ 	 if (strcmp(d-&gt;d_name, &quot;.&quot;) &amp;&amp; strcmp(d-&gt;d_name,&quot;..&quot;)){
++ 	    sprintf(tmp2,&quot;%s/%s&quot;, tmp, d-&gt;d_name);
++ 	    if (unlink(tmp2) != 0){
++ 	       sprintf(tmp2,&quot;Can not remove %s: %s&quot;, mailbox, strerror(errno));
++ 	       mm_log (tmp2,ERROR);
++ 	       return NIL;
++ 	    }
++ 	 }
++       }
++       closedir(dirp);
++       if (rmdir(tmp) != 0){
++ 	 sprintf(tmp,&quot;Can not remove %s: %s&quot;, mailbox, strerror(errno));
++ 	 mm_log (tmp,ERROR);
++ 	 return NIL;
++       }
++   }
++   /* 
++    * ok we have removed all subdirectories of the folder mailbox, Remove the
++    * hidden files.
++    */
++ 
++   if(!(dirp = opendir (realname))){
++     sprintf(tmp,&quot;Can not read %s/: %s&quot;, realname, strerror(errno));
++     mm_log (tmp,ERROR);
++     return NIL;
++   }
++ 
++   while ((d = readdir(dirp)) != NULL){
++ 	if (strcmp(d-&gt;d_name, &quot;.&quot;) &amp;&amp; strcmp(d-&gt;d_name,&quot;..&quot;)
++ 		&amp;&amp; (!strcmp(d-&gt;d_name, MDDIR)
++ 			|| !strncmp(d-&gt;d_name, MDUIDLAST, strlen(MDUIDLAST))
++ 			|| !strncmp(d-&gt;d_name, MDUIDTEMP, strlen(MDUIDTEMP)))){
++ 	   if(strcmp(d-&gt;d_name, MDDIR) == 0)
++ 	      mddir++;
++ 	   sprintf(tmp,&quot;%s/%s&quot;, realname, d-&gt;d_name);
++ 	   if (unlink(tmp) != 0)
++ 	      error++;
++ 	}
++   }
++   closedir(dirp);
++   if (error || 
++ 	 (maildir_dir_is_empty(mailbox) &amp;&amp; mddir == 0 &amp;&amp; rmdir(realname) &lt; 0)){
++         sprintf(tmp,&quot;Can not remove folder %s: %s&quot;, mailbox, strerror(errno));
++         mm_log (tmp,ERROR);
++         return NIL;
++   }
++   return LONGT;
++ }
++ 
++ long maildir_rename (MAILSTREAM *stream, char *old, char *new)
++ {
++   char tmp[MAILTMPLEN],tmpnew[MAILTMPLEN], realold[MAILTMPLEN];
++   char realnew[MAILTMPLEN];
++   int courier = IS_COURIER(old) &amp;&amp; IS_COURIER(new);
++   int i;
++   long rv = LONGT;
++   COURIER_S *cdir;
++ 
++   if((IS_COURIER(old) || IS_COURIER(new)) &amp;&amp; !courier){
++     sprintf (tmp,&quot;Can't rename mailbox %s to %s&quot;,old, new);
++     mm_log (tmp,ERROR);
++     return NIL;
++   }
++ 
++   if (!maildir_valid(old)){
++     sprintf (tmp,&quot;Can't rename mailbox %s: folder not in maildir format&quot;,old);
++     mm_log (tmp,ERROR);
++     return NIL;
++   }
++   maildir_file_path(old, realold);
++   if (!maildir_valid_name(new) &amp;&amp; new[0] == '#'){
++     sprintf (tmp,&quot;Can't rename mailbox %s: folder not in maildir format&quot;,new);
++     mm_log (tmp,ERROR);
++     return NIL;
++   }
++   maildir_file_path(new, realnew);
++   if (access(tmpnew,F_OK) == 0){ 	/* new mailbox name must not exist */
++     sprintf (tmp,&quot;Can't rename to mailbox %s: destination already exists&quot;,new);
++     mm_log (tmp,ERROR);
++     return NIL;
++   }
++ 
++   if(!courier){
++     if (rename (realold,realnew)){	/* try to rename the directory */
++        sprintf (tmp,&quot;Can't rename mailbox %s to %s: %s&quot;,old, new,
++ 							strerror(errno));
++        mm_log (tmp,ERROR);
++        return NIL;
++     }
++     return LONGT;	/* return success */
++   }
++ 
++   cdir = courier_list_dir(old);
++   for (i = 0; cdir &amp;&amp; i &lt; cdir-&gt;total; i++){
++       if(strstr(cdir-&gt;data[i]-&gt;name, old)){
++ 	sprintf(tmp,&quot;%s%s&quot;, new, cdir-&gt;data[i]-&gt;name+strlen(old));
++ 	maildir_file_path(cdir-&gt;data[i]-&gt;name, realold);
++ 	maildir_file_path(tmp, realnew);
++ 	if (rename (realold,realnew)){
++ 	   sprintf (tmp,&quot;Can't rename mailbox %s to %s: %s&quot;,old, new,
++ 							strerror(errno));
++ 	   mm_log (tmp,ERROR);
++ 	   rv = NIL;
++ 	}
++     }
++   }
++   courier_free_cdir(&amp;cdir);
++   return rv;
++ }
++ 
++ long maildir_sub (MAILSTREAM *stream,char *mailbox)
++ {
++   return sm_subscribe (mailbox);
++ }
++ 
++ long maildir_unsub (MAILSTREAM *stream,char *mailbox)
++ {
++   return sm_unsubscribe (mailbox);
++ }
++ 
++ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat)
++ {
++   void *sdb = NIL;
++   char *s, 	test[MAILTMPLEN];
++                                 /* get canonical form of name */
++   if (maildir_canonicalize (test,ref,pat) &amp;&amp; (s = sm_read (&amp;sdb))) {
++     do if (pmatch_full (s,test,'/')) mm_lsub (stream,'/',s,NIL);
++     while ((s = sm_read (&amp;sdb)) != NULL); /* until no more subscriptions */
++   }
++ }
++ 
++ long maildir_canonicalize (char *pattern,char *ref,char *pat)
++ {
++   if (ref &amp;&amp; *ref) {            /* have a reference */
++     strcpy (pattern,ref);       /* copy reference to pattern */
++                                 /* # overrides mailbox field in reference */
++     if (*pat == '#') strcpy (pattern,pat);
++                                 /* pattern starts, reference ends, with / */
++     else if ((*pat == '/') &amp;&amp; (pattern[strlen (pattern) - 1] == '/'))
++       strcat (pattern,pat + 1); /* append, omitting one of the period */
++                                                                                 
++     else strcat (pattern,pat);  /* anything else is just appended */
++   }
++   else strcpy (pattern,pat);    /* just have basic name */
++   return maildir_valid_name(pattern) ? LONGT : NIL;
++ }
++ 
++ void maildir_list_work (MAILSTREAM *stream,char *dir,char *pat,long level)
++ {
++   DIR *dp;
++   struct direct *d;
++   struct stat sbuf;
++   char curdir[MAILTMPLEN],name[MAILTMPLEN], tmp[MAILTMPLEN];
++   char realpat[MAILTMPLEN];
++   long i;
++   char *maildirpath = mdirpath();
++ 
++   sprintf(curdir,&quot;%s/%s/&quot;, myrootdir(pat), dir ? dir : maildirpath);
++   if ((dp = opendir (curdir)) != NULL){ 
++      if (dir) sprintf (name,&quot;%s%s/&quot;,MDPREFIX(CCLIENT),dir);
++      else strcpy (name, pat);
++ 
++      if (level == 0 &amp;&amp; !strpbrk(pat,&quot;%*&quot;)){
++ 	if(maildir_valid(pat)){
++ 	  i =  maildir_contains_folder(pat, NULL)
++ 		? LATT_HASCHILDREN
++ 		: (maildir_is_dir(pat, NULL)
++ 			     ? LATT_HASNOCHILDREN : LATT_NOINFERIORS);
++ 	  maildir_file_path(pat, realpat);
++ 	  i +=  maildir_any_new_msgs(realpat) 
++ 			? LATT_MARKED : LATT_UNMARKED;
++ 	  mm_list (stream,'/', pat, i);
++ 	}
++ 	else
++ 	   if(pat[strlen(pat) - 1] == '/')
++ 	     mm_list (stream,'/', pat, LATT_NOSELECT);
++      }
++ 
++      while ((d = readdir (dp)) != NULL)
++ 	if(strcmp(d-&gt;d_name, &quot;.&quot;) &amp;&amp; strcmp(d-&gt;d_name,&quot;..&quot;)
++ 		&amp;&amp; strcmp(d-&gt;d_name, MDNAME(Cur)) 
++ 		&amp;&amp; strcmp(d-&gt;d_name, MDNAME(Tmp)) 
++ 		&amp;&amp; strcmp(d-&gt;d_name, MDNAME(New))){
++ 
++ 	  if (dir) sprintf (tmp,&quot;%s%s&quot;, name,d-&gt;d_name);
++ 	  else strcpy(tmp, d-&gt;d_name);
++ 
++ 	  if(pmatch_full (tmp, pat,'/')){
++ 	     sprintf(tmp,&quot;%s/%s/%s&quot;, myrootdir(d-&gt;d_name), 
++ 				(dir ? dir : maildirpath), d-&gt;d_name);
++ 	     if(stat (tmp,&amp;sbuf) == 0 
++ 		   &amp;&amp; ((sbuf.st_mode &amp; S_IFMT) == S_IFDIR)){
++ 	       if (dir) sprintf (tmp,&quot;%s%s&quot;, name,d-&gt;d_name);
++ 	       else strcpy(tmp, d-&gt;d_name);
++                i = maildir_valid(tmp)
++ 			? (maildir_contains_folder(dir, d-&gt;d_name)
++ 			  ? LATT_HASCHILDREN
++ 			  : (maildir_is_dir(dir, d-&gt;d_name)
++ 			     ? LATT_HASNOCHILDREN : LATT_NOINFERIORS))
++ 			: LATT_NOSELECT;
++ 	       i +=  maildir_any_new_msgs(tmp)
++ 			    ? LATT_MARKED : LATT_UNMARKED;
++ 	       mm_list (stream,'/',tmp, i);
++ 	       strcat (tmp, &quot;/&quot;);
++ 	       if(dmatch (tmp, pat,'/') &amp;&amp;
++                  (level &lt; (long) mail_parameters (NIL,GET_LISTMAXLEVEL,NIL))){
++ 		   sprintf(tmp,&quot;%s/%s&quot;,dir,d-&gt;d_name);
++  		   maildir_list_work (stream,tmp,pat,level+1);
++ 	       }
++ 	     }
++ 	  }
++        }
++      closedir (dp);
++   }
++ }
++ 
++ void courier_list_work (MAILSTREAM *stream, char *dir, char *pat, long level)
++ {
++   char c, curdir[MAILTMPLEN], tmp[MAILTMPLEN];
++   char realname[MAILTMPLEN], realpat[MAILTMPLEN] = {'\0'};
++   int i, found;
++   long style = (long) maildir_parameters(GET_COURIERSTYLE, NIL), j;
++   char *maildirpath = mdirpath();
++   COURIER_S *cdir;
++ 
++   if(!strpbrk(pat,&quot;%*&quot;)){	/* a mailbox */
++      maildir_file_path(pat, curdir);
++      i = strlen(curdir) - 1;
++      if(curdir[i] == '/')
++        curdir[i] = '\0';
++      cdir = courier_list_dir(curdir);
++      if(cdir){
++ 	found = 0; j = 0L;
++ 	if(maildir_valid_name(pat)){
++ 	  for(i = 0; !found &amp;&amp; i &lt; cdir-&gt;total; i++)
++ 	     if(strstr(curdir, cdir-&gt;data[i]-&gt;name)){
++ 		if(strlen(curdir) &lt; strlen(cdir-&gt;data[i]-&gt;name))
++ 		  found += 2;
++ 		else if(strlen(curdir) == strlen(cdir-&gt;data[i]-&gt;name))
++ 		  found -= 1;
++ 	     }
++ 	  if(found &gt; 0)
++             j = LATT_HASCHILDREN;
++           else if(found == 0)
++ 	    j = (style == COURIER) ? LATT_HASNOCHILDREN : LATT_NOINFERIORS;
++ 	}
++ 	else
++ 	   j = LATT_NOSELECT;
++         j += maildir_any_new_msgs(curdir) ? LATT_MARKED : LATT_UNMARKED;
++ 	if (found)
++ 	   mm_list (stream, '.', pat, j);
++         courier_free_cdir(&amp;cdir);
++      }
++      return;
++   }
++ 
++   strcpy(tmp,pat + 4);	/* a directory */
++   j = strlen(pat) - 1;
++   maildir_file_path(pat, realpat);
++   c = pat[j];
++   pat[j] = '\0';
++   realname[0] = '\0';
++   if(dir)
++     maildir_file_path(dir, realname);
++   sprintf(curdir,&quot;%s%s%s/%s&quot;, (dir ? &quot;&quot; : myrootdir(pat)), (dir ? &quot;&quot; : &quot;/&quot;),
++ 		(dir ? realname : maildirpath),	(dir ? &quot;&quot; : &quot;.&quot;));
++   sprintf(tmp, &quot;%s%s/.&quot;, MDPREFIX(COURIER), dir ? dir : maildirpath);
++   if (level == 0 &amp;&amp; tmp &amp;&amp; pmatch_full (tmp, realpat, '.'))
++      mm_list (stream,'.', tmp, LATT_NOSELECT);
++ 
++   cdir = courier_list_dir(pat);
++   pat[j] = c;
++   for (i = 0; cdir &amp;&amp; i &lt; cdir-&gt;total; i++)
++    if(pmatch_full (cdir-&gt;data[i]-&gt;name, pat, '.')){
++       sprintf(tmp, &quot;%s.&quot;, cdir-&gt;data[i]-&gt;name);
++       courier_list_info(&amp;cdir, tmp, i);
++       mm_list (stream,'.',cdir-&gt;data[i]-&gt;name, cdir-&gt;data[i]-&gt;attribute);
++    }
++   courier_free_cdir(&amp;cdir);
++ }
++ 
++ int 
++ same_maildir_file(char *name1, char *name2)
++ {
++  char tmp1[MAILTMPLEN], tmp2[MAILTMPLEN];
++  char *s;
++ 
++  strcpy(tmp1, name1 ? name1 : &quot;&quot;);
++  strcpy(tmp2, name2 ? name2 : &quot;&quot;);
++  if ((s = strrchr(tmp1, FLAGSEP)) != NULL)
++    *s = '\0';
++  if (((s = strrchr(tmp1, SIZESEP)) != NULL) &amp;&amp; (strchr(s,'.') == NULL))
++    *s = '\0';
++  if ((s = strrchr(tmp2, FLAGSEP)) != NULL)
++    *s = '\0';
++  if (((s = strrchr(tmp2, SIZESEP)) != NULL) &amp;&amp; (strchr(s,'.') == NULL))
++    *s = '\0';
++ 
++  return !strcmp(tmp1, tmp2);
++ }
++ 
++ unsigned long antoul(char *seed)
++ {
++   int i, error = 0;
++   unsigned long val = 0L, rv1 = 0L, t;
++   char c, *p;
++  if(!seed)
++    return 0L;
++  t = strtoul(seed, &amp;p, 10);
++  if(p &amp;&amp; (*p == '.' || *p == '_'))
++    return t;
++  /* else */
++  if((p = strchr(seed,'.')) != NULL)
++    *p = '\0';
++  error = (strlen(seed) &gt; 6); /* too long */
++  for(i= strlen(seed)-1; error == 0 &amp;&amp; i &gt;= 0; i--){
++     c = seed[i];
++     if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') val = c - 'A';
++     else if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') val = c - 'a' + 26;
++     else if (c &gt;= '0' &amp;&amp; c &lt;= '9') val = c - '0' + 26 + 26; 
++     else if (c == '-') val = c - '-' + 26 + 26 + 10;
++     else if (c == '_') val = c - '_' + 26 + 26 + 10 + 1;
++     else error++;
++     rv1 = val + (rv1 &lt;&lt; 6);
++  }
++  if(p)
++    *p = '.';
++   return error ? 0L : rv1;
++ }
++ 
++ unsigned long mdfntoul (char *name)
++ {
++   unsigned long t;
++   char *r, last;
++ 
++   if((*name == '_') &amp;&amp; ((r = strpbrk(name,&quot;.,%+&quot;)) != NULL)){ /* Grrr!!! */
++     last = *r;
++     *r = '\0';
++      t = antoul(r+1);
++     *r = last;
++   }
++   else
++     t = antoul(name);
++   return t;
++ }
++ 
++ int comp_maildir_file(char *name1, char *name2)
++ {
++   int uset1 = 1, uset2 = 1, i, j, cmp;
++   unsigned long t1, t2;
++   char *s1, *s2;
++ 
++   if (!(name1 &amp;&amp; *name1))
++      return (name2 &amp;&amp; *name2) ? (*name2 == FLAGSEP ? 0 : -1) : 0;
++ 
++   if (!(name2 &amp;&amp; *name2))
++      return (name1 &amp;&amp; *name1) ? (*name1 == FLAGSEP ? 0 : 1) : 0;
++ 
++    if((cmp = strcmp(name1,name2)) == 0)
++       return 0;
++ 
++   t1 = strtoul(name1, &amp;s1, 10);
++   t2 = strtoul(name2, &amp;s2, 10);
++ 
++   if(!s1 || *s1 != '.')
++     uset1 = 0;
++ 
++   if(!s2 || *s2 != '.')
++     uset2 = 0;
++ 
++   if(uset1 &amp;&amp; uset2)	/* normal sort order */
++     return (t1 &lt; t2) ? -1 : (t1 &gt; t2 ? 1 : (cmp &lt; 0 ? -1 : 1));
++ 
++   /* If we make it here we say Grrrr.... first, then we try to figure out
++    * how to sort this mess.
++    * These are the rules.
++    * If there is a number at the beginning it is bigger than anything else.
++    * If there are digits, then the number of digits decides which one is bigger.
++    */
++ 
++   for(i = 0; isdigit(name1[i]); i++);
++   for(j = 0; isdigit(name2[j]); j++);
++ 
++   return(uset1 ? 1 
++ 	       : (uset2 ? -1 
++ 			: (i &lt; j ? -1 : (i &gt; j ? 1 : (cmp &lt; 0 ? -1 : 1)))));
++ }
++ 
++ void
++ maildir_getflag(char *name, int *d, int *f, int *r ,int *s, int *t)
++ {
++   char tmp[MAILTMPLEN], *b;
++   int offset = 0;
++   int tmpd, tmpf, tmpr, tmps, tmpt;
++ 
++   if(d) *d = 0;
++   if(f) *f = 0;
++   if(r) *r = 0;
++   if(s) *s = 0;
++   if(t) *t = 0;
++ 
++   tmpd = tmpf = tmpr = tmps = tmpt = NIL; /* no flags set by default */
++   strcpy(tmp,name);
++   while ((b = strrchr(tmp+offset, FLAGSEP)) != NULL){
++     char flag,last;
++     int  k;
++     if (!++b) break;
++     switch (*b){
++ 	case '1':
++ 	case '2':
++ 	case '3': flag = *b; b += 2;
++ 		  for (k = 0; b[k] &amp;&amp; b[k] != FLAGSEP &amp;&amp; b[k] != ','; k++);
++ 		  last = b[k];
++ 		  b[k] = '\0';
++ 		  if (flag == '2' || flag == '3'){
++ 		     tmpd = strchr (b, MDFLAGC(Draft))   ? T : NIL;
++ 		     tmpf = strchr (b, MDFLAGC(Flagged)) ? T : NIL;
++ 		     tmpr = strchr (b, MDFLAGC(Replied)) ? T : NIL;
++ 		     tmps = strchr (b, MDFLAGC(Seen))    ? T : NIL;
++ 		     tmpt = strchr (b, MDFLAGC(Trashed)) ? T : NIL;
++ 		  }
++ 		  b[k] = last;
++ 		  b += k;
++ 		  for (; tmp[offset] &amp;&amp; tmp[offset] != FLAGSEP; offset++);
++ 		  offset++;
++ 		break;
++ 	default: break;	/* Should we crash?... Nahhh */
++     }
++   }
++   if(d) *d = tmpd;
++   if(f) *f = tmpf;
++   if(r) *r = tmpr;
++   if(s) *s = tmps;
++   if(t) *t = tmpt;
++ }
++ 
++ int
++ maildir_message_in_list(char *msgname, struct direct **names, 
++ 		unsigned long bottom, unsigned long top, unsigned long *pos)
++ {
++   unsigned long middle = (bottom + top)/2;
++   int test;
++ 
++   if (!msgname)
++      return NIL;
++ 
++   if (pos) *pos = middle;
++ 
++   if (same_maildir_file(msgname, names[middle]-&gt;d_name))
++      return T;
++ 
++   if (middle == bottom){	 /* 0 &lt;= 0 &lt; 1 */
++      int rv = NIL;
++      if (same_maildir_file(msgname, names[middle]-&gt;d_name)){
++ 	rv = T;
++ 	if (pos) *pos = middle;
++      }
++      else
++        if (same_maildir_file(msgname, names[top]-&gt;d_name)){
++ 	rv = T;
++ 	if (pos) *pos = top;
++        }
++      return rv;
++   }
++ 
++   test = comp_maildir_file(msgname, names[middle]-&gt;d_name);
++ 
++   if (top &lt;= bottom)
++       return test ? NIL : T;
++ 
++   if (test &lt; 0 ) /* bottom &lt;  msgname &lt; middle */
++      return maildir_message_in_list(msgname, names, bottom, middle, pos);
++   else if (test &gt; 0)  /* middle &lt; msgname &lt; top */
++      return maildir_message_in_list(msgname, names, middle, top, pos);
++   else return T;
++ }
++ 
++ void
++ maildir_abort(MAILSTREAM *stream)
++ {
++   if (LOCAL){
++     if(LOCAL-&gt;candouid)
++       maildir_read_uid(stream, NULL, &amp;stream-&gt;uid_validity);
++     if (LOCAL-&gt;dir) fs_give ((void **) &amp;LOCAL-&gt;dir);
++     if (LOCAL-&gt;curdir) fs_give ((void **) &amp;LOCAL-&gt;curdir);
++     if (LOCAL-&gt;buf) fs_give ((void **) &amp;LOCAL-&gt;buf);
++     if(LOCAL-&gt;uidtempfile){
++       unlink(LOCAL-&gt;uidtempfile);
++       fs_give ((void **) &amp;LOCAL-&gt;uidtempfile);
++     }
++     fs_give ((void **) &amp;stream-&gt;local);
++   }
++   if (mdfpath) fs_give((void **)&amp;mdfpath);
++   stream-&gt;dtb = NIL;
++ }
++ 
++ int
++ maildir_contains_folder(char *dirname, char *name)
++ {
++   char tmp[MAILTMPLEN], tmp2[MAILTMPLEN];
++   int rv = 0;
++   DIR *dir;
++   struct direct *d;
++ 
++   maildir_file_path(dirname, tmp2);
++   if(name){
++     strcat(tmp2,&quot;/&quot;);
++     strcat(tmp2, name);
++   }
++ 
++   if (!(dir = opendir (tmp2)))
++      return NIL;
++ 
++   while ((d = readdir(dir)) != NULL){
++     if (strcmp(d-&gt;d_name, &quot;.&quot;) &amp;&amp; strcmp(d-&gt;d_name,&quot;..&quot;)
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDNAME(Cur)) 
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDNAME(Tmp)) 
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDNAME(New))){
++ 
++        sprintf(tmp,&quot;%s/%s&quot;, tmp2, d-&gt;d_name);
++        if(maildir_valid(tmp)){
++ 	  rv++;
++ 	  break;
++        }
++     }
++   }
++   closedir(dir);
++   return rv;
++ }
++ 
++ int
++ maildir_is_dir(char *dirname, char *name)
++ {
++   char tmp[MAILTMPLEN];
++   struct stat sbuf;
++ 
++   maildir_file_path(dirname, tmp);
++   if(name){
++     strcat(tmp,&quot;/&quot;);
++     strcat(tmp,name);
++   }
++   strcat(tmp,&quot;/&quot;);
++   strcat(tmp,MDDIR);
++ 
++   return ((stat(tmp, &amp;sbuf) == 0) &amp;&amp; S_ISREG (sbuf.st_mode)) ? 1 : 0;
++ }
++ 
++ int
++ maildir_dir_is_empty(char *mailbox)
++ {
++   char tmp[MAILTMPLEN], tmp2[MAILTMPLEN], tmp3[MAILTMPLEN],*s;
++   int rv = 1, courier = IS_COURIER(mailbox);
++   DIR *dir;
++   struct direct *d;
++   struct stat sbuf;
++ 
++   maildir_file_path(mailbox, tmp2);
++ 
++   if(courier){
++      strcpy(tmp3, tmp2);
++      if(s = strrchr(tmp2, '/'))
++ 	*s = '\0';
++   }
++ 
++   if (!(dir = opendir (tmp2)))
++      return rv;
++ 
++   if(courier){
++      while((d = readdir(dir)) != NULL){
++         sprintf(tmp,&quot;%s/%s&quot;, tmp2, d-&gt;d_name);
++ 	if(!strncmp(tmp, tmp3, strlen(tmp3)) 
++ 	   &amp;&amp; tmp[strlen(tmp3)] == '.'){
++ 	   rv = 0;
++ 	   break;
++ 	}
++      }
++   }
++   else
++     while ((d = readdir(dir)) != NULL){
++       sprintf(tmp,&quot;%s/%s&quot;, tmp2, d-&gt;d_name);
++       if (strcmp(d-&gt;d_name, &quot;.&quot;) 
++ 	&amp;&amp; strcmp(d-&gt;d_name,&quot;..&quot;)
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDNAME(Cur)) 
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDNAME(Tmp)) 
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDNAME(New))
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDDIR)
++ 	&amp;&amp; strcmp(d-&gt;d_name, MDUIDVALIDITY)
++ 	&amp;&amp; !(d-&gt;d_name[0] == '.' 
++ 		&amp;&amp; stat (tmp,&amp;sbuf) == 0 
++ 		&amp;&amp; S_ISREG(sbuf.st_mode))){
++ 	   rv = 0;
++ 	   break;
++        }
++     }
++   closedir(dir);
++   return rv;
++ }
++ 
++ void
++ maildir_get_file (MAILDIRFILE **mdfile)
++ {
++   MAILDIRFILE *md;
++ 
++   md = (MAILDIRFILE *) fs_get(sizeof(MAILDIRFILE));
++   memset(md, 0, sizeof(MAILDIRFILE));
++   *mdfile = md;
++ }
++ 
++ void
++ maildir_free_file (void **mdfile)
++ {
++   MAILDIRFILE *md = (mdfile &amp;&amp; *mdfile) ? (MAILDIRFILE *) *mdfile : NULL;
++ 
++   if (md){
++      if (md-&gt;name) fs_give((void **)&amp;md-&gt;name);
++      fs_give((void **)&amp;md);
++   }
++ }
++ 
++ void
++ maildir_free_file_only (void **mdfile)
++ {
++   MAILDIRFILE *md = (mdfile &amp;&amp; *mdfile) ? (MAILDIRFILE *) *mdfile : NULL;
++ 
++   if (md &amp;&amp; md-&gt;name) 
++      fs_give((void **)&amp;md-&gt;name);
++ }
++ 
++ int
++ maildir_any_new_msgs(char *mailbox)
++ {
++   char tmp[MAILTMPLEN];
++   int rv = NIL;
++   DIR *dir;
++   struct direct *d;
++ 
++   MDFLD(tmp, mailbox, New);
++ 
++   if (!(dir = opendir (tmp)))
++      return rv;
++ 
++   while ((d = readdir(dir)) != NULL){
++     if (d-&gt;d_name[0] == '.')
++ 	continue;
++     rv = T;
++     break;
++   }
++   closedir(dir);
++   return rv;
++ }
++ 
++ 
++ void
++ maildir_get_date(MAILSTREAM *stream, unsigned long msgno)
++ {
++   MESSAGECACHE *elt;
++   struct tm *t;
++   time_t ti;
++   int i,k;
++ 
++   elt = mail_elt (stream,msgno);
++   if(elt &amp;&amp; elt-&gt;year != 0)
++     return;
++   if ((ti = mdfntoul(MDFILE(elt))) &gt; 0L &amp;&amp; (t = gmtime(&amp;ti))){
++      i = t-&gt;tm_hour * 60 + t-&gt;tm_min;
++      k = t-&gt;tm_yday;
++      t = localtime(&amp;ti);
++      i = t-&gt;tm_hour * 60 + t-&gt;tm_min - i;
++      if((k = t-&gt;tm_yday - k) != 0) 
++ 	i += ((k &lt; 0) == (abs (k) == 1)) ? -24*60 : 24*60;
++      k = abs (i);
++      elt-&gt;hours = t-&gt;tm_hour; 
++      elt-&gt;minutes = t-&gt;tm_min; 
++      elt-&gt;seconds = t-&gt;tm_sec;
++      elt-&gt;day = t-&gt;tm_mday; elt-&gt;month = t-&gt;tm_mon + 1;
++      elt-&gt;year = t-&gt;tm_year - (BASEYEAR - 1900);
++      elt-&gt;zoccident = (k == i) ? 0 : 1;
++      elt-&gt;zhours = k/60;
++      elt-&gt;zminutes = k % 60;
++   }
++ }
++ 
++ /* Support for Courier Style directories 
++    When this code is complete there will be two types of support, which 
++    will be configurable. The problem is the following: In Courier style 
++    folder structure, a &quot;folder&quot; may have a subfolder called 
++    &quot;folder.subfolder&quot;, which is not natural in the file system in the 
++    sense that I can not stat for &quot;folder.subfolder&quot; wihtout knowing what 
++    &quot;subfolder&quot; is. It needs to be guessed. Because of this I need to look 
++    in the list of folders if there is a folder with a name 
++    &quot;folder.subfolder&quot;, before I can say if the folder is dual or not. One 
++    can avoid this annoyance if one ignores the problem by declaring that 
++    every folder is dual. I will however code as the default the more 
++    complicated idea of scaning the containing directory each time it is 
++    modified and search for subfolders, and list the entries it found.
++  */
++ 
++ int courier_dir_select (const struct direct *name)
++ {
++  return name-&gt;d_name[0] == '.' &amp;&amp; (strlen(name-&gt;d_name) &gt; 2
++ 	|| (strlen(name-&gt;d_name) == 2 &amp;&amp;  name-&gt;d_name[1] != '.'));
++ }
++ 
++ int courier_dir_sort (const void *d1, const  void *d2)
++ {
++   const struct direct **e1, **e2;
++ 
++   e1 = (const struct direct **)d1;
++   e2 = (const struct direct **)d2;
++ 
++   return strcmp((char*)(*e1)-&gt;d_name, (char *)(*e2)-&gt;d_name);
++ }
++ 
++ void courier_free_cdir (COURIER_S **cdir)
++ {
++   int i;
++ 
++   if (!*cdir)
++      return;
++ 
++   if ((*cdir)-&gt;path) fs_give((void **)&amp;((*cdir)-&gt;path));
++   for (i = 0; i &lt; (*cdir)-&gt;total; i++)
++     if((*cdir)-&gt;data[i]-&gt;name) fs_give((void **)&amp;((*cdir)-&gt;data[i]-&gt;name));
++   fs_give((void **)&amp;((*cdir)-&gt;data));
++   fs_give((void **)&amp;(*cdir));
++ }
++ 
++ COURIER_S *courier_get_cdir (int total)
++ {
++  COURIER_S *cdir;
++ 
++  cdir = (COURIER_S *)fs_get(sizeof(COURIER_S));
++  memset(cdir, 0, sizeof(COURIER_S));
++  cdir-&gt;data = (COURIERLOCAL **) fs_get(total*sizeof(COURIERLOCAL *));
++  memset(cdir-&gt;data, 0, sizeof(COURIERLOCAL *));
++  cdir-&gt;total = total;
++  return cdir;
++ }
++ 
++ int courier_search_list(COURIERLOCAL **data, char *name, int first, int last)
++ {
++   int try = (first + last)/2;
++ 
++   if(!strstr(data[try]-&gt;name, name)){
++      if(first == try) /* first == last || first + 1 == last */
++ 	return strstr(data[last]-&gt;name, name) ? 1 : 0;
++      if(strcmp(data[try]-&gt;name, name) &lt; 0) /*data[try] &lt; name &lt; data[end] */
++ 	return courier_search_list(data, name, try, last);
++      else	/* data[begin] &lt; name &lt; data[try] */
++ 	return courier_search_list(data, name, first, try);
++   }
++   return 1;
++ }
++ 
++ /* Lists all directories that are subdirectories of a given directory */
++ 
++ COURIER_S *courier_list_dir(char *curdir)
++ {
++   struct direct **names = NIL;
++   struct stat sbuf;
++   unsigned long ndir;
++   COURIER_S *cdir = NULL;
++   char tmp[MAILTMPLEN], tmp2[MAILTMPLEN], pathname[MAILTMPLEN], 
++ 	realname[MAILTMPLEN];
++   int i, j, scand, td;
++ 
++   /* There are two cases, either curdir is 
++  	 #mc/INBOX.	 #mc/INBOX.foo
++ 	or
++ 	 #mc/Maildir/. 	 #mc/Maildir/.foo
++    */
++   strcpy(tmp,curdir + 4);
++   if(!strncmp(ucase(tmp), &quot;INBOX&quot;, 5))
++     strcpy(tmp, &quot;#mc/INBOX.&quot;);
++   else{
++    strcpy(tmp, curdir);
++    for (i = strlen(tmp) - 1; tmp[i] &amp;&amp; tmp[i] != '/'; i--);
++    tmp[i+2] = '\0'; 	/* keep the last &quot;.&quot; intact */
++   }
++   maildir_file_path(tmp, realname);
++   maildir_scandir (realname, &amp;names, &amp;ndir, &amp;scand, COURIER);
++ 
++   if (scand &gt; 0){
++      cdir = courier_get_cdir(ndir);
++      cdir-&gt;path = cpystr(realname);
++      for(i = 0, j = 0; i &lt; ndir; i++){
++         td = realname[strlen(realname) - 1] == '.'
++ 		&amp;&amp; *names[i]-&gt;d_name == '.';
++ 	sprintf(tmp2,&quot;%s%s&quot;, tmp, names[i]-&gt;d_name+1);
++ 	sprintf(pathname,&quot;%s%s&quot;, realname, names[i]-&gt;d_name + td);
++ 	if(stat(pathname, &amp;sbuf) == 0 &amp;&amp; S_ISDIR(sbuf.st_mode)){
++ 	   cdir-&gt;data[j] = (COURIERLOCAL *) fs_get(sizeof(COURIERLOCAL));
++ 	   cdir-&gt;data[j++]-&gt;name = cpystr(tmp2);
++ 	}
++ 	fs_give((void **)&amp;names[i]);
++      }
++      cdir-&gt;total = j;
++      if(cdir-&gt;total == 0)
++         courier_free_cdir(&amp;cdir);
++   }
++   if(names)
++     fs_give((void **) &amp;names);
++   return cdir;
++ }
++ 
++ void
++ courier_list_info(COURIER_S **cdirp, char *data, int i)
++ {
++    long style = (long) maildir_parameters(GET_COURIERSTYLE, NIL);
++    COURIER_S *cdir = *cdirp;
++ 
++    if(maildir_valid(cdir-&gt;data[i]-&gt;name)){
++       if(courier_search_list(cdir-&gt;data, data, 0, cdir-&gt;total - 1))
++ 	 cdir-&gt;data[i]-&gt;attribute = LATT_HASCHILDREN;
++       else
++ 	 cdir-&gt;data[i]-&gt;attribute = (style == COURIER)
++ 				? LATT_HASNOCHILDREN : LATT_NOINFERIORS;
++    }
++    else
++       cdir-&gt;data[i]-&gt;attribute = LATT_NOSELECT;
++       cdir-&gt;data[i]-&gt;attribute += maildir_any_new_msgs(cdir-&gt;data[i]-&gt;name) 
++ 					? LATT_MARKED : LATT_UNMARKED;
++ }
++ 
++ /* UID Support */
++ /* Yes, I know I procastinated a lot about this, but here it is finally */
++ 
++ unsigned int
++ maildir_can_assign_uid (MAILSTREAM *stream)
++ {
++   unsigned int rv = 0;
++   int createtemp;
++   unsigned long t;
++   char tmp[MAILTMPLEN], *s;
++   DIR *dir;
++   struct direct *d;
++ 
++   if(!stream || stream-&gt;rdonly 
++ 	|| !LOCAL || !LOCAL-&gt;dir || !(dir = opendir(LOCAL-&gt;dir)))
++     return rv;
++ 
++   sprintf(tmp, &quot;%s.%d&quot;, MDUIDTEMP, getpid());
++   while ((d = readdir(dir)) != NULL){
++     if(!strncmp(d-&gt;d_name, tmp, strlen(tmp)) 
++ 	|| !strncmp(d-&gt;d_name, MDUIDTEMP, strlen(MDUIDTEMP)))
++        break;
++   }
++   closedir(dir);
++   rv = d ? !strncmp(d-&gt;d_name, tmp, strlen(tmp)) : 1;
++   createtemp = d ? 0 : 1;
++   if (d &amp;&amp; rv == 0){	/* is there a temp file that is not ours? */
++      s = strrchr(d-&gt;d_name, '.');
++      t = strtoul(s+1, &amp;s, 10);
++      if(s != NULL &amp;&amp; *s != '\0')
++ 	createtemp++;
++      if(time(0) &gt; t + MAXTEMPUID){
++ 	createtemp++;
++ 	sprintf(tmp,&quot;%s/%s&quot;, LOCAL-&gt;dir, d-&gt;d_name);
++ 	unlink(tmp);
++      }
++   }
++   if(createtemp){
++     FILE *fp;
++     sprintf(tmp,&quot;%s/%s.%d.%lu&quot;, LOCAL-&gt;dir, MDUIDTEMP, getpid(), time(0));
++     if(fp = fopen(tmp, &quot;w&quot;)){
++       fclose(fp);
++       if(LOCAL-&gt;uidtempfile)
++ 	 fs_give((void **)&amp;LOCAL-&gt;uidtempfile);
++       LOCAL-&gt;uidtempfile = cpystr(tmp);
++       rv++;
++     }
++   }
++   return rv;
++ }
++ 
++ void
++ maildir_read_uid(MAILSTREAM *stream, unsigned long *uid_last, 
++ 			unsigned long *uid_validity)
++ {
++   int createuid, deleteuid = 0;
++   char tmp[MAILTMPLEN], *s = NULL;
++   DIR *dir;
++   struct direct *d;
++ 
++   if(uid_last) *uid_last = 0L;
++   if(uid_last &amp;&amp; uid_validity) *uid_validity = time(0);
++   if(!stream || !LOCAL || !LOCAL-&gt;dir || !(dir = opendir(LOCAL-&gt;dir)))
++     return;
++ 
++   while ((d = readdir(dir)) != NULL){
++       if(!strncmp(d-&gt;d_name, MDUIDLAST, strlen(MDUIDLAST)))
++        break;
++   }
++   closedir(dir);
++   createuid = d == NULL ? 1 : 0;
++   if(uid_last == NULL)
++     deleteuid++;
++   if(d){
++      if(uid_last){
++ 	s = d-&gt;d_name + strlen(MDUIDLAST) + 1;
++ 	*uid_last = strtoul(s, &amp;s, 10);
++ 	if(!s || *s != '.'){
++ 	  deleteuid++;
++ 	  createuid++;
++ 	  *uid_last = 0L;
++ 	}
++      }
++      if(s &amp;&amp; *s == '.'){
++         if(uid_validity){
++ 	  s++;
++ 	  *uid_validity = strtoul(s, &amp;s, 10);
++ 	  if(s &amp;&amp; *s != '\0'){
++ 	    *uid_validity = time(0);
++ 	    deleteuid++;
++ 	    createuid++;
++ 	  }
++ 	}
++      }
++      else{
++ 	deleteuid++;
++ 	createuid++;
++      }
++   }
++   if(deleteuid){
++      sprintf(tmp,&quot;%s/%s&quot;, LOCAL-&gt;dir, d-&gt;d_name);
++      unlink(tmp);
++   }
++   if(createuid)
++      maildir_write_uid(stream, (uid_last ? *uid_last : stream-&gt;uid_last), 
++ 		uid_validity ? *uid_validity : time(0));
++ }
++ 
++ void
++ maildir_write_uid(MAILSTREAM *stream, unsigned long uid_last, 
++ 			unsigned long uid_validity)
++ {
++   char tmp[MAILTMPLEN];
++   FILE *fp;
++ 
++   if(!stream || stream-&gt;rdonly || !LOCAL || !LOCAL-&gt;dir)
++     return;
++ 
++   sprintf(tmp,&quot;%s/%s.%010lu.%010lu&quot;, LOCAL-&gt;dir, MDUIDLAST, 
++ 			uid_last, uid_validity);
++   if(fp = fopen(tmp, &quot;w&quot;))
++      fclose(fp);
++ }
++ 
++ unsigned long 
++ maildir_get_uid(char *name)
++ {
++   char *s;
++   unsigned long rv = 0L;
++ 
++   if(!name || (s = strstr(name,MDUIDSEP)) == NULL)
++     return rv;
++ 
++   s += strlen(MDUIDSEP);
++   rv = strtoul(s, NULL, 10);
++   return rv;
++ }
++ 
++ 
++ void
++ maildir_delete_uid(MAILSTREAM *stream, unsigned long msgno)
++ {
++   char old[MAILTMPLEN], new[MAILTMPLEN], *s, *t;
++   MESSAGECACHE *elt;
++ 
++   elt = mail_elt(stream, msgno);
++   if(!stream || !elt || !elt-&gt;private.spare.ptr || !LOCAL || !LOCAL-&gt;dir)
++     return;
++ 
++   sprintf(old, &quot;%s/%s/%s&quot;, LOCAL-&gt;dir, MDNAME(Cur), MDFILE(elt));
++   t = MDFILE(elt);
++   if(s = strstr(MDFILE(elt), MDUIDSEP)){
++      *s = '\0';
++      s += strlen(MDUIDSEP);
++      strtoul(s, &amp;s, 10);
++      sprintf(new, &quot;%s/%s/%s%s&quot;, LOCAL-&gt;dir, MDNAME(Cur), t, s);
++      if(rename(old, new) == 0){
++ 	maildir_free_file_only ((void **)&amp;elt-&gt;private.spare.ptr);
++ 	s = strrchr(new, '/');
++ 	MDFILE(elt) = cpystr(s+1);
++      }
++      elt-&gt;private.uid = 0L;
++   }
++ }
++ 
++ void
++ maildir_assign_uid(MAILSTREAM *stream, unsigned long msgno, unsigned long uid)
++ {
++   int createuid, deleteuid = 0;
++   char old[MAILTMPLEN], new[MAILTMPLEN], *s, *t;
++   MESSAGECACHE *elt;
++ 
++   elt = mail_elt(stream, msgno);
++   if(!stream || !elt || !elt-&gt;private.spare.ptr || !LOCAL || !LOCAL-&gt;dir)
++     return;
++ 
++   maildir_delete_uid(stream, msgno);
++   sprintf(old, &quot;%s/%s/%s&quot;, LOCAL-&gt;dir, MDNAME(Cur), MDFILE(elt));
++   t = MDFILE(elt);
++   if((s = strrchr(MDFILE(elt),FLAGSEP)) != NULL){
++      *s++ = '\0';
++      sprintf(new, &quot;%s/%s/%s%s%lu%c%s&quot;, 
++ 		LOCAL-&gt;dir, MDNAME(Cur), t, MDUIDSEP, uid, FLAGSEP, s);
++      if(rename(old, new) == 0){
++ 	maildir_free_file_only ((void **)&amp;elt-&gt;private.spare.ptr);
++ 	s = strrchr(new, '/');
++ 	MDFILE(elt) = cpystr(s+1);
++ 	stream-&gt;uid_validity = time(0);
++      }
++      elt-&gt;private.uid = uid;
++   }
++ }
++ 
++ void
++ maildir_uid_renew_tempfile(MAILSTREAM *stream)
++ {
++   char tmp[MAILTMPLEN];
++ 
++   if(!stream || stream-&gt;rdonly 
++ 	|| !LOCAL || !LOCAL-&gt;candouid || !LOCAL-&gt;dir || !LOCAL-&gt;uidtempfile)
++     return;
++ 
++   sprintf(tmp,&quot;%s/%s.%d.%lu&quot;, LOCAL-&gt;dir, MDUIDTEMP, getpid(), time(0));
++   if(rename(LOCAL-&gt;uidtempfile, tmp) == 0){
++       fs_give((void **)&amp;LOCAL-&gt;uidtempfile);
++       LOCAL-&gt;uidtempfile = cpystr(tmp);
++   }
++ }
+diff -rc alpine-1.10/imap/src/osdep/unix/maildir.h alpine-1.10.maildir/imap/src/osdep/unix/maildir.h
+*** alpine-1.10/imap/src/osdep/unix/maildir.h	2008-05-16 16:19:12.000000000 -0700
+--- alpine-1.10.maildir/imap/src/osdep/unix/maildir.h	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 0 ****
+--- 1,225 ----
++ /* 
++  * A few definitions that try to make this module portable to other
++  * platforms (e.g. Cygwin). This module is based on the information from
++  * <A HREF="http://cr.yp.to/proto/maildir.html">http://cr.yp.to/proto/maildir.html</A>
++  */
++ 
++ /* First we deal with the separator character */
++ #ifndef FLAGSEP
++ #define FLAGSEP ':'
++ #endif
++ #define SIZESEP ','
++ 
++ const char sep1[] = {FLAGSEP, '1', ',', '\0'}; /* experimental semantics*/
++ const char sep2[] = {FLAGSEP, '2', ',', '\0'}; /* Flags Information	*/
++ const char sep3[] = {FLAGSEP, '3', ',', '\0'}; /* Grrrr....		*/
++ 
++ const char *sep[] = { sep1, sep2, sep3, NULL};
++ 
++ #define MDSEP(i)  sep[((i) - 1)]
++ 
++ /* Now we deal with flags. Woohoo! */
++ typedef enum  {Draft, Flagged, Passed, Replied, Seen, Trashed, 
++ 	       EmptyFlag, EndFlags} MdFlagNamesType;
++ const int mdimapflags[] = {Draft, Flagged, Replied, Seen, Trashed, EmptyFlag, EndFlags};
++ const int mdkwdflags[]  = {Passed, EmptyFlag, EndFlags};
++ 
++ /* this array lists the codes for mdflgnms (maildir flag names) above */
++ const char *mdflags[] = { &quot;D&quot;, &quot;F&quot;, &quot;P&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;&quot;, NULL};
++ /* and as characters too */
++ const char cmdflags[] = { 'D', 'F', 'P', 'R', 'S', 'T', '0', '\0'};
++ 
++ /* MDFLAG(Seen, elt-&gt;seen) */
++ #define MDFLAG(i,j) mdflags[j ? (i) : EmptyFlag]
++ /* MDFLAGC(Seen) */
++ #define MDFLAGC(i) cmdflags[(i)]
++ 
++ /* Now we deal with the directory structure */
++ typedef enum {Cur, Tmp, New, EndDir} DirNamesType;
++ char *mdstruct[] = {&quot;cur&quot;, &quot;tmp&quot;, &quot;new&quot;, NULL};
++ #define MDNAME(i) mdstruct[(i)]
++ #define MDFLD(tmp, dir, i) sprintf((tmp),&quot;%s/%s&quot;, (dir), mdstruct[(i)])
++ #define MSGPATH(tmp, dir, msg,i) sprintf((tmp),&quot;%s/%s/%s&quot;, (dir), mdstruct[(i)],(msg))
++ 
++ /* Files associated to a maildir directory */
++ 
++ #define MDUIDVALIDITY	&quot;.uidvalidity&quot;	/* support for old maildirs    */
++ #define MDDIR		&quot;.mdir&quot;		/* this folder is a directory  */
++ #define MDUIDLAST	&quot;.uidlast&quot;	/* last assigned uid	       */
++ #define MDUIDTEMP	&quot;.uidtemp&quot;	/* We assign uid's no one else */
++ 
++ 
++ 
++ /* Support of Courier Structure */
++ #define CCLIENT 0
++ #define COURIER 1
++ #define IS_CCLIENT(t) \
++ 		(((t) &amp;&amp; (t)[0] == '#' &amp;&amp; ((t)[1] == 'm' || (t)[1] == 'M')\
++ 		&amp;&amp; ((t)[2] == 'd' || (t)[2] == 'D')\
++ 		&amp;&amp; (t)[3] == '/'  &amp;&amp; (t)[4] != '\0') ? 1 : 0)
++ 
++ #define IS_COURIER(t) \
++ 		(((t) &amp;&amp; (t)[0] == '#' &amp;&amp; ((t)[1] == 'm' || (t)[1] == 'M')\
++ 		&amp;&amp; ((t)[2] == 'c' || (t)[2] == 'C')\
++ 		&amp;&amp; (t)[3] == '/'  &amp;&amp; (t)[4] != '\0') ? 1 : 0)
++ #define MDPREFIX(s) ((s) ? &quot;#mc/&quot; : &quot;#md/&quot;)
++ #define MDSEPARATOR(s) ((s) ? '.' : '/')
++ 
++ /* UID Support */
++ 
++ #define MAXTEMPUID (unsigned long) 180L
++ const char mduid[] = {',','u','=','\0'};
++ #define MDUIDSEP mduid
++ 
++ 
++ /* Now we deal with messages filenames */
++ char mdlocaldomain[MAILTMPLEN+1] = {'\0'};
++ static char *mdfpath = NULL;
++ static char *myMdInboxDir = NIL;/* Location of the Maildir INBOX */
++ static long CourierStyle = CCLIENT;
++ 
++ #define CHUNK	16384	/* from unix.h */
++ 
++ typedef struct courier_local {
++   char *name;		/* name of directory/folder */
++   int attribute;	/* attributes (children/marked/etc) */
++ } COURIERLOCAL;
++ 
++ typedef struct courier {
++   char *path;			/* Path to collection */
++   time_t scantime;		/* time at which information was generated */
++   int total;			/* total number of elements in data */
++   COURIERLOCAL **data;
++ } COURIER_S;
++ 
++ /* In gdb this is the  *(struct maildir_local *)stream-&gt;local structure */
++ typedef struct maildir_local {
++   unsigned int dirty : 1;	/* diskcopy needs updating 		*/
++   unsigned int courier : 1;	/* It is Courier style file system	*/
++   unsigned int link : 1;	/* There is a symbolic link		*/
++   unsigned int candouid;	/* we can assign uids and no one else	*/
++   char *uidtempfile;		/* path to uid temp file		*/
++   int fd;			/* fd of open message			*/
++   char *dir;			/* mail directory name			*/
++   char *curdir;			/* mail directory name/cur		*/
++   unsigned char *buf;		/* temporary buffer 			*/
++   unsigned long buflen;		/* current size of temporary buffer 	*/
++   time_t scantime;		/* last time directory scanned 		*/
++ } MAILDIRLOCAL;
++ 
++ /* Convenient access to local data */
++ #define LOCAL ((MAILDIRLOCAL *) stream-&gt;local)
++ 
++ typedef struct maildir_file_info {
++    char *name;		/* name of the file			   */
++    DirNamesType loc;	/* location of this file		   */
++    unsigned long pos;	/* place in list where this file is listed */
++    off_t size;		/* size in bytes, on disk */
++    time_t atime;	/* last access time */
++    time_t mtime;	/* last modified time */
++    time_t ctime;	/* last changed time */
++ } MAILDIRFILE;
++ 
++ #define MDFILE(F) (((MAILDIRFILE *)((F)-&gt;private.spare.ptr))-&gt;name)
++ #define MDLOC(F)  (((MAILDIRFILE *)((F)-&gt;private.spare.ptr))-&gt;loc)
++ #define MDPOS(F)  (((MAILDIRFILE *)((F)-&gt;private.spare.ptr))-&gt;pos)
++ #define MDSIZE(F)  (((MAILDIRFILE *)((F)-&gt;private.spare.ptr))-&gt;size)
++ #define MDATIME(F)  (((MAILDIRFILE *)((F)-&gt;private.spare.ptr))-&gt;atime)
++ #define MDMTIME(F)  (((MAILDIRFILE *)((F)-&gt;private.spare.ptr))-&gt;mtime)
++ #define MDCTIME(F)  (((MAILDIRFILE *)((F)-&gt;private.spare.ptr))-&gt;ctime)
++ 
++ /* Function prototypes */
++ 
++ DRIVER *maildir_valid (char *name);
++ MAILSTREAM *maildir_open (MAILSTREAM *stream);
++ void maildir_close (MAILSTREAM *stream, long options);
++ long maildir_ping (MAILSTREAM *stream);
++ void maildir_check (MAILSTREAM *stream);
++ long maildir_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
++ char *maildir_header (MAILSTREAM *stream,unsigned long msgno,
++ 		unsigned long *length, long flags);
++ void maildir_list (MAILSTREAM *stream,char *ref,char *pat);
++ void *maildir_parameters (long function,void *value);
++ int maildir_create_folder (char *mailbox);
++ long maildir_create (MAILSTREAM *stream,char *mailbox);
++ void maildir_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt); /*check */
++ long maildir_expunge (MAILSTREAM *stream, char *sequence, long options);
++ long maildir_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options);
++ long maildir_append (MAILSTREAM *stream,char *mailbox, append_t af, void *data);
++ long maildir_delete (MAILSTREAM *stream,char *mailbox);
++ long maildir_rename (MAILSTREAM *stream,char *old,char *new);
++ long maildir_sub (MAILSTREAM *stream,char *mailbox);
++ long maildir_unsub (MAILSTREAM *stream,char *mailbox);
++ void maildir_lsub (MAILSTREAM *stream,char *ref,char *pat);
++ void courier_list (MAILSTREAM *stream,char *ref, char *pat);
++ 
++ /* utility functions */
++ void courier_realname (char *name, char *realname);
++ long maildir_dirfmttest (char *name);
++ char *maildir_file (char *dst,char *name);
++ int maildir_select (const struct direct *name);
++ int maildir_namesort (const void *d1, const void *d2);
++ unsigned long antoul (char *seed);
++ unsigned long mdfntoul (char *name);
++ int courier_dir_select (const struct direct *name);
++ int courier_dir_sort (const void *d1, const void *d2);
++ long maildir_canonicalize (char *pattern,char *ref,char *pat);
++ void maildir_list_work (MAILSTREAM *stream,char *subdir,char *pat,long level);
++ void courier_list_work (MAILSTREAM *stream,char *subdir,char *pat,long level);
++ int maildir_file_path(char *name, char *tmp);
++ int maildir_valid_name (char *name);
++ int maildir_valid_dir (char *name);
++ int is_valid_maildir (char **name);
++ int maildir_message_exists(MAILSTREAM *stream,char *name, char *tmp);
++ char *maildir_remove_root(char *name);
++ char *maildir_text_work (MAILSTREAM *stream,MESSAGECACHE *elt, unsigned long *length,long flags);
++ unsigned long  maildir_parse_message(MAILSTREAM *stream, unsigned long msgno, 
++ 						DirNamesType dirtype);
++ int maildir_eliminate_duplicate (char *name, struct direct ***flist, 
++ 					unsigned long *nfiles);
++ int maildir_doscandir (char *name, struct direct ***flist, int flag);
++ unsigned long maildir_scandir (char *name, struct direct ***flist,
++ 			unsigned long *nfiles, int *scand, int flag);
++ void maildir_parse_folder (MAILSTREAM *stream, int full);
++ void  md_domain_name (void);
++ char  *myrootdir (char *name);
++ char  *mdirpath (void);
++ int   maildir_initial_check (MAILSTREAM *stream, DirNamesType dirtype);
++ unsigned long  maildir_parse_dir(MAILSTREAM *stream, unsigned long nmsgs, 
++    DirNamesType dirtype, struct direct **names, unsigned long nfiles, int full);
++ int same_maildir_file(char *name1, char *name2);
++ int comp_maildir_file(char *name1, char *name2);
++ int maildir_message_in_list(char *msgname, struct direct **names,
++ 		unsigned long bottom, unsigned long top, unsigned long *pos);
++ void maildir_getflag(char *name, int *d, int *f, int *r ,int *s, int *t);
++ int maildir_update_elt_maildirp(MAILSTREAM *stream, unsigned long msgno);
++ void maildir_abort (MAILSTREAM *stream);
++ int maildir_contains_folder(char *dirname, char *name);
++ int maildir_is_dir(char *dirname, char *name);
++ int maildir_dir_is_empty(char *mailbox);
++ int maildir_create_work (char *mailbox, int loop);
++ void maildir_get_file (MAILDIRFILE **mdfile);
++ void maildir_free_file (void **mdfile);
++ void maildir_free_file_only (void **mdfile);
++ int maildir_any_new_msgs(char *mailbox);
++ void maildir_get_date(MAILSTREAM *stream, unsigned long msgno);
++ void maildir_fast (MAILSTREAM *stream,char *sequence,long flags);
++ 
++ /* Courier server support */
++ void courier_free_cdir (COURIER_S **cdir);
++ COURIER_S *courier_get_cdir (int total);
++ int courier_search_list(COURIERLOCAL **data, char *name, int first, int last);
++ COURIER_S *courier_list_dir(char *curdir);
++ void courier_list_info(COURIER_S **cdirp, char *data, int i);
++ 
++ /* UID Support */
++ unsigned int maildir_can_assign_uid (MAILSTREAM *stream);
++ void maildir_read_uid(MAILSTREAM *stream, unsigned long *uid_last, 
++      			                   unsigned long *uid_validity);
++ void maildir_write_uid(MAILSTREAM *stream, unsigned long uid_last, 
++      			                   unsigned long uid_validity);
++ unsigned long maildir_get_uid(char *name);
++ void maildir_delete_uid(MAILSTREAM *stream, unsigned long msgno);
++ void maildir_assign_uid(MAILSTREAM *stream, unsigned long msgno, unsigned long uid);
++ void maildir_uid_renew_tempfile(MAILSTREAM *stream);
++ 
+diff -rc alpine-1.10/imap/src/osdep/unix/Makefile alpine-1.10.maildir/imap/src/osdep/unix/Makefile
+*** alpine-1.10/imap/src/osdep/unix/Makefile	2007-12-17 14:28:33.000000000 -0800
+--- alpine-1.10.maildir/imap/src/osdep/unix/Makefile	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 144,150 ****
+  # However, mh needs to be before any sysinbox formats (such as mmdf or unix)
+  # since otherwise INBOX won't work correctly when mh_allow_inbox is set.
+  #
+! DEFAULTDRIVERS=imap nntp pop3 mix mx mbx tenex mtx mh mmdf unix news phile
+  CHUNKSIZE=65536
+  
+  # Normally no need to change any of these
+--- 144,150 ----
+  # However, mh needs to be before any sysinbox formats (such as mmdf or unix)
+  # since otherwise INBOX won't work correctly when mh_allow_inbox is set.
+  #
+! DEFAULTDRIVERS=maildir courier imap nntp pop3 mix mx mbx tenex mtx mh mmdf unix news phile
+  CHUNKSIZE=65536
+  
+  # Normally no need to change any of these
+***************
+*** 153,159 ****
+  BINARIES=osdep.o mail.o misc.o newsrc.o smanager.o utf8.o utf8aux.o siglocal.o \
+   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
+   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
+!  unix.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o mix.o
+  CFLAGS=-g
+  
+  CAT=cat
+--- 153,159 ----
+  BINARIES=osdep.o mail.o misc.o newsrc.o smanager.o utf8.o utf8aux.o siglocal.o \
+   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
+   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
+!  unix.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o mix.o maildir.o
+  CFLAGS=-g
+  
+  CAT=cat
+***************
+*** 282,288 ****
+  
+  cyg:	# Cygwin - note that most local file drivers don't work!!
+  	$(BUILD) `$(CAT) SPECIALS` OS=$@ \
+! 	DEFAULTDRIVERS=&quot;imap nntp pop3 mbx unix phile&quot; \
+  	SIGTYPE=psx CHECKPW=cyg LOGINPW=cyg CRXTYPE=std \
+  	SPOOLDIR=/var \
+  	ACTIVEFILE=/usr/local/news/lib/active \
+--- 282,288 ----
+  
+  cyg:	# Cygwin - note that most local file drivers don't work!!
+  	$(BUILD) `$(CAT) SPECIALS` OS=$@ \
+! 	DEFAULTDRIVERS=&quot;imap nntp pop3 mbx unix maildir phile&quot; \
+  	SIGTYPE=psx CHECKPW=cyg LOGINPW=cyg CRXTYPE=std \
+  	SPOOLDIR=/var \
+  	ACTIVEFILE=/usr/local/news/lib/active \
+***************
+*** 892,898 ****
+  unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
+  utf8.o: mail.h misc.h osdep.h utf8.h tmap.c widths.c
+  utf8aux.o: mail.h misc.h osdep.h utf8.h
+! 
+  
+  # OS-dependent
+  
+--- 892,898 ----
+  unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
+  utf8.o: mail.h misc.h osdep.h utf8.h tmap.c widths.c
+  utf8aux.o: mail.h misc.h osdep.h utf8.h
+! maildir.o: mail.h misc.h osdep.h maildir.h dummy.h
+  
+  # OS-dependent
+  
+diff -rc alpine-1.10/imap/src/osdep/unix/os_cyg.h alpine-1.10.maildir/imap/src/osdep/unix/os_cyg.h
+*** alpine-1.10/imap/src/osdep/unix/os_cyg.h	2006-08-30 19:21:53.000000000 -0700
+--- alpine-1.10.maildir/imap/src/osdep/unix/os_cyg.h	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 47,52 ****
+--- 47,53 ----
+  #define setpgrp setpgid
+  
+  #define SYSTEMUID 18		/* Cygwin returns this for SYSTEM */
++ #define FLAGSEP ';'
+  #define geteuid Geteuid
+  uid_t Geteuid (void);
+  
+diff -rc alpine-1.10/pith/conf.c alpine-1.10.maildir/pith/conf.c
+*** alpine-1.10/pith/conf.c	2008-03-14 11:15:38.000000000 -0700
+--- alpine-1.10.maildir/pith/conf.c	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 406,411 ****
+--- 406,414 ----
+  
+  CONF_TXT_T cf_text_newsrc_path[] =		&quot;Full path and name of NEWSRC file&quot;;
+  
++ #ifndef _WINDOWS
++ CONF_TXT_T cf_text_maildir_location[] = &quot;Location relative to your HOME directory of the directory where your INBOX\n# for the maildir format is located. Default value is \&quot;Maildir\&quot;. If your\n# inbox is located at \&quot;~/Maildir\&quot; you do not need to change this value.\n# A common value is also \&quot;.maildir\&quot;&quot;;
++ #endif
+  
+  /*----------------------------------------------------------------------
+  These are the variables that control a number of pine functions.  They
+***************
+*** 606,611 ****
+--- 609,618 ----
+  	NULL,			cf_text_news_active},
+  {&quot;news-spool-directory&quot;,		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+  	NULL,			cf_text_news_spooldir},
++ #ifndef _WINDOWS
++ {&quot;maildir-location&quot;,			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
++ 	&quot;Maildir Location&quot;,			cf_text_maildir_location},
++ #endif
+  {&quot;upload-command&quot;,			0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+  	NULL,			cf_text_upload_cmd},
+  {&quot;upload-command-prefix&quot;,		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+***************
+*** 2163,2168 ****
+--- 2170,2181 ----
+        mail_parameters(NULL, SET_NEWSSPOOL,
+  		      (void *)VAR_NEWS_SPOOL_DIR);
+  
++ #ifndef _WINDOWS
++     set_current_val(&amp;vars[V_MAILDIR_LOCATION], TRUE, TRUE);
++     if(VAR_MAILDIR_LOCATION &amp;&amp; VAR_MAILDIR_LOCATION[0])
++       mail_parameters(NULL, SET_MDINBOXPATH, (void *)VAR_MAILDIR_LOCATION);
++ #endif
++ 
+      /* guarantee a save default */
+      set_current_val(&amp;vars[V_DEFAULT_SAVE_FOLDER], TRUE, TRUE);
+      if(!VAR_DEFAULT_SAVE_FOLDER || !VAR_DEFAULT_SAVE_FOLDER[0])
+***************
+*** 2777,2782 ****
+--- 2790,2799 ----
+  	 F_SORT_DEFAULT_SAVE_ALPHA, h_config_sort_save_alpha, PREF_FLDR, 0},
+  	{&quot;vertical-folder-list&quot;, &quot;Use Vertical Folder List&quot;,
+  	 F_VERTICAL_FOLDER_LIST, h_config_vertical_list, PREF_FLDR, 0},
++ #ifndef _WINDOWS
++ 	{&quot;use-courier-folder-list&quot;, &quot;Courier Style Folder List&quot;,
++ 	 F_COURIER_FOLDER_LIST, h_config_courier_list, PREF_FLDR, 0},
++ #endif
+  
+  /* Addr book */
+  	{&quot;combined-addrbook-display&quot;, &quot;Combined Address Book Display&quot;,
+***************
+*** 6820,6825 ****
+--- 6837,6848 ----
+  
+  	break;
+  
++ #ifndef _WINDOWS
++       case F_COURIER_FOLDER_LIST:
++       mail_parameters(NULL,SET_COURIERSTYLE,(void *)(F_ON(f-&gt;id ,ps)? 1 : 0));
++       break; /* COURIER == 1, CCLIENT == 0, see maildir.h */
++ #endif
++ 
+        case F_COLOR_LINE_IMPORTANT :
+        case F_DATES_TO_LOCAL :
+  	clear_index_cache(ps-&gt;mail_stream, 0);
+***************
+*** 7589,7594 ****
+--- 7612,7621 ----
+  	return(h_config_newmailwidth);
+        case V_NEWSRC_PATH :
+  	return(h_config_newsrc_path);
++ #ifndef _WINDOWS
++       case V_MAILDIR_LOCATION :
++ 	return(h_config_maildir_location);
++ #endif
+        case V_BROWSER :
+  	return(h_config_browser);
+  #if defined(DOS) || defined(OS2)
+diff -rc alpine-1.10/pith/conf.h alpine-1.10.maildir/pith/conf.h
+*** alpine-1.10/pith/conf.h	2008-03-14 11:15:38.000000000 -0700
+--- alpine-1.10.maildir/pith/conf.h	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 249,254 ****
+--- 249,258 ----
+  #define GLO_NEWS_ACTIVE_PATH	     vars[V_NEWS_ACTIVE_PATH].global_val.p
+  #define VAR_NEWS_SPOOL_DIR	     vars[V_NEWS_SPOOL_DIR].current_val.p
+  #define GLO_NEWS_SPOOL_DIR	     vars[V_NEWS_SPOOL_DIR].global_val.p
++ #ifndef _WINDOWS
++ #define VAR_MAILDIR_LOCATION	     vars[V_MAILDIR_LOCATION].current_val.p
++ #define GLO_MAILDIR_LOCATION	     vars[V_MAILDIR_LOCATION].global_val.p
++ #endif
+  #define VAR_DISABLE_DRIVERS	     vars[V_DISABLE_DRIVERS].current_val.l
+  #define VAR_DISABLE_AUTHS	     vars[V_DISABLE_AUTHS].current_val.l
+  #define VAR_REMOTE_ABOOK_METADATA    vars[V_REMOTE_ABOOK_METADATA].current_val.p
+diff -rc alpine-1.10/pith/conftype.h alpine-1.10.maildir/pith/conftype.h
+*** alpine-1.10/pith/conftype.h	2008-03-14 11:15:38.000000000 -0700
+--- alpine-1.10.maildir/pith/conftype.h	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 114,119 ****
+--- 114,122 ----
+  		, V_NEWSRC_PATH
+  		, V_NEWS_ACTIVE_PATH
+  		, V_NEWS_SPOOL_DIR
++ #ifndef _WINDOWS
++ 		, V_MAILDIR_LOCATION
++ #endif
+  		, V_UPLOAD_CMD
+  		, V_UPLOAD_CMD_PREFIX
+  		, V_DOWNLOAD_CMD
+***************
+*** 370,375 ****
+--- 373,381 ----
+  	F_PASS_C1_CONTROL_CHARS,
+  	F_SINGLE_FOLDER_LIST,
+  	F_VERTICAL_FOLDER_LIST,
++ #ifndef _WINDOWS
++ 	F_COURIER_FOLDER_LIST,
++ #endif
+  	F_TAB_CHK_RECENT,
+  	F_AUTO_REPLY_TO,
+  	F_VERBOSE_POST,
+diff -rc alpine-1.10/pith/init.c alpine-1.10.maildir/pith/init.c
+*** alpine-1.10/pith/init.c	2007-08-16 15:25:10.000000000 -0700
+--- alpine-1.10.maildir/pith/init.c	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 407,412 ****
+--- 407,415 ----
+             &amp;&amp; stricmp(filename, folder_base)){
+  #else
+          if(strncmp(filename, folder_base, folder_base_len) == 0
++ #ifndef _WINDOWS
++ 	   &amp;&amp; filename[folder_base_len] != list_cntxt-&gt;dir-&gt;delim
++ #endif
+             &amp;&amp; strcmp(filename, folder_base)){
+  #endif
+  #endif
+diff -rc alpine-1.10/pith/pattern.c alpine-1.10.maildir/pith/pattern.c
+*** alpine-1.10/pith/pattern.c	2008-01-14 12:12:44.000000000 -0800
+--- alpine-1.10.maildir/pith/pattern.c	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 5482,5487 ****
+--- 5482,5495 ----
+  		break;
+  	      
+  	      case '#':
++ #ifndef _WINDOWS
++ 		if(!struncmp(patfolder, &quot;#md/&quot;, 4)
++ 		       || !struncmp(patfolder, &quot;#mc/&quot;, 4)){
++ 		  maildir_file_path(patfolder, tmp1);
++ 		    strncpy(patfolder, tmp1, sizeof(patfolder));
++ 		  patfolder[sizeof(patfolder)-1] = '\0';
++ 		}
++ #endif
+  	        if(!strcmp(patfolder, stream-&gt;mailbox))
+  		  match++;
+  
+***************
+*** 7894,7900 ****
+      int           we_cancel = 0, width;
+      CONTEXT_S	 *save_context = NULL;
+      char	  buf[MAX_SCREEN_COLS+1], sbuf[MAX_SCREEN_COLS+1];
+!     char         *save_ref = NULL;
+  #define	FILTMSG_MAX	30
+  
+      if(!stream)
+--- 7902,7908 ----
+      int           we_cancel = 0, width;
+      CONTEXT_S	 *save_context = NULL;
+      char	  buf[MAX_SCREEN_COLS+1], sbuf[MAX_SCREEN_COLS+1];
+!     char         *save_ref = NULL, *save_dstfldr = NULL, *save_dstfldr2 = NULL;
+  #define	FILTMSG_MAX	30
+  
+      if(!stream)
+***************
+*** 7928,7933 ****
+--- 7936,7951 ----
+      if(F_OFF(F_QUELL_FILTER_MSGS, ps_global))
+        we_cancel = busy_cue(buf, NULL, 0);
+  
++ #ifndef _WINDOWS
++     if(!struncmp(dstfldr, &quot;#md/&quot;, 4) || !struncmp(dstfldr, &quot;#mc/&quot;, 4)){  
++ 	char tmp1[MAILTMPLEN];
++ 	maildir_file_path(dstfldr, tmp1);
++ 	save_dstfldr2 = dstfldr;
++ 	save_dstfldr = cpystr(tmp1);
++ 	dstfldr = save_dstfldr;
++    }
++ #endif
++ 
+      if(!is_absolute_path(dstfldr)
+         &amp;&amp; !(save_context = default_save_context(ps_global-&gt;context_list)))
+        save_context = ps_global-&gt;context_list;
+***************
+*** 7991,7996 ****
+--- 8009,8019 ----
+      if(we_cancel)
+        cancel_busy_cue(buf[0] ? 0 : -1);
+  
++     if(save_dstfldr){
++ 	fs_give((void **)&amp;save_dstfldr);
++ 	dstfldr = save_dstfldr2;
++     }
++ 
+      return(buf[0] != '\0');
+  }
+  
+diff -rc alpine-1.10/pith/pine.hlp alpine-1.10.maildir/pith/pine.hlp
+*** alpine-1.10/pith/pine.hlp	2008-03-14 11:34:08.000000000 -0700
+--- alpine-1.10.maildir/pith/pine.hlp	2008-05-15 11:05:34.000000000 -0700
+***************
+*** 21155,21160 ****
+--- 21155,21256 ----
+  &amp;lt;End of help on this topic&amp;gt;
+  &lt;/BODY&gt;
+  &lt;/HTML&gt;
++ ====== h_config_maildir_location ======
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_maildir-location&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_maildir-location&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt;
++ This option should be used only if you have a Maildir folder which you
++ want to use as your INBOX. If this is not your case (or don't know what
++ this is), you can safely ignore this option.
++ 
++ &lt;P&gt;
++ This option overrides the default directory Pine uses to find the location of
++ your INBOX, in case this is in Maildir format. The default value of this
++ option is &quot;Maildir&quot;, but in some systems, this directory could have been
++ renamed (e.g. to &quot;.maildir&quot;). If this is your case use this option to change
++ the default.
++ 
++ &lt;P&gt;
++ The value of this option is prefixed with the &quot;~/&quot; string to determine the
++ full path to your INBOX.
++ 
++ &lt;P&gt;
++ You should probably &lt;A HREF=&quot;h_config_maildir&quot;&gt;read&lt;/A&gt; a few tips that 
++ teach you how to configure your maildir for optimal performance. This
++ version also has &lt;A HREF=&quot;h_config_courier_list&quot;&gt;support&lt;/A&gt; for the 
++ Courier style file system when a maildir collection is accessed locally.
++ 
++ &lt;P&gt;&lt;UL&gt;
++ &lt;LI&gt;&lt;A HREF=&quot;h_finding_help&quot;&gt;Finding more information and requesting help&lt;/A&gt;
++ &lt;/UL&gt;
++ &lt;P&gt;
++ &amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_maildir =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;Maildir Support&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;Maildir Support&lt;/H1&gt;
++ 
++ This version of Alpine has been enhanced with Maildir support. This text is 
++ intended to be a reference on its support.
++ &lt;P&gt;
++ 
++ A Maildir folder is a directory that contains three directories called 
++ cur, tmp and new. A program that delivers mail (e.g. postfix) will put new 
++ mail in the new directory. A program that reads mail will look for for old 
++ messages in the cur directory, while it will look for new mail in the new 
++ directory.
++ &lt;P&gt;
++ 
++ In order to use maildir support it is better to set your inbox-path to the 
++ value &amp;quot;#md/inbox&amp;quot; (without quotes). This assumes that your mail 
++ delivery agent is delivering new mail to ~/Maildir/new. If the directory 
++ where new mail is being delivered is not called &quot;Maildir&quot;, you can set the 
++ name of the subdirectory of home where it is being delivered in the &lt;A 
++ HREF=&quot;h_config_maildir_location&quot;&gt;&lt;!--#echo var=&quot;VAR_maildir-location&quot;--&gt;&lt;/A&gt; configuration 
++ variable. Most of the time you will not have to worry about the 
++ &lt;!--#echo var=&quot;VAR_maildirlocation&quot;--&gt; variable, because it will probably be set by your 
++ administrator in the pine.conf configuration file.
++ &lt;P&gt;
++ 
++ One of the advantages of the Maildir support of this version of Alpine is 
++ that you do not have to stop using folders in another styles (mbox, mbx, 
++ etc.). This is desirable since the usage of a specific mail storage system 
++ is a personal decision. Folders in the maildir format that are part of the 
++ Mail collection will be recognized without any extra configuration of your 
++ part. If your mail/ collection is located under the mail/ directory, then 
++ creating a new maildir folder in this collection is done by pressing &quot;A&quot; 
++ and entering the string &quot;#driver.md/mail/newfolder&quot;. Observe that adding a 
++ new folder as &quot;newfolder&quot; may not create such folder in maildir format.
++ 
++ &lt;P&gt;
++ If you would like to have all folders created in the maildir format by 
++ default, you do so by adding a Maildir Collection. In order to convert 
++ your current mail/ collection into a maildir collection, edit the 
++ collection and change the path variable from &amp;quot;mail/&amp;quot; to 
++ &amp;quot;#md/mail&amp;quot;. In a maildir collection folders of any other format 
++ are ignored.
++ 
++ &lt;P&gt; Finally, This version also has 
++ &lt;A HREF=&quot;h_config_courier_list&quot;&gt;support&lt;/A&gt; for the Courier style file system 
++ when a maildir collection is accessed locally.
++ 
++ &lt;P&gt;
++ &lt;UL&gt;   
++ &lt;LI&gt;&lt;A HREF=&quot;h_finding_help&quot;&gt;Finding more information and requesting help&lt;/A&gt;
++ &lt;/UL&gt;&lt;P&gt;
++ &amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
+  ====== h_config_literal_sig =====
+  &lt;HTML&gt;
+  &lt;HEAD&gt;
+***************
+*** 29005,29010 ****
+--- 29101,29149 ----
+  &amp;lt;End of help on this topic&amp;gt;
+  &lt;/BODY&gt;
+  &lt;/HTML&gt;
++ ====== h_config_courier_list =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_courier-folder-list&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_courier-folder-list&quot;--&gt;&lt;/H1&gt;
++ 
++ In a maildir collection, a folder could be used as a directory to store 
++ folders. In the Courier server if you create a folder, then a directory 
++ with the same name is created. If you use this patch to access a 
++ collection created by the Courier server, then the display of such 
++ collection will look confusing. The best way to access a maildir 
++ collection created by the Courier server is by using the &amp;quot;#mc/&amp;quot; 
++ prefix instead of the &amp;quot;#md/&amp;quot; prefix. If you use this alternate 
++ prefix, then this feature applies to you, otherwise you can safely ignore 
++ the text that follows.
++ &lt;P&gt;
++ Depending on if you have enabled the option 
++ &lt;a href=&quot;h_config_separate_fold_dir_view&quot;&gt;&lt;!--#echo var=&quot;FEAT_separate-folder-and-directory-entries&quot;--&gt;&lt;/a&gt; 
++ a folder may be listed as &amp;quot;folder[.]&amp;quot;, or as two entries in the 
++ list by &amp;quot;folder&amp;quot; and &amp;quot;folder.&amp;quot;.
++ &lt;P&gt;
++ If this option is disabled, Pine will list local folders that are in Courier
++ style format, as &amp;quot;folder&amp;quot;, and those that are also directories as
++ &amp;quot;folder[.]&amp;quot;. This makes the default display cleaner.
++ &lt;P&gt;
++ If this feature is enabled then creating folders in a maildir collection
++ will create a directory with the same name. If this feature is disabled, then 
++ a folder is considered a directory only if it contains subfolders, so you can
++ not create a directory with the same name as an exisiting folder unless 
++ you create a subfolder of that folder first (e.g. if you have a folder
++ called &amp;quot;foo&amp;quot; simply add &amp;quot;foo.bar&amp;quot; directly. This will
++ create the directory &amp;quot;foo&amp;quot; and the subfolder &amp;quot;bar&amp;quot; of it).
++ &lt;P&gt;
++ Observe that this feature works only for maildir collections that are accessed
++ locally. If a collection is accessed remotely then this feature has no value,
++ as the report is created in a server, and Pine only reports what received
++ from the server in this case.
++ &lt;P&gt;
++ &amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
+  ====== h_config_verbose_post =====
+  &lt;HTML&gt;
+  &lt;HEAD&gt;
+diff -rc alpine-1.10/pith/send.c alpine-1.10.maildir/pith/send.c
+*** alpine-1.10/pith/send.c	2008-02-14 18:11:48.000000000 -0800
+--- alpine-1.10.maildir/pith/send.c	2008-05-15 11:05:35.000000000 -0700
+***************
+*** 257,262 ****
+--- 257,269 ----
+  
+      if(exists &amp; FEX_ISFILE){
+  	context_apply(tmp, p_cntxt, mbox, sizeof(tmp));
++ #ifndef _WINDOWS
++         if (!struncmp(tmp, &quot;#md/&quot;,4) || !struncmp(tmp, &quot;#mc/&quot;, 4)){
++ 	    char tmp2[MAILTMPLEN];
++ 	    maildir_file_path(tmp, tmp2);
++ 	    strcpy(tmp, tmp2);
++ 	}
++ #endif
+  	if(!(IS_REMOTE(tmp) || is_absolute_path(tmp))){
+  	    /*
+  	     * The mbox is relative to the home directory.
+diff -rc alpine-1.10/README.maildir alpine-1.10.maildir/README.maildir
+*** alpine-1.10/README.maildir	2008-05-16 16:19:12.000000000 -0700
+--- alpine-1.10.maildir/README.maildir	2008-05-15 11:05:35.000000000 -0700
+***************
+*** 0 ****
+--- 1,153 ----
++ ---------------------------------------
++ 
++ Maildir Driver for Alpine 1.0
++ By Eduardo Chappa &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">chappa at washington.edu</A>&gt;
++ <A HREF="http://staff.washington.edu/chappa/alpine/">http://staff.washington.edu/chappa/alpine/</A>
++ 
++ ---------------------------------------
++ 1. General Information About This Patch
++ ---------------------------------------
++ 
++ This patch adds support for the maildir format to Alpine. We take the 
++ approach that this patch is one more driver among the number of formats 
++ supported by Alpine (more generally c-client). This approach differs from 
++ older versions of similar patches, in that once a maildir patch was 
++ applied, it was assumed that all your folders would be created in the 
++ maildir format. 
++ 
++ This patch does not assume that maildir is a preferred format, instead 
++ puts maildir in equal footing with other formats (mbox, mbx, mix, etc), 
++ and so a maildir folder in the mail/ collection is treated in the same way 
++ as any other folder in any other format. In other words, just by reading 
++ the name of a folder, or opening it, or doing any operation with it, you 
++ can not know in which format the folder is.
++ 
++ This implies that if you want to add a folder in the maildir format to the 
++ mail/ collection, then you must add by pressing &quot;A&quot; in the folder list 
++ collection and enter &quot;#driver.md/mail/name_maildir_folder&quot;.
++ 
++ If you only want to use maildir, however, you can do so too. In this case, 
++ you must create a maildir collection. In that collection, only maildir 
++ folders will be listed. If there is any folder in any other format, that 
++ folder will be ignored. In another words, any folder listed there is in 
++ maildir format and can be accessed through that collection, conversely, 
++ any folder not listed there is not in maildir format and there is no way 
++ to access it using this collection.
++ 
++ In order to create a maildir collection, you could press M S L, and &quot;A&quot; to 
++ add a collection. Fill in the required fields as follows:
++ 
++ Nickname  : Anything
++ Server    :
++ Path      : #md/relative/path/to/maildir/collection/
++ View      :
++ 
++ For example, if &quot;path&quot; is set to &quot;#md/mail/&quot;, then Alpine will look for your 
++ maildir folders that are in ~/mail/.
++ 
++ The code in this patch is mostly based in code for the unix driver plus 
++ some combinations of the mh, mbx and nntp drivers for the c-client 
++ library. Those drivers were designed by Mark Crispin, and bugs in this 
++ code are not his bugs, but my own.
++ 
++   I got all the specification for this patch from 
++ <A HREF="http://cr.yp.to/proto/maildir.html.">http://cr.yp.to/proto/maildir.html.</A> If you know of a place with a better 
++ specification for maildir format please let me know. The method this patch 
++ uses to create a unique filename for a message is one of the &quot;old 
++ fashioned&quot; methods. I realize that this is old fashioned, but it is 
++ portable, and portability is the main reason why I decided to use an old 
++ fashioned method (most methods are not portable. See the word 
++ &quot;Unfortunately&quot; in that document).
++ 
++ --------------
++ 2. Other Goals
++ --------------
++ 
++   It is intended that this code will work well with any application 
++ written using the c-client library. Of paramount importance is to make the 
++ associated imap server work well when the server accesses a folder in 
++ Maildir format. The program mailutil should also work flawlessly with this 
++ implemetation of the driver.
++ 
++   It is intended that this driver be fast and stable. We intend not to 
++ patch Alpine to make this driver do its work, unless such patching is for 
++ fixing bugs in Alpine or to pass parameters to the driver.
++ 
++ ------------------------------------------------------------------------ 
++ 3. What are the known bugs of this implementation of the Maildir driver? 
++ ------------------------------------------------------------------------
++ 
++   I don't know any at this time. There have been bugs before, though, but 
++ I try to fix bugs as soon as they are reported. A complete list of updates 
++ for this patch, which includes bug fixes, improvements and addition of new 
++ features can be found at
++ 
++  <A HREF="http://staff.washington.edu/chappa/alpine/updates/maildir.html">http://staff.washington.edu/chappa/alpine/updates/maildir.html</A>
++ 
++ ----------
++ 4. On UIDs
++ ----------
++ 
++  This patch keeps uids in the name of the file that contains the message, 
++ by adding a &quot;,u=&quot; string to the file name to save the uid of a message. A 
++ file is kept between sessions to save information on the last uid assigned 
++ and its time of validity. Only one session with writing access can write 
++ uids, all others must wait for the other session to assign them. The 
++ session assigning uids creates a &quot;.uidtemp&quot; file which other sessions must 
++ not disturb.
++ 
++   Uid support appeared in Alpine 1.00 (snapshot 925), and is experimental,
++ please report any problems.
++ 
++ --------------------------------------------
++ 5. Configuring Alpine and Setting up a Maildir 
++ --------------------------------------------
++ 
++ Once this approach was chosen, it implied the following:
++ 
++     * This patch assumes that your INBOX is located at &quot;$HOME/Maildir&quot;.  
++       This is a directory which should have three subdirectories &quot;cur&quot;, 
++       &quot;tmp&quot; and &quot;new&quot;. Mail is delivered to 'new' and read from 'cur'. I 
++       have added a configuration option &quot;maildir-location&quot; which can be 
++       used to tell Alpine where your Maildir inbox is, in case your system 
++       do not use the above directory (e.g. your system may use 
++       &quot;~/.maildir&quot;). In this case define that variable to be the name of 
++       the directory where your e-mail is being delivered (e.g.  
++       &quot;.maildir&quot;).
++ 
++     * If you want to use the above configuration as your inbox, you must 
++       define your inbox-path as &quot;#md/inbox&quot; (no quotes).  You can define 
++       the inbox-path like above even if you have changed the 
++       maildir-location variable. That's the whole point of that variable.
++ 
++ -----------------------------------
++ 6. What about Courier file systems?
++ -----------------------------------
++ 
++ In a courier file system all folders are subfolders of a root folder 
++ called INBOX. Normally INBOX is located at ~/Maildir and subfolders are 
++ &quot;dot&quot; directories in ~/Maildir. For example ~/Maildir/.Trash is a 
++ subfolder of INBOX and is accessed with the nickname &quot;INBOX.Trash&quot;.
++ 
++ You can not access folders in this way unless you preceed them with the 
++ string &quot;#mc/&quot;. The purpose of the string &quot;#mc/&quot; is to warn Alpine that a 
++ collection in the Courier format is going to be accessed, so you can 
++ SELECT a folder like &quot;#mc/INBOX.Trash&quot;, but not &quot;INBOX.Trash&quot;
++ 
++ You can access a collection through a server, but if you want to access a 
++ collection of folders created using the Courier server, you MUST edit your
++ &quot;.pinerc&quot; file and enter the definition of the collection as follows:
++ 
++ folder-collections=&quot;Anything you want&quot; #mc/INBOX.[]
++ 
++ You can replace the string &quot;#mc/INBOX.&quot; by something different, for example
++ &quot;#mc/Courier/.&quot; will make Alpine search for your collection in ~/Courier.
++ 
++ You can not add this directly into Alpine because Alpine fails to accept this 
++ value from its input, but it takes it correctly when it is added through 
++ the &quot;.pinerc&quot; file.
++ 
++ You can access your inbox as &quot;#mc/INBOX&quot; or &quot;#md/INBOX&quot;. Both definitions 
++ point to the same place.
++ 
++ Last Updated February 9, 2008

Added: trunk/rpms/alpine/alpine-1.10-rules.patch
===================================================================
--- trunk/rpms/alpine/alpine-1.10-rules.patch	                        (rev 0)
+++ trunk/rpms/alpine/alpine-1.10-rules.patch	2008-07-31 00:54:17 UTC (rev 6434)
@@ -0,0 +1,5878 @@
+diff -rc alpine-1.10/alpine/adrbkcmd.c alpine-1.10.rules/alpine/adrbkcmd.c
+*** alpine-1.10/alpine/adrbkcmd.c	2007-10-10 10:10:59.000000000 -0700
+--- alpine-1.10.rules/alpine/adrbkcmd.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 4123,4128 ****
+--- 4123,4130 ----
+  	 * won't do anything, but will cause compose_mail to think there's
+  	 * already a role so that it won't try to confirm the default.
+  	 */
++ 	if (ps_global-&gt;role)
++ 	   fs_give((void **)&amp;ps_global-&gt;role);
+  	if(role)
+  	  role = copy_action(role);
+  	else{
+***************
+*** 4130,4135 ****
+--- 4132,4138 ----
+  	    memset((void *)role, 0, sizeof(*role));
+  	    role-&gt;nick = cpystr(&quot;Default Role&quot;);
+  	}
++ 	ps_global-&gt;role = cpystr(role-&gt;nick);
+      }
+  
+      compose_mail(addr, fcc, role, NULL, NULL);
+diff -rc alpine-1.10/alpine/alpine.c alpine-1.10.rules/alpine/alpine.c
+*** alpine-1.10/alpine/alpine.c	2008-02-29 10:18:49.000000000 -0800
+--- alpine-1.10.rules/alpine/alpine.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 448,453 ****
+--- 448,454 ----
+      /* Set up optional for user-defined display filtering */
+      pine_state-&gt;tools.display_filter	     = dfilter;
+      pine_state-&gt;tools.display_filter_trigger = dfilter_trigger;
++     pine_state-&gt;tools.exec_rule		     = exec_function_rule;
+  
+  #ifdef _WINDOWS
+      if(ps_global-&gt;install_flag){
+***************
+*** 3094,3099 ****
+--- 3095,3103 ----
+      extern KBESC_T *kbesc;
+  
+      dprint((2, &quot;goodnight_gracey:\n&quot;));    
++     strncpy(pine_state-&gt;cur_folder, pine_state-&gt;inbox_name, 
++ 					sizeof(pine_state-&gt;cur_folder));
++     pine_state-&gt;cur_folder[sizeof(pine_state-&gt;cur_folder) - 1] = '\0';
+  
+      /* We want to do this here before we close up the streams */
+      trim_remote_adrbks();
+diff -rc alpine-1.10/alpine/confscroll.c alpine-1.10.rules/alpine/confscroll.c
+*** alpine-1.10/alpine/confscroll.c	2008-01-04 14:49:15.000000000 -0800
+--- alpine-1.10.rules/alpine/confscroll.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 49,54 ****
+--- 49,55 ----
+  #include &quot;../pith/tempfile.h&quot;
+  #include &quot;../pith/pattern.h&quot;
+  #include &quot;../pith/charconv/utf8.h&quot;
++ #include &quot;../pith/rules.h&quot;
+  
+  
+  #define	CONFIG_SCREEN_HELP_TITLE	_(&quot;HELP FOR SETUP CONFIGURATION&quot;)
+***************
+*** 2415,2420 ****
+--- 2416,2424 ----
+  	 * Now go and set the current_val based on user_val changes
+  	 * above.  Turn off command line settings...
+  	 */
++ 	set_current_val((*cl)-&gt;var,
++ 	    (strcmp((*cl)-&gt;var-&gt;name,&quot;key-definition-rules&quot;) ? TRUE : FALSE),
++ 	    FALSE);
+  	set_current_val((*cl)-&gt;var, TRUE, FALSE);
+  	fix_side_effects(ps, (*cl)-&gt;var, 0);
+  
+***************
+*** 5143,5148 ****
+--- 5147,5176 ----
+  	    var == &amp;ps-&gt;vars[V_ABOOK_FORMATS]){
+  	addrbook_reset();
+      }
++     else if(var == &amp;ps-&gt;vars[V_INDEX_RULES]){
++ 	   if(ps_global-&gt;rule_list)
++ 	      free_parsed_rule_list(&amp;ps_global-&gt;rule_list);
++ 	   create_rule_list(ps-&gt;vars);
++ 	   reset_index_format();
++ 	   clear_index_cache(ps-&gt;mail_stream, 0);
++     }
++     else if(var == &amp;ps-&gt;vars[V_COMPOSE_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_FORWARD_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_KEY_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_REPLACE_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_REPLY_INDENT_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_REPLY_LEADIN_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_RESUB_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_SAVE_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_SMTP_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_SORT_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_STARTUP_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_THREAD_DISP_STYLE_RULES] ||
++ 	    var == &amp;ps-&gt;vars[V_THREAD_INDEX_STYLE_RULES]){
++ 	if(ps_global-&gt;rule_list)
++ 	   free_parsed_rule_list(&amp;ps_global-&gt;rule_list);
++ 	create_rule_list(ps-&gt;vars);
++     }
+      else if(var == &amp;ps-&gt;vars[V_INDEX_FORMAT]){
+  	reset_index_format();
+  	clear_index_cache(ps-&gt;mail_stream, 0);
+diff -rc alpine-1.10/alpine/dispfilt.c alpine-1.10.rules/alpine/dispfilt.c
+*** alpine-1.10/alpine/dispfilt.c	2007-10-11 11:03:32.000000000 -0700
+--- alpine-1.10.rules/alpine/dispfilt.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 451,453 ****
+--- 451,513 ----
+  
+      return(passed);
+  }
++ 
++ char *
++ exec_function_rule(char *rawcmd, gf_io_t input_gc, gf_io_t output_pc)
++ {
++     char *status = NULL, *cmd,  *tmpfile = NULL;
++ 
++     if((cmd = expand_filter_tokens(rawcmd,NULL,&amp;tmpfile,NULL,NULL,NULL,NULL)) != NULL){
++ 	suspend_busy_cue();
++ 	ps_global-&gt;mangled_screen = 1;
++ 	if(tmpfile){
++ 	    PIPE_S	  *filter_pipe;
++ 	    FILE          *fp;
++ 	    gf_io_t	   gc, pc;
++ 	    STORE_S       *tmpf_so;
++ 
++ 	    /* write the tmp file */
++ 	    if((tmpf_so = so_get(FileStar, tmpfile, WRITE_ACCESS|OWNER_ONLY|WRITE_TO_LOCALE)) != NULL){
++ 	        /* copy input to tmp file */
++ 		gf_set_so_writec(&amp;pc, tmpf_so);
++ 		gf_filter_init();
++ 		status = gf_pipe(input_gc, pc);
++ 		gf_clear_so_writec(tmpf_so);
++ 		if(so_give(&amp;tmpf_so) != 0 &amp;&amp; status == NULL)
++ 		  status = error_description(errno);
++ 
++ 		/* prepare the terminal in case the filter uses it */
++ 		if(status == NULL){
++ 		    if((filter_pipe = open_system_pipe(cmd, NULL, NULL,
++ 						      PIPE_USER|PIPE_PROT|PIPE_NOSHELL|PIPE_SILENT,
++ 						      0, pipe_callback, NULL)) != NULL){
++ 			if(close_system_pipe(&amp;filter_pipe, NULL, pipe_callback) == 0){
++ 			    /* pull result out of tmp file */
++ 			    if((fp = our_fopen(tmpfile, &quot;rb&quot;)) != NULL){
++ 				gf_set_readc(&amp;gc, fp, 0L, FileStar, READ_FROM_LOCALE);
++ 				gf_filter_init();
++ 				status = gf_pipe(gc, output_pc);
++ 				fclose(fp);
++ 			    }
++ 			    else
++ 			      status = &quot;Can't read result of EXEC command&quot;;
++ 			}
++ 			else
++ 			  status = &quot;EXEC command command returned error.&quot;;
++ 		    }
++ 		    else
++ 		      status = &quot;Can't open pipe for EXEC command&quot;;
++ 		}
++ 
++ 		our_unlink(tmpfile);
++ 	    }
++ 	    else
++ 	      status = &quot;Can't open EXEC command tmp file&quot;;
++ 	}
++ 
++ 	resume_busy_cue(0);
++ 	fs_give((void **)&amp;cmd);
++     }
++ 
++     return(status);
++ }
+diff -rc alpine-1.10/alpine/dispfilt.h alpine-1.10.rules/alpine/dispfilt.h
+*** alpine-1.10/alpine/dispfilt.h	2006-09-26 12:30:49.000000000 -0700
+--- alpine-1.10.rules/alpine/dispfilt.h	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 24,30 ****
+  char	*expand_filter_tokens(char *, ENVELOPE *, char **, char **, char **, int *, int *);
+  char	*filter_session_key(void);
+  char	*filter_data_file(int);
+! 
+  
+  
+  #endif /* PINE_DISPFILT_INCLUDED */
+--- 24,30 ----
+  char	*expand_filter_tokens(char *, ENVELOPE *, char **, char **, char **, int *, int *);
+  char	*filter_session_key(void);
+  char	*filter_data_file(int);
+! char	*exec_function_rule(char *, gf_io_t, gf_io_t);
+  
+  
+  #endif /* PINE_DISPFILT_INCLUDED */
+diff -rc alpine-1.10/alpine/folder.c alpine-1.10.rules/alpine/folder.c
+*** alpine-1.10/alpine/folder.c	2008-03-06 14:35:32.000000000 -0800
+--- alpine-1.10.rules/alpine/folder.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 237,243 ****
+      dprint((1, &quot;=== folder_screen called ====\n&quot;));
+      mailcap_free(); /* free resources we won't be using for a while */
+      ps-&gt;next_screen = SCREEN_FUN_NULL;
+! 
+      /* Initialize folder state and dispatches */
+      memset(&amp;fs, 0, sizeof(FSTATE_S));
+      fs.context		= cntxt;
+--- 237,243 ----
+      dprint((1, &quot;=== folder_screen called ====\n&quot;));
+      mailcap_free(); /* free resources we won't be using for a while */
+      ps-&gt;next_screen = SCREEN_FUN_NULL;
+!     strcpy(ps-&gt;screen_name, &quot;folder&quot;);
+      /* Initialize folder state and dispatches */
+      memset(&amp;fs, 0, sizeof(FSTATE_S));
+      fs.context		= cntxt;
+***************
+*** 334,339 ****
+--- 334,340 ----
+        pine_mail_close(*fs.cache_streamp);
+  
+      ps-&gt;prev_screen = folder_screen;
++     strcpy(ps-&gt;screen_name, &quot;unknown&quot;);
+  }
+  
+  
+diff -rc alpine-1.10/alpine/mailcmd.c alpine-1.10.rules/alpine/mailcmd.c
+*** alpine-1.10/alpine/mailcmd.c	2008-02-29 10:18:49.000000000 -0800
+--- alpine-1.10.rules/alpine/mailcmd.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 71,76 ****
+--- 71,77 ----
+  #include &quot;../pith/pattern.h&quot;
+  #include &quot;../pith/tempfile.h&quot;
+  #include &quot;../pith/search.h&quot;
++ #include &quot;../pith/rules.h&quot;
+  #ifdef _WINDOWS
+  #include &quot;../pico/osdep/mswin.h&quot;
+  #endif
+***************
+*** 2359,2364 ****
+--- 2360,2366 ----
+  
+      dprint((4, &quot;\n - saving message -\n&quot;));
+  
++     saved_stream = stream;		/* ugly hack! */
+      state-&gt;ugly_consider_advancing_bit = 0;
+      if(F_OFF(F_SAVE_PARTIAL_WO_CONFIRM, state)
+         &amp;&amp; msgno_any_deletedparts(stream, msgmap)
+***************
+*** 2578,2583 ****
+--- 2580,2588 ----
+  		role-&gt;nick = cpystr(&quot;Default Role&quot;);
+  	    }
+  
++ 	    if(state-&gt;role)
++ 	      fs_give((void **)&amp;state-&gt;role);
++ 	    state-&gt;role = cpystr(role-&gt;nick); /* remember the role */
+  	    state-&gt;redrawer = NULL;
+  	    switch(action){
+  	      case 'c':
+***************
+*** 2628,2639 ****
+  	    char *nmsgs, ENVELOPE *env, long int rawmsgno, char *section,
+  	    SaveDel *dela, SavePreserveOrder *prea)
+  {
+!     int		      rc, ku = -1, n, flags, last_rc = 0, saveable_count = 0, done = 0;
+      int		      delindex, preindex, r;
+      char	      prompt[6*MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
+      char              *buf = tmp_20k_buf;
+      char              shortbuf[200];
+!     char              *folder;
+      HelpType	      help;
+      SaveDel           del = DontAsk;
+      SavePreserveOrder pre = DontAskPreserve;
+--- 2633,2644 ----
+  	    char *nmsgs, ENVELOPE *env, long int rawmsgno, char *section,
+  	    SaveDel *dela, SavePreserveOrder *prea)
+  {
+!     int		      rc, ku = -1, n = 0, flags, last_rc = 0, saveable_count = 0, done = 0;
+      int		      delindex, preindex, r;
+      char	      prompt[6*MAX_SCREEN_COLS+1], *p, expanded[MAILTMPLEN];
+      char              *buf = tmp_20k_buf;
+      char              shortbuf[200];
+!     char              *folder, folder2[MAXPATH];
+      HelpType	      help;
+      SaveDel           del = DontAsk;
+      SavePreserveOrder pre = DontAskPreserve;
+***************
+*** 2641,2646 ****
+--- 2646,2654 ----
+      static HISTORY_S *history = NULL;
+      CONTEXT_S	     *tc;
+      ESCKEY_S	      ekey[10];
++     RULE_RESULT	     *rule;
++ 
++     saved_stream = state-&gt;mail_stream;
+  
+      if(!cntxt)
+        panic(&quot;no context ptr in save_prompt&quot;);
+***************
+*** 2650,2655 ****
+--- 2658,2672 ----
+      if(!(folder = save_get_default(state, env, rawmsgno, section, cntxt)))
+        return(0);		/* message expunged! */
+  
++     if (rule = get_result_rule(V_SAVE_RULES, FOR_SAVE, env)){
++        strncpy(folder2,rule-&gt;result,sizeof(folder2)-1);
++        folder2[sizeof(folder2)-1] = '\0';
++        folder = folder2;
++        if (rule-&gt;result)
++ 	   fs_give((void **)&amp;rule-&gt;result);
++        fs_give((void **)&amp;rule);
++     }
++ 
+      /* how many context's can be saved to... */
+      for(tc = state-&gt;context_list; tc; tc = tc-&gt;next)
+        if(!NEWS_TEST(tc))
+diff -rc alpine-1.10/alpine/mailindx.c alpine-1.10.rules/alpine/mailindx.c
+*** alpine-1.10/alpine/mailindx.c	2008-02-01 10:42:29.000000000 -0800
+--- alpine-1.10.rules/alpine/mailindx.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 228,233 ****
+--- 228,235 ----
+      state-&gt;prev_screen = mail_index_screen;
+      state-&gt;next_screen = SCREEN_FUN_NULL;
+  
++     setup_threading_display_style();
++ 
+      if(THRD_AUTO_VIEW()
+         &amp;&amp; sp_viewing_a_thread(state-&gt;mail_stream)
+         &amp;&amp; state-&gt;view_skipped_index
+***************
+*** 239,248 ****
+--- 241,254 ----
+  
+      adjust_cur_to_visible(state-&gt;mail_stream, state-&gt;msgmap);
+  
++     strcpy(state-&gt;screen_name,&quot;index&quot;);
++ 
+      if(THRD_INDX())
+        thread_index_screen(state);
+      else
+        index_index_screen(state);
++ 
++     strcpy(state-&gt;screen_name,&quot;unknown&quot;);
+  }
+  
+  
+--- alpine-1.10/alpine/mailview.c.orig	2008-07-30 01:42:17.551793992 +0200
++++ alpine-1.10/alpine/mailview.c	2008-07-30 01:44:37.945450912 +0200
+@@ -252,6 +252,8 @@
+     ps-&gt;prev_screen = mail_view_screen;
+     ps-&gt;force_prefer_plain = ps-&gt;force_no_prefer_plain = 0;
+ 
++    strcpy(ps-&gt;screen_name, &quot;text&quot;);
++
+     if(ps-&gt;ttyo-&gt;screen_rows - HEADER_ROWS(ps) - FOOTER_ROWS(ps) &lt; 1){
+ 	q_status_message(SM_ORDER | SM_DING, 0, 3,
+ 			 _(&quot;Screen too small to view message&quot;));
+@@ -478,6 +480,8 @@
+     }
+     while(ps-&gt;next_screen == SCREEN_FUN_NULL);
+ 
++    strcpy(ps-&gt;screen_name, &quot;unknown&quot;);
++
+     if (prefix &amp;&amp; *prefix)
+        fs_give((void **)&amp;prefix);
+     if(we_cancel)
+diff -rc alpine-1.10/alpine/osdep/termin.gen.c alpine-1.10.rules/alpine/osdep/termin.gen.c
+*** alpine-1.10/alpine/osdep/termin.gen.c	2008-01-08 09:04:58.000000000 -0800
+--- alpine-1.10.rules/alpine/osdep/termin.gen.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 32,37 ****
+--- 32,39 ----
+  #include &quot;../../pith/newmail.h&quot;
+  #include &quot;../../pith/conf.h&quot;
+  #include &quot;../../pith/busy.h&quot;
++ #include &quot;../../pith/list.h&quot;
++ #include &quot;../../pith/rules.h&quot;
+  
+  #include &quot;../../pico/estruct.h&quot;
+  #include &quot;../../pico/pico.h&quot;
+***************
+*** 71,77 ****
+   *     Generic tty input routines
+   */
+  
+! 
+  /*----------------------------------------------------------------------
+          Read a character from keyboard with timeout
+   Input:  none
+--- 73,80 ----
+   *     Generic tty input routines
+   */
+  
+! void    process_init_cmds(struct pine *, char **);
+! void    queue_init_errors(struct pine *);
+  /*----------------------------------------------------------------------
+          Read a character from keyboard with timeout
+   Input:  none
+***************
+*** 113,118 ****
+--- 116,156 ----
+        *utf8str = NULL;
+  
+      ucs = read_char(tm);
++     if(!ps_global-&gt;initial_cmds){
++       RULE_RESULT *rule;
++       char **list = NULL, *error = NULL;
++       int    commas = 0, k;   /* From args.c */
++ 
++       ps_global-&gt;pressed_key = cpystr(pretty_command(ucs));
++       rule = (RULE_RESULT *)get_result_rule(V_KEY_RULES, FOR_KEY, NULL);
++       if(ps_global-&gt;pressed_key)
++         fs_give((void **)&amp;ps_global-&gt;pressed_key);
++       if (rule){
++          for(k = 0; rule-&gt;result[k]; k++)
++             if(rule-&gt;result[k] == ',') commas++;
++          list = parse_list(rule-&gt;result, commas+1, 0, &amp;error);
++          if(error)
++             sprintf(tmp_20k_buf, &quot;Error in parsing command list: %s, %s&quot;,
++                       rule-&gt;result, error);
++          if (rule-&gt;result)
++            fs_give((void **)&amp;rule-&gt;result);
++          fs_give((void **)&amp;rule);
++          if(error){
++             q_status_message(SM_ORDER | SM_DING, 0, 2, tmp_20k_buf);
++             return (NO_OP_COMMAND);
++          }
++ 	 process_init_cmds(ps_global, list);
++ 	 if(ps_global-&gt;init_errs){
++ 	    queue_init_errors(ps_global);
++             return (NO_OP_COMMAND);
++ 	 }
++ 	 ucs = read_char(tm);
++ 	 ps_global-&gt;in_init_seq = 1;  /* no output please */
++ 	 for(k = 0; k &lt; commas; k++)
++             if(list[k]) fs_give((void **)&amp;list[k]);
++          if (list) fs_give((void **)list);
++       }
++     }
+      if(ucs != NO_OP_COMMAND &amp;&amp; ucs != NO_OP_IDLE &amp;&amp; ucs != KEY_RESIZE)
+        zero_new_mail_count();
+  
+***************
+*** 1155,1160 ****
+--- 1193,1199 ----
+  	if(!*ps_global-&gt;initial_cmds &amp;&amp; ps_global-&gt;free_initial_cmds){
+  	    fs_give((void **) &amp;ps_global-&gt;free_initial_cmds);
+  	    ps_global-&gt;initial_cmds = NULL;
++ 	    firsttime = (char) 1;
+  	}
+  
+  	return(ret);
+diff -rc alpine-1.10/alpine/reply.c alpine-1.10.rules/alpine/reply.c
+*** alpine-1.10/alpine/reply.c	2008-02-27 17:04:46.000000000 -0800
+--- alpine-1.10.rules/alpine/reply.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 61,67 ****
+  #include &quot;../pith/tempfile.h&quot;
+  #include &quot;../pith/busy.h&quot;
+  #include &quot;../pith/ablookup.h&quot;
+! 
+  
+  /*
+   * Internal Prototypes
+--- 61,68 ----
+  #include &quot;../pith/tempfile.h&quot;
+  #include &quot;../pith/busy.h&quot;
+  #include &quot;../pith/ablookup.h&quot;
+! #include &quot;../pith/copyaddr.h&quot;
+! #include &quot;../pith/rules.h&quot;
+  
+  /*
+   * Internal Prototypes
+***************
+*** 138,143 ****
+--- 139,180 ----
+         &amp;&amp; F_ON(F_ENABLE_FULL_HDR_AND_TEXT, ps_global))
+        reply_raw_body = 1;
+  
++     /* Setup possible role */
++     if(role_arg)
++       role = copy_action(role_arg);
++ 
++     if(!role){
++ 	rflags = ROLE_REPLY;
++ 	if(nonempty_patterns(rflags, &amp;dummy)){
++ 	    /* setup default role */
++ 	    nrole = NULL;
++ 	    j = mn_first_cur(pine_state-&gt;msgmap);
++ 	    do {
++ 		role = nrole;
++ 		nrole = set_role_from_msg(pine_state, rflags,
++ 					  mn_m2raw(pine_state-&gt;msgmap, j),
++ 					  NULL);
++ 	    } while(nrole &amp;&amp; (!role || nrole == role)
++ 		    &amp;&amp; (j=mn_next_cur(pine_state-&gt;msgmap)) &gt; 0L);
++ 
++ 	    if(!role || nrole == role)
++ 	      role = nrole;
++ 	    else
++ 	      role = NULL;
++ 
++ 	    if(confirm_role(rflags, &amp;role))
++ 	      role = combine_inherited_role(role);
++ 	    else{				/* cancel reply */
++ 		role = NULL;
++ 		cmd_cancelled(&quot;Reply&quot;);
++ 		goto done_early;
++ 	    }
++ 	}
++     }
++ 
++     if (role)
++ 	ps_global-&gt;role = cpystr(role-&gt;nick); /* remember the role */
++ 
+      /*
+       * We may have to loop through first to figure out what default
+       * reply-indent-string to offer...
+***************
+*** 285,292 ****
+  		outgoing-&gt;subject = cpystr(&quot;Re: several messages&quot;);
+  	    }
+  	}
+! 	else
+! 	  outgoing-&gt;subject = reply_subject(env-&gt;subject, NULL, 0);
+      }
+  
+      /* fill reply header */
+--- 322,339 ----
+  		outgoing-&gt;subject = cpystr(&quot;Re: several messages&quot;);
+  	    }
+  	}
+! 	else{
+! 	   RULE_RESULT *rule;
+! 	   rule = get_result_rule(V_RESUB_RULES,FOR_RESUB|FOR_TRIM , env);
+! 	   if (rule){
+! 	     outgoing-&gt;subject = reply_subject(rule-&gt;result, NULL, 0);
+! 	     if (rule-&gt;result)
+! 	        fs_give((void **)&amp;rule-&gt;result);
+! 	     fs_give((void **)&amp;rule);
+! 	   }
+! 	   else
+! 	       outgoing-&gt;subject = reply_subject(env-&gt;subject, NULL, 0);
+! 	}
+      }
+  
+      /* fill reply header */
+***************
+*** 305,343 ****
+      if(sp_expunge_count(pine_state-&gt;mail_stream))	/* cur msg expunged */
+        goto done_early;
+  
+-     /* Setup possible role */
+-     if(role_arg)
+-       role = copy_action(role_arg);
+- 
+-     if(!role){
+- 	rflags = ROLE_REPLY;
+- 	if(nonempty_patterns(rflags, &amp;dummy)){
+- 	    /* setup default role */
+- 	    nrole = NULL;
+- 	    j = mn_first_cur(pine_state-&gt;msgmap);
+- 	    do {
+- 		role = nrole;
+- 		nrole = set_role_from_msg(pine_state, rflags,
+- 					  mn_m2raw(pine_state-&gt;msgmap, j),
+- 					  NULL);
+- 	    } while(nrole &amp;&amp; (!role || nrole == role)
+- 		    &amp;&amp; (j=mn_next_cur(pine_state-&gt;msgmap)) &gt; 0L);
+- 
+- 	    if(!role || nrole == role)
+- 	      role = nrole;
+- 	    else
+- 	      role = NULL;
+- 
+- 	    if(confirm_role(rflags, &amp;role))
+- 	      role = combine_inherited_role(role);
+- 	    else{				/* cancel reply */
+- 		role = NULL;
+- 		cmd_cancelled(&quot;Reply&quot;);
+- 		goto done_early;
+- 	    }
+- 	}
+-     }
+- 
+      /*
+       * Reply_seed may call c-client in get_fcc_based_on_to, so env may
+       * no longer be valid. Get it again.
+--- 352,357 ----
+***************
+*** 721,726 ****
+--- 735,743 ----
+      if(prefix)
+        fs_give((void **)&amp;prefix);
+  
++     if (ps_global-&gt;role)
++ 	fs_give((void **)&amp;ps_global-&gt;role);
++ 
+      if(fcc)
+        fs_give((void **) &amp;fcc);
+  
+***************
+*** 1441,1449 ****
+  	}
+      }
+  
+!     if(role)
+        q_status_message1(SM_ORDER, 3, 4,
+  			_(&quot;Forwarding using role \&quot;%s\&quot;&quot;), role-&gt;nick);
+  
+      if(role &amp;&amp; role-&gt;template){
+  	char *filtered;
+--- 1458,1471 ----
+  	}
+      }
+  
+!     if (ps_global-&gt;role)
+!       fs_give((void **)&amp;ps_global-&gt;role);
+! 
+!     if(role){
+        q_status_message1(SM_ORDER, 3, 4,
+  			_(&quot;Forwarding using role \&quot;%s\&quot;&quot;), role-&gt;nick);
++       ps_global-&gt;role = cpystr(role-&gt;nick);
++     }
+  
+      if(role &amp;&amp; role-&gt;template){
+  	char *filtered;
+***************
+*** 1676,1681 ****
+--- 1698,1704 ----
+  #if	defined(DOS) &amp;&amp; !defined(_WINDOWS)
+      free((void *)reserve);
+  #endif
++     outgoing-&gt;sparep = env &amp;&amp; env-&gt;from ? copyaddr(env-&gt;from) : NULL;
+      pine_send(outgoing, &amp;body, &quot;FORWARD MESSAGE&quot;,
+  	      role, NULL, &amp;reply, redraft_pos,
+  	      NULL, NULL, 0);
+diff -rc alpine-1.10/alpine/roleconf.c alpine-1.10.rules/alpine/roleconf.c
+*** alpine-1.10/alpine/roleconf.c	2008-02-27 17:04:46.000000000 -0800
+--- alpine-1.10.rules/alpine/roleconf.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 7705,7710 ****
+--- 7705,7715 ----
+  	    if(apval)
+  	      *apval = (role &amp;&amp; role-&gt;nick) ? cpystr(role-&gt;nick) : NULL;
+  
++ 	    if (ps_global-&gt;role)
++ 		fs_give((void **)&amp;ps_global-&gt;role);
++ 	    if (role &amp;&amp; role-&gt;nick)
++ 		ps_global-&gt;role = cpystr(role-&gt;nick);
++ 
+  	    if((*cl)-&gt;value)
+  	      fs_give((void **)&amp;((*cl)-&gt;value));
+  
+diff -rc alpine-1.10/alpine/send.c alpine-1.10.rules/alpine/send.c
+*** alpine-1.10/alpine/send.c	2008-02-08 09:43:23.000000000 -0800
+--- alpine-1.10.rules/alpine/send.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 62,68 ****
+  #include &quot;../pith/busy.h&quot;
+  #include &quot;../pith/mimetype.h&quot;
+  #include &quot;../pith/send.h&quot;
+! 
+  
+  typedef struct body_particulars {
+      unsigned short     type, encoding, had_csp;
+--- 62,68 ----
+  #include &quot;../pith/busy.h&quot;
+  #include &quot;../pith/mimetype.h&quot;
+  #include &quot;../pith/send.h&quot;
+! #include &quot;../pith/rules.h&quot;
+  
+  typedef struct body_particulars {
+      unsigned short     type, encoding, had_csp;
+***************
+*** 237,242 ****
+--- 237,247 ----
+  	role-&gt;nick = cpystr(&quot;Default Role&quot;);
+      }
+  
++     if (ps_global-&gt;role)
++        fs_give((void **)&amp;ps_global-&gt;role);  
++ 
++     ps_global-&gt;role = cpystr(role-&gt;nick);
++ 
+      pine_state-&gt;redrawer = NULL;
+      compose_mail(NULL, NULL, role, NULL, NULL);
+      free_action(&amp;role);
+***************
+*** 446,453 ****
+  
+  	      ps_global-&gt;next_screen = prev_screen;
+  	      ps_global-&gt;redrawer = redraw;
+! 	      if(role)
+  		role = combine_inherited_role(role);
+  	    }
+  	    break;
+  	  
+--- 451,462 ----
+  
+  	      ps_global-&gt;next_screen = prev_screen;
+  	      ps_global-&gt;redrawer = redraw;
+! 	      if (ps_global-&gt;role)
+! 		  fs_give((void **)&amp;ps_global-&gt;role);  
+! 	      if(role){
+  		role = combine_inherited_role(role);
++ 		ps_global-&gt;role = cpystr(role-&gt;nick);
++ 	      }
+  	    }
+  	    break;
+  	  
+***************
+*** 642,650 ****
+  	    }
+  	}
+  
+! 	if(role)
+  	  q_status_message1(SM_ORDER, 3, 4, _(&quot;Composing using role \&quot;%s\&quot;&quot;),
+  			    role-&gt;nick);
+  
+  	/*
+  	 * The type of storage object allocated below is vitally
+--- 651,664 ----
+  	    }
+  	}
+  
+! 	if (ps_global-&gt;role)
+! 	    fs_give((void **)&amp;ps_global-&gt;role);
+! 
+! 	if(role){
+  	  q_status_message1(SM_ORDER, 3, 4, _(&quot;Composing using role \&quot;%s\&quot;&quot;),
+  			    role-&gt;nick);
++ 	  ps_global-&gt;role = cpystr(role-&gt;nick);
++ 	}
+  
+  	/*
+  	 * The type of storage object allocated below is vitally
+***************
+*** 2410,2415 ****
+--- 2424,2449 ----
+  		    removing_trailing_white_space(pf-&gt;textbuf);
+  		    (void)removing_double_quotes(pf-&gt;textbuf);
+  		    build_address(pf-&gt;textbuf, &amp;addr, NULL, NULL, NULL);
++ 		    if (!strncmp(pf-&gt;name,&quot;Lcc&quot;,3) &amp;&amp; addr &amp;&amp; *addr){
++ 			RULE_RESULT *rule;
++ 
++   			outgoing-&gt;date = (unsigned char *) cpystr(addr);
++ 			ps_global-&gt;procid = cpystr(&quot;fwd-lcc&quot;);
++ 			rule = get_result_rule(V_FORWARD_RULES,
++ 			           FOR_COMPOSE|FOR_TRIM, outgoing);
++ 			if (rule){
++ 			    addr = cpystr(rule-&gt;result);
++ 			    removing_trailing_white_space(addr);
++ 			    (void)removing_extra_stuff(addr);
++ 			    if (rule-&gt;result)
++ 				fs_give((void **)&amp;rule-&gt;result);
++ 				fs_give((void **)&amp;rule);
++ 			}
++ 			fs_give((void **)&amp;ps_global-&gt;procid);
++ 			if (outgoing-&gt;date)
++ 			    fs_give((void **)&amp;outgoing-&gt;date);
++ 		    }   
++ 
+  		    rfc822_parse_adrlist(pf-&gt;addr, addr,
+  					 ps_global-&gt;maildomain);
+  		    fs_give((void **)&amp;addr);
+diff -rc alpine-1.10/pith/adrbklib.c alpine-1.10.rules/pith/adrbklib.c
+*** alpine-1.10/pith/adrbklib.c	2008-03-05 17:13:33.000000000 -0800
+--- alpine-1.10.rules/pith/adrbklib.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 5308,5315 ****
+  	    if(as.cur &gt;= as.how_many_personals)
+  	      pab-&gt;type |= GLOBAL;
+  
+! 	    pab-&gt;access = adrbk_access(pab);
+! 
+  	    /* global address books are forced readonly */
+  	    if(pab-&gt;type &amp; GLOBAL &amp;&amp; pab-&gt;access != NoAccess)
+  	      pab-&gt;access = ReadOnly;
+--- 5308,5321 ----
+  	    if(as.cur &gt;= as.how_many_personals)
+  	      pab-&gt;type |= GLOBAL;
+  
+! 	    if(ps_global-&gt;mail_stream &amp;&amp; 
+! 		ps_global-&gt;mail_stream-&gt;lock &amp;&amp; (pab-&gt;type &amp; REMOTE_VIA_IMAP)){
+! 	      as.initialized = 0;
+! 	      pab-&gt;access = NoAccess;
+! 	    }
+! 	    else{
+! 	      pab-&gt;access = adrbk_access(pab);
+! 	    }
+  	    /* global address books are forced readonly */
+  	    if(pab-&gt;type &amp; GLOBAL &amp;&amp; pab-&gt;access != NoAccess)
+  	      pab-&gt;access = ReadOnly;
+diff -rc alpine-1.10/pith/conf.c alpine-1.10.rules/pith/conf.c
+*** alpine-1.10/pith/conf.c	2008-03-14 11:15:38.000000000 -0700
+--- alpine-1.10.rules/pith/conf.c	2008-03-17 20:33:23.000000000 -0700
+***************
+*** 28,33 ****
+--- 28,34 ----
+  #include &quot;../pith/remote.h&quot;
+  #include &quot;../pith/keyword.h&quot;
+  #include &quot;../pith/mailview.h&quot;
++ #include &quot;../pith/rules.h&quot;
+  #include &quot;../pith/list.h&quot;
+  #include &quot;../pith/status.h&quot;
+  #include &quot;../pith/ldap.h&quot;
+***************
+*** 198,203 ****
+--- 199,234 ----
+  
+  CONF_TXT_T cf_text_editor[] =		&quot;Specifies the program invoked by ^_ in the Composer,\n# or the \&quot;enable-alternate-editor-implicitly\&quot; feature.&quot;;
+  
++ CONF_TXT_T cf_text_compose_rules[] =	&quot;Allows a user to set rules when composing messages.&quot;;
++  
++ CONF_TXT_T cf_text_forward_rules[] =	&quot;Allows a user to set rules when forwarding messages.&quot;;
++  
++ CONF_TXT_T cf_text_reply_rules[] =	&quot;Allows a user to set rules when replying messages.&quot;;
++  
++ CONF_TXT_T cf_text_index_rules[] =	&quot;Allows a user to supersede global index format variable in designated folders.&quot;;
++  
++ CONF_TXT_T cf_text_key_def_rules[] =	&quot;Allows a user to override keystrokes in certain screens.&quot;;
++ 
++ CONF_TXT_T cf_text_replace_rules[] =	&quot;Allows a user to change the form a specify field in the index-format is \n# displayed.&quot;;
++  
++ CONF_TXT_T cf_text_reply_indent_rules[] = &quot;Allows a user to change the form a specify a reply-indent-string\n# based of rules.&quot;;
++  
++ CONF_TXT_T cf_text_reply_leadin_rules[] =	&quot;Allows a user to replace the reply-leadin message based on different parameters.&quot;;
++  
++ CONF_TXT_T cf_text_reply_subject_rules[] =	&quot;Allows a user to replace the subject of a message in a customs based way&quot;;
++  
++ CONF_TXT_T cf_text_thread_displaystyle_rule[] = &quot;Allows a user to specify the threading style of specific folders&quot;;
++  
++ CONF_TXT_T cf_text_thread_indexstyle_rule[] = &quot;Allows a user to specify the threading index style of specific folders&quot;;
++  
++ CONF_TXT_T cf_text_save_rules[] =	&quot;Allows a user to specify a save folder message for specific senders or folders.&quot;;
++  
++ CONF_TXT_T cf_text_smtp_rules[] =	&quot;Allows a user to specify a smtp server to be used when sending e-mail,\n# according to the rules specified here.&quot;;
++  
++ CONF_TXT_T cf_text_sort_rules[] =	&quot;Allows a user to specify the sort default order of a specific folder.&quot;;
++  
++ CONF_TXT_T cf_text_startup_rules[] =	&quot;Allows a user to specify the position of a highlighted message when opening a \n# folder.&quot;;
++  
+  CONF_TXT_T cf_text_speller[] =		&quot;Specifies the program invoked by ^T in the Composer.&quot;;
+  
+  CONF_TXT_T cf_text_deadlets[] =		&quot;Specifies the number of dead letter files to keep when canceling.&quot;;
+***************
+*** 518,523 ****
+--- 549,582 ----
+  	NULL,			cf_text_thread_exp_char},
+  {&quot;threading-lastreply-character&quot;,	0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+  	&quot;Threading Last Reply Character&quot;,	cf_text_thread_lastreply_char},
++ {&quot;threading-display-style-rule&quot;,	0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Threading Display Style Rule&quot;,	cf_text_thread_displaystyle_rule},
++ {&quot;threading-index-style-rule&quot;,		0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Threading Index Style Rule&quot;,	cf_text_thread_indexstyle_rule},
++ {&quot;compose-rules&quot;,			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Compose Rules&quot;,	cf_text_compose_rules},
++ {&quot;forward-rules&quot;,			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Forward Rules&quot;, 	cf_text_forward_rules},
++ {&quot;index-rules&quot;,				0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
++ 	&quot;Index Rules&quot;,		cf_text_index_rules},
++ {&quot;key-definition-rules&quot;,		0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
++ 	&quot;Key Definition Rules&quot;,	cf_text_key_def_rules},
++ {&quot;replace-rules&quot;,			0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
++ 	&quot;Replace Rules&quot;,	cf_text_replace_rules},
++ {&quot;reply-indent-rules&quot;,			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Reply Indent Rules&quot;,	cf_text_reply_indent_rules},
++ {&quot;reply-leadin-rules&quot;,			0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
++ 	&quot;Reply Leadin Rules&quot;,	cf_text_reply_leadin_rules},
++ {&quot;reply-subject-rules&quot;,			0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0,
++ 	&quot;Reply Subject Rules&quot;,	cf_text_reply_subject_rules},
++ {&quot;save-rules&quot;,				0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Save Rules&quot;,		cf_text_save_rules},
++ {&quot;smtp-rules&quot;,				0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Smtp Rules&quot;,		cf_text_smtp_rules},
++ {&quot;sort-rules&quot;,				0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Sort Rules&quot;,		cf_text_sort_rules},
++ {&quot;startup-rules&quot;,			0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0,
++ 	&quot;Startup Rules&quot;,	cf_text_startup_rules},
+  #ifndef	_WINDOWS
+  {&quot;display-character-set&quot;,		0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0,
+  	NULL,			cf_text_disp_char_set},
+***************
+*** 2486,2491 ****
+--- 2545,2551 ----
+        if(cmds_f)
+          (*cmds_f)(ps, VAR_INIT_CMD_LIST);
+  
++     (void)create_rule_list(ps_global-&gt;vars);
+  #ifdef	_WINDOWS
+      mswin_set_quit_confirm (F_OFF(F_QUIT_WO_CONFIRM, ps_global));
+  #endif	/* _WINDOWS */
+***************
+*** 2928,2933 ****
+--- 2988,2995 ----
+  	 F_FORCE_LOW_SPEED, h_config_force_low_speed, PREF_OS_LWSD, 0},
+  	{&quot;auto-move-read-msgs&quot;, &quot;Auto Move Read Messages&quot;,
+  	 F_AUTO_READ_MSGS, h_config_auto_read_msgs, PREF_MISC, 0},
++ 	{&quot;auto-move-read-msgs-using-rules&quot;, &quot;Auto Move Read Messages Using Rules&quot;,
++ 	 F_AUTO_READ_MSGS_RULES, h_config_auto_read_msgs_rules, PREF_MISC, 0},
+  	{&quot;auto-unselect-after-apply&quot;, NULL,
+  	 F_AUTO_UNSELECT, h_config_auto_unselect, PREF_MISC, 0},
+  	{&quot;auto-unzoom-after-apply&quot;, NULL,
+***************
+*** 7417,7422 ****
+--- 7479,7512 ----
+  	return(h_config_ab_sort_rule);
+        case V_FLD_SORT_RULE :
+  	return(h_config_fld_sort_rule);
++       case V_THREAD_DISP_STYLE_RULES:
++ 	return(h_config_thread_display_style_rule);
++       case V_THREAD_INDEX_STYLE_RULES:
++ 	return(h_config_thread_index_style_rule);
++       case V_COMPOSE_RULES:
++ 	return(h_config_compose_rules);
++       case V_FORWARD_RULES:
++ 	return(h_config_forward_rules);
++       case V_INDEX_RULES:
++ 	return(h_config_index_rules);
++       case V_KEY_RULES:
++ 	return(h_config_key_macro_rules);
++       case V_REPLACE_RULES:
++ 	return(h_config_replace_rules);
++       case V_REPLY_INDENT_RULES:
++ 	return(h_config_reply_indent_rules);
++       case V_REPLY_LEADIN_RULES:
++ 	return(h_config_reply_leadin_rules);
++       case V_RESUB_RULES:
++ 	return(h_config_resub_rules);
++       case V_SAVE_RULES:
++ 	return(h_config_save_rules);
++       case V_SMTP_RULES:
++ 	return(h_config_smtp_rules);
++       case V_SORT_RULES:
++ 	return(h_config_sort_rules);
++       case V_STARTUP_RULES:
++ 	return(h_config_startup_rules);
+        case V_POST_CHAR_SET :
+  	return(h_config_post_char_set);
+        case V_UNK_CHAR_SET :
+***************
+*** 8077,8079 ****
+--- 8167,8170 ----
+  }
+  
+  #endif	/* _WINDOWS */
++ 
+diff -rc alpine-1.10/pith/conf.h alpine-1.10.rules/pith/conf.h
+*** alpine-1.10/pith/conf.h	2008-03-14 11:15:38.000000000 -0700
+--- alpine-1.10.rules/pith/conf.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 147,152 ****
+--- 147,192 ----
+  #define GLO_AB_SORT_RULE	     vars[V_AB_SORT_RULE].global_val.p
+  #define VAR_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].current_val.p
+  #define GLO_FLD_SORT_RULE	     vars[V_FLD_SORT_RULE].global_val.p
++ #define VAR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].current_val.l
++ #define GLO_COMPOSE_RULES	     vars[V_COMPOSE_RULES].global_val.l
++ #define USR_COMPOSE_RULES	     vars[V_COMPOSE_RULES].user_val.l
++ #define VAR_FORWARD_RULES	     vars[V_FORWARD_RULES].current_val.l
++ #define GLO_FORWARD_RULES	     vars[V_FORWARD_RULES].global_val.l
++ #define USR_FORWARD_RULES	     vars[V_FORWARD_RULES].user_val.l
++ #define VAR_INDEX_RULES		     vars[V_INDEX_RULES].current_val.l
++ #define GLO_INDEX_RULES		     vars[V_INDEX_RULES].global_val.l
++ #define USR_INDEX_RULES		     vars[V_INDEX_RULES].user_val.l
++ #define VAR_KEY_RULES		     vars[V_KEY_RULES].current_val.l
++ #define GLO_KEY_RULES		     vars[V_KEY_RULES].global_val.l
++ #define USR_KEY_RULES		     vars[V_KEY_RULES].user_val.l
++ #define VAR_REPLACE_RULES	     vars[V_REPLACE_RULES].current_val.l
++ #define GLO_REPLACE_RULES	     vars[V_REPLACE_RULES].global_val.l
++ #define USR_REPLACE_RULES	     vars[V_REPLACE_RULES].user_val.l
++ #define VAR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].current_val.l
++ #define GLO_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].global_val.l
++ #define USR_REPLY_INDENT_RULES	     vars[V_REPLY_INDENT_RULES].user_val.l
++ #define VAR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].current_val.l
++ #define GLO_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].global_val.l
++ #define USR_REPLY_LEADIN_RULES	     vars[V_REPLY_LEADIN_RULES].user_val.l
++ #define VAR_RESUB_RULES		     vars[V_RESUB_RULES].current_val.l
++ #define GLO_RESUB_RULES		     vars[V_RESUB_RULES].global_val.l
++ #define USR_RESUB_RULES		     vars[V_RESUB_RULES].user_val.l
++ #define VAR_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].current_val.l
++ #define GLO_THREAD_DISP_STYLE_RULES  vars[V_THREAD_DISP_STYLE_RULES].global_val.l
++ #define VAR_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].current_val.l
++ #define GLO_THREAD_INDEX_STYLE_RULES vars[V_THREAD_INDEX_STYLE_RULES].global_val.l
++ #define VAR_SAVE_RULES		     vars[V_SAVE_RULES].current_val.l
++ #define GLO_SAVE_RULES		     vars[V_SAVE_RULES].global_val.l
++ #define USR_SAVE_RULES		     vars[V_SAVE_RULES].user_val.l
++ #define VAR_SMTP_RULES		     vars[V_SMTP_RULES].current_val.l
++ #define GLO_SMTP_RULES		     vars[V_SMTP_RULES].global_val.l
++ #define USR_SMTP_RULES		     vars[V_SMTP_RULES].user_val.l
++ #define VAR_SORT_RULES		     vars[V_SORT_RULES].current_val.l
++ #define GLO_SORT_RULES		     vars[V_SORT_RULES].global_val.l
++ #define USR_SORT_RULES		     vars[V_SORT_RULES].user_val.l
++ #define VAR_STARTUP_RULES	     vars[V_STARTUP_RULES].current_val.l
++ #define GLO_STARTUP_RULES	     vars[V_STARTUP_RULES].global_val.l
++ #define USR_STARTUP_RULES	     vars[V_STARTUP_RULES].user_val.l
+  #ifndef	_WINDOWS
+  #define VAR_CHAR_SET		     vars[V_CHAR_SET].current_val.p
+  #define GLO_CHAR_SET		     vars[V_CHAR_SET].global_val.p
+diff -rc alpine-1.10/pith/conftype.h alpine-1.10.rules/pith/conftype.h
+*** alpine-1.10/pith/conftype.h	2008-03-14 11:15:38.000000000 -0700
+--- alpine-1.10.rules/pith/conftype.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 69,74 ****
+--- 69,88 ----
+  		, V_THREAD_MORE_CHAR
+  		, V_THREAD_EXP_CHAR
+  		, V_THREAD_LASTREPLY_CHAR
++ 		, V_THREAD_DISP_STYLE_RULES
++ 		, V_THREAD_INDEX_STYLE_RULES
++ 		, V_COMPOSE_RULES
++ 		, V_FORWARD_RULES
++ 		, V_INDEX_RULES
++ 		, V_KEY_RULES
++ 		, V_REPLACE_RULES
++ 		, V_REPLY_INDENT_RULES
++ 		, V_REPLY_LEADIN_RULES
++ 		, V_RESUB_RULES
++ 		, V_SAVE_RULES
++ 		, V_SMTP_RULES
++ 		, V_SORT_RULES
++ 		, V_STARTUP_RULES
+  #ifndef	_WINDOWS
+  		, V_CHAR_SET
+  		, V_OLD_CHAR_SET
+***************
+*** 309,314 ****
+--- 323,329 ----
+  	F_FULL_AUTO_EXPUNGE,
+  	F_EXPUNGE_MANUALLY,
+  	F_AUTO_READ_MSGS,
++ 	F_AUTO_READ_MSGS_RULES,
+  	F_AUTO_FCC_ONLY,
+  	F_READ_IN_NEWSRC_ORDER,
+  	F_SELECT_WO_CONFIRM,
+diff -rc alpine-1.10/pith/detoken.c alpine-1.10.rules/pith/detoken.c
+*** alpine-1.10/pith/detoken.c	2007-08-14 12:02:07.000000000 -0700
+--- alpine-1.10.rules/pith/detoken.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 24,30 ****
+  #include &quot;../pith/reply.h&quot;
+  #include &quot;../pith/mailindx.h&quot;
+  #include &quot;../pith/options.h&quot;
+! 
+  
+  /*
+   * Hook to read signature from local file
+--- 24,30 ----
+  #include &quot;../pith/reply.h&quot;
+  #include &quot;../pith/mailindx.h&quot;
+  #include &quot;../pith/options.h&quot;
+! #include &quot;../pith/rules.h&quot;
+  
+  /*
+   * Hook to read signature from local file
+***************
+*** 90,95 ****
+--- 90,97 ----
+  
+      if(is_sig){
+  	/*
++ 	 * First we check if there is a rule about signatures, if there is
++ 	 * use it, otherwise keep going and do the following:
+  	 * If role-&gt;litsig is set, we use it;
+  	 * Else, if VAR_LITERAL_SIG is set, we use that;
+  	 * Else, if role-&gt;sig is set, we use that;
+***************
+*** 103,116 ****
+  	 * there is no reason to mix them, so we don't provide support to
+  	 * do so.
+  	 */
+! 	if(role &amp;&amp; role-&gt;litsig)
+! 	  literal_sig = role-&gt;litsig;
+! 	else if(ps_global-&gt;VAR_LITERAL_SIG)
+! 	  literal_sig = ps_global-&gt;VAR_LITERAL_SIG;
+! 	else if(role &amp;&amp; role-&gt;sig)
+! 	  sigfile = role-&gt;sig;
+! 	else
+! 	  sigfile = ps_global-&gt;VAR_SIGNATURE_FILE;
+      }
+      else if(role &amp;&amp; role-&gt;template)
+        sigfile = role-&gt;template;
+--- 105,129 ----
+  	 * there is no reason to mix them, so we don't provide support to
+  	 * do so.
+  	 */
+!         { RULE_RESULT *rule;
+!            rule = get_result_rule(V_COMPOSE_RULES, FOR_COMPOSE, env);
+!            if (rule){
+!                sigfile = cpystr(rule-&gt;result);
+! 	       if (rule-&gt;result)
+! 	          fs_give((void **)&amp;rule-&gt;result);
+! 	       fs_give((void **)&amp;rule);
+! 	   }
+!         }
+! 	if (!sigfile){
+! 	  if(role &amp;&amp; role-&gt;litsig)
+! 	    literal_sig = role-&gt;litsig;
+! 	  else if(ps_global-&gt;VAR_LITERAL_SIG)
+! 	    literal_sig = ps_global-&gt;VAR_LITERAL_SIG;
+! 	  else if(role &amp;&amp; role-&gt;sig)
+! 	    sigfile = role-&gt;sig;
+! 	  else
+! 	    sigfile = ps_global-&gt;VAR_SIGNATURE_FILE;
+! 	}
+      }
+      else if(role &amp;&amp; role-&gt;template)
+        sigfile = role-&gt;template;
+***************
+*** 301,307 ****
+  			}
+  		    }
+  		}
+! 		else if(pt-&gt;what_for &amp; FOR_REPLY_INTRO)
+  		  repl = get_reply_data(env, role, pt-&gt;ctype,
+  					subbuf, sizeof(subbuf)-1);
+  
+--- 314,320 ----
+  			}
+  		    }
+  		}
+! 		else if(pt-&gt;what_for &amp; (FOR_REPLY_INTRO | FOR_RULE))
+  		  repl = get_reply_data(env, role, pt-&gt;ctype,
+  					subbuf, sizeof(subbuf)-1);
+  
+diff -rc alpine-1.10/pith/indxtype.h alpine-1.10.rules/pith/indxtype.h
+*** alpine-1.10/pith/indxtype.h	2007-11-28 15:02:46.000000000 -0800
+--- alpine-1.10.rules/pith/indxtype.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 81,86 ****
+--- 81,89 ----
+  	      iCurNews, iArrow,
+  	      iMailbox, iAddress, iInit, iCursorPos,
+  	      iDay2Digit, iMon2Digit, iYear2Digit,
++ 	      iFolder, iFlag, iCollection, iRole, iProcid, iScreen, iPkey,
++ 	      iNick, iAddressTo, iAddressCc, iAddressRecip, iBcc, iLcc,
++ 	      iFfrom, iFadd,
+  	      iSTime, iKSize,
+  	      iRoleNick, iNewLine,
+  	      iHeader, iText,
+***************
+*** 102,116 ****
+  
+  
+  /* these are flags for the what_for field in INDEX_PARSE_T */
+! #define FOR_NOTHING	0x00
+! #define FOR_INDEX	0x01
+! #define FOR_REPLY_INTRO	0x02
+! #define FOR_TEMPLATE	0x04		/* or for signature */
+! #define FOR_FILT	0x08
+! #define DELIM_USCORE	0x10
+! #define DELIM_PAREN	0x20
+! #define DELIM_COLON	0x40
+! 
+  
+  #define DEFAULT_REPLY_INTRO &quot;default&quot;
+  
+--- 105,130 ----
+  
+  
+  /* these are flags for the what_for field in INDEX_PARSE_T */
+! #define FOR_NOTHING	0x00000
+! #define FOR_INDEX	0x00001
+! #define FOR_REPLY_INTRO	0x00002
+! #define FOR_TEMPLATE	0x00004  /* or for signature */
+! #define FOR_FILT	0x00008
+! #define DELIM_USCORE	0x00010
+! #define DELIM_PAREN	0x00020
+! #define DELIM_COLON	0x00040
+! #define FOR_FOLDER	0x00080  /* for rules */
+! #define FOR_RULE	0x00100  /* for rules */
+! #define FOR_TRIM	0x00200  /* for rules */
+! #define FOR_RESUB	0x00400  /* for rules */
+! #define FOR_REPLACE	0x00800  /* for rules */
+! #define FOR_SORT	0x01000  /* for rules */
+! #define FOR_FLAG	0x02000  /* for rules */
+! #define FOR_COMPOSE	0x04000  /* for rules */
+! #define FOR_THREAD	0x08000  /* for rules */
+! #define FOR_STARTUP	0x10000  /* for rules */
+! #define FOR_KEY		0x20000	 /* for rules */
+! #define FOR_SAVE	0x40000  /* for rules */
+  
+  #define DEFAULT_REPLY_INTRO &quot;default&quot;
+  
+diff -rc alpine-1.10/pith/mailcmd.c alpine-1.10.rules/pith/mailcmd.c
+*** alpine-1.10/pith/mailcmd.c	2008-03-05 10:56:28.000000000 -0800
+--- alpine-1.10.rules/pith/mailcmd.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 38,43 ****
+--- 38,44 ----
+  #include &quot;../pith/ablookup.h&quot;
+  #include &quot;../pith/search.h&quot;
+  #include &quot;../pith/charconv/utf8.h&quot;
++ #include &quot;../pith/rules.h&quot;
+  
+  #ifdef _WINDOWS
+  #include &quot;../pico/osdep/mswin.h&quot;
+***************
+*** 659,664 ****
+--- 660,666 ----
+  	strncpy(ps_global-&gt;cur_folder, p, sizeof(ps_global-&gt;cur_folder)-1);
+  	ps_global-&gt;cur_folder[sizeof(ps_global-&gt;cur_folder)-1] = '\0';
+  	ps_global-&gt;context_current = ps_global-&gt;context_list;
++ 	setup_threading_index_style();
+  	reset_index_format();
+  	clear_index_cache(ps_global-&gt;mail_stream, 0);
+          /* MUST sort before restoring msgno! */
+***************
+*** 974,979 ****
+--- 976,982 ----
+  
+      clear_index_cache(ps_global-&gt;mail_stream, 0);
+      reset_index_format();
++     setup_threading_index_style();
+  
+      /*
+       * Start news reading with messages the user's marked deleted
+***************
+*** 1092,1098 ****
+  
+      if(!cur_already_set &amp;&amp; mn_get_total(ps_global-&gt;msgmap) &gt; 0L){
+  
+! 	perfolder_startup_rule = reset_startup_rule(ps_global-&gt;mail_stream);
+  
+  	if(ps_global-&gt;start_entry &gt; 0){
+  	    mn_set_cur(ps_global-&gt;msgmap, mn_get_revsort(ps_global-&gt;msgmap)
+--- 1095,1104 ----
+  
+      if(!cur_already_set &amp;&amp; mn_get_total(ps_global-&gt;msgmap) &gt; 0L){
+  
+! 	perfolder_startup_rule = get_perfolder_startup_rule(ps_global-&gt;mail_stream,
+!                                        V_STARTUP_RULES, newfolder);
+! 
+! 	reset_startup_rule(ps_global-&gt;mail_stream);
+  
+  	if(ps_global-&gt;start_entry &gt; 0){
+  	    mn_set_cur(ps_global-&gt;msgmap, mn_get_revsort(ps_global-&gt;msgmap)
+***************
+*** 1114,1237 ****
+  	    else
+  	      use_this_startup_rule = ps_global-&gt;inc_startup_rule;
+  
+! 	    switch(use_this_startup_rule){
+! 	      /*
+! 	       * For news in incoming collection we're doing the same thing
+! 	       * for first-unseen and first-recent. In both those cases you
+! 	       * get first-unseen if FAKE_NEW is off and first-recent if
+! 	       * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
+! 	       * same as first recent because all recent msgs are unseen
+! 	       * and all unrecent msgs are seen (see pine_mail_open).
+! 	       */
+! 	      case IS_FIRST_UNSEEN:
+! first_unseen:
+! 		mn_set_cur(ps_global-&gt;msgmap,
+! 			(sp_first_unseen(m)
+! 			 &amp;&amp; mn_get_sort(ps_global-&gt;msgmap) == SortArrival
+! 			 &amp;&amp; !mn_get_revsort(ps_global-&gt;msgmap)
+! 			 &amp;&amp; !get_lflag(ps_global-&gt;mail_stream, NULL,
+! 				       sp_first_unseen(m), MN_EXLD)
+! 			 &amp;&amp; (n = mn_raw2m(ps_global-&gt;msgmap, 
+! 					  sp_first_unseen(m))))
+! 			   ? n
+! 			   : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
+! 					      THREADING() ? 0 : FSF_SKIP_CHID));
+! 		break;
+! 
+! 	      case IS_FIRST_RECENT:
+! first_recent:
+! 		/*
+! 		 * We could really use recent for news but this is the way
+! 		 * it has always worked, so we'll leave it. That is, if
+! 		 * the FAKE_NEW feature is on, recent and unseen are
+! 		 * equivalent, so it doesn't matter. If the feature isn't
+! 		 * on, all the undeleted messages are unseen and we start
+! 		 * at the first one. User controls with the FAKE_NEW feature.
+! 		 */
+! 		if(IS_NEWS(ps_global-&gt;mail_stream)){
+! 		    mn_set_cur(ps_global-&gt;msgmap,
+! 			       first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+! 					       THREADING() ? 0 : FSF_SKIP_CHID));
+! 		}
+! 		else{
+! 		    mn_set_cur(ps_global-&gt;msgmap,
+! 			       first_sorted_flagged(F_RECENT | F_UNSEEN
+! 						    | F_UNDEL,
+! 						    m, pc,
+! 					      THREADING() ? 0 : FSF_SKIP_CHID));
+! 		}
+! 		break;
+! 
+! 	      case IS_FIRST_IMPORTANT:
+! 		mn_set_cur(ps_global-&gt;msgmap,
+! 			   first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+! 					      THREADING() ? 0 : FSF_SKIP_CHID));
+! 		break;
+! 
+! 	      case IS_FIRST_IMPORTANT_OR_UNSEEN:
+! 
+! 		if(IS_NEWS(ps_global-&gt;mail_stream))
+! 		  goto first_unseen;
+! 
+! 		{
+! 		    MsgNo flagged, first_unseen;
+! 
+! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+! 					       THREADING() ? 0 : FSF_SKIP_CHID);
+! 		    first_unseen = (sp_first_unseen(m)
+! 			     &amp;&amp; mn_get_sort(ps_global-&gt;msgmap) == SortArrival
+! 			     &amp;&amp; !mn_get_revsort(ps_global-&gt;msgmap)
+! 			     &amp;&amp; !get_lflag(ps_global-&gt;mail_stream, NULL,
+! 					   sp_first_unseen(m), MN_EXLD)
+! 			     &amp;&amp; (n = mn_raw2m(ps_global-&gt;msgmap, 
+! 					      sp_first_unseen(m))))
+! 				? n
+! 				: first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
+! 					       THREADING() ? 0 : FSF_SKIP_CHID);
+! 		    mn_set_cur(ps_global-&gt;msgmap,
+! 			  (MsgNo) MIN((int) flagged, (int) first_unseen));
+! 
+! 		}
+! 
+! 		break;
+! 
+! 	      case IS_FIRST_IMPORTANT_OR_RECENT:
+! 
+! 		if(IS_NEWS(ps_global-&gt;mail_stream))
+! 		  goto first_recent;
+! 
+! 		{
+! 		    MsgNo flagged, first_recent;
+! 
+! 		    flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
+! 					       THREADING() ? 0 : FSF_SKIP_CHID);
+! 		    first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
+! 							| F_UNDEL,
+! 							m, pc,
+! 					       THREADING() ? 0 : FSF_SKIP_CHID);
+! 		    mn_set_cur(ps_global-&gt;msgmap,
+! 			      (MsgNo) MIN((int) flagged, (int) first_recent));
+! 		}
+! 
+! 		break;
+! 
+! 	      case IS_FIRST:
+! 		mn_set_cur(ps_global-&gt;msgmap,
+! 			   first_sorted_flagged(F_UNDEL, m, pc,
+! 					      THREADING() ? 0 : FSF_SKIP_CHID));
+! 		break;
+! 
+! 	      case IS_LAST:
+! 		mn_set_cur(ps_global-&gt;msgmap,
+! 			   first_sorted_flagged(F_UNDEL, m, pc,
+! 			         FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
+! 		break;
+! 
+! 	      default:
+! 		panic(&quot;Unexpected incoming startup case&quot;);
+! 		break;
+! 
+! 	    }
+  	}
+  	else if(IS_NEWS(ps_global-&gt;mail_stream)){
+  	    /*
+--- 1120,1126 ----
+  	    else
+  	      use_this_startup_rule = ps_global-&gt;inc_startup_rule;
+  
+! 	    find_startup_position(use_this_startup_rule, m, pc);
+  	}
+  	else if(IS_NEWS(ps_global-&gt;mail_stream)){
+  	    /*
+***************
+*** 1409,1417 ****
+  	    /* Save read messages? */
+  	    if(VAR_READ_MESSAGE_FOLDER &amp;&amp; VAR_READ_MESSAGE_FOLDER[0]
+  	       &amp;&amp; sp_flagged(stream, SP_INBOX)
+! 	       &amp;&amp; (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL))){
+  
+  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
+  		   || (pith_opt_read_msg_prompt
+  		       &amp;&amp; (*pith_opt_read_msg_prompt)(seen_not_del, VAR_READ_MESSAGE_FOLDER)))
+  		  /* move inbox's read messages */
+--- 1298,1308 ----
+  	    /* Save read messages? */
+  	    if(VAR_READ_MESSAGE_FOLDER &amp;&amp; VAR_READ_MESSAGE_FOLDER[0]
+  	       &amp;&amp; sp_flagged(stream, SP_INBOX)
+! 	       &amp;&amp; (F_ON(F_AUTO_READ_MSGS_RULES, ps_global) ||
+! 		  (seen_not_del = count_flagged(stream, F_SEEN | F_UNDEL)))){
+  
+  		if(F_ON(F_AUTO_READ_MSGS,ps_global)
++ 		   || F_ON(F_AUTO_READ_MSGS_RULES, ps_global)
+  		   || (pith_opt_read_msg_prompt
+  		       &amp;&amp; (*pith_opt_read_msg_prompt)(seen_not_del, VAR_READ_MESSAGE_FOLDER)))
+  		  /* move inbox's read messages */
+***************
+*** 1682,1687 ****
+--- 1573,1581 ----
+      char	  *bufp = NULL;
+      MESSAGECACHE *mc;
+  
++     if (F_ON(F_AUTO_READ_MSGS_RULES, ps_global))
++      return move_read_msgs_using_rules(stream, dstfldr, buf);
++ 
+      if(!is_absolute_path(dstfldr)
+         &amp;&amp; !(save_context = default_save_context(ps_global-&gt;context_list)))
+        save_context = ps_global-&gt;context_list;
+***************
+*** 1721,1728 ****
+  	snprintf(buf, buflen, &quot;Moving %s read message%s to \&quot;%s\&quot;&quot;,
+  		comatose(searched), plural(searched), dstfldr);
+  	we_cancel = busy_cue(buf, NULL, 0);
+! 	if(save(ps_global, stream, save_context, dstfldr, msgmap,
+! 		SV_DELETE | SV_FIX_DELS | SV_INBOXWOCNTXT) == searched)
+  	  strncpy(bufp = buf + 1, &quot;Moved&quot;, MIN(5,buflen)); /* change Moving to Moved */
+  
+  	buf[buflen-1] = '\0';
+--- 1615,1623 ----
+  	snprintf(buf, buflen, &quot;Moving %s read message%s to \&quot;%s\&quot;&quot;,
+  		comatose(searched), plural(searched), dstfldr);
+  	we_cancel = busy_cue(buf, NULL, 0);
+! 	ps_global-&gt;exiting = 1;
+! 	if((save(ps_global, stream, save_context, dstfldr, msgmap,
+! 		SV_DELETE | SV_FIX_DELS | SV_INBOXWOCNTXT) == searched))
+  	  strncpy(bufp = buf + 1, &quot;Moved&quot;, MIN(5,buflen)); /* change Moving to Moved */
+  
+  	buf[buflen-1] = '\0';
+***************
+*** 1760,1766 ****
+         &amp;&amp; ((context_isambig(folder)
+  	    &amp;&amp; folder_is_nick(folder, FOLDERS(context), 0))
+  	   || folder_index(folder, context, FI_FOLDER) &gt; 0)
+!        &amp;&amp; (seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))){
+  
+  	for(; f &amp;&amp; *archive; archive++){
+  	    char *p;
+--- 1655,1663 ----
+         &amp;&amp; ((context_isambig(folder)
+  	    &amp;&amp; folder_is_nick(folder, FOLDERS(context), 0))
+  	   || folder_index(folder, context, FI_FOLDER) &gt; 0)
+!        &amp;&amp; ((seen_undel = count_flagged(stream, F_SEEN | F_UNDEL))
+! 	   || (F_ON(F_AUTO_READ_MSGS,ps_global) &amp;&amp;
+! 	       F_ON(F_AUTO_READ_MSGS_RULES, ps_global)))){
+  
+  	for(; f &amp;&amp; *archive; archive++){
+  	    char *p;
+***************
+*** 2714,2716 ****
+--- 2611,2912 ----
+  
+      return(*target ? target : NULL);
+  }
++ 
++ char *
++ move_read_msgs_using_rules(MAILSTREAM *stream, char *dstfldr, char *buf)
++ {
++     CONTEXT_S  *save_context = NULL;
++     char **folder_to_save = NULL;
++     int  num, we_cancel;
++     long i, j, success;
++     MSGNO_S *msgmap = NULL;
++     unsigned long nmsgs = 0L, stream_nmsgs;
++ 
++     saved_stream = stream;              /* horrible hack! */
++     if(!is_absolute_path(dstfldr)
++        &amp;&amp; !(save_context = default_save_context(ps_global-&gt;context_list)))
++        save_context = ps_global-&gt;context_list;
++ 
++     folder_to_save = (char **)fs_get((stream-&gt;nmsgs + 1)*sizeof(char *));
++     folder_to_save[0] = NULL;
++     mn_init(&amp;msgmap, stream-&gt;nmsgs);
++     stream_nmsgs = stream-&gt;nmsgs;
++     for (i = 1L; i &lt;= stream_nmsgs ; i++){
++         set_lflag(stream, msgmap, i, MN_SLCT, 0);
++         folder_to_save[i] = get_lflag(stream, NULL, i, MN_EXLD)
++                             ? NULL : get_folder_to_save(stream, i, dstfldr);
++     }
++     for (i = 1L; i &lt;= stream_nmsgs; i++){
++         num = 0;
++         if (folder_to_save[i]){
++            mn_init(&amp;msgmap, stream_nmsgs);
++            for (j = i; j &lt;= stream_nmsgs ; j++){
++                 if (folder_to_save[j]){
++                    if (!strcmp(folder_to_save[i], folder_to_save[j])){
++                         set_lflag(stream, msgmap, j, MN_SLCT, 1);
++                         num++;
++                         if (j != i)
++                            fs_give((void **)&amp;folder_to_save[j]);
++                    }
++                  }
++            }
++            pseudo_selected(msgmap);
++            sprintf(buf, &quot;Moving %s read message%s to \&quot;%.45s\&quot;&quot;,
++                       comatose(num), plural(num), folder_to_save[i]);
++            we_cancel = busy_cue(buf, NULL, 1);
++            ps_global-&gt;exiting = 1;
++            if(success = save(ps_global, stream,save_context, folder_to_save[i],
++                                 msgmap, SV_DELETE | SV_FIX_DELS))
++            nmsgs += success;
++            if(we_cancel)
++              cancel_busy_cue(success ? 0 : -1);
++            for (j = i; j &lt;= stream_nmsgs ; j++)
++                set_lflag(stream, msgmap, j, MN_SLCT, 0);
++            fs_give((void **)&amp;folder_to_save[i]);
++            mn_give(&amp;msgmap);
++         }
++     }
++     ps_global-&gt;exiting = 0; /* useful if we call from aggregate operations */
++     sprintf(buf, &quot;Moved automatically %s message%s&quot;,
++                 comatose(nmsgs), plural(nmsgs));
++     if (folder_to_save)
++         fs_give((void **)folder_to_save);
++     rule_curpos = 0L;
++     return buf;
++ }
++ 
++ char *
++ get_folder_to_save(MAILSTREAM *stream, long i, char *dstfldr)
++ {
++     MESSAGECACHE *mc = NULL;
++     RULE_RESULT *rule;
++     MSGNO_S *msgmap = NULL;
++     char *folder_to_save = NULL, *save_folder = NULL;
++     int n;
++     long msgno;
++ 
++     /* The plan is as follows: Select each message of the folder. We
++      * need to set the cursor correctly so that iFlag gets the value
++      * correctly too, otherwise iFlag will get the value of the position
++      * of the cursor. After that we need to look for a rule that applies
++      * to the message and get the saving folder. If we get a saving folder,
++      * and we used the _FLAG_ token, use that folder, if no
++      * _FLAG_ token was used, move only if seen and not deleted, to the
++      * folder specified in the saving rule. If we did not get a saving
++      * folder from the rule, just save in the default folder.
++      */
++     mn_init(&amp;msgmap, stream-&gt;nmsgs);
++     rule_curpos = i;
++     msgno = mn_m2raw(msgmap, i);
++     if (msgno &gt; 0L){
++         mc = mail_elt(stream, msgno);
++         rule = (RULE_RESULT *)
++             get_result_rule(V_SAVE_RULES, FOR_SAVE, mc-&gt;private.msg.env);
++         if (rule){
++             folder_to_save = cpystr(rule-&gt;result);
++             n = rule-&gt;number;
++             fs_give((void **)&amp;rule-&gt;result);
++             fs_give((void **)&amp;rule);
++         }
++     }
++ 
++     if (folder_to_save &amp;&amp; *folder_to_save){
++         RULELIST *list = get_rulelist_from_code(V_SAVE_RULES,
++                                                 ps_global-&gt;rule_list);
++         RULE_S *prule = get_rule(list, n);
++         if (condition_contains_token(prule-&gt;condition, &quot;_FLAG_&quot;)
++              || (mc-&gt;valid &amp;&amp; mc-&gt;seen &amp;&amp; !mc-&gt;deleted)
++              || (!mc-&gt;valid &amp;&amp; mc-&gt;searched))
++              save_folder = cpystr(folder_to_save);
++           else
++              save_folder = NULL;
++     }
++     else
++        if (!mc || (mc-&gt;seen &amp;&amp; !mc-&gt;deleted))
++           save_folder = cpystr(dstfldr);
++     mn_give(&amp;msgmap);
++     rule_curpos = 0L;
++     return save_folder;
++ }
++ 
++ MAILSTREAM *
++ find_open_stream(void)
++ {
++  return saved_stream;
++ }
++ 
++ unsigned long
++ rules_cursor_pos(MAILSTREAM *stream)
++ {
++   MSGNO_S *msgmap = sp_msgmap(stream);
++   return rule_curpos != 0L ? rule_curpos : mn_m2raw(msgmap,mn_get_cur(msgmap));
++ }
++ 
++ void
++ setup_threading_index_style(void)
++ {
++   RULE_RESULT *rule;
++   NAMEVAL_S *v;
++   int i;
++ 
++   rule = get_result_rule(V_THREAD_INDEX_STYLE_RULES, FOR_THREAD, NULL);
++   if (rule || ps_global-&gt;VAR_THREAD_INDEX_STYLE){
++      for(i = 0; v = thread_index_styles(i); i++)
++         if(!strucmp(rule ? rule-&gt;result : ps_global-&gt;VAR_THREAD_INDEX_STYLE,
++                     rule ? (v ? v-&gt;name : &quot;&quot; ) : S_OR_L(v))){
++               ps_global-&gt;thread_index_style = v-&gt;value;
++               break;
++         }
++      if (rule){
++         if (rule-&gt;result)
++            fs_give((void **)&amp;rule-&gt;result);
++         fs_give((void **)&amp;rule);
++      }
++   }
++ }
++ 
++ unsigned
++ get_perfolder_startup_rule(MAILSTREAM *stream, int rule_type, char *folder)
++ {
++     unsigned    startup_rule;
++     char        *rule_result;
++ 
++     startup_rule =  reset_startup_rule(stream);
++     rule_result = get_rule_result(FOR_STARTUP, folder, rule_type);
++     if (rule_result &amp;&amp; *rule_result){
++        int        i;
++        NAMEVAL_S *v;
++ 
++        for(i = 0; v = incoming_startup_rules(i); i++)
++           if(!strucmp(rule_result, v-&gt;name)){
++              startup_rule = v-&gt;value;
++              break;
++           }
++        fs_give((void **)&amp;rule_result);
++      }
++    return startup_rule;
++ }
++ 
++ void
++ find_startup_position(int rule, MAILSTREAM *m, long pc)
++ {
++   long n;
++   switch(rule){
++               /*
++                * For news in incoming collection we're doing the same thing
++                * for first-unseen and first-recent. In both those cases you
++                * get first-unseen if FAKE_NEW is off and first-recent if
++                * FAKE_NEW is on. If FAKE_NEW is on, first unseen is the
++                * same as first recent because all recent msgs are unseen
++                * and all unrecent msgs are seen (see pine_mail_open).
++                */
++               case IS_FIRST_UNSEEN:
++ first_unseen:
++                 mn_set_cur(ps_global-&gt;msgmap,
++                         (sp_first_unseen(m)
++                          &amp;&amp; mn_get_sort(ps_global-&gt;msgmap) == SortArrival
++                          &amp;&amp; !mn_get_revsort(ps_global-&gt;msgmap)
++                          &amp;&amp; !get_lflag(ps_global-&gt;mail_stream, NULL,
++                                        sp_first_unseen(m), MN_EXLD)
++                          &amp;&amp; (n = mn_raw2m(ps_global-&gt;msgmap,
++                                           sp_first_unseen(m))))
++                            ? n
++                            : first_sorted_flagged(F_UNSEEN | F_UNDEL, m, pc,
++                                               THREADING() ? 0 : FSF_SKIP_CHID));
++                 break;
++ 
++               case IS_FIRST_RECENT:
++ first_recent:
++                 /*
++                  * We could really use recent for news but this is the way
++                  * it has always worked, so we'll leave it. That is, if
++                  * the FAKE_NEW feature is on, recent and unseen are
++                  * equivalent, so it doesn't matter. If the feature isn't
++                  * on, all the undeleted messages are unseen and we start
++                  * at the first one. User controls with the FAKE_NEW feature.
++                  */
++                 if(IS_NEWS(ps_global-&gt;mail_stream)){
++                     mn_set_cur(ps_global-&gt;msgmap,
++                                first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
++                                                THREADING() ? 0 : FSF_SKIP_CHID));
++                 }
++                 else{
++                     mn_set_cur(ps_global-&gt;msgmap,
++                                first_sorted_flagged(F_RECENT | F_UNSEEN
++                                                     | F_UNDEL,
++                                                     m, pc,
++                                               THREADING() ? 0 : FSF_SKIP_CHID));
++                 }
++                 break;
++ 
++               case IS_FIRST_IMPORTANT:
++                 mn_set_cur(ps_global-&gt;msgmap,
++                            first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
++                                               THREADING() ? 0 : FSF_SKIP_CHID));
++                 break;
++ 
++               case IS_FIRST_IMPORTANT_OR_UNSEEN:
++ 
++                 if(IS_NEWS(ps_global-&gt;mail_stream))
++                   goto first_unseen;
++ 
++                 {
++                     MsgNo flagged, first_unseen;
++ 
++                     flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
++                                                THREADING() ? 0 : FSF_SKIP_CHID);
++                     first_unseen = (sp_first_unseen(m)
++                              &amp;&amp; mn_get_sort(ps_global-&gt;msgmap) == SortArrival
++                              &amp;&amp; !mn_get_revsort(ps_global-&gt;msgmap)
++                              &amp;&amp; !get_lflag(ps_global-&gt;mail_stream, NULL,
++                                            sp_first_unseen(m), MN_EXLD)
++                              &amp;&amp; (n = mn_raw2m(ps_global-&gt;msgmap,
++                                               sp_first_unseen(m))))
++                                 ? n
++                                 : first_sorted_flagged(F_UNSEEN|F_UNDEL, m, pc,
++                                                THREADING() ? 0 : FSF_SKIP_CHID);
++                     mn_set_cur(ps_global-&gt;msgmap,
++                           (MsgNo) MIN((int) flagged, (int) first_unseen));
++ 
++                 }
++ 
++                 break;
++ 
++               case IS_FIRST_IMPORTANT_OR_RECENT:
++ 
++                 if(IS_NEWS(ps_global-&gt;mail_stream))
++                   goto first_recent;
++ 
++                 {
++                     MsgNo flagged, first_recent;
++ 
++                     flagged = first_sorted_flagged(F_FLAG|F_UNDEL, m, pc,
++                                                THREADING() ? 0 : FSF_SKIP_CHID);
++                     first_recent = first_sorted_flagged(F_RECENT | F_UNSEEN
++                                                         | F_UNDEL,
++                                                         m, pc,
++                                                THREADING() ? 0 : FSF_SKIP_CHID);
++                     mn_set_cur(ps_global-&gt;msgmap,
++                               (MsgNo) MIN((int) flagged, (int) first_recent));
++                 }
++ 
++                 break;
++ 
++               case IS_FIRST:
++                 mn_set_cur(ps_global-&gt;msgmap,
++                            first_sorted_flagged(F_UNDEL, m, pc,
++                                               THREADING() ? 0 : FSF_SKIP_CHID));
++                 break;
++ 
++               case IS_LAST:
++                 mn_set_cur(ps_global-&gt;msgmap,
++                            first_sorted_flagged(F_UNDEL, m, pc,
++                                  FSF_LAST | (THREADING() ? 0 : FSF_SKIP_CHID)));
++                 break;
++ 
++               default:
++                 panic(&quot;Unexpected incoming startup case&quot;);
++                 break;
++ 
++   }
++ }
+diff -rc alpine-1.10/pith/mailcmd.h alpine-1.10.rules/pith/mailcmd.h
+*** alpine-1.10/pith/mailcmd.h	2007-11-08 12:39:45.000000000 -0800
+--- alpine-1.10.rules/pith/mailcmd.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 41,46 ****
+--- 41,48 ----
+  #define DB_FROMTAB	0x02	/* opening because of TAB command      */
+  #define DB_INBOXWOCNTXT	0x04	/* interpret inbox as one true inbox */
+  
++ static  MAILSTREAM *saved_stream;
++ static  unsigned long rule_curpos = 0L;
+  
+  /*
+   * generic &quot;is aggregate message command?&quot; test
+***************
+*** 61,67 ****
+--- 63,76 ----
+  void	   expunge_and_close(MAILSTREAM *, char **, unsigned long);
+  void	   agg_select_all(MAILSTREAM *, MSGNO_S *, long *, int);
+  char	  *move_read_msgs(MAILSTREAM *, char *, char *, size_t, long);
++ char	  *move_read_msgs_using_rules (MAILSTREAM *, char *, char *);
++ unsigned   get_perfolder_startup_rule (MAILSTREAM *, int, char *);
++ void	   setup_threading_index_style (void);
++ void	   find_startup_position (int, MAILSTREAM *, long);
++ char	  *get_folder_to_save (MAILSTREAM *, long, char *);
+  char	  *move_read_incoming(MAILSTREAM *, CONTEXT_S *, char *, char **, char *, size_t);
++ MAILSTREAM *find_open_stream (void);
++ unsigned   long rules_cursor_pos (MAILSTREAM *);
+  void	   cross_delete_crossposts(MAILSTREAM *);
+  long	   zoom_index(struct pine *, MAILSTREAM *, MSGNO_S *);
+  int	   unzoom_index(struct pine *, MAILSTREAM *, MSGNO_S *);
+diff -rc alpine-1.10/pith/mailindx.c alpine-1.10.rules/pith/mailindx.c
+*** alpine-1.10/pith/mailindx.c	2008-03-03 09:52:11.000000000 -0800
+--- alpine-1.10.rules/pith/mailindx.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 39,44 ****
+--- 39,45 ----
+  #include &quot;../pith/send.h&quot;
+  #include &quot;../pith/options.h&quot;
+  #include &quot;../pith/ablookup.h&quot;
++ #include &quot;../pith/rules.h&quot;
+  #ifdef _WINDOWS
+  #include &quot;../pico/osdep/mswin.h&quot;
+  #endif
+***************
+*** 103,109 ****
+  void            set_print_format(IELEM_S *, int, int);
+  void            set_ielem_widths_in_field(IFIELD_S *);
+  
+- 
+  #define BIGWIDTH 2047
+  
+  
+--- 104,109 ----
+***************
+*** 355,360 ****
+--- 355,367 ----
+      PAT_STATE     pstate;
+      PAT_S        *pat;
+      int           we_set_it = 0;
++     char *rule;
++ 
++     if(rule = get_rule_result(FOR_INDEX, ps_global-&gt;cur_folder, V_INDEX_RULES)){
++       init_index_format(rule, &amp;ps_global-&gt;index_disp_format);
++       fs_give((void **)&amp;rule);
++       return;
++     }
+  
+      if(ps_global-&gt;mail_stream &amp;&amp; nonempty_patterns(rflags, &amp;pstate)){
+  	for(pat = first_pattern(&amp;pstate); pat; pat = next_pattern(&amp;pstate)){
+***************
+*** 428,441 ****
+  static INDEX_PARSE_T itokens[] = {
+      {&quot;STATUS&quot;,		iStatus,	FOR_INDEX},
+      {&quot;MSGNO&quot;,		iMessNo,	FOR_INDEX},
+!     {&quot;DATE&quot;,		iDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;FROMORTO&quot;,	iFromTo,	FOR_INDEX},
+      {&quot;FROMORTONOTNEWS&quot;,	iFromToNotNews,	FOR_INDEX},
+      {&quot;SIZE&quot;,		iSize,		FOR_INDEX},
+      {&quot;SIZECOMMA&quot;,	iSizeComma,	FOR_INDEX},
+      {&quot;SIZENARROW&quot;,	iSizeNarrow,	FOR_INDEX},
+      {&quot;KSIZE&quot;,		iKSize,		FOR_INDEX},
+!     {&quot;SUBJECT&quot;,		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;FULLSTATUS&quot;,	iFStatus,	FOR_INDEX},
+      {&quot;IMAPSTATUS&quot;,	iIStatus,	FOR_INDEX},
+      {&quot;SHORTIMAPSTATUS&quot;,	iSIStatus,	FOR_INDEX},
+--- 435,448 ----
+  static INDEX_PARSE_T itokens[] = {
+      {&quot;STATUS&quot;,		iStatus,	FOR_INDEX},
+      {&quot;MSGNO&quot;,		iMessNo,	FOR_INDEX},
+!     {&quot;DATE&quot;,		iDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+      {&quot;FROMORTO&quot;,	iFromTo,	FOR_INDEX},
+      {&quot;FROMORTONOTNEWS&quot;,	iFromToNotNews,	FOR_INDEX},
+      {&quot;SIZE&quot;,		iSize,		FOR_INDEX},
+      {&quot;SIZECOMMA&quot;,	iSizeComma,	FOR_INDEX},
+      {&quot;SIZENARROW&quot;,	iSizeNarrow,	FOR_INDEX},
+      {&quot;KSIZE&quot;,		iKSize,		FOR_INDEX},
+!     {&quot;SUBJECT&quot;,		iSubject,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE|FOR_TRIM},
+      {&quot;FULLSTATUS&quot;,	iFStatus,	FOR_INDEX},
+      {&quot;IMAPSTATUS&quot;,	iIStatus,	FOR_INDEX},
+      {&quot;SHORTIMAPSTATUS&quot;,	iSIStatus,	FOR_INDEX},
+***************
+*** 444,498 ****
+      {&quot;SUBJECTTEXT&quot;,	iSubjectText,	FOR_INDEX},
+      {&quot;SUBJKEYTEXT&quot;,	iSubjKeyText,	FOR_INDEX},
+      {&quot;SUBJKEYINITTEXT&quot;, iSubjKeyInitText, FOR_INDEX},
+!     {&quot;OPENINGTEXT&quot;,	iOpeningText,	FOR_INDEX},
+!     {&quot;OPENINGTEXTNQ&quot;,	iOpeningTextNQ,	FOR_INDEX},
+!     {&quot;KEY&quot;,		iKey,		FOR_INDEX},
+!     {&quot;KEYINIT&quot;,		iKeyInit,	FOR_INDEX},
+      {&quot;DESCRIPSIZE&quot;,	iDescripSize,	FOR_INDEX},
+      {&quot;ATT&quot;,		iAtt,		FOR_INDEX},
+      {&quot;SCORE&quot;,		iScore,		FOR_INDEX},
+      {&quot;PRIORITY&quot;,	iPrio,		FOR_INDEX},
+      {&quot;PRIORITYALPHA&quot;,	iPrioAlpha,	FOR_INDEX},
+!     {&quot;PRIORITY!&quot;,	iPrioBang,	FOR_INDEX},
+!     {&quot;LONGDATE&quot;,	iLDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SHORTDATE1&quot;,	iS1Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SHORTDATE2&quot;,	iS2Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SHORTDATE3&quot;,	iS3Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SHORTDATE4&quot;,	iS4Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DATEISO&quot;,		iDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SHORTDATEISO&quot;,	iDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATE&quot;,	iSDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTTIME&quot;,	iSTime,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATEISO&quot;,	iSDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATESHORTISO&quot;,iSDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATES1&quot;,	iSDateS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATES2&quot;,	iSDateS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATES3&quot;,	iSDateS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATES4&quot;,	iSDateS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIME&quot;,	iSDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMEISO&quot;,iSDateTimeIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMESHORTISO&quot;,iSDateTimeIsoS,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES1&quot;,	iSDateTimeS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES2&quot;,	iSDateTimeS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES3&quot;,	iSDateTimeS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES4&quot;,	iSDateTimeS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIME24&quot;,		iSDateTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMEISO24&quot;,	iSDateTimeIso24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMESHORTISO24&quot;,iSDateTimeIsoS24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES124&quot;,	iSDateTimeS124,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES224&quot;,	iSDateTimeS224,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES324&quot;,	iSDateTimeS324,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SMARTDATETIMES424&quot;,	iSDateTimeS424,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;TIME24&quot;,		iTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;TIME12&quot;,		iTime12,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;TIMEZONE&quot;,	iTimezone,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;MONTHABBREV&quot;,	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DAYOFWEEKABBREV&quot;,	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DAYOFWEEK&quot;,	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;FROM&quot;,		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;TO&quot;,		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;SENDER&quot;,		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;CC&quot;,		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;RECIPS&quot;,		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;NEWS&quot;,		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;TOANDNEWS&quot;,	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+--- 451,508 ----
+      {&quot;SUBJECTTEXT&quot;,	iSubjectText,	FOR_INDEX},
+      {&quot;SUBJKEYTEXT&quot;,	iSubjKeyText,	FOR_INDEX},
+      {&quot;SUBJKEYINITTEXT&quot;, iSubjKeyInitText, FOR_INDEX},
+!     {&quot;OPENINGTEXT&quot;,	iOpeningText,	FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_TRIM},
+!     {&quot;OPENINGTEXTNQ&quot;,	iOpeningTextNQ,	FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_TRIM},
+!     {&quot;KEY&quot;,		iKey,		FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_COMPOSE},
+!     {&quot;KEYINIT&quot;,		iKeyInit,	FOR_INDEX|FOR_RULE|FOR_SAVE|FOR_COMPOSE},
+      {&quot;DESCRIPSIZE&quot;,	iDescripSize,	FOR_INDEX},
+      {&quot;ATT&quot;,		iAtt,		FOR_INDEX},
+      {&quot;SCORE&quot;,		iScore,		FOR_INDEX},
+      {&quot;PRIORITY&quot;,	iPrio,		FOR_INDEX},
+      {&quot;PRIORITYALPHA&quot;,	iPrioAlpha,	FOR_INDEX},
+!     {&quot;PRIORITY!&quot;,	iPrioBang,	FOR_INDEX},  
+!     {&quot;LONGDATE&quot;,	iLDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SHORTDATE1&quot;,	iS1Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SHORTDATE2&quot;,	iS2Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SHORTDATE3&quot;,	iS3Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SHORTDATE4&quot;,	iS4Date,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;DATEISO&quot;,		iDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SHORTDATEISO&quot;,	iDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATE&quot;,	iSDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTTIME&quot;,	iSTime,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATEISO&quot;,	iSDateIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATESHORTISO&quot;,iSDateIsoS,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATES1&quot;,	iSDateS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATES2&quot;,	iSDateS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATES3&quot;,	iSDateS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATES4&quot;,	iSDateS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIME&quot;,	iSDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMEISO&quot;,iSDateTimeIso,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMESHORTISO&quot;,iSDateTimeIsoS,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES1&quot;,	iSDateTimeS1,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES2&quot;,	iSDateTimeS2,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES3&quot;,	iSDateTimeS3,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES4&quot;,	iSDateTimeS4,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIME24&quot;,		iSDateTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMEISO24&quot;,	iSDateTimeIso24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMESHORTISO24&quot;,iSDateTimeIsoS24,FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES124&quot;,	iSDateTimeS124,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES224&quot;,	iSDateTimeS224,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES324&quot;,	iSDateTimeS324,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;SMARTDATETIMES424&quot;,	iSDateTimeS424,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;TIME24&quot;,		iTime24,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;TIME12&quot;,		iTime12,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;TIMEZONE&quot;,	iTimezone,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;MONTHABBREV&quot;,	iMonAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;DAYOFWEEKABBREV&quot;,	iDayOfWeekAbb,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;DAYOFWEEK&quot;,	iDayOfWeek,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;FROM&quot;,		iFrom,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_COMPOSE},
+!     {&quot;TO&quot;,		iTo,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_COMPOSE},
+!     {&quot;SENDER&quot;,		iSender,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;CC&quot;,		iCc,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_SAVE|FOR_SAVE},
+!     {&quot;ADDRESSTO&quot;,	iAddressTo,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;ADDRESSCC&quot;,	iAddressCc,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;ADDRESSRECIPS&quot;,	iAddressRecip,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+      {&quot;RECIPS&quot;,		iRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;NEWS&quot;,		iNews,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;TOANDNEWS&quot;,	iToAndNews,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+***************
+*** 501,556 ****
+      {&quot;NEWSANDRECIPS&quot;,	iNewsAndRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;MSGID&quot;,		iMsgID,		FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;CURNEWS&quot;,		iCurNews,	FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DAYDATE&quot;,		iRDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;PREFDATE&quot;,	iPrefDate,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;PREFTIME&quot;,	iPrefTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;PREFDATETIME&quot;,	iPrefDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DAY&quot;,		iDay,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DAYORDINAL&quot;,	iDayOrdinal,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DAY2DIGIT&quot;,	iDay2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;MONTHLONG&quot;,	iMonLong,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;MONTH&quot;,		iMon,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;MONTH2DIGIT&quot;,	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;YEAR&quot;,		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;YEAR2DIGIT&quot;,	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;ADDRESS&quot;,		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;MAILBOX&quot;,		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;ROLENICK&quot;,       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;INIT&quot;,		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;CURDATE&quot;,		iCurDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURDATEISO&quot;,	iCurDateIso,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURDATEISOS&quot;,	iCurDateIsoS,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURTIME24&quot;,	iCurTime24,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURTIME12&quot;,	iCurTime12,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURDAY&quot;,		iCurDay,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURDAY2DIGIT&quot;,	iCurDay2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURDAYOFWEEK&quot;,	iCurDayOfWeek,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+      {&quot;CURDAYOFWEEKABBREV&quot;, iCurDayOfWeekAbb,
+! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURMONTH&quot;,	iCurMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURMONTH2DIGIT&quot;,	iCurMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURMONTHLONG&quot;,	iCurMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURMONTHABBREV&quot;,	iCurMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURYEAR&quot;,		iCurYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURYEAR2DIGIT&quot;,	iCurYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURPREFDATE&quot;,	iCurPrefDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;CURPREFTIME&quot;,	iCurPrefTime,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+      {&quot;CURPREFDATETIME&quot;,	iCurPrefDateTime,
+! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;LASTMONTH&quot;,	iLstMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;LASTMONTH2DIGIT&quot;,	iLstMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;LASTMONTHLONG&quot;,	iLstMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;LASTMONTHABBREV&quot;,	iLstMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;LASTMONTHYEAR&quot;,	iLstMonYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+      {&quot;LASTMONTHYEAR2DIGIT&quot;, iLstMonYear2Digit,
+! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;LASTYEAR&quot;,	iLstYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+!     {&quot;LASTYEAR2DIGIT&quot;,	iLstYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT},
+      {&quot;HEADER&quot;,		iHeader,	FOR_INDEX},
+      {&quot;TEXT&quot;,		iText,		FOR_INDEX},
+      {&quot;ARROW&quot;,		iArrow,		FOR_INDEX},
+      {&quot;NEWLINE&quot;,		iNewLine,	FOR_REPLY_INTRO},
+      {&quot;CURSORPOS&quot;,	iCursorPos,	FOR_TEMPLATE},
+      {NULL,		iNothing,	FOR_NOTHING}
+  };
+  
+--- 511,578 ----
+      {&quot;NEWSANDRECIPS&quot;,	iNewsAndRecips,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;MSGID&quot;,		iMsgID,		FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;CURNEWS&quot;,		iCurNews,	FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;DAYDATE&quot;,		iRDate,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;PREFDATE&quot;,	iPrefDate,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;PREFTIME&quot;,	iPrefTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;PREFDATETIME&quot;,	iPrefDateTime,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;DAY&quot;,		iDay,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;DAYORDINAL&quot;,	iDayOrdinal,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;DAY2DIGIT&quot;,	iDay2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;MONTHLONG&quot;,	iMonLong,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;MONTH&quot;,		iMon,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;MONTH2DIGIT&quot;,	iMon2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;YEAR&quot;,		iYear,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;YEAR2DIGIT&quot;,	iYear2Digit,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE|FOR_SAVE},
+!     {&quot;ADDRESS&quot;,		iAddress,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_RULE},
+      {&quot;MAILBOX&quot;,		iMailbox,	FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;ROLENICK&quot;,       	iRoleNick,	FOR_REPLY_INTRO|FOR_TEMPLATE},
+      {&quot;INIT&quot;,		iInit,		FOR_INDEX|FOR_REPLY_INTRO|FOR_TEMPLATE},
+!     {&quot;CURDATE&quot;,		iCurDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURDATEISO&quot;,	iCurDateIso,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURDATEISOS&quot;,	iCurDateIsoS,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURTIME24&quot;,	iCurTime24,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURTIME12&quot;,	iCurTime12,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURDAY&quot;,		iCurDay,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURDAY2DIGIT&quot;,	iCurDay2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURDAYOFWEEK&quot;,	iCurDayOfWeek,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+      {&quot;CURDAYOFWEEKABBREV&quot;, iCurDayOfWeekAbb,
+! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURMONTH&quot;,	iCurMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURMONTH2DIGIT&quot;,	iCurMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURMONTHLONG&quot;,	iCurMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURMONTHABBREV&quot;,	iCurMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURYEAR&quot;,		iCurYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURYEAR2DIGIT&quot;,	iCurYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURPREFDATE&quot;,	iCurPrefDate,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;CURPREFTIME&quot;,	iCurPrefTime,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+      {&quot;CURPREFDATETIME&quot;,	iCurPrefDateTime,
+! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;LASTMONTH&quot;,	iLstMon,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;LASTMONTH2DIGIT&quot;,	iLstMon2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;LASTMONTHLONG&quot;,	iLstMonLong,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;LASTMONTHABBREV&quot;,	iLstMonAbb,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;LASTMONTHYEAR&quot;,	iLstMonYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+      {&quot;LASTMONTHYEAR2DIGIT&quot;, iLstMonYear2Digit,
+! 					FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;LASTYEAR&quot;,	iLstYear,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+!     {&quot;LASTYEAR2DIGIT&quot;,	iLstYear2Digit,	FOR_REPLY_INTRO|FOR_TEMPLATE|FOR_FILT|FOR_RULE|FOR_SAVE},
+      {&quot;HEADER&quot;,		iHeader,	FOR_INDEX},
+      {&quot;TEXT&quot;,		iText,		FOR_INDEX},
+      {&quot;ARROW&quot;,		iArrow,		FOR_INDEX},
+      {&quot;NEWLINE&quot;,		iNewLine,	FOR_REPLY_INTRO},
+      {&quot;CURSORPOS&quot;,	iCursorPos,	FOR_TEMPLATE},
++     {&quot;NICK&quot;,		iNick,		FOR_RULE|FOR_SAVE},
++     {&quot;FOLDER&quot;,		iFolder,	FOR_RULE|FOR_SAVE|FOR_FOLDER},
++     {&quot;ROLE&quot;,		iRole,		FOR_RULE|FOR_RESUB|FOR_TRIM|FOR_TEMPLATE},
++     {&quot;PROCID&quot;,		iProcid,	FOR_RULE|FOR_RESUB|FOR_FLAG|FOR_COMPOSE|FOR_TRIM|FOR_TEMPLATE},
++     {&quot;PKEY&quot;,		iPkey,		FOR_RULE|FOR_KEY},
++     {&quot;SCREEN&quot;,		iScreen,	FOR_RULE|FOR_KEY},
++     {&quot;FLAG&quot;,		iFlag,		FOR_RULE|FOR_SAVE|FOR_FLAG},
++     {&quot;COLLECTION&quot;,	iCollection,	FOR_RULE|FOR_SAVE|FOR_COMPOSE|FOR_FOLDER},
++     {&quot;BCC&quot;,		iBcc,		FOR_COMPOSE|FOR_RULE},
++     {&quot;LCC&quot;,		iLcc,		FOR_COMPOSE|FOR_RULE},
++     {&quot;FORWARDFROM&quot;,	iFfrom,		FOR_COMPOSE|FOR_RULE},
++     {&quot;FORWARDADDRESS&quot;,	iFadd,		FOR_COMPOSE|FOR_RULE},
+      {NULL,		iNothing,	FOR_NOTHING}
+  };
+  
+***************
+*** 2433,2438 ****
+--- 2455,2478 ----
+  		from_str(cdesc-&gt;ctype, idata, str, sizeof(str), ice);
+  	        break;
+  
++ 	      case iAddressTo:
++ 	      case iAddressCc:
++ 	      case iAddressRecip:
++ 		{ENVELOPE *env;
++ 		 int we_clear;
++ 		env = rules_fetchenvelope(idata, &amp;we_clear); 
++ 		sprintf(str, &quot;%-*.*s&quot;, ifield-&gt;width, ifield-&gt;width,
++ 		        detoken_src((cdesc-&gt;ctype == iAddressTo 
++ 				? &quot;_ADDRESSTO_&quot;
++ 				: (cdesc-&gt;ctype == iAddressCc
++ 				   ? &quot;_ADRESSCC_&quot;
++ 				   : &quot;_ADRESSRECIPS_&quot;)), FOR_INDEX, 
++ 				env, NULL, NULL, NULL));
++ 		if(we_clear)
++ 		   mail_free_envelope(&amp;env);
++ 		}
++ 		break;
++ 
+  	      case iTo:
+  		if(((field = ((addr = fetch_to(idata))
+  			      ? &quot;To&quot;
+***************
+*** 3763,3769 ****
+--- 3803,3819 ----
+  
+  			if(p &gt; buf){
+  			    size_t l;
++ 			    ENVELOPE *env;
++ 			    char *rule_result;
+  
++ 			    if(rule_result = find_value((delete_quotes
++ 				      ? &quot;_OPENINGTEXTNQ_&quot; : &quot;_OPENINGTEXT_&quot;), 
++ 				      buf, PROCESS_SP, idata, 4)){
++ 			      collspaces(rule_result);
++ 			      strncpy(buf, rule_result, sizeof(buf));
++ 			      buf[sizeof(buf) - 1] = '\0';
++ 			      fs_give((void **) &amp;rule_result);
++ 			    }
+  			    l = strlen(buf);
+  			    l += 100;
+  			    firsttext = fs_get((l+1) * sizeof(char));
+***************
+*** 5226,5235 ****
+  {
+      char          *subject, *origsubj, *origstr, *rawsubj, *sptr = NULL;
+      char          *p, *border, *q = NULL, *free_subj = NULL;
+!     char	  *sp;
+      size_t         len;
+      int            width = -1;
+!     int            depth = 0, mult = 2;
+      int            save;
+      int            do_subj = 0, truncated_tree = 0;
+      PINETHRD_S    *thd, *thdorig;
+--- 5276,5285 ----
+  {
+      char          *subject, *origsubj, *origstr, *rawsubj, *sptr = NULL;
+      char          *p, *border, *q = NULL, *free_subj = NULL;
+!     char	  *sp, *rule_result;
+      size_t         len;
+      int            width = -1;
+!     int            depth = 0, mult = 2, collapsed, i, we_clear = 0;
+      int            save;
+      int            do_subj = 0, truncated_tree = 0;
+      PINETHRD_S    *thd, *thdorig;
+***************
+*** 5283,5289 ****
+       * origsubj is the original subject but it has been decoded. We need
+       * to free it at the end of this routine.
+       */
+! 
+  
+      /*
+       * prepend_keyword will put the keyword stuff before the subject
+--- 5333,5345 ----
+       * origsubj is the original subject but it has been decoded. We need
+       * to free it at the end of this routine.
+       */
+!     if (rule_result = find_value(&quot;_SUBJECT_&quot;, origsubj, USE_RAW_SP, idata, 4)){
+!        if(origsubj)
+! 	 fs_give((void **)&amp;origsubj);
+!        we_clear++;
+!        origsubj = cpystr(rule_result);
+!        fs_give((void **)&amp;rule_result);
+!     }
+  
+      /*
+       * prepend_keyword will put the keyword stuff before the subject
+***************
+*** 5724,5729 ****
+--- 5780,5788 ----
+  
+      if(free_subj)
+        fs_give((void **) &amp;free_subj);
++ 
++     if (we_clear &amp;&amp; origsubj)
++       fs_give((void **)&amp;origsubj);
+  }
+  
+  
+***************
+*** 6092,6107 ****
+  				 ? &quot;To&quot;
+  				 : (addr = fetch_cc(idata))
+  				 ? &quot;Cc&quot;
+! 				 : NULL))
+! 		       &amp;&amp; set_index_addr(idata, field, addr, &quot;To: &quot;,
+! 					 strsize-1, fptr))
+! 		      break;
+  
+  		    if(ctype == iFromTo &amp;&amp;
+  		       (newsgroups = fetch_newsgroups(idata)) &amp;&amp;
+  		       *newsgroups){
+! 			snprintf(fptr, strsize, &quot;To: %-*.*s&quot;, strsize-1-4, strsize-1-4,
+! 				newsgroups);
+  			break;
+  		    }
+  
+--- 6151,6183 ----
+  				 ? &quot;To&quot;
+  				 : (addr = fetch_cc(idata))
+  				 ? &quot;Cc&quot;
+! 				 : NULL))){
+! 			  char *rule_result;
+! 			  rule_result = find_value(&quot;_FROM_&quot;, NULL, 0, idata, 1);
+! 			  if (!rule_result)
+! 			  set_index_addr(idata, field, addr, &quot;To: &quot;,
+! 				strsize-1, fptr);
+! 			  else{
+! 			    sprintf(str, &quot;%-*.*s&quot;, strsize-1, strsize-1, 
+! 								rule_result);
+! 			    fs_give((void **)&amp;rule_result);
+! 			  }
+  
++ 		      break;
++ 		    }
+  		    if(ctype == iFromTo &amp;&amp;
+  		       (newsgroups = fetch_newsgroups(idata)) &amp;&amp;
+  		       *newsgroups){
+! 			   char *rule_result;
+! 			   rule_result = find_value(&quot;_FROM_&quot;, NULL, 0, idata, 1);
+! 			   if (!rule_result)
+! 				sprintf(str, &quot;To: %-*.*s&quot;, strsize-1-4, 
+! 					strsize-1-4, newsgroups);
+! 				else{
+! 				  sprintf(str, &quot;%-*.*s&quot;, strsize-1, strsize-1,
+! 							 rule_result);
+! 				  fs_give((void **)&amp;rule_result);
+! 				}
+  			break;
+  		    }
+  
+***************
+*** 6114,6120 ****
+  	      break;
+  
+  	  case iFrom:
+! 	    set_index_addr(idata, &quot;From&quot;, fetch_from(idata), NULL, strsize-1, fptr);
+  	    break;
+  
+  	  case iAddress:
+--- 6190,6204 ----
+  	      break;
+  
+  	  case iFrom:
+! 	   { char *rule_result;
+! 	     rule_result = find_value(&quot;_FROM_&quot;, NULL, 0, idata, 4);
+! 	     if (!rule_result) 
+! 	      set_index_addr(idata, &quot;From&quot;, fetch_from(idata), NULL, strsize-1, fptr);
+! 	     else{
+! 		sprintf(str, &quot;%-*.*s&quot;, strsize-1, strsize-1, rule_result);
+! 		fs_give((void **)&amp;rule_result);
+! 	     }
+! 	   }
+  	    break;
+  
+  	  case iAddress:
+***************
+*** 6411,6413 ****
+--- 6495,6558 ----
+  	}
+      }
+  }
++ 
++ void
++ setup_threading_display_style(void)
++ {
++   RULE_RESULT *rule;
++   NAMEVAL_S *v;
++   int i;
++ 
++   rule = get_result_rule(V_THREAD_DISP_STYLE_RULES, FOR_THREAD, NULL);
++   if (rule || ps_global-&gt;VAR_THREAD_DISP_STYLE){
++      for(i = 0; v = thread_disp_styles(i); i++)
++         if(!strucmp(rule ? rule-&gt;result : ps_global-&gt;VAR_THREAD_DISP_STYLE, 
++ 		    rule ? (v ? v-&gt;name : &quot;&quot; ) : S_OR_L(v))){
++               ps_global-&gt;thread_disp_style = v-&gt;value;
++               break;
++         }
++      if (rule){
++ 	if (rule-&gt;result)
++ 	   fs_give((void **)&amp;rule-&gt;result);
++ 	fs_give((void **)&amp;rule);
++      }
++   }
++ }
++ 
++ char *
++ find_value(char *token, char *use_this, int flag, INDEXDATA_S *idata, int nfcn)
++ {
++  int n = 0, i, rule_context, we_clear;
++  char  *rule_result = NULL, **list;
++  ENVELOPE *env;
++  RULELIST *rule;
++  RULE_S *prule;
++ 
++  env = rules_fetchenvelope(idata, &amp;we_clear);
++  if(env &amp;&amp; env-&gt;sparep)
++     fs_give((void **)&amp;env-&gt;sparep);
++  if(we_clear)
++    mail_free_envelope(&amp;env);
++  if(rule = get_rulelist_from_code(V_REPLACE_RULES, ps_global-&gt;rule_list)){
++     list = functions_for_token(token);
++     while(rule_result == NULL &amp;&amp; (prule = get_rule(rule,n++))){
++         rule_context = 0;
++         if (prule-&gt;action-&gt;token &amp;&amp; !strcmp(prule-&gt;action-&gt;token, token)){
++            for (i = 0; i &lt; nfcn; i++)
++               if(list[i+1] &amp;&amp; !strcmp(prule-&gt;action-&gt;function, list[i+1]))
++                  rule_context |= context_for_function(list[i+1]);
++            if (rule_context){
++ 	      env = rules_fetchenvelope(idata, &amp;we_clear);
++ 	      if(use_this)
++ 		env-&gt;sparep = get_sparep_for_rule(use_this, flag);
++ 	     rule_result = process_rule(prule, rule_context, env);
++ 	     if(env-&gt;sparep)
++ 		free_sparep_for_rule(&amp;env-&gt;sparep);
++ 	     if(we_clear)
++ 	       mail_free_envelope(&amp;env);
++ 	   }
++         }
++     }
++  }
++  return rule_result;
++ }
+diff -rc alpine-1.10/pith/mailindx.h alpine-1.10.rules/pith/mailindx.h
+*** alpine-1.10/pith/mailindx.h	2008-02-01 10:42:29.000000000 -0800
+--- alpine-1.10.rules/pith/mailindx.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 29,34 ****
+--- 29,37 ----
+  
+  
+  /* exported prototypes */
++ SortOrder      translate (char *, int);
++ char	      *find_value (char *, char *, int, INDEXDATA_S *, int);
++ void	       setup_threading_display_style (void);
+  int	       msgline_hidden(MAILSTREAM *, MSGNO_S *, long, int);
+  void	       adjust_cur_to_visible(MAILSTREAM *, MSGNO_S *);
+  unsigned long  line_hash(char *);
+diff -rc alpine-1.10/pith/Makefile.am alpine-1.10.rules/pith/Makefile.am
+*** alpine-1.10/pith/Makefile.am	2007-10-25 14:57:54.000000000 -0700
+--- alpine-1.10.rules/pith/Makefile.am	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 25,31 ****
+  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
+  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
+  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
+! 	readfile.c remote.c reply.c rfc2231.c save.c search.c sequence.c send.c sort.c \
+  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
+  	thread.c adjtime.c url.c util.c helptext.c
+  
+--- 25,31 ----
+  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
+  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
+  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
+! 	readfile.c remote.c reply.c rfc2231.c rules.c save.c search.c sequence.c send.c sort.c \
+  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
+  	thread.c adjtime.c url.c util.c helptext.c
+  
+diff -rc alpine-1.10/pith/Makefile.in alpine-1.10.rules/pith/Makefile.in
+*** alpine-1.10/pith/Makefile.in	2008-01-11 11:15:07.000000000 -0800
+--- alpine-1.10.rules/pith/Makefile.in	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 77,83 ****
+  	margin.$(OBJEXT) mimedesc.$(OBJEXT) mimetype.$(OBJEXT) \
+  	msgno.$(OBJEXT) newmail.$(OBJEXT) news.$(OBJEXT) \
+  	pattern.$(OBJEXT) pipe.$(OBJEXT) readfile.$(OBJEXT) \
+! 	remote.$(OBJEXT) reply.$(OBJEXT) rfc2231.$(OBJEXT) \
+  	save.$(OBJEXT) search.$(OBJEXT) sequence.$(OBJEXT) \
+  	send.$(OBJEXT) sort.$(OBJEXT) state.$(OBJEXT) status.$(OBJEXT) \
+  	store.$(OBJEXT) stream.$(OBJEXT) string.$(OBJEXT) \
+--- 77,83 ----
+  	margin.$(OBJEXT) mimedesc.$(OBJEXT) mimetype.$(OBJEXT) \
+  	msgno.$(OBJEXT) newmail.$(OBJEXT) news.$(OBJEXT) \
+  	pattern.$(OBJEXT) pipe.$(OBJEXT) readfile.$(OBJEXT) \
+! 	remote.$(OBJEXT) reply.$(OBJEXT) rfc2231.$(OBJEXT) rules.$(OBJEXT) \
+  	save.$(OBJEXT) search.$(OBJEXT) sequence.$(OBJEXT) \
+  	send.$(OBJEXT) sort.$(OBJEXT) state.$(OBJEXT) status.$(OBJEXT) \
+  	store.$(OBJEXT) stream.$(OBJEXT) string.$(OBJEXT) \
+***************
+*** 274,280 ****
+  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
+  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
+  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
+! 	readfile.c remote.c reply.c rfc2231.c save.c search.c sequence.c send.c sort.c \
+  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
+  	thread.c adjtime.c url.c util.c helptext.c
+  
+--- 274,280 ----
+  	filter.c flag.c folder.c handle.c help.c helpindx.c hist.c icache.c imap.c init.c \
+  	keyword.c ldap.c list.c mailcap.c mailcmd.c mailindx.c maillist.c mailview.c \
+  	margin.c mimedesc.c mimetype.c msgno.c newmail.c news.c pattern.c pipe.c \
+! 	readfile.c remote.c reply.c rfc2231.c rules.c save.c search.c sequence.c send.c sort.c \
+  	state.c status.c store.c stream.c string.c strlst.c takeaddr.c tempfile.c text.c \
+  	thread.c adjtime.c url.c util.c helptext.c
+  
+***************
+*** 401,406 ****
+--- 401,407 ----
+  @AMDEP_TRUE@@am__include@ @<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">am__quote at .</A>/$(DEPDIR)/<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">thread.Po at am__quote</A>@
+  @AMDEP_TRUE@@am__include@ @<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">am__quote at .</A>/$(DEPDIR)/<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">url.Po at am__quote</A>@
+  @AMDEP_TRUE@@am__include@ @<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">am__quote at .</A>/$(DEPDIR)/<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">util.Po at am__quote</A>@
++ @AMDEP_TRUE@@am__include@ @<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">am__quote at .</A>/$(DEPDIR)/<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">rules.Po at am__quote</A>@
+  
+  .c.o:
+  @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $&lt;
+diff -rc alpine-1.10/pith/makefile.wnt alpine-1.10.rules/pith/makefile.wnt
+*** alpine-1.10/pith/makefile.wnt	2007-10-24 14:58:00.000000000 -0700
+--- alpine-1.10.rules/pith/makefile.wnt	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 44,50 ****
+  	init.h keyword.h ldap.h list.h mailcap.h mailcmd.h mailindx.h maillist.h \
+  	mailpart.h mailview.h margin.h mimedesc.h mimetype.h msgno.h newmail.h news.h \
+  	options.h pattern.h pineelt.h pipe.h readfile.h remote.h remtype.h repltype.h reply.h \
+! 	rfc2231.h save.h savetype.h search.h send.h sequence.h signal.h sort.h sorttype.h \
+  	state.h status.h store.h stream.h string.h strlst.h takeaddr.h tempfile.h text.h \
+  	thread.h url.h user.h util.h
+  
+--- 44,50 ----
+  	init.h keyword.h ldap.h list.h mailcap.h mailcmd.h mailindx.h maillist.h \
+  	mailpart.h mailview.h margin.h mimedesc.h mimetype.h msgno.h newmail.h news.h \
+  	options.h pattern.h pineelt.h pipe.h readfile.h remote.h remtype.h repltype.h reply.h \
+! 	rfc2231.h rules.h save.h savetype.h search.h send.h sequence.h signal.h sort.h sorttype.h \
+  	state.h status.h store.h stream.h string.h strlst.h takeaddr.h tempfile.h text.h \
+  	thread.h url.h user.h util.h
+  
+***************
+*** 53,59 ****
+  	filter.obj flag.obj folder.obj handle.obj help.obj helptext.obj hist.obj icache.obj imap.obj init.obj \
+  	keyword.obj ldap.obj list.obj mailcap.obj mailcmd.obj mailindx.obj maillist.obj mailview.obj \
+  	margin.obj mimedesc.obj mimetype.obj msgno.obj newmail.obj news.obj pattern.obj pipe.obj \
+! 	readfile.obj remote.obj reply.obj rfc2231.obj save.obj search.obj sequence.obj send.obj sort.obj state.obj \
+  	status.obj store.obj stream.obj string.obj strlst.obj takeaddr.obj tempfile.obj text.obj \
+  	thread.obj adjtime.obj url.obj util.obj
+  
+--- 53,59 ----
+  	filter.obj flag.obj folder.obj handle.obj help.obj helptext.obj hist.obj icache.obj imap.obj init.obj \
+  	keyword.obj ldap.obj list.obj mailcap.obj mailcmd.obj mailindx.obj maillist.obj mailview.obj \
+  	margin.obj mimedesc.obj mimetype.obj msgno.obj newmail.obj news.obj pattern.obj pipe.obj \
+! 	readfile.obj remote.obj reply.obj rfc2231.obj rules.obj save.obj search.obj sequence.obj send.obj sort.obj state.obj \
+  	status.obj store.obj stream.obj string.obj strlst.obj takeaddr.obj tempfile.obj text.obj \
+  	thread.obj adjtime.obj url.obj util.obj
+  
+diff -rc alpine-1.10/pith/pine.hlp alpine-1.10.rules/pith/pine.hlp
+*** alpine-1.10/pith/pine.hlp	2008-03-14 11:34:08.000000000 -0700
+--- alpine-1.10.rules/pith/pine.hlp	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 2962,2967 ****
+--- 2962,2968 ----
+  &lt;li&gt;&lt;a href=&quot;h_config_alt_role_menu&quot;&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_alternate-role-menu&quot;--&gt;&lt;/a&gt;
+  &lt;li&gt;&lt;a href=&quot;h_config_force_low_speed&quot;&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_assume-slow-link&quot;--&gt;&lt;/a&gt;
+  &lt;li&gt;&lt;a href=&quot;h_config_auto_read_msgs&quot;&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_auto-move-read-msgs&quot;--&gt;&lt;/a&gt;
++ &lt;li&gt;&lt;a href=&quot;h_config_auto_read_msgs_rules&quot;&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_auto-move-read-msgs-using-rules&quot;--&gt;&lt;/a&gt;
+  &lt;li&gt;&lt;a href=&quot;h_config_auto_open_unread&quot;&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_auto-open-next-unread&quot;--&gt;&lt;/a&gt;
+  &lt;li&gt;&lt;a href=&quot;h_config_auto_unselect&quot;&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_auto-unselect-after-apply&quot;--&gt;&lt;/a&gt;
+  &lt;li&gt;&lt;a href=&quot;h_config_auto_unzoom&quot;&gt;FEATURE: &lt;!--#echo var=&quot;FEAT_auto-unzoom-after-apply&quot;--&gt;&lt;/a&gt;
+***************
+*** 17972,17977 ****
+--- 17973,17979 ----
+  &lt;A HREF=&quot;h_config_index_format&quot;&gt;&amp;quot;&lt;!--#echo var=&quot;VAR_index-format&quot;--&gt;&amp;quot;&lt;/A&gt; option,
+  in the &lt;A HREF=&quot;h_config_reply_intro&quot;&gt;&amp;quot;&lt;!--#echo var=&quot;VAR_reply-leadin&quot;--&gt;&amp;quot;&lt;/A&gt; option,
+  in signature files,
++ in the &lt;A HREF=&quot;h_config_reply_leadin_rules&quot;&gt;&amp;quot;new-rules&amp;quot; option&lt;/A&gt;,
+  in template files used in
+  &lt;A HREF=&quot;h_rules_roles&quot;&gt;&amp;quot;roles&amp;quot;&lt;/A&gt;, and in the folder name
+  that is the target of a Filter Rule.
+***************
+*** 17984,17990 ****
+  &lt;P&gt;
+  &lt;P&gt;
+  
+! &lt;H1&gt;&lt;EM&gt;Tokens Available for all Cases (except Filter Rules)&lt;/EM&gt;&lt;/H1&gt;
+  
+  &lt;DL&gt;
+  &lt;DT&gt;SUBJECT&lt;/DT&gt;
+--- 17986,17992 ----
+  &lt;P&gt;
+  &lt;P&gt;
+  
+! &lt;H1&gt;&lt;EM&gt;Tokens Available for all Cases (except Filter Rules or in some cases for new-rules)&lt;/EM&gt;&lt;/H1&gt;
+  
+  &lt;DL&gt;
+  &lt;DT&gt;SUBJECT&lt;/DT&gt;
+***************
+*** 18017,18022 ****
+--- 18019,18033 ----
+  For example, &amp;quot;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mailbox at domain</A>&amp;quot;.
+  &lt;/DD&gt;
+  
++ &lt;DT&gt;ADDRESSTO&lt;/DT&gt;
++ &lt;DD&gt;
++ This is similar to the &amp;quot;TO&amp;quot; token, only it is always the
++ email address of all people listed in the TO: field of the messages. Addresses
++ are separated by a blank space. Example, &amp;quot;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mailbox at domain</A>&amp;quot; when
++ the e-mail message contains only one person in the To: field, or
++ &amp;quot;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">peter at flintstones.com</A> <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">president at world.com</A>&amp;quot;.
++ &lt;/DD&gt;
++ 
+  &lt;DT&gt;MAILBOX&lt;/DT&gt;
+  &lt;DD&gt;
+  This is the same as the &amp;quot;ADDRESS&amp;quot; except that the 
+***************
+*** 18064,18069 ****
+--- 18075,18089 ----
+  message's &amp;quot;Cc:&amp;quot; header field.
+  &lt;/DD&gt;
+  
++ &lt;DT&gt;ADDRESSCC&lt;/DT&gt;
++ &lt;DD&gt;
++ This is similar to the &amp;quot;CC&amp;quot; token, only it is always the
++ email address of all people listed in the Cc: field of the messages. Addresses
++ are separated by a blank space. Example: &amp;quot;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mailbox at domain</A>&amp;quot; when
++ the e-mail message contains only one person in the Cc: field, or
++ &amp;quot;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">peter at flintstones.com</A> <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">president at world.com</A>&amp;quot;.
++ &lt;/DD&gt;
++ 
+  &lt;DT&gt;RECIPS&lt;/DT&gt;
+  &lt;DD&gt;
+  This token represents the personal names (or email addresses if the names
+***************
+*** 18072,18077 ****
+--- 18092,18105 ----
+  the message's &amp;quot;Cc:&amp;quot; header field.
+  &lt;/DD&gt;
+  
++ &lt;DT&gt;ADDRESSRECIPS&lt;/DT&gt;
++ &lt;DD&gt;
++ This token represent the e-mail addresses of the people in the To: and
++ Cc: fields, exactly in that order separated by a space. It is almost obtained
++ by concatenating the ADDRESSTO and ADDRESSCC tokens.
++ &lt;/DD&gt;
++ 
++ 
+  &lt;DT&gt;NEWSANDRECIPS&lt;/DT&gt;
+  &lt;DD&gt;
+  This token represents the newsgroups from the
+***************
+*** 19168,19173 ****
+--- 19196,19273 ----
+  &lt;/DL&gt;
+  
+  &lt;P&gt;
++ &lt;H1&gt;&lt;EM&gt;Tokens Available Only for New-Rules&lt;/EM&gt;&lt;/H1&gt;
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;FOLDER&lt;/DT&gt;
++ &lt;DD&gt;
++ Name of the folder where the rule will be applied
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;COLLECTION&lt;/DT&gt;
++ &lt;DD&gt;
++ Name of the collection list where the rule will be applied.
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;ROLE&lt;/DT&gt;
++ &lt;DD&gt;
++ Name of the Role used to reply a message.
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;BCC&lt;/DT&gt;
++ &lt;DD&gt;
++ Not implemented yet, but it will be implemented in future versions. It will
++ be used for &lt;A HREF=&quot;h_config_compose_rules&quot;&gt;compose&lt;/A&gt;
++ &lt;A HREF=&quot;h_config_reply_rules&quot;&gt;reply&lt;/A&gt;
++ &lt;A HREF=&quot;h_config_forward_rules&quot;&gt;forward&lt;/A&gt;
++ rules.
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;LCC&lt;/DT&gt;
++ &lt;DD&gt;
++ This is the value of the Lcc: field at the moment that you start the composition.
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;FORWARDFROM&lt;/DT&gt;
++ &lt;DD&gt;
++ This corresponds to the personal name (or address if there's no personal
++ name) of the person who sent the message that you are forwarding.
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;FORWARDADDRESS&lt;/DT&gt;
++ &lt;DD&gt;
++ This is the address of the person that sent the message that you
++ are forwarding.
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ 
++ 
++ 
++ &lt;DL&gt;
++ &lt;DT&gt;FLAG&lt;/DT&gt;
++ &lt;DD&gt; 
++ A string containing the value of all the flags associated to a specific
++ message. The possible values of allowed flags are &quot;*&quot; for Important, &quot;N&quot;
++ for recent or new, &quot;U&quot; for unseen or unread, &quot;R&quot; for seen or read, &quot;A&quot; for
++ answered and &quot;D&quot; for deleted. See an example of its use in the 
++ &lt;A HREF=&quot;h_config_new_rules&quot;&gt;new rules&lt;/A&gt; explanation and example help.
++ &lt;/DD&gt;
++ &lt;/DL&gt;
++ 
++ &lt;P&gt;
+  &lt;H1&gt;&lt;EM&gt;Token Available Only for Templates and Signatures&lt;/EM&gt;&lt;/H1&gt;
+  
+  &lt;DL&gt;
+***************
+*** 22184,22189 ****
+--- 22284,23181 ----
+  &amp;lt;End of help on this topic&amp;gt;
+  &lt;/BODY&gt;
+  &lt;/HTML&gt;
++ ====== h_config_procid =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;Token: PROCID&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;TOKEN: PROCID explained&lt;/H1&gt;
++ 
++ &lt;P&gt;
++ The PROCID token is a way in which the user and the program can differentiate
++ between different parts of a program. It allows the user to tell the
++ program when to use a specific rule, and only use it at that specific
++ moment.
++ 
++ &lt;P&gt; The normal way in which this is done is by adding a new configuration 
++ variable. The idea behind the PROCID token is that instead of adding a new 
++ configuration variable (which means the user has to go through more 
++ configuration variables just to tune the program to his liking), we reuse 
++ an old variable and let the user look inside that variable for the desired
++ behavior, which is actually set by setting the PROCID token.
++ 
++ &lt;P&gt;
++ Consider the following examples for forward-rules:
++ 
++ &lt;P&gt;
++ _ROLE_ == {work} =&amp;gt; _SUBJECT_ := _COPY_{[tag] _SUBJECT_}
++ 
++ &lt;P&gt;
++ and
++ 
++ &lt;P&gt;
++ _ROLE_ == {work} =&amp;gt; _LCC_ := _TRIM_{_FORWARDFROM_ &amp;lt;_FORWARDADDRESS_&amp;gt;}
++ 
++ &lt;P&gt;
++ both are triggered by the same condition. Since both are configured in the 
++ same variable, only one of them will be executed all the time (whichever 
++ is first). Therefore in order to differentiate, we add a _PROCID_ token. 
++ So, for example, the first example above will be executed only when we are 
++ determining the subject. In this case, the following rule will accomplish 
++ this task
++ 
++ &lt;P&gt;
++ _PROCID_ == {fwd-subject} &amp;&amp; _ROLE_ == {work} =&amp;gt; _SUBJECT_ := _COPY_{[tag] _SUBJECT_}
++ 
++ &lt;P&gt;
++ In this case, this rule will be tested fully only when we are determining 
++ the subject line of a forwarded message, not otherwise.
++ 
++ &lt;P&gt;
++ It is wise to add the _PROCID_ token as the first condition in a rule, so 
++ that other conditions will not be tested in a long list of rules.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_compose_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_compose-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_compose-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; At this time, this option is used to generate values for signature
++ files that is not possible to do with the use of 
++ &lt;A HREF=&quot;h_rules_roles&quot;&gt;roles&lt;/A&gt;.
++ 
++ &lt;P&gt; For example, you can have a rule like:&lt;BR&gt;
++ _TO_ &gt;&gt; {Peter Flinstones} =&gt; _SIGNATURE_{~/.petersignature}
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_forward_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_forward-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_forward-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option has several uses. This feature uses the PROCID function
++ to identify different features of forwarding. You can read more about PROCID
++ by following &lt;A HREF=&quot;h_config_procid&quot;&gt;this link&lt;/A&gt;.
++ 
++ &lt;P&gt; If you want to edit the subject of a forwarded message, use the
++ PROCID &lt;I&gt;fwd-subject&lt;/I&gt;. For example you could have a rule like
++ 
++ &lt;P&gt;
++ _ROLE_ == {admin} &amp;&amp; _SUBJECT_ !&amp;gt; {[tag] } =&amp;gt; _COPY_{[tag] _SUBJECT_}
++ 
++ &lt;P&gt; Another way in which this option can be used, is to trim the values of 
++ some fields. For this application the PROCID is &lt;I&gt;fwd-lcc&lt;/I&gt;. For 
++ example it can be used in the following way:
++ 
++ &lt;P&gt;
++ _ROLE_ == {work} =&gt; _LCC_ := _TRIM_{_FORWARDFROM_ &amp;lt;_FORWARDADDRESS_&amp;gt;}
++ 
++ &lt;P&gt; Other functions that can be used in this option are _EXEC_ and _REXTRIM_.
++ 
++ &lt;P&gt; You can also use the _EXEC_ function. The documentation for this function
++ is in the 
++ &lt;A HREF=&quot;h_config_resub_rules&quot;&gt;&lt;!--#echo var=&quot;VAR_reply-subject-rules&quot;--&gt;&lt;/A&gt;
++ help text.
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_index_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_index-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_index-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to supersede the value of the option &lt;A
++ HREF=&quot;h_config_index_format&quot;&gt;&lt;!--#echo var=&quot;VAR_index-format&quot;--&gt;&lt;/A&gt; for specific folders. In
++ this form you can have different index-formats for different folders. For
++ example an entry here may be:
++ 
++ &lt;P&gt;
++ _FOLDER_ == {INBOX} =&gt; _INDEX_{IMAPSTATUS DATE FROM(33%) SIZE SUBJECT(67%)}
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_pretty_command =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;Pretty-Command Explained&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;Pretty Command Explained&lt;/H1&gt;
++ 
++ &lt;P&gt; This text explains how to encode keys so that they will be recognized 
++ by Alpine in the _PKEY_ token. Most direct keystrokes are recognized in the 
++ same way. For example, the key ~ is recognized by the same character. The 
++ issue is how control, or functions keys are recognized. The internal code 
++ is most times easy to find out. If the key you want to use is not already 
++ recognized by Alpine simply press it. Alpine will print its code. For example, 
++ the return key is not recognized in this screen, so if you press it, you 
++ will see the following message.
++ 
++ &lt;P&gt; [Command &amp;quot;RETURN&amp;quot; not defined for this screen. Use ? for help]
++ 
++ &lt;P&gt; from here you can guess that the code for the return command is 
++ RETURN. You can try other commands, like Control-C, the TAB key, F4, etc. 
++ to see their codes.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_key_macro_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_key-definition-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_key-definition-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option can be used to define macros, that is, to define a key that
++ when pressed executes a group of predetermined keystrokes. Since Alpine is
++ a menu driven program, sometimes the same key may have different meanings
++ in different screens, so a global redefinition of a key although possible
++ is not advisable. 
++ 
++ &lt;P&gt; &lt;B&gt;Always use the _SCREEN_ token as defined below.&lt;/B&gt;. You have been
++ warned!
++ 
++ &lt;P&gt; In each screen, every time you press a recognized key a command is 
++ activated. In order to understand this feature, think of commands instead 
++ of keystrokes. For example, you can think of the sort by thread command. 
++ This command is associated to the keystrokes $ and h. You may want to 
++ associate this command to a specific keystroke, like ~, so every time you
++ press the ~ key, Alpine understand the $ and h keystrokes, which activates
++ the sort by thread command.
++ 
++ &lt;P&gt; Therefore, in order to use this option you must think of three 
++ components. The screen where you will use the macro, the keystroke you 
++ want to use and the set of keystrokes used by Alpine to accomplish the task 
++ you want to accomplish. We will talk about these three components in what 
++ follows.
++ 
++ &lt;P&gt; First you must decide in which screen the macro will be used. This 
++ feature is currently only available for the screen where your messages
++ are listed in index form (&lt;A HREF=&quot;h_mail_index&quot;&gt;MESSAGE INDEX&lt;/A&gt;),
++ the screen where your message is displayed
++ (&lt;A HREF=&quot;h_mail_view&quot;&gt;MESSAGE TEXT&lt;/A&gt;) and the screen where the list of
++ folders is displayed (&lt;A HREF=&quot;h_folder_maint&quot;&gt;FOLDER LIST&lt;/A&gt;). The 
++ internal names of these screens for this patch are &amp;quot;index&amp;quot;, 
++ &amp;quot;text&amp;quot; and 
++ &amp;quot;folder&amp;quot; respectively. Please note that the internal names are 
++ all in lowercase are are case sensitive.
++ 
++ &lt;P&gt; In order to define the screen, you use the _SCREEN_ token, so for 
++ example, you can write _SCREEN_ == {index}.
++ 
++ &lt;P&gt; Second you must think of which key you will use to activate the macro. 
++ Here you can use any key of your choice. The token you use to designate a 
++ key is the _PKEY_ token (PKEY stands for &amp;quot;pressed key&amp;quot;). For 
++ example you could use _PKEY_ == {~}, to designate the &amp;quot;~&amp;quot; 
++ character to activate the command. Some keystrokes (like control, or 
++ function keys) are encoded in special ways. You should read the 
++ &lt;A HREF=&quot;h_config_pretty_command&quot;&gt;full explanation&lt;/A&gt; on how to find
++ out the encoding for each keystroke.
++ 
++ &lt;P&gt; Last, you must think of the list of keys you will use to accomplish 
++ the task you want Alpine to perform. Say for example you want to have the 
++ folder sorted by thread. That means you want Aline to execute the keys 
++ &amp;quot;$&amp;quot; and &amp;quot;h&amp;quot;. You use the _COMMAND_ function to specify 
++ this. The syntax in this case is _COMMAND_{$,h}.
++ 
++ &lt;P&gt; Observe that in the above example the different inputs are separated 
++ by commas. This is the standard way in which the
++ &lt;A HREF=&quot;h_config_init_cmd_list&quot;&gt;&lt;!--#echo var=&quot;VAR_initial-keystroke-list&quot;--&gt;&lt;/A&gt; command works from 
++ the command line. Due to restrictions in the way Alpine works, a comma is a 
++ special character, which when added to a configuration option like this 
++ will cause the configuration to split into several lines in the 
++ configuration screen. This has the effect of producing several 
++ configuration options, all of which are incorrect. This is undesirable 
++ because what you want is to have it all in one line. In order to force the 
++ configuration into one line you must quote the comma. The best way to 
++ accomplish this is by quoting the full definition of the rule. For 
++ example.
++ 
++ &lt;P&gt;
++ &amp;quot;_SCREEN_ == {index} &amp;&amp; _PKEY_ == {~} =&gt; _COMMAND_{$,h}&amp;quot;
++ 
++ &lt;P&gt; Another way to accomplish the same effect is by quoting the command and 
++ not using quotes for the full command, nor commas to separate the 
++ keystrokes in the command, for example
++ 
++ &lt;P&gt;
++ _SCREEN_ == {index} &amp;&amp; _PKEY_ == {~} =&gt; _COMMAND_{&amp;quot;$h&amp;quot;}
++ 
++ &lt;P&gt; For more information on how to define the argument of the _COMMAND_
++ token see the help of 
++ &lt;A HREF=&quot;h_config_init_cmd_list&quot;&gt;&lt;!--#echo var=&quot;VAR_initial-keystroke-list&quot;--&gt;&lt;/A&gt;.
++ 
++ &lt;P&gt; Because the $ command can also be used as the first character in the
++ definition of an environemnt variable, no expansion of environment variables
++ is done when parsing this variable. The $ character does not need quoting
++ and quoting it will make Alpine fail to produce the correct result.
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to 
++ override the value of some global configurations within Alpine. There is a 
++ help text explaining how to define all of them, which you can read by 
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_replace_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_replace-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_replace-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to have Alpine print different values for specific 
++ tokens in the &lt;A HREF=&quot;h_config_index_format&quot;&gt;&lt;!--#echo var=&quot;VAR_index-format&quot;--&gt;&lt;/A&gt;. For example you
++ can replace strings like &quot;To: newsgroup&quot; by your name.
++ 
++ &lt;P&gt; Here are examples of possible rules:&lt;BR&gt;
++ _FOLDER_ != {sent-mail} &amp;&amp; _NICK_ != {} =&gt; _FROM_ := _REPLACE_{_FROM_ (_NICK_)}
++ 
++ &lt;P&gt; or if you receive messages with tags that contain arbitrary numbers, and
++ you want them removed from the index (but not from the subject), use a rule
++ like the following&lt;BR&gt;
++ _FOLDER_ == {INBOX} =&gt; _SUBJECT_ := _REXTRIM_{&amp;#92;[some-tag-here #[0-9].*&amp;#92;]}
++ 
++ &lt;P&gt; You can also use this configuration option to remove specific strings of
++ the index display screen, so that you can trim unnecessary information in
++ your index, like the reply leadin string in the OPENINGTEXTNQ token of the index.
++ &lt;BR&gt;
++ _FOLDER_ == {mailing-list} =&gt; _OPENINGTEXTNQ_ := _REXTRIM_{On.*wrote: }
++ 
++ &lt;P&gt; or if you receive messages with tags that contain arbitrary numbers, and
++ you want them removed from the index (but not from the subject), use a rule
++ like the following&lt;BR&gt;
++ 
++ &lt;P&gt; You can also use the _EXEC_ function. The documentation for this function
++ is in the 
++ &lt;A HREF=&quot;h_config_resub_rules&quot;&gt;&lt;!--#echo var=&quot;VAR_reply-subject-rules&quot;--&gt;&lt;/A&gt;
++ help text.
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_reply_leadin_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_reply-leadin-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_reply-leadin-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to have Alpine generate a different 
++ &lt;A HREF=&quot;h_config_reply_intro&quot;&gt;&lt;!--#echo var=&quot;VAR_reply-leadin&quot;--&gt;&lt;/A&gt; string dependent either on
++ the person you are replying to, or the folder where the message is being
++ replied is in, or both.
++ 
++ &lt;P&gt; Here there are examples of how this can be used. One can use the definition
++ below to post to newsgroups and the pine-info mailing list, say:
++ &lt;P&gt;
++ _FOLDER_ &lt;&lt; {pine-info;_NEWS_} =&gt; _REPLY_{*** _FROM_ _ADDRESS_(&quot;_FROM_&quot;  &quot;&quot; &quot;(_ADDRESS_) &quot;)wrote in_NEWS_(&quot;&quot; &quot; the&quot; &quot;&quot;) _FOLDER_ _NEWS_(&quot;&quot; &quot;list &quot; &quot;&quot;)_SMARTDATE_(&quot;Today&quot; &quot;today&quot; &quot;on _LONGDATE_&quot;):}
++ 
++ &lt;P&gt; Here there is an example that one can use to change the reply indent string
++ to reply people that speak spanish.
++ &lt;P&gt;
++ _FROM_{Condorito;Quico} =&gt; _REPLY_{*** _FROM_ (_ADDRESS_) escribi&amp;oacute; _SMARTDATE_(&quot;Today&quot; &quot;hoy&quot; &quot;en _LONGDATE_&quot;):}
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_resub_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_reply-subject-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_reply-subject-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to have Alpine generate a different subject when
++ replying rather than the one Alpine would generate automatically. 
++ 
++ &lt;P&gt; Here there are a couple of examples about how to use this
++ configuration option:
++ 
++ &lt;P&gt; In order to have messages with empty subject to be replied with the message
++ &quot;your message&quot; use the rule&lt;BR&gt;
++ &lt;center&gt;_SUBJECT_ == {} =&gt; _RESUB_{Re: your message}&lt;/center&gt;
++ 
++ &lt;P&gt; If you want to trim some parts of the subject when you reply use the
++ rule&lt;BR&gt; 
++ &lt;center&gt;_SUBJECT_ &gt;&gt; {[one];two} =&gt; _SUBJECT_ := _TRIM_{[;];two}&lt;/center&gt; 
++ 
++ &lt;P&gt;this rule removes the brackets &quot;[&quot; and &quot;]&quot; whenever the string &quot;[one]&quot;
++ appears in it, it also removes the word &quot;two&quot; from it.
++ 
++ &lt;P&gt;Another example where you may want to use this rule is when you 
++ correspond with people that change the reply string from &amp;quot;Re:&amp;quot; 
++ to &amp;quot;AW:&amp;quot; or &amp;quot;Sv:&amp;quot;. In this case a rule like&lt;BR&gt;
++ &lt;center&gt;_SUBJECT_ &gt;&gt; {Sv: ;AW: } =&gt; _SUBJECT_ := _TRIM_{Sv: ;AW: }&lt;/center&gt; 
++ &lt;P&gt;
++ would eliminate undesired strings in replies.
++ 
++ &lt;P&gt; Another interesting use of this option is the use of the _EXEC_ function.
++ This function takes as an argument a program or a script. This program
++ must take as the input a file, and write its output to that file. For example,
++ below is a sample of a script that removes the letter &amp;quot;a&amp;quot; of a file.
++ 
++ &lt;PRE&gt;
++ #!/bin/sh
++ sed 's/a//g' $1 &gt; /tmp/mytest
++ mv /tmp/mytest $1
++ &lt;/PRE&gt;
++ 
++ &lt;P&gt;
++ As you can see this script took &amp;quot;$1&amp;quot; as input file, the sed program
++ wrote its output to /tmp/mytest, and then the move program moved the file
++ /tmp/mytest to the input file &amp;quot;$1&amp;quot;. This is the kind of behavior
++ that your program is expected to have.
++ 
++ &lt;P&gt;
++ The content of the input file (&amp;quot;$1&amp;quot; above) is the value of a token
++ like _SUBJECT_. In order to indicate this, we use the notation
++ 
++ &lt;P&gt;
++ _SUBJECT_ := _EXEC_{/path/to/script}
++ 
++ &lt;P&gt; for the action. So for example
++ 
++ &lt;P&gt;
++ _FOLDER_ := {sent-mail} =&amp;gt; _SUBJECT_ := _EXEC_{/path/to/script}
++ 
++ &lt;P&gt; is a valid rule.
++ 
++ &lt;P&gt; You can also use this configuration option to customize reply subjects
++ according to the sender of the message.
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_sort_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_sort-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_sort-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to have Alpine sort different folders in different orders
++ and thus override the value already set in the
++ &lt;A HREF=&quot;h_config_sort_key&quot;&gt;&lt;!--#echo var=&quot;VAR_sort-key&quot;--&gt;&lt;/A&gt; configuration option.
++ 
++ &lt;P&gt; Here's an example of the way it can be used. In this case all incoming
++ folders are mailing lists, except for INBOX, so we sort INBOX by arrival
++ (which is the default type of sort), but we want all the rest of mailing
++ lists and newsgroups to be sorted by thread.
++ 
++ &lt;P&gt;
++ _COLLECTION_ &gt;&gt; {Incoming-Folders;News} &amp;&amp; _FOLDER_ != {INBOX} =&gt; _SORT_{tHread}
++ 
++ &lt;P&gt; Another example could be&lt;BR&gt;
++ _FOLDER_ == {Mailing List} =&gt; _SORT_{Reverse tHread}
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ 
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_save_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_save-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_save-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to specify which folder should be used to save a
++ message depending either on the folder the message is in, who the message
++ is from, or text that the message contains in specific headers (Cc:,
++ Subject:, etc).
++ 
++ &lt;P&gt; If this option is set and the 
++ &lt;A HREF=&quot;h_config_auto_read_msgs&quot;&gt;&lt;!--#echo var=&quot;FEAT_auto-move-read-msgs&quot;--&gt;&lt;/A&gt; configuration
++ option is also enabled then these definitions will be used to move messages
++ from your INBOX when exiting Alpine.
++ 
++ &lt;P&gt;Here there are some examples&lt;BR&gt;
++ _FLAG_ &gt;&gt; {D} -&gt; Trash&lt;BR&gt;
++ _FROM_ == {U2} -&gt; Bono&lt;BR&gt;
++ _FOLDER_ == {comp.mail.pine} -&gt; pine-stuff&lt;BR&gt;
++ _NICK_ != {} -&gt; _NICK_/_NICK_&lt;BR&gt;
++ _DATEISO_ &gt;&gt; {02-10;02-11} -&gt; archive-oct-nov-2002
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ 
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_reply_indent_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_reply-indent-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_reply-indent-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to specify which reply-indent-string is to be used
++ when replying to an e-mail. If none of the rules are successful, the result in
++ the variable &lt;a href=&quot;h_config_reply_indent_string&quot;&gt;&lt;!--#echo var=&quot;VAR_reply-indent-string&quot;--&gt;&lt;/a&gt;
++ is used.
++ 
++ &lt;P&gt; The associated function to this configuration option is called &quot;RESTR&quot; (for
++ REply STRing). Some examples of its use are:&lt;BR&gt;
++ _FROM_ == {Your Boss} =&gt; _RESTR_{&quot;&gt; &quot;}&lt;BR&gt;
++ _FROM_ == {My Wife} =&gt; _RESTR_{&quot;:* &quot;}&lt;BR&gt;
++ _FROM_ == {Perter Flinstone;Wilma Flinstone} =&gt; _RESTR_{&quot;_INIT_ &gt; &quot;}&lt;BR&gt;
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ 
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_smtp_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_smtp-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_smtp-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used to specify which SMTP server should be used when
++ sending a message, if this rule is not defined, or the execution of the rule
++ results in no server selected, then Alpine will look for 
++ the value from the role that is being used to compose the message. If no smtp
++ server is defined in that role or you are not using a role, then Alpine will get
++ the name of the server from the
++ &lt;A HREF=&quot;h_config_smtp_server&quot;&gt;&amp;quot;&lt;!--#echo var=&quot;VAR_smtp-server&quot;--&gt;&amp;quot;&lt;/A&gt; configuration
++ option according to the rules used in that variable.
++ 
++ &lt;P&gt; The function associated to this configuration option is _SMTP_, an example
++ of the use of this function is&lt;BR&gt;
++ _ADDRESSTO_ == {<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">peter at bedrock.com</A>} =&gt; _SMTP_{smtp.bedrock.com}
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ 
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_startup_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: &lt;!--#echo var=&quot;VAR_startup-rules&quot;--&gt;&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: &lt;!--#echo var=&quot;VAR_startup-rules&quot;--&gt;&lt;/H1&gt;
++ 
++ &lt;P&gt; This option is used when a folder is being opened. You can use it to specify its &lt;A 
++ HREF=&quot;h_config_inc_startup&quot;&gt;&lt;!--#echo var=&quot;VAR_incoming-startup-rule&quot;--&gt;&lt;/A&gt; and override 
++ Alpine's global value set for all folders.
++ 
++ &lt;P&gt; An example of the usage of this option is:&lt;BR&gt;
++ _FOLDER_ == {Lynx;pine-info;_NEWS_} =&gt; _STARTUP_{first-unseen}
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Alpine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;&amp;lt;End of help on this topic&amp;gt;
++ 
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_new_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: New Rules Explained&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: New Rules Explained&lt;/H1&gt;
++ 
++ This is a quite powerful option. Here you can define rules that override
++ the values of any other option you have set in Alpine.
++ 
++ &lt;P&gt;
++   For example, you can set your folders to be sorted in a certain way when 
++ you open them (say by Arrival). You may want, however, your newsgroups to 
++ be sorted by thread. The set of &amp;quot;rules&amp;quot; options allows you to 
++ configure this and many other options, including the index-format for 
++ specific folders, the way the subject is displayed in the index screen or 
++ the reply-leadin-string, to name a few.
++ 
++ &lt;P&gt;
++   Every rule has three parts: a condition, a separator and an action. The
++ action is what will happen if the condition of the rule is satisified.
++ 
++ &lt;P&gt;
++   Here is an example:
++ 
++ &lt;P&gt;
++    _FROM_ == {Fred Flinstone} =&amp;gt; _SAVE_{Fred}
++ 
++ &lt;P&gt;
++   Here the separator is &quot;=&amp;gt;&quot;. Whatever is to the left of the separator 
++ is the condition (that is _FROM_ == {Fred Flinstone}) and to the right is 
++ the action (_SAVE_{Fred}). The condition means that the rule will be 
++ applied only if the message that you are reading is from &amp;quot;Fred 
++ Flinstone&amp;quot;, and the action will be that you will be offered to save 
++ it in the folder &amp;quot;Fred&amp;quot;, whenever you press the letter 
++ &amp;quot;S&amp;quot; to save a message.
++ 
++ &lt;P&gt;
++   The separator is always &amp;quot;=&amp;gt;&amp;quot;, with one exception to be seen 
++ later. But for the most part this will be the only one you will ever need.
++ 
++ &lt;P&gt;
++   Now let us see how to do it. There are 13 functions already defined for 
++ you. These are: _EXEC_, _INDEX_, _REPLACE_, _REPLY_, _RESUB_, _SAVE_, 
++ _SIGNATURE_, _SORT_, _STARTUP_, _TRIM_, _REXTRIM_, _THREADSTYLE and 
++ _THREADINDEX_. The parameter of a function has to be enclosed between 
++ &amp;quot;{&amp;quot; and &amp;quot;}&amp;quot;, so for example you can specify 
++ _SAVE_{saved-messages} as a valid sentence.
++ 
++ &lt;P&gt;
++   Later in the document you will find examples. Here is a short 
++ description of what each function does:
++ 
++ &lt;P&gt;
++ &lt;UL&gt;
++ &lt;LI&gt; _EXEC_ : This function takes as an argument a program. This program 
++ gets as the input a file and must rewrite its output to that file, which 
++ is then taken as the value to replace from the contents of that file. You 
++ can use this function with 
++ &lt;A HREF=&quot;h_config_resub_rules&quot;&gt;&lt;!--#echo var=&quot;VAR_reply-subject-rules&quot;--&gt;&lt;/A&gt;, 
++ &lt;A HREF=&quot;h_config_replace_rules&quot;&gt;&lt;!--#echo var=&quot;VAR_replace-rules&quot;--&gt;&lt;/A&gt; and 
++ &lt;A HREF=&quot;h_config_forward_rules&quot;&gt;&lt;!--#echo var=&quot;VAR_forward-rules&quot;--&gt;&lt;/A&gt;. 
++ See the help of those options for examples of how to use this function
++ and configure these rules.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _INDEX_ : This function takes as an argument an index-format, and
++ makes that the index-format for the specified folder.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _REPLACE_ : This function replaces the subject/from of the given e-mail by
++ another subject/from only when displaying the index.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _REPLY_ : This function takes as an argument a definition of a
++ reply-leadin-string and makes this the reply-leading-string of the
++ specified folder or person.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _RESTR_ : This function takes as an argument the value of the 
++ reply-indent-string to be used to answer the message being replied to.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _RESUB_ : This function replaces the subject of the given e-mail by
++ another subject only when replying to a message.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _SAVE_ : The save function takes as an argument the name of a
++ possibly non existing folder, whenever you want to save a message, that
++ folder will be offered for you to save.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _SIGNATURE_ : This function takes as an argument a signature file and
++ uses that file as the signature for the message you are about to
++ compose/reply/forward.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _SMTP_ : This function takes as an argument the definition of a
++ SMTP server.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _SORT_ : This function takes as an argument a Sort Style, and sorts a
++ specified folder in that sort order.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _TRIM_ : This function takes as an argument a list of strings that
++ you want removed from another string. At this time this only works for
++ _FROM_ and _SUBJECT_.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _REXTRIM_ : Same as _TRIM_ but its argument is one and
++ only one extended regular expression.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _STARTUP_ : This function takes as an argument an
++ incoming-startup-rule, and open an specified folder using that rule.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _THREADSTYLE_ : This function takes as an argument a
++ threading-display-style and uses it to display threads in a folder.
++ &lt;BR&gt;&amp;nbsp;&lt;BR&gt;
++ &lt;LI&gt; _THREADINDEX_ : This function takes as an argument a
++ threading-index-style and uses it to display threads in a folder.
++ &lt;/UL&gt;
++ 
++ &lt;P&gt;
++ You must me wondering how to define the person/folder over who to apply
++ the action. This is done in the condition. When you specify a rule, the
++ rule is only executed if the condition is satisfied. In another words for
++ the rule:
++ 
++ &lt;P&gt;
++    _FROM_ == {Fred Flinstone} =&amp;gt; _SAVE_{Fred}
++ 
++ &lt;P&gt; it will only be applied if the from is &amp;quot;Fred Flinstone&amp;quot;. If 
++ the From is &amp;quot;Wilma Flinstone&amp;quot; the rule will be skipped.
++ 
++ &lt;P&gt; In order to test a condition you can use the following tokens (in 
++ alphabetical order): _ADDRESS_, _CC_, _FOLDER_, _FROM_,_NICK_, _ROLE, 
++ _SENDER_, _SUBJECT_ and _TO_. The token will always be tested against what 
++ it is between &amp;quot;{&amp;quot; and &amp;quot;}&amp;quot; in the condition, this part 
++ of the condition is called the &amp;quot;condition set&amp;quot;. The definition 
++ of each token can be found &lt;A HREF=&quot;h_index_tokens&quot;&gt;here&lt;/A&gt;. 
++ 
++ &lt;P&gt; A special testing token called _PROCID_ can be used to differentiate 
++ inside a rule, between two rules that are triggered by the same condition. 
++ A full explanation of the _PROCID_ token can be found in 
++ &lt;A HREF=&quot;h_config_procid&quot;&gt;this link&lt;/A&gt;.
++ 
++ &lt;P&gt; There are two more tokens related to the option
++ &lt;A HREF=&quot;h_config_key_macro_rules&quot;&gt;key-definition-rules&lt;/A&gt;. Those tokens
++ are only specific to that option, and hence are not explained here.
++ 
++ &lt;P&gt; You can also test in different ways, you can use the following 
++ &amp;quot;test operands&amp;quot;: &amp;lt;&amp;lt;, !&amp;lt;, &amp;gt;&amp;gt;, !&amp;gt;, == and !=. 
++ All of them are two strings long. Here is the meaning of them:
++ 
++ &lt;P&gt;
++ &lt;UL&gt; 
++ &lt;LI&gt; &amp;lt;&amp;lt; : It tests if the value of the token is contained in
++ the condition set. Here for example if the condition set were equal to
++ &amp;quot;Freddy&amp;quot;, then the condition: _NICK_ &amp;lt;&amp;lt; {Freddy}, would be true if
++ the value of _NICK_ were &amp;quot;Fred&amp;quot;, &amp;quot;red&amp;quot; or &amp;quot;Freddy&amp;quot;. You are just looking
++ for substrings here.
++ &lt;LI&gt; &amp;gt;&amp;gt; : It tests if the value of the token contains the value of
++ the condition set. Here for example if the condittion set were equal to
++ &amp;quot;Fred&amp;quot;, then the condition: _FROM_ &amp;gt;&amp;gt; {Fred}, would be true if
++ the value of _FROM_ were &amp;quot;Fred Flinstone&amp;quot; or &amp;quot;Fred P. Flinstone&amp;quot; or &amp;quot;Freddy&amp;quot;.
++ &lt;LI&gt; == : It tests if the value of the token is exactly equal to the value
++ of the set condition. For example _NICK_ == {Fred} will be false if the value 
++ of _NICK_ is &amp;quot;Freddy&amp;quot; or &amp;quot;red&amp;quot;. 
++ &lt;LI&gt; !&amp;lt; : This is true only when &amp;lt;&amp;lt; is false and viceversa.
++ &lt;LI&gt; !&amp;gt; : This is true only when &amp;gt;&amp;gt; is false and viceversa.
++ &lt;LI&gt; != : This is true only when == is false and viceversa.
++ &lt;/UL&gt;
++ 
++ &lt;P&gt;
++   Now let us say that you want the same action to be applied to more than
++ one person or folder, say you want &amp;quot;folder1&amp;quot; and &amp;quot;folder2&amp;quot; to be sorted by
++ Ordered Subject upon entering. Then you can list them all of them in the
++ condition part separting them by a &amp;quot;;&amp;quot;. Here is the way to do it.
++ 
++ &lt;P&gt;
++  _FOLDER_ &amp;lt;&amp;lt; {folder1; folder2} =&amp;gt; _SORT_{OrderedSubj}
++ 
++ &lt;P&gt;
++   Here is the first subtelty about these definitions. Notice that the
++ following rule:
++ 
++ &lt;P&gt;
++  _FOLDER_ == {folder1; folder2} =&amp;gt; _SORT_{Reverse OrderedSubj}
++ 
++ &lt;P&gt; works only for &amp;quot;folder1&amp;quot; but not for &amp;quot;folder2&amp;quot;. This is because the
++ comparison of the name of the folder is done with whatever is in between
++ &amp;quot;{&amp;quot;, &amp;quot;;&amp;quot; or &amp;quot;}&amp;quot;, so in the above rule you would be testing &lt;BR&gt;
++ &amp;quot;folder2&amp;quot; == &amp;quot; folder2&amp;quot;. The extra space makes the difference. 
++ The reason why the first rule does not fail is because 
++ &amp;quot;folder2&amp;quot; &amp;lt;&amp;lt; &amp;quot; folder2&amp;quot; is actually
++ true. If something ever fails this may be something to look into.
++ 
++ &lt;P&gt;
++  Here are a few examples of what we have talked about before.
++ 
++ &lt;P&gt;
++ _NICK_ == {lisa;kika} =&amp;gt; _SAVE_{_NICK_/_NICK_} &lt;BR&gt;
++ This means that if the nick is lisa, it will 
++ save the message in the folder &amp;quot;lisa/lisa&amp;quot;, and if the nick 
++ is &amp;quot;kika&amp;quot;, it will save the message in the folder &amp;quot;kika/kika&amp;quot;
++ 
++ &lt;P&gt;
++ _FOLDER_ == {Lynx} -&amp;gt; lynx &lt;BR&gt;
++ This, is an abreviation of the following rule:&lt;BR&gt;
++ _FOLDER_ == {Lynx} =&amp;gt; _SAVE_{lynx} &lt;BR&gt;
++ (note the change in separator from &amp;quot;=&amp;gt;&amp;quot; to &amp;quot;-&amp;gt;&amp;quot;). In the future 
++ I will use that abreviation.
++ 
++ &lt;P&gt; _FOLDER_ &amp;lt;&amp;lt; {comp.mail.pine; pine-info; pine-alpha} -&amp;gt; pine &lt;BR&gt;
++ Any message in the folders &amp;quot;comp.mail.pine&amp;quot;, &amp;quot;pine-info&amp;quot; or &amp;quot;pine-alpha&amp;quot;
++ will be saved to the folder &amp;quot;pine&amp;quot;.
++ 
++ &lt;P&gt; _FROM_ &amp;lt;&amp;lt; {Pine Master} -&amp;gt; pine &lt;BR&gt;
++ Any message whose From field contains
++ &amp;quot;Pine Master&amp;quot; will be saved in the folder pine.
++ 
++ &lt;P&gt; _FOLDER_ &amp;lt;&amp;lt; {Lynx; pine-info; comp.mail.pine} =&amp;gt;
++ _INDEX_{IMAPSTATUS MSGNO DATE FROMORTO(33%) SUBJECT(66%)} &lt;BR&gt; Use a
++ different index-format for the folders &amp;quot;Lynx&amp;quot;, &amp;quot;pine-info&amp;quot; and
++ &amp;quot;comp.mail.pine&amp;quot;, where the size is not present.
++ 
++ &lt;P&gt; _FOLDER_ == {Lynx;pine-info} =&amp;gt; _REPLY_{*** _FROM_ (_ADDRESS_)
++ wrote in the _FOLDER_ list _SMARTDATE_(&amp;quot;Today&amp;quot; &amp;quot;today&amp;quot; &amp;quot;on
++ _LONGDATE_&amp;quot;):}&lt;BR&gt; If a message is in one of the incoming folders &amp;quot;Lynx&amp;quot;
++ or &amp;quot;pine-info&amp;quot;, create a reply-leadin-string that acknowledges that. Note
++ the absence of &amp;quot;,&amp;quot; in the function _SMARTDATE_. For example answering to a
++ message in the pine-info list would look like:
++ 
++ &lt;P&gt;
++ *** Steve Hubert (<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">hubert at cac.washington.edu</A>) wrote in the pine-info list today:
++ 
++ &lt;P&gt;
++ However replying for a message in the Lynx list would look:
++ 
++ &lt;P&gt;
++ *** <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mattack at area.com</A> (<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mattack at area.com</A>) wrote in the Lynx list today:
++ 
++ &lt;P&gt;
++ If you write in more than one language you can use this feature to create
++ Reply-leadin-strings in different languages.
++ 
++ &lt;P&gt; Note that at least for people you can create particular
++ reply-leadin-string using the role features, but it does not work as this
++ one does. This seems to be the right way to do it.
++ 
++ &lt;P&gt; _FOLDER_ &amp;lt;&amp;lt; {Lynx; comp.mail.pine; pine_info; pine-alpha} =&amp;gt;
++ _SORT_{OrderedSubj}&lt;BR&gt; This means upon opening, sort the folders &amp;quot;Lynx&amp;quot;,
++ &amp;quot;comp.mail.pine&amp;quot;, etc in ordered subject. All the others use the default
++ sort order. You can not sort in reverse in this form. The possible
++ arguments of this function are listed in the definition of the
++ default-sort-rule (Arrival, scorE, siZe, etc).
++ 
++ &lt;P&gt; The last examples use the function _TRIM_ which has a special form.
++ This function can only be used in the index list.
++ 
++ &lt;P&gt; _FOLDER_ &amp;lt;&amp;lt; {Lynx} =&amp;gt; _SUBJECT_ := _TRIM_{lynx-dev }&lt;BR&gt; In
++ the folder &amp;quot;Lynx&amp;quot; eliminate from the subject the string &amp;quot;lynx-dev &amp;quot; (with
++ the space at the end). For example a message whose subject is &amp;quot;Re:
++ lynx-dev unvisited Visited Links&amp;quot;, would be shown in the index with
++ subject: &amp;quot;Re: unvisited Visited Links&amp;quot;, making the subject shorter and
++ giving the same information.
++ 
++ &lt;P&gt; _FROM_ &amp;gt;&amp;gt; {Name (Comment)} =&amp;gt; _FROM_ :=
++ _TRIM_{ (Comment)}&lt;BR&gt; Remove the part &amp;quot; (Comment)&amp;quot;
++ from the _FROM_, so when displaying in the index the real From &amp;quot;Name&amp;quot;
++ will appear.
++ 
++ &lt;P&gt; _SUBJECT_ == {} =&amp;gt; _RESUB_{Re: your mail without subject}
++ If there is no subject in the message, use the subject &amp;quot;Re: your mail
++ wiyhout subject&amp;quot; as a subject for the reply message.
++ 
++ &lt;P&gt; You can add more complexity to your rules by checking more than one
++ conditions before a rule is executed. For example: Assume that you want to
++ answer every email that contains the string &amp;quot;bug report&amp;quot;, with the subject
++ &amp;quot;Re: About your bug report&amp;quot;, you could make
++ 
++ &lt;P&gt;
++ _SUBJECT_ == {bug report} =&amp;gt; _RESUB_{Re: About your _SUBJECT_}
++ 
++ &lt;P&gt; The problem with this construction is that if the person emails you
++ back, then the next time you answer the message the subject will be: &amp;quot;Re:
++ About your Re: About your bug report&amp;quot;, so it grew. You may want to avoid
++ this growth by using the following rule:
++ 
++ &lt;P&gt;
++ _SUBJECT_ &amp;gt;&amp;gt; {bug report} &amp;&amp;  _SUBJECT_ !&amp;gt; {Re: } =&amp;gt; _RESUB_{Re: About your _SUBJECT_}&lt;BR&gt;
++ 
++ &lt;P&gt;
++ which will only add the string &amp;quot;Re: About your&amp;quot; only the first time the
++ message is replied.
++ 
++ &lt;P&gt;
++   Say your personal name is &amp;quot;Fred Flinstones&amp;quot;, and assume that you don't
++ like to see &amp;quot;To: comp.mail.pine&amp;quot; in every post you make to this newsgroup,
++ but instead would like to see it as everyone else sees it. &lt;BR&gt; 
++ _FOLDER_ == {comp.mail.pine} &amp;&amp; _FROM_ == {Fred Flinstones} =&gt; _FROM_ := _REPLACE_{_FROM_}
++ 
++ &lt;P&gt; 
++   You can also list your index by nick, in the following way:&lt;BR&gt;
++ _NICK_ != {} =&gt; _FROM_ := _REPLACE_{_NICK_}
++ 
++ &lt;P&gt;
++   If you want to open the folder &amp;quot;pine-info&amp;quot; in the first non-read message
++ use the rule:&lt;BR&gt;
++ _FOLDER_ == {pine-info} =&gt; _STARTUP_{first-unseen}
++ 
++ &lt;P&gt;
++  If you want to move your deleted messages to a folder, called &amp;quot;Trash&amp;quot;, use
++ the following rule:&lt;BR&gt;
++ _FLAG_ &gt;&gt; {D} -&gt; Trash
++ 
++ &lt;P&gt;
++ The reason why the above test is not &amp;quot;_FLAG_ == {D}&amp;quot; is because that would mean
++ that this is the only flag set in the message. It's better to test by containment in this case.
++ 
++ &lt;P&gt; If you want to use a specific signature when you are in a specific collection
++ use the following rule:&lt;BR&gt;
++ _COLLECTION_ == {Mail} =&gt; _SIGNATURE_{/full/path/to/.signature}
++ 
++ &lt;P&gt; Finally about the question of which rule will be executed. Only the
++ first rule that matches will be executed. It is important to notice though
++ that &amp;quot;saving&amp;quot; rules do not compete with &amp;quot;sorting&amp;quot; rules. So the first
++ &amp;quot;saving&amp;quot; rule that matches will be executed in the case of saving and so
++ on.
++ 
++ &lt;P&gt;
++ &lt;UL&gt;
++ &lt;LI&gt;&lt;A HREF=&quot;h_finding_help&quot;&gt;Finding more information and requesting help&lt;/A&gt;
++ &lt;/UL&gt;&lt;P&gt;
++ &amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
+  ====== h_config_char_set =====
+  &lt;HTML&gt;
+  &lt;HEAD&gt;
+***************
+*** 25760,25765 ****
+--- 26752,26827 ----
+  &amp;lt;End of help on this topic&amp;gt;
+  &lt;/BODY&gt;
+  &lt;/HTML&gt;
++ ====== h_config_thread_display_style_rule =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: Threading-Display-Style-Rule&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: Threading-Display-Style-Rule&lt;/H1&gt;
++ 
++ This option is very similar to &lt;A HREF=&quot;h_config_thread_disp_style&quot;&gt;
++ &lt;!--#echo var=&quot;VAR_threading-display-style&quot;--&gt;&lt;/A&gt;, but it is a rule which specifies the
++ display styles for a thread that you want displayed in a specific
++ folder or collection.
++ &lt;P&gt;
++ The token to be used in this function is _THREADSTYLE_. Here there is
++ an example of its use
++ &lt;P&gt;
++ _FOLDER_ == {pine-info} =&gt; _THREADSTYLE_{mutt-like}
++ &lt;P&gt;
++ The values that can be given for the _THREADSTYLE_ function are the
++ values of the threading-display-style function, which can be found
++ listed in the &lt;A HREF=&quot;h_config_thread_disp_style&quot;&gt;threading-display-style&lt;/A&gt;
++ configuration option.
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Pine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;
++ &lt;UL&gt;   
++ &lt;LI&gt;&lt;A HREF=&quot;h_finding_help&quot;&gt;Finding more information and requesting help&lt;/A&gt;
++ &lt;/UL&gt;&lt;P&gt;
++ &amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
++ ====== h_config_thread_index_style_rule =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;OPTION: Threading-Index-Style-Rule&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;OPTION: Threading-Index-Style-Rule&lt;/H1&gt;
++ 
++ This option is very similar to &lt;A HREF=&quot;h_config_thread_index_style&quot;&gt;
++ &lt;!--#echo var=&quot;VAR_threading-index-style&quot;--&gt;&lt;/A&gt;, but it is a rule which specifies the
++ index styles for a thread that you want displayed in a specific
++ folder or collection.
++ &lt;P&gt;
++ The token to be used in this function is _THREADINDEX_. Here there is
++ an example of its use
++ &lt;P&gt;
++ _FOLDER_ == {pine-info} =&gt; _THREADINDEX_{regular-index-with-expanded-threads}
++ &lt;P&gt;
++ The values that can be given for the _THREADINDEX_ function are the
++ values of the threading-index-display function, which can be found
++ listed in the &lt;A HREF=&quot;h_config_thread_index_style&quot;&gt;&lt;!--#echo var=&quot;VAR_threading-index-style&quot;--&gt;&lt;/A&gt;
++ configuration option.
++ 
++ &lt;P&gt; This configuration option is just one of many that allow you to
++ override the value of some global configurations within Pine. There is a
++ help text explaining how to define all of them, which you can read by
++ following this &lt;A HREF=&quot;h_config_new_rules&quot;&gt;link&lt;/A&gt;.
++ 
++ &lt;P&gt;
++ &lt;UL&gt;   
++ &lt;LI&gt;&lt;A HREF=&quot;h_finding_help&quot;&gt;Finding more information and requesting help&lt;/A&gt;
++ &lt;/UL&gt;&lt;P&gt;
++ &amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
+  ====== h_config_pruning_rule =====
+  &lt;HTML&gt;
+  &lt;HEAD&gt;
+***************
+*** 29159,29164 ****
+--- 30221,30249 ----
+  &amp;lt;End of help on this topic&amp;gt;
+  &lt;/BODY&gt;
+  &lt;/HTML&gt;
++ ====== h_config_auto_read_msgs_rules =====
++ &lt;HTML&gt;
++ &lt;HEAD&gt;
++ &lt;TITLE&gt;FEATURE: auto-move-read-msgs-using-rules&lt;/TITLE&gt;
++ &lt;/HEAD&gt;
++ &lt;BODY&gt;
++ &lt;H1&gt;FEATURE: auto-move-read-msgs-using-rules&lt;/H1&gt;
++ This feature controls an aspect of Pine's behavior upon quitting.  If set,
++ and the 
++ &lt;A HREF=&quot;h_config_read_message_folder&quot;&gt;&amp;quot;&lt;!--#echo var=&quot;VAR_read-message-folder&quot;--&gt;&amp;quot;&lt;/A&gt;
++ option is also set, then Pine will automatically transfer all read
++ messages to the designated folder using the rules that you have defined in
++ your
++ &lt;A HREF=&quot;h_config_save_rules&quot;&gt;&amp;quot;&lt;!--#echo var=&quot;VAR_save-rules&quot;--&gt;&amp;quot;&lt;/A&gt; and mark
++ them as deleted in the INBOX.  Messages in the INBOX marked with an 
++ &amp;quot;N&amp;quot; (meaning New, or unseen) are not affected.
++ &lt;P&gt;
++ &lt;UL&gt;   
++ &lt;LI&gt;&lt;A HREF=&quot;h_finding_help&quot;&gt;Finding more information and requesting help&lt;/A&gt;
++ &lt;/UL&gt;&lt;P&gt;
++ &amp;lt;End of help on this topic&amp;gt;
++ &lt;/BODY&gt;
++ &lt;/HTML&gt;
+  ====== h_config_auto_fcc_only =====
+  &lt;HTML&gt;
+  &lt;HEAD&gt;
+diff -rc alpine-1.10/pith/reply.c alpine-1.10.rules/pith/reply.c
+*** alpine-1.10/pith/reply.c	2008-03-06 12:54:01.000000000 -0800
+--- alpine-1.10.rules/pith/reply.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 44,50 ****
+  #include &quot;../pith/list.h&quot;
+  #include &quot;../pith/ablookup.h&quot;
+  #include &quot;../pith/mailcmd.h&quot;
+! 
+  
+  /*
+   * Internal prototypes
+--- 44,51 ----
+  #include &quot;../pith/list.h&quot;
+  #include &quot;../pith/ablookup.h&quot;
+  #include &quot;../pith/mailcmd.h&quot;
+! #include &quot;../pith/copyaddr.h&quot;
+! #include &quot;../pith/rules.h&quot;
+  
+  /*
+   * Internal prototypes
+***************
+*** 792,799 ****
+  reply_quote_str(ENVELOPE *env)
+  {
+      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
+  
+!     strncpy(buf, ps_global-&gt;VAR_REPLY_STRING, sizeof(buf)-1);
+      buf[sizeof(buf)-1] = '\0';
+  
+      /* set up the prefix to quote included text */
+--- 793,819 ----
+  reply_quote_str(ENVELOPE *env)
+  {
+      char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];
++     char reply_string[MAX_PREFIX+1];
+  
+!     { RULE_RESULT *rule;
+!       rule = get_result_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE , env);
+!        if (rule){
+!            strncpy(reply_string,rule-&gt;result,sizeof(reply_string));
+! 	   reply_string[sizeof(reply_string)-1] = '\0';
+!            if (rule-&gt;result)
+! 	      fs_give((void **)&amp;rule-&gt;result);
+! 	   fs_give((void **)&amp;rule);
+!        }
+!        else
+! 	  if ((ps_global-&gt;VAR_REPLY_STRING) &amp;&amp; (ps_global-&gt;VAR_REPLY_STRING[0])){
+! 	    strncpy(reply_string,ps_global-&gt;VAR_REPLY_STRING, sizeof(reply_string)-1);
+! 	    reply_string[sizeof(reply_string)-1] = '\0';
+! 	  }
+! 	  else
+!            strncpy(reply_string,&quot;&gt; &quot;,sizeof(&quot;&gt; &quot;));
+!     }
+! 
+!     strncpy(buf, reply_string, sizeof(buf)-1);
+      buf[sizeof(buf)-1] = '\0';
+  
+      /* set up the prefix to quote included text */
+***************
+*** 845,854 ****
+  int
+  reply_quote_str_contains_tokens(void)
+  {
+!     return(ps_global-&gt;VAR_REPLY_STRING &amp;&amp; ps_global-&gt;VAR_REPLY_STRING[0] &amp;&amp;
+! 	   (strstr(ps_global-&gt;VAR_REPLY_STRING, from_token) ||
+! 	    strstr(ps_global-&gt;VAR_REPLY_STRING, nick_token) ||
+! 	    strstr(ps_global-&gt;VAR_REPLY_STRING, init_token)));
+  }
+  
+  
+--- 865,893 ----
+  int
+  reply_quote_str_contains_tokens(void)
+  {
+!    char *reply_string;
+!       
+!    reply_string = (char *) malloc( 80*sizeof(char));
+!    { RULE_RESULT *rule;
+!      rule = get_result_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE, NULL);
+!       if (rule){
+!           reply_string = cpystr(rule-&gt;result);
+! 	  if (rule-&gt;result)
+! 	     fs_give((void **)&amp;rule-&gt;result);
+! 	  fs_give((void **)&amp;rule);
+!       }
+!       else
+! 	  if ((ps_global-&gt;VAR_REPLY_STRING) &amp;&amp; (ps_global-&gt;VAR_REPLY_STRING[0])){
+! 	    strncpy(reply_string,ps_global-&gt;VAR_REPLY_STRING, sizeof(reply_string)-1);
+! 	    reply_string[sizeof(reply_string)-1] = '\0';
+! 	  }
+! 	  else
+!           reply_string = cpystr(&quot;&gt; &quot;);
+!    }
+!     return(reply_string &amp;&amp; reply_string[0] &amp;&amp;
+! 	   (strstr(reply_string, from_token) ||
+! 	    strstr(reply_string, nick_token) ||
+! 	    strstr(reply_string, init_token)));
+  }
+  
+  
+***************
+*** 1312,1317 ****
+--- 1351,1360 ----
+      buf[0] = '\0';
+  
+      switch(type){
++       case iFfrom:
++ 	addr = env &amp;&amp; env-&gt;sparep ? env-&gt;sparep : NULL;
++ 	break;
++ 
+        case iFrom:
+  	addr = env ? env-&gt;from : NULL;
+  	break;
+***************
+*** 1697,1717 ****
+  
+  	break;
+  
+        case iFrom:
+        case iTo:
+        case iCc:
+        case iSender:
+        case iRecips:
+        case iInit:
+  	get_addr_data(env, type, buf, maxlen);
+  	break;
+  
+!       case iRoleNick:
+! 	if(role &amp;&amp; role-&gt;nick){
+! 	    strncpy(buf, role-&gt;nick, maxlen);
+! 	    buf[maxlen] = '\0';
+! 	}
+! 	break;
+  
+        case iNewLine:
+  	if(maxlen &gt;= strlen(NEWLINE)){
+--- 1740,1890 ----
+  
+  	break;
+  
++       case iProcid:
++         if(ps_global-&gt;procid){
++ 	   strncpy(buf, ps_global-&gt;procid, maxlen);
++ 	   buf[maxlen] = '\0';
++ 	}
++       break;
++ 
++       case iRole:
++         if (ps_global-&gt;role){
++ 	   strncpy(buf, ps_global-&gt;role, maxlen);
++ 	   buf[maxlen] = '\0';
++ 	}
++       break;
++ 
++       case iRoleNick:
++ 	if(role &amp;&amp; role-&gt;nick){
++ 	  strncpy(buf, role-&gt;nick, maxlen);
++ 	  buf[maxlen] = '\0';
++ 	}
++ 	break;
++ 
++       case iPkey:
++ 	if(ps_global-&gt;pressed_key){
++ 	  strcpy(buf, ps_global-&gt;pressed_key);
++ 	  buf[maxlen] = '\0';
++ 	}
++ 	break;
++ 
++       case iScreen:
++ 	if(ps_global-&gt;screen_name){
++ 	  strncpy(buf, ps_global-&gt;screen_name, maxlen);
++ 	  buf[maxlen] = '\0';
++ 	}
++ 	break;
++ 
++       case iFfrom:
+        case iFrom:
+        case iTo:
+        case iCc:
+        case iSender:
+        case iRecips:
+        case iInit:
++       if (env)  
+  	get_addr_data(env, type, buf, maxlen);
+  	break;
+  
+!      case iFolder:
+! 	if(ps_global-&gt;cur_folder){
+! 	  strncpy(buf,ps_global-&gt;cur_folder, maxlen);
+! 	  buf[maxlen] = '\0';
+! 	}
+!       break;
+! 
+!      case iCollection:
+! 	if(ps_global-&gt;context_current-&gt;nickname){
+! 	  strncpy(buf,ps_global-&gt;context_current-&gt;nickname, maxlen);
+! 	  buf[maxlen] = '\0';
+! 	}
+!       break;
+!       
+!      case iFlag:
+!         {MAILSTREAM *stream = find_open_stream();
+! 	 MSGNO_S *msgmap = NULL;
+!          long msgno;
+!          MESSAGECACHE *mc;
+! 	 strncpy(buf, &quot;_FLAG_&quot;, maxlen);	/* default value */
+! 	 if (stream){
+! 	     mn_init(&amp;msgmap, stream-&gt;nmsgs);
+! 	     msgno =  mn_m2raw(msgmap, rules_cursor_pos(stream));
+! 	     if (msgno &gt; 0L) mc = stream ? mail_elt(stream,  msgno) : NULL;
+! 	     if (mc)
+! 	        sprintf(buf,&quot;%s%s%s%s&quot;,mc-&gt;flagged ? &quot;*&quot; : &quot;&quot;,
+!                 mc-&gt;recent   ? (mc-&gt;seen ? &quot;R&quot; : &quot;N&quot;) : (mc-&gt;seen) ? &quot;R&quot; : &quot;U&quot;,
+!                 mc-&gt;answered ? &quot;A&quot; : &quot;&quot;,
+!                 mc-&gt;deleted  ? &quot;D&quot; : &quot;&quot; );
+! 	     mn_give(&amp;msgmap);
+! 	 }
+! 	 buf[maxlen] = '\0';
+!         }
+!         break;
+!          
+!      case iNick:
+!      {
+!       ADDRESS *tmp_adr = NULL;
+!       if (env){
+!          tmp_adr = env-&gt;from ? copyaddr(env-&gt;from)
+!                      : env-&gt;sender ? copyaddr(env-&gt;sender) : NULL;
+!          get_nickname_from_addr(tmp_adr,buf,maxlen);
+! 	 mail_free_address(&amp;tmp_adr);
+!       }
+!      }
+!         break;
+! 
+!      case iAddressCc:
+!      case iAddressRecip:
+!      case iAddressTo:
+!      case iFadd:
+!      {
+!      int plen = 0; 	/* partial length */
+!      ADDRESS *sparep2 = (type == iAddressTo || type == iAddressRecip) 
+! 			? ((env &amp;&amp; env-&gt;to) 
+! 			   ? copyaddrlist(env-&gt;to)
+! 			   : NULL)
+! 			: (type == iAddressCc)
+! 			    ? ((env &amp;&amp; env-&gt;cc) 
+! 				? copyaddrlist(env-&gt;cc)
+! 				: NULL)
+! 			    : ((env &amp;&amp; env-&gt;sparep) 
+! 				? copyaddr((ADDRESS *)env-&gt;sparep)
+! 				: NULL);
+!       ADDRESS *sparep;
+! 
+!       if (type == iAddressRecip){
+! 	  ADDRESS *last_to = NULL;
+! 
+! 	for(last_to = sparep2;last_to &amp;&amp; last_to-&gt;next; last_to= last_to-&gt;next);
+! 	
+! 	/* Make the end of To list point to cc list */
+! 	if(last_to)
+! 	  last_to-&gt;next = (env &amp;&amp; env-&gt;cc ? copyaddrlist(env-&gt;cc) : NULL);
+! 
+!       }
+!       sparep = sparep2;
+!       for(; sparep ; sparep = sparep-&gt;next)
+! 	if(sparep &amp;&amp; sparep-&gt;mailbox &amp;&amp; sparep-&gt;mailbox[0] &amp;&amp;
+! 	   (plen ? plen + 1 : plen) + strlen(sparep-&gt;mailbox) &lt;= maxlen){
+! 	   if (plen == 0)
+! 	       strcpy(buf, sparep-&gt;mailbox);
+! 	   else{
+! 	       strcat(buf, &quot; &quot;);
+! 	       strcat(buf, sparep-&gt;mailbox);
+! 	   }
+! 	   if(sparep-&gt;host &amp;&amp;
+!         	   sparep-&gt;host[0] &amp;&amp;
+! 		   sparep-&gt;host[0] != '.' &amp;&amp;
+! 		   strlen(buf) + strlen(sparep-&gt;host) + 1 &lt;= maxlen){
+! 	      strcat(buf, &quot;@&quot;);
+!               strcat(buf, sparep-&gt;host);
+!            }
+! 	   plen = strlen(buf);
+! 	}
+! 	 mail_free_address(&amp;sparep2);
+!      }
+!          
+!       break;  
+  
+        case iNewLine:
+  	if(maxlen &gt;= strlen(NEWLINE)){
+***************
+*** 1740,1745 ****
+--- 1913,1923 ----
+  
+  	break;
+  
++       case iLcc:	/* fake it, there are not enough spare pointers */
++ 	if (env &amp;&amp; env-&gt;date)
++ 	  sprintf(buf,&quot;%s&quot;,env-&gt;date);
++ 	break;
++ 
+        case iNews:
+        case iCurNews:
+  	get_news_data(env, type, buf, maxlen);
+***************
+*** 1789,1794 ****
+--- 1967,1980 ----
+  
+  	break;
+  
++       case iOpeningText:
++       case iOpeningTextNQ:
++ 	if(env &amp;&amp; env-&gt;sparep){
++ 	   strncpy(buf, ((SPAREP_S *)env-&gt;sparep)-&gt;value, maxlen);
++ 	   buf[maxlen] = '\0';
++ 	}
++ 	break;
++ 
+        case iSubject:
+  	if(env &amp;&amp; env-&gt;subject){
+  	    size_t n, len;
+***************
+*** 1847,1853 ****
+      if(!env)
+        return;
+  
+!     strncpy(buf, ps_global-&gt;VAR_REPLY_INTRO, MAX_DELIM);
+      buf[MAX_DELIM] = '\0';
+      /* preserve exact default behavior from before */
+      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
+--- 2033,2050 ----
+      if(!env)
+        return;
+  
+!     { RULE_RESULT *rule;
+! 	rule = get_result_rule(V_REPLY_LEADIN_RULES, FOR_REPLY_INTRO, env);
+! 	if(rule){
+! 	   strncpy(buf, rule-&gt;result, MAX_DELIM);
+! 	   if (rule-&gt;result)
+! 	      fs_give((void **)&amp;rule-&gt;result);
+! 	   fs_give((void **)&amp;rule);
+! 	}
+! 	else
+! 	  strncpy(buf, ps_global-&gt;VAR_REPLY_INTRO, MAX_DELIM);
+!     }
+! 
+      buf[MAX_DELIM] = '\0';
+      /* preserve exact default behavior from before */
+      if(!strcmp(buf, DEFAULT_REPLY_INTRO)){
+***************
+*** 2106,2111 ****
+--- 2303,2309 ----
+  {
+      size_t l;
+      char  *p, buftmp[MAILTMPLEN];
++     RULE_RESULT *rule;
+      
+      if(!env)
+        return(NULL);
+***************
+*** 2113,2121 ****
+      dprint((9, &quot;checking subject: \&quot;%s\&quot;\n&quot;,
+  	       env-&gt;subject ? env-&gt;subject : &quot;NULL&quot;));
+  
+!     if(env-&gt;subject &amp;&amp; env-&gt;subject[0]){		/* add (fwd)? */
+! 	snprintf(buftmp, sizeof(buftmp), &quot;%s&quot;, env-&gt;subject);
+! 	buftmp[sizeof(buftmp)-1] = '\0';
+  	/* decode any 8bit (copy to the temp buffer if decoding doesn't) */
+  	if(rfc1522_decode_to_utf8((unsigned char *) tmp_20k_buf,
+  				  SIZEOF_20KBUF, buftmp) == (unsigned char *) buftmp)
+--- 2311,2330 ----
+      dprint((9, &quot;checking subject: \&quot;%s\&quot;\n&quot;,
+  	       env-&gt;subject ? env-&gt;subject : &quot;NULL&quot;));
+  
+!     buftmp[0] = '\0';
+!     ps_global-&gt;procid = cpystr(&quot;fwd-subject&quot;);
+!     if (rule = get_result_rule(V_FORWARD_RULES,FOR_COMPOSE, env)){
+!        sprintf(buftmp, &quot;%.200s&quot;, rule-&gt;result);
+!        if(rule-&gt;result)
+!        fs_give((void **)&amp;rule-&gt;result);
+!        fs_give((void **)&amp;rule);
+!     }
+!     else if(env-&gt;subject)
+!        sprintf(buftmp, &quot;%.200s&quot;, env-&gt;subject);
+!     buftmp[sizeof(buftmp)-1] = '\0';
+!     fs_give((void **)&amp;ps_global-&gt;procid);
+! 
+!     if(buftmp[0]){            /* add (fwd)? */
+  	/* decode any 8bit (copy to the temp buffer if decoding doesn't) */
+  	if(rfc1522_decode_to_utf8((unsigned char *) tmp_20k_buf,
+  				  SIZEOF_20KBUF, buftmp) == (unsigned char *) buftmp)
+diff -rc alpine-1.10/pith/rules.c alpine-1.10.rules/pith/rules.c
+*** alpine-1.10/pith/rules.c	2008-03-17 20:33:24.000000000 -0700
+--- alpine-1.10.rules/pith/rules.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 0 ****
+--- 1,1148 ----
++ /* This module was written by
++  *
++  * Eduardo Chappa (<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">chappa at washington.edu</A>)
++  * <A HREF="http://staff.washington.edu/chappa/pine/">http://staff.washington.edu/chappa/pine/</A>
++  *
++  *  Original Version: November 1999
++  *  Last Modified   : January 24, 2008
++  *
++  * Send bug reports about this module to the address above.
++  */
++ 
++ #include &quot;../pith/headers.h&quot;
++ #include &quot;../pith/state.h&quot;
++ #include &quot;../pith/conf.h&quot;
++ #include &quot;../pith/copyaddr.h&quot;
++ #include &quot;../pith/rules.h&quot;
++ 
++ /* Internal Prototypes */
++ 
++ int   test_condition  (CONDITION_S *, int, ENVELOPE *);
++ int   test_in         (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
++ int   test_ni         (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
++ int   test_not_in     (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
++ int   test_not_ni     (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
++ int   test_eq         (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
++ int   test_not_eq     (CONDITION_S *, TOKEN_VALUE *, ENVELOPE *, int);
++ int   isolate_condition (char *, char **, int *);
++ char  *test_rule      (RULELIST *, int, ENVELOPE *, int *);
++ char  *trim           (RULEACTION_S *, int, ENVELOPE *);
++ char  *rextrim        (RULEACTION_S *, int, ENVELOPE *);
++ char  *raw_value      (RULEACTION_S *, int, ENVELOPE *);
++ char  *extended_value (RULEACTION_S *, int, ENVELOPE *);
++ char  *exec_fcn	      (RULEACTION_S *, int, ENVELOPE *);
++ char  *expand         (char *, void *);
++ char  *get_name_token (char *);
++ char  *advance_to_char (char *, char, int, int *);
++ char  **functions_for_token (char *);
++ void  free_token_value (TOKEN_VALUE **);
++ void  free_condition  (CONDITION_S **);
++ void  free_ruleaction (RULEACTION_S **);
++ void  free_rule       (RULE_S **);
++ void  free_rule_list  (RULELIST **);
++ void  free_alloc_rule (void **, int);
++ void  *alloc_mem      (size_t);
++ void  add_rule        (int, int);
++ void  set_rule_list    (struct variable *);
++ void  parse_patterns_into_action(TOKEN_VALUE **);
++ void  free_parsed_value(TOKEN_VALUE **value);
++ RULE_S   *parse_rule  (char *, int);
++ RULELIST *get_rule_list (char **, int, int);
++ TOKEN_VALUE *parse_group_data (char *,int *);
++ TOKEN_VALUE *copy_parsed_value (TOKEN_VALUE *, int, ENVELOPE *);
++ CONDITION_S *fill_condition (char *);
++ CONDITION_S *parse_condition (char *, int *);
++ PRULELIST_S *add_prule        (PRULELIST_S *, PRULELIST_S *);
++ RULEACTION_S *parse_action (char *, int);
++ 
++ REL_TOKEN rel_rules_test[] = {
++    {EQ_REL,     Equal,          test_eq},
++    {IN_REL,     Subset,         test_in},
++    {NI_REL,     Includes,       test_ni},
++    {NOT_EQ_REL, NotEqual,       test_not_eq},
++    {NOT_IN_REL, NotSubset,      test_not_in},
++    {NOT_NI_REL, NotIncludes,    test_not_ni},
++    {NULL,       EndTypes,       NULL}
++ };
++ 
++ #define NREL  (sizeof(rel_rules_test)/sizeof(rel_rules_test[0]) - 1)
++ 
++ RULE_FCN rule_fcns[] = {
++ {COPY_FCN,      extended_value, FOR_SAVE|FOR_COMPOSE},
++ {SAVE_FCN,      extended_value, FOR_SAVE},
++ {EXEC_FCN,	exec_fcn,	FOR_REPLACE|FOR_TRIM|FOR_RESUB|FOR_COMPOSE},
++ {REPLY_FCN,     extended_value, FOR_REPLY_INTRO},
++ {TRIM_FCN,      trim,           FOR_TRIM|FOR_RESUB|FOR_COMPOSE},
++ {REPLACE_FCN,   extended_value, FOR_REPLACE},
++ {SORT_FCN,      raw_value,      FOR_SORT},
++ {INDEX_FCN,     raw_value,      FOR_INDEX},
++ {COMMAND_FCN,   raw_value,      FOR_KEY},
++ {REPLYSTR_FCN,  raw_value,      FOR_COMPOSE},
++ {SIGNATURE_FCN, raw_value,      FOR_COMPOSE},
++ {RESUB_FCN,     extended_value, FOR_RESUB},
++ {STARTUP_FCN,   raw_value,      FOR_STARTUP},
++ {REXTRIM_FCN,   rextrim,        FOR_TRIM|FOR_RESUB|FOR_COMPOSE},
++ {THRDSTYLE_FCN, raw_value,      FOR_THREAD},
++ {THRDINDEX_FCN, raw_value,      FOR_THREAD},
++ {SMTP_FCN,      raw_value,      FOR_COMPOSE},
++ {NULL,          0,              FOR_NOTHING}
++ };
++ 
++ char* token_rules[] = {
++    FROM_TOKEN,
++    NICK_TOKEN,
++    OTEXT_TOKEN,
++    OTEXTNQ_TOKEN,
++    ROLE_TOKEN,
++    FOLDER_TOKEN,
++    SUBJ_TOKEN,
++    PROCID_TOKEN,
++    THDDSPSTY_TOKEN,
++    THDNDXSTY_TOKEN,
++    FLAG_TOKEN,
++    COLLECT_TOKEN,
++    THDDSPSTY_TOKEN,
++    ADDR_TOKEN,
++    TO_TOKEN,
++    ADDTO_TOKEN,
++    ADDCC_TOKEN,
++    ADDRECIP_TOKEN,
++    SCREEN_TOKEN,
++    KEY_TOKEN,
++    SEND_TOKEN,
++    CC_TOKEN,
++    LCC_TOKEN,
++    BCC_TOKEN,
++    FFROM_TOKEN,
++    FADDRESS_TOKEN,
++    NULL
++ };
++ 
++ #define NTOKENS  (sizeof(token_rules)/sizeof(token_rules[0]) - 1)
++ #define NFCN    (sizeof(rule_fcns)/sizeof(rule_fcns[0]) - 1)
++ 
++ char *subj_fcn[]    = {SUBJ_TOKEN,    REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
++ char *from_fcn[]    = {FROM_TOKEN,    REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
++ char *otext_fcn[]   = {OTEXT_TOKEN,   REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
++ char *otextnq_fcn[] = {OTEXTNQ_TOKEN, REPLACE_FCN, TRIM_FCN, REXTRIM_FCN, EXEC_FCN};
++ 
++ char *adto_fcn[] = {ADDTO_TOKEN, EXEC_FCN, NULL, NULL, NULL};
++ 
++ char **fcns_for_index[] = {subj_fcn, from_fcn, otext_fcn, otextnq_fcn};
++ 
++ #define NFCNFI    (sizeof(fcns_for_index)/sizeof(fcns_for_index[0])) /*for idx*/
++ #define NFPT      (sizeof(fcns_for_index[0])) /* functions pert token */
++ 
++ SPAREP_S *
++ get_sparep_for_rule(char *value, int flag)
++ {
++   SPAREP_S *rv;
++   rv = (SPAREP_S *) alloc_mem(sizeof(SPAREP_S));
++   rv-&gt;flag = flag;
++   rv-&gt;value = value ? cpystr(value) : NULL;
++   return rv;
++ }
++ 
++ void free_sparep_for_rule(void **sparep)
++ {
++   SPAREP_S *spare = (SPAREP_S *) *sparep;
++   if(!spare) return;
++   if(spare-&gt;value)
++      fs_give((void **)&amp;spare-&gt;value);
++   fs_give((void **)sparep);
++ }
++ 
++ 
++ int context_for_function(char *name)
++ {
++   int i, j;
++   for (i = 0; i &lt; NFCN &amp;&amp; strcmp(rule_fcns[i].name, name); i++);
++   return i == NFCN ? 0 : rule_fcns[i].what_for;
++ 
++ }
++ 
++ char **functions_for_token(char *name)
++ {
++   int i;
++   for (i = 0; i &lt; NFCNFI &amp;&amp; strcmp(fcns_for_index[i][0], name); i++);
++   return i == NFCNFI ? NULL : fcns_for_index[i];
++ }
++ 
++ void
++ free_alloc_rule (void **voidtext, int code)
++ {
++   switch(code){
++      case FREEREGEX : regfree((regex_t *)*voidtext);
++ 			break;
++ 	default: break;
++   }
++ }
++ 
++ 
++ 
++ void free_token_value(TOKEN_VALUE **token)
++ {
++    if(token &amp;&amp; *token){
++      if ((*token)-&gt;testxt)
++ 	fs_give((void **)&amp;(*token)-&gt;testxt);
++      free_alloc_rule (&amp;(*token)-&gt;voidtxt, (*token)-&gt;codefcn);
++      if((*token)-&gt;next)
++ 	free_token_value(&amp;(*token)-&gt;next);
++      fs_give((void **)token);
++    }
++ }
++ 
++ void free_condition(CONDITION_S **condition)
++ {
++    if(condition &amp;&amp; *condition){
++      if ((*condition)-&gt;tname)
++ 	fs_give((void **)&amp;((*condition)-&gt;tname));
++      if ((*condition)-&gt;value)
++ 	free_token_value(&amp;((*condition)-&gt;value));
++      if((*condition)-&gt;next)
++ 	free_condition(&amp;((*condition)-&gt;next));
++      fs_give((void **)condition);
++    }
++ }
++ 
++ void free_ruleaction(RULEACTION_S **raction)
++ {
++    if(raction &amp;&amp; *raction){
++      if ((*raction)-&gt;token)
++ 	fs_give((void **)&amp;((*raction)-&gt;token));
++      if ((*raction)-&gt;function)
++ 	fs_give((void **)&amp;((*raction)-&gt;function));
++      if ((*raction)-&gt;value)
++ 	free_token_value(&amp;(*raction)-&gt;value);
++      fs_give((void **)raction);
++    }
++ }
++ 
++ void free_rule(RULE_S **rule)
++ {
++    if(rule &amp;&amp; *rule){
++      free_condition(&amp;((*rule)-&gt;condition));
++      free_ruleaction(&amp;((*rule)-&gt;action));
++      fs_give((void **)rule);
++    }
++ }
++ 
++ void free_rule_list(RULELIST **rule)
++ {
++   if(!*rule)
++     return;
++ 
++   if((*rule)-&gt;next)
++     free_rule_list(&amp;((*rule)-&gt;next));
++ 
++   if((*rule)-&gt;prule)
++     free_rule(&amp;((*rule)-&gt;prule));
++ 
++   fs_give((void **)rule);
++ }
++ 
++ void
++ free_parsed_rule_list(PRULELIST_S **rule)
++ {
++   if(!*rule)
++     return;
++ 
++   if((*rule)-&gt;next)
++     free_parsed_rule_list(&amp;((*rule)-&gt;next));
++ 
++   if((*rule)-&gt;rlist)
++     free_rule_list(&amp;((*rule)-&gt;rlist));
++ 
++   fs_give((void **)rule);
++ }
++ 
++ void *
++ alloc_mem (size_t amount)
++ {
++    void *genmem;
++    memset(genmem = fs_get(amount), 0, amount);
++    return genmem;
++ }
++ 
++ 
++ void
++ parse_patterns_into_action(TOKEN_VALUE **tokenp)
++ {
++   if(!*tokenp)
++     return;
++ 
++   if((*tokenp)-&gt;testxt){
++       regex_t preg;
++ 
++       (*tokenp)-&gt;voidtxt = NULL;
++       (*tokenp)-&gt;voidtxt = fs_get(sizeof(regex_t));
++       if (regcomp((regex_t *)(*tokenp)-&gt;voidtxt, 
++ 			(*tokenp)-&gt;testxt, REG_EXTENDED) != 0){
++          regfree((regex_t *)(*tokenp)-&gt;voidtxt);
++ 	 (*tokenp)-&gt;voidtxt = NULL;
++       }
++   }
++   if((*tokenp)-&gt;voidtxt)
++      (*tokenp)-&gt;codefcn = FREEREGEX;
++   if((*tokenp)-&gt;next)
++      parse_patterns_into_action(&amp;(*tokenp)-&gt;next);
++ }
++ 
++ 
++ int
++ isolate_condition (char *data, char **cvalue, int  *len)
++ {
++   char *p = data;
++   int done = 0, error = 0, next_condition = 0, l;
++ 
++   if(*p == '&quot;' &amp;&amp; p[strlen(p) - 1] == '&quot;'){
++     p[strlen(p) - 1] = '\0';
++     p++;
++   }
++   *cvalue = NULL;
++   while (*p &amp;&amp; !done){
++ 	switch (*p){
++ 	   case '_': *cvalue = advance_to_char(p,'}', STRICTLY, NULL);
++ 		     if(*cvalue){
++ 			strcat(*cvalue,&quot;}&quot;);
++ 			p += strlen(*cvalue);
++ 		     }
++ 		     else
++ 			error++;
++ 		     done++;
++ 	   case ' ': p++;
++ 		     break;
++ 	   case '&amp;': if (*(p+1) == '&amp;'){	/* looking for &amp;&amp; */
++ 			p += 2;
++ 			next_condition++;
++ 		     }
++ 		     else{
++ 			error++;
++ 			done++;
++ 		     }
++ 		     break;
++ 	   case '=': /* looking for =&gt; or -&gt; */
++ 	   case '-': if ((*(p+1) == '&gt;') &amp;&amp; (!next_condition)){
++ 		        is_save = (*p == '-');
++ 			p += 2;
++ 		     }
++ 		     else
++ 			error++;
++ 		     done++;
++ 		     break;
++ 	   default : done++;
++ 		     error++;
++ 		     break;
++ 	}
++   }
++   *len = p - data;
++   return error ? -1 : (*cvalue ? 1 : 0);
++ }
++ 
++ TOKEN_VALUE *
++ parse_group_data (char *data, int *error)
++ {
++   TOKEN_VALUE *rvalue;
++   char *p;
++   int offset, err = 0;
++ 
++   if(error)
++     *error = 0;
++ 
++   if (!data)
++      return (TOKEN_VALUE *) NULL;
++ 
++   rvalue = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
++   if (p = advance_to_char(data,';', STRICTLY, &amp;offset)){
++       rvalue-&gt;testxt = cpystr(p);
++       data += strlen(p) + 1 + offset;
++       rvalue-&gt;next   = parse_group_data(data, error);
++   }
++   else if (p = advance_to_char(data,'}', STRICTLY, NULL))
++       rvalue-&gt;testxt = cpystr(p);
++   else if (data &amp;&amp; *data == '}')
++       rvalue-&gt;testxt = cpystr(&quot;&quot;);
++   else{
++       err++;
++       free_token_value(&amp;rvalue);
++   }
++   if (error)
++     *error += err;
++   return(rvalue);
++ }
++ 
++ CONDITION_S *
++ fill_condition(char *data)
++ {
++   CONDITION_S *condition;
++   int i, done, error = 0;
++   char *group;
++ 
++   for (i = 0, done = 0; !done &amp;&amp; (i &lt; NTOKENS); i++)
++       done = strncmp(data,token_rules[i], strlen(token_rules[i])) ? 0 : 1;
++   if (done){
++      condition = (CONDITION_S *) alloc_mem(sizeof(CONDITION_S));
++      condition-&gt;tname = cpystr(token_rules[--i]);
++   }
++   else
++      return (CONDITION_S *)NULL;
++ 
++   data += strlen(token_rules[i]);
++   for (; *data &amp;&amp; *data == ' '; data++);
++   if (*data){
++      for (i = 0, done = 0; !done &amp;&amp; (i &lt; NREL); i++)
++        done = strncmp(data, rel_rules_test[i].value, 2) ? 0 : 1;
++      if (done)
++        condition-&gt;ttype = rel_rules_test[--i].ttype;
++      else{
++ 	 free_condition(&amp;condition);
++ 	 return (CONDITION_S *) NULL;
++      }
++   }
++   data += 2;
++   for (; *data &amp;&amp; *data == ' '; data++);
++   if (*data++ != '{'){
++      free_condition(&amp;condition);
++      return (CONDITION_S *) NULL;
++   }
++   group = advance_to_char(data,'}', STRICTLY, &amp;error); 
++   if (group || (!group &amp;&amp;  error &lt; 0)){
++      condition-&gt;value = parse_group_data(data, &amp;error);
++      if(group &amp;&amp; error)
++ 	free_condition(&amp;condition);
++      if(group)
++         fs_give((void **) &amp;group);
++   }
++   else
++      free_condition(&amp;condition);
++   return condition;
++ }
++ 
++ /* eoc = end of condition, equal to -1 on error */
++ CONDITION_S *
++ parse_condition (char *data, int *eoc)
++ {
++   CONDITION_S *condition = NULL;
++   char *p = data, *cvalue;
++   int len, error = 0, rv;
++ 
++   if((rv = isolate_condition(data, &amp;cvalue, &amp;len)) &gt; 0){
++     if(condition = fill_condition(cvalue))
++        condition-&gt;next = parse_condition(data+len, eoc);
++     else
++        error++;
++   }
++   *eoc += len;
++   if (error)
++     *eoc = -1;
++   return condition;
++ }
++ 
++ RULEACTION_S *
++ parse_action (char *data, int context)
++ {
++   int i, done;
++   RULEACTION_S *raction = NULL;
++   char *function, *p = data;
++ 
++   if (!p)
++      return (RULEACTION_S *) NULL;
++ 
++   for (; *p &amp;&amp; *p == ' '; p++);
++   if (!*p)
++      return (RULEACTION_S *) NULL;
++ 
++   if (is_save){
++      raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
++      raction-&gt;function = cpystr(&quot;_SAVE_&quot;);
++      raction-&gt;value    = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
++      raction-&gt;context |= FOR_SAVE;
++      raction-&gt;exec     = extended_value;
++      raction-&gt;value-&gt;testxt = cpystr(p);
++      return raction;
++   }
++   for (i = 0, done = 0; !done &amp;&amp; (i &lt; NFCN); i++)
++        done = (strstr(p,rule_fcns[i].name) == p);
++   p += done ? strlen(rule_fcns[--i].name) + 1 : 0;
++   if(!*p || (rule_fcns[i].what_for &amp;&amp; !(rule_fcns[i].what_for &amp; context)))
++      return (RULEACTION_S *) NULL;
++   if (done){
++      raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
++ 	/* We assign raction-&gt;token to be subject. This is not necessary for
++ 	   most rules. It is done only for rules that need it and will not
++ 	   make any difference in rules that do not need it. It will hopefully
++ 	   reduce complexity in the language
++ 	 */
++      raction-&gt;token    = cpystr(SUBJ_TOKEN);
++      raction-&gt;function = cpystr(rule_fcns[i].name);
++      raction-&gt;context  = rule_fcns[i].what_for;
++      raction-&gt;exec     = rule_fcns[i].execute;
++      raction-&gt;value    = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
++      raction-&gt;value-&gt;testxt = advance_to_char(p,'}', STRICTLY, NULL);
++      if(!raction-&gt;value-&gt;testxt)
++        free_ruleaction(&amp;raction);
++      return raction;
++   }
++ 
++   done = (((function = strstr(p, &quot;_TRIM_&quot;)) != NULL)
++ 	  ? 1 : ((function = strstr(p, &quot;_COPY_&quot;)) != NULL)
++ 	  ? 2 : ((function = strstr(p, &quot;_EXEC_&quot;)) != NULL)
++ 	  ? 3 : ((function = strstr(p, &quot;_REXTRIM_&quot;)) != NULL)
++ 	  ? 4 : ((function = strstr(p, &quot;_REPLACE_&quot;)) != NULL)
++ 	  ? 5 : 0);
++ 
++   if(!function)
++      return (RULEACTION_S *) NULL;
++ 
++   *function = '\0';
++    raction = (RULEACTION_S *) alloc_mem(sizeof(RULEACTION_S));
++    raction-&gt;token = get_name_token(p);
++   *function = '_';
++    p += strlen(raction-&gt;token) + 1;
++    for (; *p &amp;&amp; *p == ' '; p++);
++    if (!strncmp(p,&quot;:=&quot;,2))
++       p += 2;
++    else{
++       free_ruleaction(&amp;raction);
++       return (RULEACTION_S *) NULL;
++    }
++    for (; *p &amp;&amp; *p == ' '; p++);
++    if (p != function){
++       free_ruleaction(&amp;raction);
++       return (RULEACTION_S *) NULL;
++    }
++    p += done &lt;= 3 ? 6 : 9; /* 6 = strlen(&quot;_EXEC_&quot;), 9 = strlen(&quot;_REPLACE_&quot;) */
++    if (*p != '{'){
++       free_ruleaction(&amp;raction);
++       return (RULEACTION_S *) NULL;
++    }
++    *p = '\0';
++    for(i = 0; i &lt; NFCN &amp;&amp; strcmp(function, rule_fcns[i].name);i++);
++    raction-&gt;function   = cpystr(function);
++    raction-&gt;is_trim    = strcmp(function,&quot;_TRIM_&quot;)    ? 0 : 1;
++    raction-&gt;is_rextrim = strcmp(function,&quot;_REXTRIM_&quot;) ? 0 : 1;
++    raction-&gt;is_replace = strcmp(function,&quot;_REPLACE_&quot;) ? 0 : 1;
++    raction-&gt;context  = rule_fcns[i].what_for;
++    raction-&gt;exec     = rule_fcns[i].execute;
++    *p++ = '{';
++    if((raction-&gt;value = parse_group_data(p, NULL)) == NULL 
++ 	|| raction-&gt;value-&gt;testxt == NULL)
++       free_ruleaction(&amp;raction);
++    if(raction &amp;&amp; raction-&gt;is_rextrim)
++       parse_patterns_into_action(&amp;raction-&gt;value);
++    return raction;
++ }
++ 
++ RULE_S *
++ parse_rule (char *data, int context)
++ {
++   RULE_S *prule;	/*parsed rule */
++   int len = 0;
++   
++   if (!(prule = (RULE_S *) alloc_mem(sizeof(RULE_S))) ||
++ 	!(prule-&gt;condition = parse_condition(data, &amp;len)) ||
++ 	!(prule-&gt;action = parse_action(data+len, context)))
++       free_rule(&amp;prule);
++ 
++   return prule;
++ }
++ 
++ RULELIST *
++ get_rule_list(char **list, int context, int i)
++ {
++   RULE_S *rule;
++   RULELIST *trulelist = NULL;
++ 
++   if (list[i] &amp;&amp; *list[i]){
++      if(rule = parse_rule(list[i], context)){
++ 	trulelist  = (RULELIST *)alloc_mem(sizeof(RULELIST));
++ 	trulelist-&gt;prule = rule;
++ 	trulelist-&gt;next = get_rule_list(list, context, i+1);
++      }
++      else
++ 	trulelist = get_rule_list(list, context, i+1);
++   }
++   return trulelist;
++ }
++ 
++ PRULELIST_S *
++ add_prule(PRULELIST_S *rule_list, PRULELIST_S *rule)
++ {
++    if (!rule_list)
++       rule_list = (PRULELIST_S *) alloc_mem(sizeof(PRULELIST_S));
++ 
++    if(rule_list-&gt;next)
++      rule_list-&gt;next = add_prule(rule_list-&gt;next, rule);
++    else{
++      if (rule_list-&gt;rlist)
++ 	rule_list-&gt;next = rule;
++      else
++ 	rule_list = rule;
++    }
++    return rule_list;
++ }  
++ 
++ void
++ add_rule(int code, int context)
++ {
++   char **list = ps_global-&gt;vars[code].current_val.l;
++   PRULELIST_S *prulelist, *trulelist, *orulelist;
++ 
++   if (list &amp;&amp; *list &amp;&amp; **list){
++      trulelist = (PRULELIST_S *)alloc_mem(sizeof(PRULELIST_S));
++      trulelist-&gt;varnum = code;
++      if (trulelist-&gt;rlist = get_rule_list(list, context, 0))
++         ps_global-&gt;rule_list = add_prule(ps_global-&gt;rule_list, trulelist);
++      else
++ 	free_parsed_rule_list(&amp;trulelist);
++   }
++ }
++ 
++ /* see create_rule_list below */
++ void
++ set_rule_list(struct variable *vars)
++ {
++     set_current_val(&amp;vars[V_THREAD_DISP_STYLE_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_THREAD_INDEX_STYLE_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_COMPOSE_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_FORWARD_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_INDEX_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_KEY_RULES], FALSE, TRUE);
++     set_current_val(&amp;vars[V_REPLACE_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_REPLY_INDENT_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_REPLY_LEADIN_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_RESUB_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_SAVE_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_SMTP_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_SORT_RULES], TRUE, TRUE);
++     set_current_val(&amp;vars[V_STARTUP_RULES], TRUE, TRUE);
++ }
++ 
++ /* see set_rule_list above */
++ void
++ create_rule_list(struct variable *vars)
++ {
++   set_rule_list(vars);
++   add_rule(V_THREAD_DISP_STYLE_RULES, FOR_THREAD);
++   add_rule(V_THREAD_INDEX_STYLE_RULES, FOR_THREAD);
++   add_rule(V_COMPOSE_RULES, FOR_COMPOSE);
++   add_rule(V_FORWARD_RULES, FOR_COMPOSE);
++   add_rule(V_INDEX_RULES, FOR_INDEX);
++   add_rule(V_KEY_RULES, FOR_KEY);
++   add_rule(V_REPLACE_RULES, FOR_REPLACE);
++   add_rule(V_REPLY_INDENT_RULES, FOR_COMPOSE);
++   add_rule(V_REPLY_LEADIN_RULES, FOR_REPLY_INTRO);
++   add_rule(V_RESUB_RULES, FOR_RESUB|FOR_TRIM);
++   add_rule(V_SAVE_RULES, FOR_SAVE);
++   add_rule(V_SMTP_RULES, FOR_COMPOSE);
++   add_rule(V_SORT_RULES, FOR_SORT);
++   add_rule(V_STARTUP_RULES, FOR_STARTUP);
++ }
++ 
++ int
++ condition_contains_token(CONDITION_S *condition, char *token)
++ {
++   return condition ? (!strcmp(condition-&gt;tname, token) 
++ 			? 1
++ 			: condition_contains_token(condition-&gt;next, token)) 
++ 		    : 0;
++ }
++ 
++ RULELIST *
++ get_rulelist_from_code(int code, PRULELIST_S *list)
++ {
++   return list ? (list-&gt;varnum == code ? list-&gt;rlist 
++ 			      : get_rulelist_from_code(code, list-&gt;next))
++ 	      : (RULELIST *) NULL;
++ }   
++ 
++ char *
++ test_rule(RULELIST *rlist, int ctxt, ENVELOPE *env, int *n)
++ {
++   char *result;
++ 
++   if(!rlist)
++      return NULL;
++ 
++   if (result = process_rule(rlist-&gt;prule, ctxt, env))
++       return result;
++   else{
++        (*n)++;
++        return test_rule(rlist-&gt;next, ctxt, env, n);
++   } 
++ }
++ 
++ RULE_S *
++ get_rule (RULELIST *rule, int n)
++ {
++   return rule ? (n ? get_rule(rule-&gt;next, n-1) : rule-&gt;prule) 
++ 	      : (RULE_S *) NULL;
++ }
++ 
++ /* get_result_rule:
++  * Parameters: list: the list of rules to be passed to the function to check
++  *             rule_context: context of the rule
++  *             env : envelope used to check the rule, if needed.
++  *
++  * Returns: The value of the first rule that is satisfied in the list, or
++  *          NULL if not. This function should be called in the following 
++  *          way (notice that memory is freed by caller).
++  *
++  * You should use this function to obtain the result of a rule. You can
++  * also call directly &quot;process_rule&quot;, but I advice to use this function if
++  * there's no difference on which function to call.
++ 
++    RULE_RESULT *rule;
++ 
++    rule = (RULE_RESULT *) 
++            get_result_rule(V_SOME_RULE, context, envelope);
++ 
++    if (rule){ 
++        assign the value of rule-&gt;result;
++        if (rule-&gt;result)
++           fs_give((void **)&amp;rule-&gt;result);
++        fs_give((void **)&amp;rule);
++    }
++  */
++ 
++ RULE_RESULT *
++ get_result_rule(int code, int rule_context, ENVELOPE *env)
++ {
++     char  *rule_result;
++     RULE_RESULT *rule = NULL;
++     RULELIST *rlist;
++     int n = 0;
++ 
++     if(!(rule_context &amp; FOR_RULE))
++       rule_context |= FOR_RULE;
++     rlist = get_rulelist_from_code(code, ps_global-&gt;rule_list);
++     if (rlist){
++        rule_result = test_rule(rlist, rule_context, env, &amp;n);
++        if (rule_result &amp;&amp; *rule_result){
++           rule = (RULE_RESULT *) fs_get (sizeof(RULE_RESULT));
++           rule-&gt;result = rule_result;
++           rule-&gt;number = n;
++        }
++     }
++     return rule;
++ }
++ 
++ char *get_rule_result(int rule_context, char *newfolder, int code)
++ {   
++     char        *rule_result = NULL;
++     ENVELOPE    *news_envelope;
++     RULE_RESULT *rule;
++ 
++     if (IS_NEWS(ps_global-&gt;mail_stream)){
++        news_envelope = mail_newenvelope();
++        news_envelope-&gt;newsgroups = cpystr(newfolder);
++     }
++     else
++        news_envelope = NULL;
++ 
++     rule = get_result_rule(code, rule_context, news_envelope);
++ 
++     if (news_envelope)
++         mail_free_envelope (&amp;news_envelope);
++ 
++     if (rule){
++         rule_result = cpystr(rule-&gt;result);
++         if (rule-&gt;result)
++           fs_give((void **)&amp;rule-&gt;result);
++         fs_give((void **)&amp;rule);
++     }
++     return rule_result;
++ }
++ 
++ /* process_rule:
++    Parameters: rule_data, is a rule. It's obtained as
++                 rule_data = ps_global-&gt;VAR_SOME_RULE[n], for
++                 some integer n
++                 rule_context: context of the rule, and
++                 env: An envelope if needed.
++ 
++    Returns   : The value of the processed rule_data if the processing was 
++                successful and matches context and possibly the envelope, or
++                NULL if there's no match
++  */
++ 
++ char *
++ process_rule (RULE_S *prule, int rule_context, ENVELOPE *env)
++ {
++     char *result = NULL;
++     int rv;
++     CONDITION_S *condition;
++ 
++    if(!prule)
++      return NULL;
++ 
++    if(!(rule_context &amp; FOR_RULE))
++       rule_context |= FOR_RULE;
++ 
++    for(condition = prule-&gt;condition; 
++ 		   condition &amp;&amp; 
++ 		   (rv = test_condition(condition, rule_context, env));
++ 		   condition = condition-&gt;next);
++ 
++    if(rv &amp;&amp; !condition)
++       result = (prule-&gt;action-&gt;exec)(prule-&gt;action, rule_context, env);
++ 
++    return result;
++ }
++ 
++ TOKEN_VALUE *
++ copy_parsed_value(TOKEN_VALUE *value, int ctxt, ENVELOPE *env)
++ {
++    TOKEN_VALUE *tval = NULL;
++ 
++    if(!value)
++       return NULL;
++ 
++    if(value-&gt;testxt){
++      tval = (TOKEN_VALUE *) alloc_mem(sizeof(TOKEN_VALUE));
++      tval-&gt;testxt = detoken_src(value-&gt;testxt, ctxt, env, NULL, NULL, NULL);
++      tval-&gt;voidtxt = value-&gt;voidtxt;
++      tval-&gt;codefcn = value-&gt;codefcn;     
++    }
++    if(value-&gt;next)
++      tval-&gt;next = copy_parsed_value(value-&gt;next, ctxt, env);
++ 
++    return tval;
++ }
++ 
++ void
++ free_parsed_value(TOKEN_VALUE **value)
++ {
++    TOKEN_VALUE *tval = NULL;
++ 
++    if(!*value)
++       return;
++ 
++    if((*value)-&gt;testxt)
++      fs_give((void **)&amp;(*value)-&gt;testxt);
++ 
++    if((*value)-&gt;next)
++      free_parsed_value(&amp;(*value)-&gt;next);
++ 
++     fs_give((void **)value);
++ }
++ 
++ 
++ int
++ test_condition(CONDITION_S *condition, int rule_context, ENVELOPE *env)
++ {
++    int next_step;
++    TOKEN_VALUE *group;
++ 
++    group = copy_parsed_value(condition-&gt;value, rule_context, env);
++    next_step = (*rel_rules_test[condition-&gt;ttype].execute)(condition, group, env, rule_context);
++    free_parsed_value(&amp;group);
++    return next_step;
++ }
++ 
++ /* returns the name of the token it found or NULL if there is no token, the
++  * real value of the token is obtained by calling the detoken_src function.
++  */ 
++ 
++ char *
++ get_name_token (char *condition)
++ {
++   char *p = NULL, *q, *s;
++ 
++     if ((q = strchr(condition,'_')) &amp;&amp; (s = strchr(q+1,'_'))){
++ 	char c = *++s;
++ 	*s = '\0';
++ 	 p = cpystr(q);
++ 	*s = c;
++     }
++     return p;
++ }
++ 
++ /* This function tests if a string contained in the variable &quot;group&quot; is
++  * in the &quot;condition&quot;
++  */
++ int test_in (CONDITION_S *condition, TOKEN_VALUE *group, ENVELOPE *env, 
++ 		int context)
++ {
++  int rv = 0;
++  char *test;
++  TOKEN_VALUE *test_group = group;
++ 
++  test = env &amp;&amp; env-&gt;sparep &amp;&amp; ((SPAREP_S *)env-&gt;sparep)-&gt;flag &amp; USE_RAW_SP
++ 	? cpystr(((SPAREP_S *)env-&gt;sparep)-&gt;value)
++ 	: detoken_src(condition-&gt;tname, context, env, NULL, NULL, NULL);
++  if (test){
++     while (rv == 0 &amp;&amp; test_group){
++        if(!*test || strstr(test_group-&gt;testxt, test))
++ 	  rv++;
++        else
++ 	  test_group = test_group-&gt;next;
++     }
++     fs_give((void **)&amp;test);
++  }
++  return rv;
++ }
++ 
++ int test_ni (CONDITION_S *condition, TOKEN_VALUE *group, 
++ 		ENVELOPE *env, int context)
++ {
++  int rv = 0;
++  char *test;
++  TOKEN_VALUE *test_group = group;
++ 
++  test = env &amp;&amp; env-&gt;sparep &amp;&amp; ((SPAREP_S *)env-&gt;sparep)-&gt;flag &amp; USE_RAW_SP
++ 	? cpystr(((SPAREP_S *)env-&gt;sparep)-&gt;value)
++ 	: detoken_src(condition-&gt;tname, context, env, NULL, NULL, NULL);
++  if (test){
++     if(!test_group)
++       rv++;
++     while (rv == 0 &amp;&amp; test_group){
++        if(!*test_group-&gt;testxt || strstr(test, test_group-&gt;testxt))
++ 	  rv++;
++        else
++ 	  test_group = test_group-&gt;next;
++     }
++     fs_give((void **)&amp;test);
++  }
++  return rv;
++ }
++ 
++ int test_not_in (CONDITION_S *condition, TOKEN_VALUE *group, 
++ 		ENVELOPE *env, int context)
++ {
++  return !test_in(condition, group, env, context);
++ }
++ 
++ int test_not_ni (CONDITION_S *condition, TOKEN_VALUE *group, 
++ 		ENVELOPE *env, int context)
++ {
++  return !test_ni(condition, group, env, context);
++ }
++ 
++ int test_eq (CONDITION_S *condition, TOKEN_VALUE *group, 
++ 		ENVELOPE *env, int context)
++ {
++  int rv = 0;
++  char *test;
++  TOKEN_VALUE *test_group = group;
++ 
++  test = env &amp;&amp; env-&gt;sparep &amp;&amp; ((SPAREP_S *)env-&gt;sparep)-&gt;flag &amp; USE_RAW_SP
++ 	? cpystr(((SPAREP_S *)env-&gt;sparep)-&gt;value)
++ 	:detoken_src(condition-&gt;tname, context, env, NULL, NULL, NULL);
++  if (test){
++     while (rv == 0 &amp;&amp; test_group){
++        if((!*test &amp;&amp; !*test_group-&gt;testxt) || !strcmp(test_group-&gt;testxt, test))
++ 	  rv++;
++        else
++ 	  test_group = test_group-&gt;next;
++     }
++     fs_give((void **)&amp;test);
++  }
++  return rv;
++ }
++ 
++ int test_not_eq (CONDITION_S *condition, TOKEN_VALUE *group, 
++ 		ENVELOPE *env, int context)
++ {
++  return !test_eq(condition, group, env, context);
++ }
++ 
++ char *
++ do_trim (char *test, TOKEN_VALUE *tval)
++ {
++    char *begin_text;
++    int offset = 0;
++ 
++    if (!tval)
++       return test;
++ 
++    while(begin_text = strstr(test+offset,tval-&gt;testxt)){
++       strcpy(begin_text, begin_text+strlen(tval-&gt;testxt));
++       offset = begin_text - test;
++    }
++ 
++    return do_trim(test, tval-&gt;next);
++ }
++ 
++ char *
++ trim (RULEACTION_S *action, int context, ENVELOPE *env)
++ {
++  char *begin_text, *test;
++  RULEACTION_S *taction = action;
++  int offset;
++ 
++  if (taction-&gt;context &amp; context){
++     if (test = detoken_src(taction-&gt;token, context, env, NULL, NULL, NULL))
++        test = do_trim(test, taction-&gt;value);
++     return test;
++  }
++  return NULL;
++ }
++ 
++ 
++ char *
++ do_rextrim (char *test, TOKEN_VALUE *tval)
++ {
++    char *begin_text, *trim_text;
++    int offset = 0;
++ 
++    if (!tval)
++       return test;
++ 
++    trim_text = expand(test, tval-&gt;voidtxt);
++    while(trim_text &amp;&amp; (begin_text = strstr(test+offset,trim_text))){
++       strcpy(begin_text, begin_text+strlen(trim_text));
++       offset = begin_text - test;
++    }
++ 
++    return do_rextrim(test, tval-&gt;next);
++ }
++ 
++ char *
++ rextrim (RULEACTION_S *action, int context, ENVELOPE *env)
++ {
++  char *test = NULL;
++  RULEACTION_S *taction = action;
++ 
++  if (taction-&gt;context &amp; context &amp;&amp;
++     (test = detoken_src(taction-&gt;token, context, env, NULL, NULL, NULL)))
++ 	test = do_rextrim(test, taction-&gt;value);
++  return test;
++ }
++ 
++ char *
++ raw_value (RULEACTION_S *action, int context, ENVELOPE *env)
++ {
++ return (action-&gt;context &amp; context) ? cpystr(action-&gt;value-&gt;testxt) : NULL;
++ }
++ 
++ char *
++ extended_value (RULEACTION_S *action, int ctxt, ENVELOPE *env)
++ {
++ return (action-&gt;context &amp; ctxt) 
++ 	? detoken_src(action-&gt;value-&gt;testxt, ctxt, env, NULL, NULL, NULL)
++ 	: NULL;
++ }
++ 
++ /* advances given_string until it finds given_char  */
++ char *
++ advance_to_char(char *given_string, char given_char, int flag, int *error) 
++ {
++    char *b, *s, c;
++    int i, err  = 0, quoted ;
++ 
++    if (error)
++       *error = 0;
++ 
++    if (!given_string || !*given_string)
++        return NULL;
++ 
++    b = s = cpystr(given_string);
++    for(i = 0, quoted = 0, c = *s; c ; c = *++s){
++       if(c == '\\'){
++ 	 quoted++;
++ 	 continue;
++       }
++       if(quoted){
++ 	quoted = 0;
++ 	if (c == given_char){
++ 	  err += flag &amp; STRICTLY ? 0 : 1;
++ 	  err++;
++ 	  break;
++ 	}
++ 	b[i++] = '\\';
++       }
++       if(c == given_char){
++ 	 err += flag &amp; STRICTLY ? 0 : 1;
++ 	 break;
++       }
++       b[i++] = c;
++    }
++    b[i] = '\0';
++    if (b &amp;&amp; (strlen(b) == strlen(given_string)) &amp;&amp; (flag &amp; STRICTLY))
++       return NULL;   /* character not found */
++ 
++    if(b &amp;&amp; !*b){
++      fs_give((void **)&amp;b);
++      err = -1;
++    }
++ 
++    if (error)
++       *error = err;
++ 
++    return b;
++ }
++ 
++ /* Regular Expressions Support */
++ char *
++ expand (char *string, void *pattern)
++ {
++  char c, *ret_string = NULL;
++  regmatch_t pmatch;
++  
++   if((regex_t *)pattern == NULL)
++      return NULL;
++ 
++   if(regexec((regex_t *)pattern, string , 1, &amp;pmatch, 0) == 0 
++ 	&amp;&amp; pmatch.rm_so &lt; pmatch.rm_eo){
++       c = string[pmatch.rm_eo];
++       string[pmatch.rm_eo] = '\0';
++       ret_string = cpystr(string+pmatch.rm_so);
++       string[pmatch.rm_eo] = c;
++   }
++   return ret_string;
++ }
++ 
++ 
++ char *
++ exec_fcn (RULEACTION_S *action, int ctxt, ENVELOPE *env)
++ {
++   STORE_S *output_so;
++   gf_io_t	gc, pc;
++   char *status, *rv, *cmd, *test;
++ 
++   if(!(action-&gt;context &amp; ctxt))
++     return NULL;
++ 
++   if((test = detoken_src(action-&gt;token, ctxt, env, NULL, NULL, NULL)) != NULL)
++     gf_set_readc(&amp;gc, test, (unsigned long)strlen(test), CharStar, 0);
++ 
++   if((output_so = so_get(CharStar, NULL, EDIT_ACCESS)) != NULL)
++      gf_set_so_writec(&amp;pc, output_so);
++ 
++   cmd = (char *)fs_get((strlen(action-&gt;value-&gt;testxt) + strlen(&quot;_TMPFILE_&quot;) + 2)*sizeof(char));
++   sprintf(cmd,&quot;%s _TMPFILE_&quot;, action-&gt;value-&gt;testxt);
++   status = (*ps_global-&gt;tools.exec_rule)(cmd, gc, pc);
++ 
++   so_seek(output_so, 0L, 0);
++   rv = cpystr(output_so-&gt;dp);
++   so_give(&amp;output_so);
++   if(test)
++     fs_give((void **)&amp;test);
++ 
++   return status ? NULL : rv;
++ }
++ 
++ ENVELOPE *
++ rules_fetchenvelope(INDEXDATA_S *idata, int *we_clear)
++ {
++   ENVELOPE *env;
++ 
++   if (idata-&gt;no_fetch){
++      if(we_clear)
++         *we_clear = 1;
++     env = mail_newenvelope();
++     env-&gt;from     = copyaddrlist(idata-&gt;from);
++     env-&gt;to       = copyaddrlist(idata-&gt;to);
++     env-&gt;cc       = copyaddrlist(idata-&gt;cc);
++     env-&gt;sender   = copyaddrlist(idata-&gt;sender);
++     env-&gt;subject  = cpystr(idata-&gt;subject);
++     env-&gt;date     = cpystr((unsigned char *) idata-&gt;date);
++     env-&gt;newsgroups = cpystr(idata-&gt;newsgroups);
++     return env;
++   }
++   if(we_clear)
++      *we_clear = 0;
++   env = pine_mail_fetchenvelope(idata-&gt;stream, idata-&gt;rawno);
++   return env;
++ }
+diff -rc alpine-1.10/pith/rules.h alpine-1.10.rules/pith/rules.h
+*** alpine-1.10/pith/rules.h	2008-03-17 20:33:24.000000000 -0700
+--- alpine-1.10.rules/pith/rules.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 0 ****
+--- 1,151 ----
++ /* Included file rules.h */
++ 
++ #ifndef PITH_RULES_INCLUDED
++ #define PITH_RULES_INCLUDED
++ 
++ #include &quot;../pith/conftype.h&quot;
++ #include &quot;../pith/detoken.h&quot;
++ #include &quot;../pith/indxtype.h&quot;
++ #include &quot;../pith/rulestype.h&quot;
++ 
++ int is_save;	/* this rule has the form condition -&gt; folder */
++ 
++ /* Exported prototypes */
++ 
++ void  create_rule_list (struct variable *);
++ SPAREP_S *get_sparep_for_rule(char *, int);
++ void  free_sparep_for_rule(void **);
++ void  free_parsed_rule_list (PRULELIST_S **);
++ RULE_RESULT *get_result_rule (int, int, ENVELOPE *);
++ char  *get_rule_result (int , char *, int);
++ char  *process_rule   (RULE_S *, int, ENVELOPE *);
++ char  **functions_for_token (char *);
++ RULELIST *get_rulelist_from_code (int, PRULELIST_S *);
++ RULE_S   *get_rule  (RULELIST *, int);
++ int   condition_contains_token (CONDITION_S *, char *);
++ int   context_for_function (char *);
++ ENVELOPE *rules_fetchenvelope(INDEXDATA_S *idata, int *we_clear);
++ 
++ /* Separators:
++  *
++  * A separator is a string that separates the rule condition with the rule
++  * action. Below is the list of separators
++  *
++  */
++ 
++ #define  SAVE_TO_SEP  &quot;-&gt;&quot;
++ #define  APPLY_SEP    &quot;=&gt;&quot;
++ 
++ /*------- Definitions of tokens -------*/
++ /*------ Keep the list alphabetically sorted, thanks -------*/
++ 
++ #define ADDR_TOKEN	&quot;_ADDRESS_&quot;
++ #define ADDCC_TOKEN	&quot;_ADDRESSCC_&quot;
++ #define ADDRECIP_TOKEN	&quot;_ADDRESSRECIPS_&quot;
++ #define ADDTO_TOKEN	&quot;_ADDRESSTO_&quot;
++ #define BCC_TOKEN	&quot;_BCC_&quot;
++ #define CC_TOKEN	&quot;_CC_&quot;
++ #define COLLECT_TOKEN	&quot;_COLLECTION_&quot;
++ #define FLAG_TOKEN	&quot;_FLAG_&quot;
++ #define FOLDER_TOKEN	&quot;_FOLDER_&quot;
++ #define FADDRESS_TOKEN	&quot;_FORWARDADDRESS_&quot;
++ #define FFROM_TOKEN	&quot;_FORWARDFROM_&quot;
++ #define FROM_TOKEN	&quot;_FROM_&quot;
++ #define KEY_TOKEN	&quot;_PKEY_&quot;
++ #define LCC_TOKEN	&quot;_LCC_&quot;
++ #define NICK_TOKEN	&quot;_NICK_&quot;
++ #define OTEXT_TOKEN	&quot;_OPENINGTEXT_&quot;
++ #define OTEXTNQ_TOKEN	&quot;_OPENINGTEXTNQ_&quot;
++ #define PROCID_TOKEN	&quot;_PROCID_&quot;
++ #define ROLE_TOKEN	&quot;_ROLE_&quot;
++ #define SCREEN_TOKEN	&quot;_SCREEN_&quot;
++ #define SEND_TOKEN	&quot;_SENDER_&quot;
++ #define SUBJ_TOKEN	&quot;_SUBJECT_&quot;
++ #define THDDSPSTY_TOKEN	&quot;_THREADSTYLE_&quot;
++ #define THDNDXSTY_TOKEN	&quot;_THREADINDEX_&quot;
++ #define TO_TOKEN	&quot;_TO_&quot;
++ 
++ /*------ Definitions of relational operands -------------*/
++ 
++ typedef struct {
++         char       *value;
++ 	TestType    ttype;
++         int        (*execute)();
++ } REL_TOKEN;
++ 
++ /* Relational Operands */
++ #define AND_REL     &quot;&amp;&amp;&quot;        /* For putting more than one condition  */
++ #define IN_REL      &quot;&lt;&lt;&quot;        /* For belonging relation */
++ #define NI_REL      &quot;&gt;&gt;&quot;        /* For contain relation   */
++ #define NOT_IN_REL  &quot;!&lt;&quot;        /* Negation of IN_REL   */
++ #define NOT_NI_REL  &quot;!&gt;&quot;        /* Negation of NI_REL   */
++ #define EQ_REL      &quot;==&quot;        /* Test of equality     */
++ #define NOT_EQ_REL  &quot;!=&quot;        /* Test of inequality   */
++ #define OPEN_SET    &quot;{&quot;         /* Braces to open a set */
++ #define CLOSE_SET   &quot;}&quot;         /* Braces to close a set*/
++ 
++ /*--- Context in which these variables can be used ---*/
++ 
++ typedef struct use_context {
++     char        *name;
++     int          what_for;
++ } USE_IN_CONTEXT;
++ 
++ 
++ static USE_IN_CONTEXT tokens_use[] = {
++     {NICK_TOKEN,	FOR_SAVE},
++     {FROM_TOKEN,	FOR_SAVE},
++     {OTEXT_TOKEN,	FOR_SAVE|FOR_FOLDER},
++     {OTEXTNQ_TOKEN,	FOR_SAVE|FOR_FOLDER},
++     {ROLE_TOKEN,	FOR_COMPOSE},
++     {FOLDER_TOKEN,	FOR_SAVE|FOR_FOLDER|FOR_THREAD|FOR_COMPOSE},
++     {SUBJ_TOKEN,	FOR_SAVE|FOR_FOLDER|FOR_COMPOSE},
++     {FLAG_TOKEN,	FOR_SAVE|FOR_FLAG},
++     {COLLECT_TOKEN,	FOR_SAVE|FOR_COMPOSE|FOR_FOLDER|FOR_THREAD},
++     {THDDSPSTY_TOKEN,	FOR_THREAD},
++     {THDNDXSTY_TOKEN,	FOR_THREAD},
++     {ADDR_TOKEN,	FOR_SAVE|FOR_FOLDER},
++     {TO_TOKEN,		FOR_SAVE},
++     {ADDTO_TOKEN,	FOR_SAVE|FOR_COMPOSE},
++     {ADDCC_TOKEN,	FOR_SAVE|FOR_COMPOSE},
++     {ADDRECIP_TOKEN,	FOR_SAVE|FOR_COMPOSE},
++     {SCREEN_TOKEN,	FOR_KEY},
++     {KEY_TOKEN,		FOR_KEY},
++     {SEND_TOKEN,	FOR_SAVE},
++     {CC_TOKEN,		FOR_SAVE},
++     {BCC_TOKEN,		FOR_COMPOSE},
++     {LCC_TOKEN,		FOR_COMPOSE},
++     {FFROM_TOKEN,	FOR_COMPOSE},
++     {FADDRESS_TOKEN,	FOR_COMPOSE},
++     {NULL,		FOR_NOTHING}
++ };
++ 
++ 
++ typedef struct {
++         char         *name;
++         char*        (*execute)();
++         int          what_for;
++ } RULE_FCN;
++ 
++ #define COMMAND_FCN	&quot;_COMMAND_&quot;
++ #define COPY_FCN	&quot;_COPY_&quot;
++ #define EXEC_FCN	&quot;_EXEC_&quot;
++ #define INDEX_FCN       &quot;_INDEX_&quot;
++ #define REPLACE_FCN     &quot;_REPLACE_&quot;
++ #define REPLYSTR_FCN    &quot;_RESTR_&quot;
++ #define REPLY_FCN       &quot;_REPLY_&quot;
++ #define RESUB_FCN       &quot;_RESUB_&quot;
++ #define REXTRIM_FCN	&quot;_REXTRIM_&quot;
++ #define SAVE_FCN        &quot;_SAVE_&quot;
++ #define SIGNATURE_FCN   &quot;_SIGNATURE_&quot;
++ #define SMTP_FCN        &quot;_SMTP_&quot;
++ #define SORT_FCN        &quot;_SORT_&quot;
++ #define STARTUP_FCN     &quot;_STARTUP_&quot;
++ #define THRDSTYLE_FCN   &quot;_THREADSTYLE_&quot;
++ #define THRDINDEX_FCN   &quot;_THREADINDEX_&quot;
++ #define TRIM_FCN        &quot;_TRIM_&quot;
++ 
++ #define STRICTLY  0x1
++ #define RELAXED 0x2
++ 
++ #endif 	/* PITH_RULES_INCLUDED */
+diff -rc alpine-1.10/pith/rulestype.h alpine-1.10.rules/pith/rulestype.h
+*** alpine-1.10/pith/rulestype.h	2008-03-17 20:33:24.000000000 -0700
+--- alpine-1.10.rules/pith/rulestype.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 0 ****
+--- 1,78 ----
++ #ifndef PITH_RULESTYPE_INCLUDED
++ #define PITH_RULESTYPE_INCLUDED
++ 
++ typedef struct rule {
++ 	char *result;	/* The result of the rule */
++ 	int number;	/* The number of the rule that succeded, -1 if not */
++ } RULE_RESULT;
++ 
++ typedef struct {
++         char    *value;
++         int     type;
++ } RULE_ACTION;
++ 
++ 
++ #define TOKEN_VALUE	struct tokenvalue_s
++ #define CONDITION_S	struct condition_s
++ #define RULEACTION_S	struct ruleaction_s
++ #define RULE_S		struct rule_s
++ #define RULELIST	struct rulelist_s
++ #define PRULELIST_S	struct parsedrulelist_s
++ 
++ #define FREEREGEX	1
++ 
++ TOKEN_VALUE {
++ 	char	*testxt;
++ 	void	*voidtxt;
++ 	int	codefcn;
++ 	TOKEN_VALUE *next;
++ };
++ 
++ typedef enum {Equal, Subset, Includes,
++ 		NotEqual, NotSubset, NotIncludes,
++ 		EndTypes} TestType;
++ 
++ CONDITION_S {
++     char	*tname;		/* tname ttype {value} */
++     TestType	ttype;		/* tname ttype {value} */
++     TOKEN_VALUE	*value;		/* value to check against */
++     CONDITION_S	*next;		/* next condition to test */
++ };
++ 
++ RULEACTION_S {
++    char *token;		/* token := function{value} or token = null  */
++    char *function;	/* token := function{value} or simply function{value}*/
++    TOKEN_VALUE  *value; /* token := function{value} or simply function{value}*/
++    int   context;	/* context in which this rule can be used */
++    char* (*exec)();
++    unsigned int is_trim:1;
++    unsigned int is_rextrim:1;
++    unsigned int is_replace:1;
++ };
++ 
++ RULE_S {
++   CONDITION_S  *condition;
++   RULEACTION_S *action;
++ };
++ 
++ RULELIST {
++    RULE_S *prule;
++    RULELIST *next;
++ };
++ 
++ PRULELIST_S {
++    int varnum;		/* number associated to the variable */
++    RULELIST *rlist;
++    PRULELIST_S *next;
++ };
++ 
++ #define USE_RAW_SP      0x001
++ #define PROCESS_SP      0x010
++ 
++ typedef struct sparep {
++    int flag;
++    char *value;
++ } SPAREP_S;
++ 
++ 
++ #endif	/* PITH_RULESTYPE_INCLUDED */
+diff -rc alpine-1.10/pith/save.c alpine-1.10.rules/pith/save.c
+*** alpine-1.10/pith/save.c	2008-02-29 10:18:49.000000000 -0800
+--- alpine-1.10.rules/pith/save.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 939,945 ****
+  	      *date = '\0';
+  
+  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
+! 				   NULL, save_stream, save_folder, context,
+  				   mc ? mc-&gt;rfc822_size : 0L, flags, date, so);
+  
+  	    if(flags)
+--- 939,945 ----
+  	      *date = '\0';
+  
+  	    rv = save_fetch_append(stream, mn_m2raw(msgmap, i),
+! 				   NULL, save_stream, folder, context,
+  				   mc ? mc-&gt;rfc822_size : 0L, flags, date, so);
+  
+  	    if(flags)
+diff -rc alpine-1.10/pith/send.c alpine-1.10.rules/pith/send.c
+*** alpine-1.10/pith/send.c	2008-02-14 18:11:48.000000000 -0800
+--- alpine-1.10.rules/pith/send.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 42,47 ****
+--- 42,48 ----
+  #include &quot;../pith/imap.h&quot;
+  #include &quot;../pith/ablookup.h&quot;
+  #include &quot;../pith/sort.h&quot;
++ #include &quot;../pith/rules.h&quot;
+  
+  #include &quot;../c-client/smtp.h&quot;
+  #include &quot;../c-client/nntp.h&quot;
+***************
+*** 1728,1736 ****
+      char         error_buf[200], *error_mess = NULL, *postcmd;
+      ADDRESS     *a;
+      ENVELOPE	*fake_env = NULL;
+!     int          addr_error_count, we_cancel = 0;
+      long	 smtp_opts = 0L;
+!     char	*verbose_file = NULL;
+      BODY	*bp = NULL;
+      PINEFIELD	*pf;
+  
+--- 1729,1737 ----
+      char         error_buf[200], *error_mess = NULL, *postcmd;
+      ADDRESS     *a;
+      ENVELOPE	*fake_env = NULL;
+!     int          addr_error_count, we_cancel = 0, choice, num_rules = 0, added_rules = -1;
+      long	 smtp_opts = 0L;
+!     char	*verbose_file = NULL, **smtp_list;
+      BODY	*bp = NULL;
+      PINEFIELD	*pf;
+  
+***************
+*** 1859,1878 ****
+       * OK, who posts what?  We tried an mta_handoff above, but there
+       * was either none specified or we decided not to use it.  So,
+       * if there's an smtp-server defined anywhere, 
+       */
+!     if(alt_smtp_servers &amp;&amp; alt_smtp_servers[0] &amp;&amp; alt_smtp_servers[0][0]){
+! 	/*---------- SMTP ----------*/
+! 	dprint((4, &quot;call_mailer: via TCP (%s)\n&quot;,
+! 		alt_smtp_servers[0]));
+! 	TIME_STAMP(&quot;smtp-open start (tcp)&quot;, 1);
+! 	sending_stream = smtp_open(alt_smtp_servers, smtp_opts);
+!     }
+!     else if(ps_global-&gt;VAR_SMTP_SERVER &amp;&amp; ps_global-&gt;VAR_SMTP_SERVER[0]
+! 	    &amp;&amp; ps_global-&gt;VAR_SMTP_SERVER[0][0]){
+! 	/*---------- SMTP ----------*/
+! 	dprint((4, &quot;call_mailer: via TCP\n&quot;));
+! 	TIME_STAMP(&quot;smtp-open start (tcp)&quot;, 1);
+! 	sending_stream = smtp_open(ps_global-&gt;VAR_SMTP_SERVER, smtp_opts);
+      }
+      else if((postcmd = smtp_command(ps_global-&gt;c_client_error, sizeof(ps_global-&gt;c_client_error))) != NULL){
+  	char *cmdlist[2];
+--- 1860,1908 ----
+       * OK, who posts what?  We tried an mta_handoff above, but there
+       * was either none specified or we decided not to use it.  So,
+       * if there's an smtp-server defined anywhere, 
++      * First we check for rules and make a list using the rules.
+       */
+!     if(ps_global-&gt;VAR_SMTP_RULES &amp;&amp; ps_global-&gt;VAR_SMTP_RULES[0]
+!         &amp;&amp; ps_global-&gt;VAR_SMTP_RULES[0][0])
+!         while (ps_global-&gt;VAR_SMTP_RULES[num_rules]) num_rules++;
+! 
+!     if(num_rules){
+! 	int i, j;
+! 
+!         added_rules = 0;
+!         smtp_list = (char **) fs_get ((num_rules + 1)*sizeof(char*));
+!         for (i = 0, j = 0; i &lt; num_rules; i++){
+! 	   RULELIST *rule = get_rulelist_from_code(V_SMTP_RULES,
+!                                                       ps_global-&gt;rule_list);
+! 	   RULE_S *prule = get_rule(rule, i);
+!            if(prule){
+! 	     char *rule_result = process_rule(prule, FOR_COMPOSE, header-&gt;env);
+! 	     if(rule_result &amp;&amp; *rule_result){
+! 		smtp_list[j++] = cpystr(rule_result);
+! 		added_rules++;
+! 	     }
+! 	   }
+! 	}
+!     }
+! 
+!     if (added_rules &lt; 0){
+! 	smtp_list = (char **) fs_get (sizeof(char*));
+! 	added_rules = 0;
+!     }
+!     smtp_list[added_rules] = NULL;
+! 
+!     choice = smtp_list &amp;&amp; smtp_list[0] &amp;&amp; smtp_list[0][0] ? 3 :
+! 	(alt_smtp_servers &amp;&amp; alt_smtp_servers[0] &amp;&amp; alt_smtp_servers[0][0] ? 2 :
+! 	(ps_global-&gt;VAR_SMTP_SERVER &amp;&amp; ps_global-&gt;VAR_SMTP_SERVER[0] 
+! 		&amp;&amp; ps_global-&gt;VAR_SMTP_SERVER[0][0] ? 1 : -1));
+! 
+!     if(choice &gt; 0){
+!         /*---------- SMTP ----------*/
+!        dprint((4, &quot;call_mailer: via TCP (%s)\n&quot;,smtp_list[0]));
+!         TIME_STAMP(&quot;smtp-open start (tcp)&quot;, 1);
+!         sending_stream = smtp_open(choice == 3 ? smtp_list
+! 				: (choice == 2 ? alt_smtp_servers
+! 				: ps_global-&gt;VAR_SMTP_SERVER), smtp_opts);
+      }
+      else if((postcmd = smtp_command(ps_global-&gt;c_client_error, sizeof(ps_global-&gt;c_client_error))) != NULL){
+  	char *cmdlist[2];
+diff -rc alpine-1.10/pith/sort.c alpine-1.10.rules/pith/sort.c
+*** alpine-1.10/pith/sort.c	2008-01-15 17:20:37.000000000 -0800
+--- alpine-1.10.rules/pith/sort.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 28,34 ****
+  #include &quot;../pith/signal.h&quot;
+  #include &quot;../pith/busy.h&quot;
+  #include &quot;../pith/icache.h&quot;
+! 
+  
+  /*
+   * global place to store mail_sort and mail_thread results
+--- 28,34 ----
+  #include &quot;../pith/signal.h&quot;
+  #include &quot;../pith/busy.h&quot;
+  #include &quot;../pith/icache.h&quot;
+! #include &quot;../pith/rules.h&quot;
+  
+  /*
+   * global place to store mail_sort and mail_thread results
+***************
+*** 681,687 ****
+      PAT_S        *pat;
+      SortOrder	  the_sort_order;
+      int           sort_is_rev;
+! 
+      /* set default order */
+      the_sort_order = ps_global-&gt;def_sort;
+      sort_is_rev    = ps_global-&gt;def_sort_rev;
+--- 681,701 ----
+      PAT_S        *pat;
+      SortOrder	  the_sort_order;
+      int           sort_is_rev;
+!     char       *rule_result;
+!     SortOrder   new_sort = EndofList;
+!     int               is_rev;
+! 
+!    rule_result = get_rule_result(FOR_SORT, ps_global-&gt;cur_folder, V_SORT_RULES);
+!    if (rule_result &amp;&amp; *rule_result){
+!       new_sort  = (SortOrder) translate(rule_result, 1);
+!       is_rev    = (SortOrder) translate(rule_result, 0) == EndofList ? 0 : 1;
+!       fs_give((void **)&amp;rule_result);
+!    }
+!    if (new_sort != EndofList){
+!        the_sort_order = new_sort;
+!        sort_is_rev    = is_rev;
+!    }
+!    else{
+      /* set default order */
+      the_sort_order = ps_global-&gt;def_sort;
+      sort_is_rev    = ps_global-&gt;def_sort_rev;
+***************
+*** 699,705 ****
+  	    sort_is_rev    = pat-&gt;action-&gt;revsort;
+  	}
+      }
+! 
+      sort_folder(ps_global-&gt;mail_stream, ps_global-&gt;msgmap,
+  		the_sort_order, sort_is_rev, flags);
+  }
+--- 713,755 ----
+  	    sort_is_rev    = pat-&gt;action-&gt;revsort;
+  	}
+      }
+!    }
+      sort_folder(ps_global-&gt;mail_stream, ps_global-&gt;msgmap,
+  		the_sort_order, sort_is_rev, flags);
+  }
++ 
++ SortOrder translate(char *order, int is_rev)
++ {
++    int rev = 0;
++      if (!strncmp(order,&quot;tHread&quot;, 6)
++                 || (rev = !strncmp(order,&quot;Reverse tHread&quot;, 14)))
++         return is_rev || rev ? SortThread : EndofList;
++      if (!strncmp(order,&quot;OrderedSubj&quot;, 11)
++                 || (rev = !strncmp(order,&quot;Reverse OrderedSubj&quot;, 19)))
++         return is_rev || rev  ? SortSubject2 : EndofList;
++      if (!strncmp(order,&quot;Subject&quot;, 7)
++                 || (rev = !strncmp(order,&quot;Reverse SortSubject&quot;, 15)))
++         return is_rev || rev  ?  SortSubject : EndofList;
++      if (!strncmp(order,&quot;Arrival&quot;, 7)
++                 || (rev = !strncmp(order,&quot;Reverse Arrival&quot;, 15)))
++         return is_rev || rev  ?  SortArrival : EndofList;
++      if (!strncmp(order,&quot;From&quot;, 4)
++                 || (rev = !strncmp(order,&quot;Reverse From&quot;, 12)))
++         return is_rev || rev  ?  SortFrom : EndofList;
++      if (!strncmp(order,&quot;To&quot;, 2)
++                 || (rev = !strncmp(order,&quot;Reverse To&quot;, 10)))
++         return is_rev || rev  ?  SortTo : EndofList;
++      if (!strncmp(order,&quot;Cc&quot;, 2)
++                 || (rev = !strncmp(order,&quot;Reverse Cc&quot;, 10)))
++         return is_rev || rev  ?  SortCc : EndofList;
++      if (!strncmp(order,&quot;Date&quot;, 4)
++                 || (rev = !strncmp(order,&quot;Reverse Date&quot;, 12)))
++         return is_rev || rev  ?  SortDate : EndofList;
++      if (!strncmp(order,&quot;siZe&quot;, 4)
++                 || (rev = !strncmp(order,&quot;Reverse siZe&quot;, 12)))
++         return is_rev || rev  ?  SortSize : EndofList;
++      if (!strncmp(order,&quot;scorE&quot;, 5)
++                 || (rev = !strncmp(order,&quot;Reverse scorE&quot;, 13)))
++         return is_rev || rev  ?  SortScore : EndofList;
++    return EndofList;
++ }
+diff -rc alpine-1.10/pith/sort.h alpine-1.10.rules/pith/sort.h
+*** alpine-1.10/pith/sort.h	2006-09-22 13:06:05.000000000 -0700
+--- alpine-1.10.rules/pith/sort.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 44,49 ****
+  void	 sort_folder(MAILSTREAM *, MSGNO_S *, SortOrder, int, unsigned);
+  int	 decode_sort(char *, SortOrder *, int *);
+  void	 reset_sort_order(unsigned);
+! 
+  
+  #endif /* PITH_SORT_INCLUDED */
+--- 44,49 ----
+  void	 sort_folder(MAILSTREAM *, MSGNO_S *, SortOrder, int, unsigned);
+  int	 decode_sort(char *, SortOrder *, int *);
+  void	 reset_sort_order(unsigned);
+! SortOrder translate(char *, int);
+  
+  #endif /* PITH_SORT_INCLUDED */
+diff -rc alpine-1.10/pith/state.c alpine-1.10.rules/pith/state.c
+*** alpine-1.10/pith/state.c	2007-10-11 11:03:32.000000000 -0700
+--- alpine-1.10.rules/pith/state.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 31,37 ****
+  #include &quot;../pith/mailindx.h&quot;
+  #include &quot;../pith/remote.h&quot;
+  #include &quot;../pith/list.h&quot;
+! 
+  
+  /*
+   * Globals referenced throughout pine...
+--- 31,37 ----
+  #include &quot;../pith/mailindx.h&quot;
+  #include &quot;../pith/remote.h&quot;
+  #include &quot;../pith/list.h&quot;
+! #include &quot;../pith/rules.h&quot;
+  
+  /*
+   * Globals referenced throughout pine...
+***************
+*** 194,199 ****
+--- 194,202 ----
+      if((*pps)-&gt;msgmap)
+        msgno_give(&amp;(*pps)-&gt;msgmap);
+      
++     if((*pps)-&gt;rule_list)
++ 	free_parsed_rule_list(&amp;(*pps)-&gt;rule_list);
++ 
+      free_vars(*pps);
+  
+      fs_give((void **) pps);
+diff -rc alpine-1.10/pith/state.h alpine-1.10.rules/pith/state.h
+*** alpine-1.10/pith/state.h	2008-02-27 17:04:46.000000000 -0800
+--- alpine-1.10.rules/pith/state.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 32,38 ****
+  #include &quot;../pith/stream.h&quot;
+  #include &quot;../pith/color.h&quot;
+  #include &quot;../pith/user.h&quot;
+! 
+  
+  /*
+   * Printing control structure
+--- 32,38 ----
+  #include &quot;../pith/stream.h&quot;
+  #include &quot;../pith/color.h&quot;
+  #include &quot;../pith/user.h&quot;
+! #include &quot;../pith/rulestype.h&quot;
+  
+  /*
+   * Printing control structure
+***************
+*** 104,109 ****
+--- 104,114 ----
+      MAILSTREAM  *mail_stream;		/* ptr to current folder stream */
+      MSGNO_S	*msgmap;		/* ptr to current message map   */
+  
++     char	screen_name[10];	/* name of current screen */
++     char	*role;			/* role used when composing */
++     char	*procid;		/* procedure id when needed */
++     int		exiting;
++ 
+      unsigned     read_predicted:1;
+  
+      char         cur_folder[MAXPATH+1];
+***************
+*** 325,330 ****
+--- 330,336 ----
+      struct {
+          char	*(*display_filter)(char *, STORE_S *, gf_io_t, FILTLIST_S *);
+          char	*(*display_filter_trigger)(BODY *, char *, size_t);
++ 	char	*(*exec_rule)(char *, gf_io_t, gf_io_t);
+      } tools;
+  
+      KEYWORD_S   *keywords;
+***************
+*** 335,340 ****
+--- 341,349 ----
+      char	 last_error[500];
+      INIT_ERR_S  *init_errs;
+  
++     PRULELIST_S *rule_list;
++     char	*pressed_key;
++ 
+      PRINT_S	*print;
+  
+      struct variable *vars;
+diff -rc alpine-1.10/pith/string.c alpine-1.10.rules/pith/string.c
+*** alpine-1.10/pith/string.c	2008-01-09 12:45:31.000000000 -0800
+--- alpine-1.10.rules/pith/string.c	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 19,24 ****
+--- 19,25 ----
+      string.c
+      Misc extra and useful string functions
+        - rplstr         replace a substring with another string
++       - collspaces     consecutive spaces are reduced to one space.
+        - sqzspaces      Squeeze out the extra blanks in a string
+        - sqznewlines    Squeeze out \n and \r.
+        - removing_trailing_white_space 
+***************
+*** 131,136 ****
+--- 132,162 ----
+      return(x3);
+  }
+  
++ /*----------------------------------------------------------------------
++      collapse blank space
++   ----------------------------------------------------------------------*/
++ void
++ collspaces(char *string)
++ {
++     char *p = string;
++     int only_one_space = 0;
++ 
++     if(!string)
++       return;
++ 
++     for(;isspace(*p); p++);
++ 
++     while(*string = *p++)
++       if(!isspace((unsigned char)*string)){
++ 	only_one_space = 0;
++ 	string++;
++       }
++       else if(!only_one_space){
++ 		string++;
++ 		only_one_space++;
++ 	   }
++     *string = '\0';
++ }
+  
+  
+  /*----------------------------------------------------------------------
+***************
+*** 2859,2861 ****
+--- 2885,2919 ----
+  	fs_give((void **) strp);
+      }
+  }
++ 
++ 
++ void
++ removing_extra_stuff(string)
++     char *string;
++ {
++     char *p = NULL;
++     int change = 0, length = 0;
++ 
++ 
++     if(!string)
++       return;
++ 
++     for(; *string; string++, length++)
++       p = ((unsigned char)*string != ',') ? NULL : (!p) ? string : p;
++ 
++     if(p)
++       *p = '\0';
++ 
++     string -= length;
++         for (; *string; string++){
++            if (change){
++               *string = ' ';
++               change = 0;
++            }
++            if ((((unsigned char)*string == ' ') ||
++                 ((unsigned char)*string == ',')) &amp;&amp;
++                 ((unsigned char)*(string + 1) == ','))
++             change++;
++         }
++ }
++ 
+diff -rc alpine-1.10/pith/string.h alpine-1.10.rules/pith/string.h
+*** alpine-1.10/pith/string.h	2007-08-15 13:28:09.000000000 -0700
+--- alpine-1.10.rules/pith/string.h	2008-03-17 20:33:24.000000000 -0700
+***************
+*** 85,96 ****
+--- 85,98 ----
+  
+  /* exported protoypes */
+  char	   *rplstr(char *, size_t, int, char *);
++ void	    collspaces(char *);
+  void	    sqzspaces(char *);
+  void	    sqznewlines(char *);
+  void	    removing_leading_white_space(char *);
+  void	    removing_trailing_white_space(char *);
+  void	    removing_leading_and_trailing_white_space(char *);
+  int 	    removing_double_quotes(char *);
++ void	    removing_extra_stuff (char *);
+  char	   *skip_white_space(char *);
+  char	   *skip_to_white_space(char *);
+  char	   *removing_quotes(char *);

Added: trunk/rpms/alpine/alpine-1.10-select-bold-x.patch
===================================================================
--- trunk/rpms/alpine/alpine-1.10-select-bold-x.patch	                        (rev 0)
+++ trunk/rpms/alpine/alpine-1.10-select-bold-x.patch	2008-07-31 00:54:17 UTC (rev 6434)
@@ -0,0 +1,61 @@
+--- alpine/mailindx.c.orig	2008-07-29 01:06:53.124552512 +0200
++++ alpine/mailindx.c	2008-07-29 01:07:23.177983696 +0200
+@@ -1896,7 +1896,7 @@
+ 	  if(ielem &amp;&amp; ielem-&gt;datalen &gt; 0){
+ 	    if(ielem-&gt;datalen == 1){
+ 	      save_schar1 = ielem-&gt;data[0];
+-	      if(sel &amp;&amp; !doing_bold){
++	      if(sel){
+ 	        ielem-&gt;data[0] = 'X';
+ 		drew_X++;
+ 	      }
+@@ -1910,7 +1910,7 @@
+ 	      }
+ 	    }
+ 	    else if(ielem-&gt;datalen &gt; 1){
+-	      if(sel &amp;&amp; !doing_bold){
++	      if(sel){
+ 	        ielem-&gt;data[0] = 'X';
+ 		drew_X++;
+ 	      }
+--- pith/pine.hlp.orig	2008-07-28 03:55:51.389098520 +0200
++++ pith/pine.hlp	2008-07-28 03:56:48.216459448 +0200
+@@ -30569,9 +30569,9 @@
+ specified criteria, and &amp;quot;tag&amp;quot; the resulting messages with an 
+ &amp;quot;X&amp;quot; in the
+ first column of the applicable lines in the MESSAGE INDEX.  If this feature
+-is set, instead of using the &amp;quot;X&amp;quot; to denote a selected message, 
++is set, while still using the &amp;quot;X&amp;quot; to denote a selected message, 
+ Alpine will
+-attempt to display those index lines in boldface. Whether this is
++attempt to also display those index lines in boldface. Whether this is
+ preferable to the &amp;quot;X&amp;quot; will depend on personal taste and the type of
+ terminal being used.
+ &lt;P&gt;
+--- doc/tech-notes.txt.orig	2008-07-28 04:01:31.845341304 +0200
++++ doc/tech-notes.txt	2008-07-28 04:02:19.158148664 +0200
+@@ -5992,9 +5992,9 @@
+           and  _WhereIs_  (with  the _^X_ subcommand) will search the current
+           folder  for  messages meeting a specified criteria, and _tag_ the
+           resulting messages with an _X_ in the first column of the applicable
+-          lines in the &quot;Folder Index&quot;. If this feature is set, instead of using
++          lines in the &quot;Folder Index&quot;. If this feature is set, while still using
+           the  _X_  to  denote  a  selected message, _Alpine_ will attempt to
+-          display those index lines in boldface. Whether this is preferable to
++          also display those index lines in boldface. Whether this is preferable to
+           the _X_ will depend on personal taste and the type of terminal being
+           used.
+    _show-sort_
+--- ./doc/tech-notes/config.html.orig	2008-07-28 04:03:00.717830632 +0200
++++ ./doc/tech-notes/config.html	2008-07-28 04:03:38.734051288 +0200
+@@ -7245,8 +7245,8 @@
+ specified criteria, and &lt;EM&gt;tag&lt;/EM&gt; the resulting
+ messages with an &lt;EM&gt;X&lt;/EM&gt; in the
+ first column of the applicable lines in the &quot;Folder Index&quot;. If this feature
+-is set, instead of using the &lt;EM&gt;X&lt;/EM&gt; to denote a selected message,
+-&lt;EM&gt;Alpine&lt;/EM&gt; will attempt to display those index lines in boldface.
++is set, while still using the &lt;EM&gt;X&lt;/EM&gt; to denote a selected message,
++&lt;EM&gt;Alpine&lt;/EM&gt; will attempt to also display those index lines in boldface.
+ Whether this is preferable to the &lt;EM&gt;X&lt;/EM&gt; will depend on personal
+ taste and the type of terminal being used.
+ &lt;P&gt;

Modified: trunk/rpms/alpine/alpine.spec
===================================================================
--- trunk/rpms/alpine/alpine.spec	2008-07-31 00:53:17 UTC (rev 6433)
+++ trunk/rpms/alpine/alpine.spec	2008-07-31 00:54:17 UTC (rev 6434)
@@ -4,7 +4,7 @@
 Summary: Alternative Pine mail user agent implementation
 Name: alpine
 Version: 1.10
-Release: 2
+Release: 3
 License: Apache License
 Group: Applications/Internet
 URL: <A HREF="http://www.washington.edu/alpine/">http://www.washington.edu/alpine/</A>
@@ -13,9 +13,13 @@
 Source1: pine.conf
 Source2: pine.conf.fixed
 ### <A HREF="http://staff.washington.edu/chappa/alpine/patches/">http://staff.washington.edu/chappa/alpine/patches/</A>
-Patch0: <A HREF="http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/maildir.patch.gz">http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/maildir.patch.gz</A>
-Patch1: <A HREF="http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/fillpara.patch.gz">http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/fillpara.patch.gz</A>
-Patch2: alpine-1.10-select-bold-x.patch
+#Patch0: <A HREF="http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/maildir.patch.gz">http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/maildir.patch.gz</A>
+Patch0: alpine-1.10-maildir.patch
+#Patch1: <A HREF="http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/fillpara.patch.gz">http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/fillpara.patch.gz</A>
+Patch1: alpine-1.10-fillpara.patch
+#Patch2: <A HREF="http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/rules.patch.gz">http://staff.washington.edu/chappa/alpine/patches/alpine-1.10/rules.patch.gz</A>
+Patch2: alpine-1.10-rules.patch
+Patch3: alpine-1.10-select-bold-x.patch
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
 
 BuildRequires: inews, aspell, openldap-devel, openssl-devel, krb5-devel, pam-devel
@@ -38,7 +42,8 @@
 %setup
 %patch0 -p1
 %patch1 -p1
-%patch2 -p0 -b .orig
+%patch2 -p1
+%patch3 -p0 -b .orig
 
 #%{__perl} -pi.orig -e 's|/lib\b|/%{_lib}|g' configure */Makefile */*/Makefile imap/src/osdep/unix/Makefile.gss
 %{__perl} -pi.orig -e 's|/lib\b|/%{_lib}|g' imap/src/osdep/unix/Makefile.gss
@@ -111,6 +116,9 @@
 %{_sbindir}/mlock
 
 %changelog
+* Wed Jul 30 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 1.10-3
+- Added rules patch.
+
 * Sun Jul 27 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 1.10-2
 - Added patch to show both X and bold on selection. (Dag Wieers)
 - Added maildir and fillpara patch.

Modified: trunk/rpms/collectd/collectd.spec
===================================================================
--- trunk/rpms/collectd/collectd.spec	2008-07-31 00:53:17 UTC (rev 6433)
+++ trunk/rpms/collectd/collectd.spec	2008-07-31 00:54:17 UTC (rev 6434)
@@ -7,7 +7,7 @@
 
 Summary: Statistics collection daemon for filling RRD files
 Name: collectd
-Version: 4.3.3
+Version: 4.4.2
 Release: 1
 License: GPL
 Group: System Environment/Daemons
@@ -103,6 +103,9 @@
 %exclude %{perl_sitearch}
 
 %changelog
+* Tue Jul 29 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 4.4.2-1
+- Updated to release 4.4.2.
+
 * Sun Apr 27 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 4.3.3-1
 - Updated to release 4.3.3.
 

Modified: trunk/rpms/perl-Algorithm-Cluster/perl-Algorithm-Cluster.spec
===================================================================
--- trunk/rpms/perl-Algorithm-Cluster/perl-Algorithm-Cluster.spec	2008-07-31 00:53:17 UTC (rev 6433)
+++ trunk/rpms/perl-Algorithm-Cluster/perl-Algorithm-Cluster.spec	2008-07-31 00:54:17 UTC (rev 6434)
@@ -9,7 +9,7 @@
 
 Summary: Interface to the C Clustering Library
 Name: perl-Algorithm-Cluster
-Version: 1.38
+Version: 1.39
 Release: 1
 License: Artistic/GPL
 Group: Applications/CPAN
@@ -52,6 +52,9 @@
 %{perl_vendorarch}/Algorithm/Cluster.pm
 
 %changelog
+* Sat Jul 26 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 1.39-1
+- Updated to release 1.39.
+
 * Tue Mar 11 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 1.38-1
 - Updated to release 1.38.
 

Modified: trunk/rpms/perl-Algorithm-MedianSelect-XS/perl-Algorithm-MedianSelect-XS.spec
===================================================================
--- trunk/rpms/perl-Algorithm-MedianSelect-XS/perl-Algorithm-MedianSelect-XS.spec	2008-07-31 00:53:17 UTC (rev 6433)
+++ trunk/rpms/perl-Algorithm-MedianSelect-XS/perl-Algorithm-MedianSelect-XS.spec	2008-07-31 00:54:17 UTC (rev 6434)
@@ -9,7 +9,7 @@
 
 Summary: Median finding algorithm
 Name: perl-Algorithm-MedianSelect-XS
-Version: 0.20
+Version: 0.21
 Release: 1
 License: Artistic/GPL
 Group: Applications/CPAN
@@ -55,6 +55,9 @@
 %{perl_vendorarch}/Algorithm/MedianSelect/XS.pm
 
 %changelog
+* Sat Jul 26 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.21-1
+- Updated to release 0.21.
+
 * Wed Jan 23 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.20-1
 - Updated to release 0.20.
 

Modified: trunk/rpms/perl-Alien-wxWidgets/perl-Alien-wxWidgets.spec
===================================================================
--- trunk/rpms/perl-Alien-wxWidgets/perl-Alien-wxWidgets.spec	2008-07-31 00:53:17 UTC (rev 6433)
+++ trunk/rpms/perl-Alien-wxWidgets/perl-Alien-wxWidgets.spec	2008-07-31 00:54:17 UTC (rev 6434)
@@ -9,7 +9,7 @@
 
 Summary: building, finding and using wxWidgets binaries
 Name: perl-Alien-wxWidgets
-Version: 0.36
+Version: 0.37
 Release: 1
 License: Artistic/GPL
 Group: Applications/CPAN
@@ -56,6 +56,9 @@
 #%{perl_vendorlib}/Alien/wxWidgets.pm
 
 %changelog
+* Sat Jul 26 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.37-1
+- Updated to release 0.37.
+
 * Sun Jun 22 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.36-1
 - Updated to release 0.36.
 

Modified: trunk/rpms/testdisk/testdisk.spec
===================================================================
--- trunk/rpms/testdisk/testdisk.spec	2008-07-31 00:53:17 UTC (rev 6433)
+++ trunk/rpms/testdisk/testdisk.spec	2008-07-31 00:54:17 UTC (rev 6434)
@@ -11,8 +11,8 @@
 
 Summary: Tools to check and undelete partition or recover deleted files
 Name: testdisk
-Version: 6.9
-Release: 2
+Version: 6.10
+Release: 1
 License: GPL
 Group: Applications/System
 URL: <A HREF="http://www.cgsecurity.org/wiki/TestDisk">http://www.cgsecurity.org/wiki/TestDisk</A>
@@ -61,8 +61,11 @@
 %{_sbindir}/testdisk
 
 %changelog
+* Sat Jul 26 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 6.10-1
+- Updated to release 6.10.
+
 * Thu May 22 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 6.9-2
-- Built ntfs support.
+- Built with ntfs support.
 
 * Thu Feb 14 2008 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 6.9-1
 - Updated to release 6.9.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005232.html">[svn] r6433 - in trunk/rpms: fuse-unionfs	perl-Algorithm-Evolutionary perl-SOAP-Lite subversion txt2tags zvbi
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5233">[ date ]</a>
              <a href="thread.html#5233">[ thread ]</a>
              <a href="subject.html#5233">[ subject ]</a>
              <a href="author.html#5233">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
