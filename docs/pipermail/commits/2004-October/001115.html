<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [SVN] r2309 - in trunk/rpms: libtheora xmame
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5BSVN%5D%20r2309%20-%20in%20trunk/rpms%3A%20libtheora%20xmame&In-Reply-To=%3C20041025114844.8FFFF18145%40web22.us.megagiga.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001114.html">
   <LINK REL="Next"  HREF="001116.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[SVN] r2309 - in trunk/rpms: libtheora xmame</H1>
    <B>svn-commits at rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5BSVN%5D%20r2309%20-%20in%20trunk/rpms%3A%20libtheora%20xmame&In-Reply-To=%3C20041025114844.8FFFF18145%40web22.us.megagiga.com%3E"
       TITLE="[SVN] r2309 - in trunk/rpms: libtheora xmame">svn-commits at rpmforge.net
       </A><BR>
    <I>Mon Oct 25 13:48:44 CEST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="001114.html">[SVN] r2308 - in trunk/rpms: asterisk asterisk-sounds fftw plone	python-imaging rhythmbox rpmlint xmms-acme zope
</A></li>
        <LI>Next message: <A HREF="001116.html">[SVN] r2310 - trunk/rpms/libtheora
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1115">[ date ]</a>
              <a href="thread.html#1115">[ thread ]</a>
              <a href="subject.html#1115">[ subject ]</a>
              <a href="author.html#1115">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dude
Date: 2004-10-25 13:48:41 +0200 (Mon, 25 Oct 2004)
New Revision: 2309

Added:
   trunk/rpms/libtheora/libtheora-1.0alpha3-autotools.patch
   trunk/rpms/libtheora/libtheora-1.0alpha3-include.patch
   trunk/rpms/libtheora/libtheora-1.0alpha3-mmx.patch
Removed:
   trunk/rpms/xmame/xmame.wrapper
Modified:
   trunk/rpms/libtheora/libtheora.spec
   trunk/rpms/xmame/xmame.spec
Log:
Major packaging changes for xmame and libtheora.


Added: trunk/rpms/libtheora/libtheora-1.0alpha3-autotools.patch
===================================================================
--- trunk/rpms/libtheora/libtheora-1.0alpha3-autotools.patch	2004-10-25 11:47:23 UTC (rev 2308)
+++ trunk/rpms/libtheora/libtheora-1.0alpha3-autotools.patch	2004-10-25 11:48:41 UTC (rev 2309)
@@ -0,0 +1,92 @@
+diff -Naur libtheora-1.0alpha3/configure.ac libtheora-1.0alpha3.autotools/configure.ac
+--- libtheora-1.0alpha3/configure.ac	2004-03-20 01:02:42.000000000 +0100
++++ libtheora-1.0alpha3.autotools/configure.ac	2004-08-18 13:35:26.391009832 +0200
+@@ -5,8 +5,13 @@
+ dnl ------------------------------------------------
+ 
+ AC_INIT(libtheora,[1.0alpha3])
+-AC_CONFIG_HEADERS([config.h])
++
++AC_CANONICAL_HOST
++AC_CANONICAL_TARGET
++
++AM_CONFIG_HEADER([config.h])
+ AC_CONFIG_SRCDIR([lib/dct.c])
++
+ AM_INIT_AUTOMAKE
+ 
+ dnl Library versioning
+@@ -38,9 +43,6 @@
+ dnl Set build flags based on environment
+ dnl --------------------------------------------------
+ 
+-AC_CANONICAL_HOST
+-AC_CANONICAL_TARGET
+-
+ dnl Set some target options
+ 
+ cflags_save=&quot;$CFLAGS&quot;
+diff -Naur libtheora-1.0alpha3/debian/Makefile.am libtheora-1.0alpha3.autotools/debian/Makefile.am
+--- libtheora-1.0alpha3/debian/Makefile.am	2004-03-20 06:09:51.000000000 +0100
++++ libtheora-1.0alpha3.autotools/debian/Makefile.am	2004-08-18 13:34:40.092048344 +0200
+@@ -1,6 +1,4 @@
+ ## Process this file with automake to produce Makefile.in
+ 
+-AUTOMAKE_OPTIONS = foreign
+-
+ EXTRA_DIST = changelog control copyright rules \
+ 	libtheora-dev.install libtheora0.install
+diff -Naur libtheora-1.0alpha3/doc/Makefile.am libtheora-1.0alpha3.autotools/doc/Makefile.am
+--- libtheora-1.0alpha3/doc/Makefile.am	2004-03-20 06:39:33.000000000 +0100
++++ libtheora-1.0alpha3.autotools/doc/Makefile.am	2004-08-18 13:35:41.947644864 +0200
+@@ -1,7 +1,5 @@
+ ## Process this file with automake to produce Makefile.in
+ 
+-AUTOMAKE_OPTIONS = foreign
+-
+ docdir = $(datadir)/doc/$(PACKAGE)-$(VERSION)
+ 
+ built_docs = spec.py spec.html
+diff -Naur libtheora-1.0alpha3/examples/Makefile.am libtheora-1.0alpha3.autotools/examples/Makefile.am
+--- libtheora-1.0alpha3/examples/Makefile.am	2004-03-20 00:18:59.000000000 +0100
++++ libtheora-1.0alpha3.autotools/examples/Makefile.am	2004-08-18 13:34:47.805875664 +0200
+@@ -1,7 +1,5 @@
+ ## Process this file with automake to produce Makefile.in
+ 
+-AUTOMAKE_OPTIONS = foreign
+-
+ INCLUDES = -I$(top_srcdir)/include 
+ 
+ noinst_PROGRAMS = encoder_example dump_video $(BUILDABLE_EXAMPLES)
+diff -Naur libtheora-1.0alpha3/include/Makefile.am libtheora-1.0alpha3.autotools/include/Makefile.am
+--- libtheora-1.0alpha3/include/Makefile.am	2002-09-23 05:02:07.000000000 +0200
++++ libtheora-1.0alpha3.autotools/include/Makefile.am	2004-08-18 13:34:40.092048344 +0200
+@@ -1,5 +1,3 @@
+ ## Process this file with automake to produce Makefile.in
+ 
+-AUTOMAKE_OPTIONS = foreign
+-
+ SUBDIRS = theora
+diff -Naur libtheora-1.0alpha3/include/theora/Makefile.am libtheora-1.0alpha3.autotools/include/theora/Makefile.am
+--- libtheora-1.0alpha3/include/theora/Makefile.am	2002-09-23 05:02:07.000000000 +0200
++++ libtheora-1.0alpha3.autotools/include/theora/Makefile.am	2004-08-18 13:53:07.512694816 +0200
+@@ -1,8 +1,5 @@
+ ## Process this file with automake to produce Makefile.in
+ 
+-AUTOMAKE_OPTIONS = foreign
+-
+-includedir = $(prefix)/include/theora
+-
+-include_HEADERS = theora.h
++theoraincludedir = $(includedir)/theora
+ 
++theorainclude_HEADERS = theora.h
+diff -Naur libtheora-1.0alpha3/lib/Makefile.am libtheora-1.0alpha3.autotools/lib/Makefile.am
+--- libtheora-1.0alpha3/lib/Makefile.am	2003-06-15 02:56:42.000000000 +0200
++++ libtheora-1.0alpha3.autotools/lib/Makefile.am	2004-08-18 13:34:47.804875816 +0200
+@@ -1,5 +1,3 @@
+-AUTOMAKE_OPTIONS = foreign
+-
+ INCLUDES = -I$(top_srcdir)/include
+ 
+ lib_LTLIBRARIES = libtheora.la

Added: trunk/rpms/libtheora/libtheora-1.0alpha3-include.patch
===================================================================
--- trunk/rpms/libtheora/libtheora-1.0alpha3-include.patch	2004-10-25 11:47:23 UTC (rev 2308)
+++ trunk/rpms/libtheora/libtheora-1.0alpha3-include.patch	2004-10-25 11:48:41 UTC (rev 2309)
@@ -0,0 +1,122 @@
+diff -Naur libtheora-1.0alpha3/include/theora/Makefile.am libtheora-1.0alpha3.patched/include/theora/Makefile.am
+--- libtheora-1.0alpha3/include/theora/Makefile.am	2002-09-23 05:02:07.000000000 +0200
++++ libtheora-1.0alpha3.patched/include/theora/Makefile.am	2004-03-29 16:20:56.000000000 +0200
+@@ -2,7 +2,7 @@
+ 
+ AUTOMAKE_OPTIONS = foreign
+ 
+-includedir = $(prefix)/include/theora
++theoraincludedir = $(includedir)/theora
+ 
+-include_HEADERS = theora.h
++theorainclude_HEADERS = theora.h
+ 
+diff -Naur libtheora-1.0alpha3/include/theora/Makefile.in libtheora-1.0alpha3.patched/include/theora/Makefile.in
+--- libtheora-1.0alpha3/include/theora/Makefile.in	2004-03-20 06:43:24.000000000 +0100
++++ libtheora-1.0alpha3.patched/include/theora/Makefile.in	2004-03-29 16:29:24.000000000 +0200
+@@ -128,7 +128,7 @@
+ host_os = @host_os@
+ host_vendor = @host_vendor@
+ 
+-includedir = $(prefix)/include/theora
++includedir = @includedir@
+ infodir = @infodir@
+ install_sh = @install_sh@
+ libdir = @libdir@
+@@ -147,18 +147,19 @@
+ target_os = @target_os@
+ target_vendor = @target_vendor@
+ 
++theoraincludedir = $(includedir)/theora
+ AUTOMAKE_OPTIONS = foreign
+ 
+-include_HEADERS = theora.h
++theorainclude_HEADERS = theora.h
+ subdir = include/theora
+ ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+ mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+ CONFIG_HEADER = $(top_builddir)/config.h
+ CONFIG_CLEAN_FILES =
+ DIST_SOURCES =
+-HEADERS = $(include_HEADERS)
++HEADERS = $(theorainclude_HEADERS)
+ 
+-DIST_COMMON = $(include_HEADERS) $(srcdir)/Makefile.in Makefile.am
++DIST_COMMON = $(theorainclude_HEADERS) $(srcdir)/Makefile.in Makefile.am
+ all: all-am
+ 
+ .SUFFIXES:
+@@ -177,23 +178,23 @@
+ distclean-libtool:
+ 	-rm -f libtool
+ uninstall-info-am:
+-includeHEADERS_INSTALL = $(INSTALL_HEADER)
+-install-includeHEADERS: $(include_HEADERS)
++theoraincludeHEADERS_INSTALL = $(INSTALL_HEADER)
++install-theoraincludeHEADERS: $(theorainclude_HEADERS)
+ 	@$(NORMAL_INSTALL)
+-	$(mkinstalldirs) $(DESTDIR)$(includedir)
+-	@list='$(include_HEADERS)'; for p in $$list; do \
++	$(mkinstalldirs) $(DESTDIR)$(theoraincludedir)
++	@list='$(theorainclude_HEADERS)'; for p in $$list; do \
+ 	  if test -f &quot;$$p&quot;; then d=; else d=&quot;$(srcdir)/&quot;; fi; \
+ 	  f=&quot;`echo $$p | sed -e 's|^.*/||'`&quot;; \
+-	  echo &quot; $(includeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(includedir)/$$f&quot;; \
+-	  $(includeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(includedir)/$$f; \
++	  echo &quot; $(theoraincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(theoraincludedir)/$$f&quot;; \
++	  $(theoraincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(theoraincludedir)/$$f; \
+ 	done
+ 
+-uninstall-includeHEADERS:
++uninstall-theoraincludeHEADERS:
+ 	@$(NORMAL_UNINSTALL)
+-	@list='$(include_HEADERS)'; for p in $$list; do \
++	@list='$(theorainclude_HEADERS)'; for p in $$list; do \
+ 	  f=&quot;`echo $$p | sed -e 's|^.*/||'`&quot;; \
+-	  echo &quot; rm -f $(DESTDIR)$(includedir)/$$f&quot;; \
+-	  rm -f $(DESTDIR)$(includedir)/$$f; \
++	  echo &quot; rm -f $(DESTDIR)$(theoraincludedir)/$$f&quot;; \
++	  rm -f $(DESTDIR)$(theoraincludedir)/$$f; \
+ 	done
+ 
+ ETAGS = etags
+@@ -286,7 +287,7 @@
+ all-am: Makefile $(HEADERS)
+ 
+ installdirs:
+-	$(mkinstalldirs) $(DESTDIR)$(includedir)
++	$(mkinstalldirs) $(DESTDIR)$(theoraincludedir)
+ install: install-am
+ install-exec: install-exec-am
+ install-data: install-data-am
+@@ -328,7 +329,7 @@
+ 
+ info-am:
+ 
+-install-data-am: install-includeHEADERS
++install-data-am: install-theoraincludeHEADERS
+ 
+ install-exec-am:
+ 
+@@ -354,18 +355,18 @@
+ 
+ ps-am:
+ 
+-uninstall-am: uninstall-includeHEADERS uninstall-info-am
++uninstall-am: uninstall-theoraincludeHEADERS uninstall-info-am
+ 
+ .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+ 	clean-libtool ctags distclean distclean-generic \
+ 	distclean-libtool distclean-tags distdir dvi dvi-am info \
+ 	info-am install install-am install-data install-data-am \
+-	install-exec install-exec-am install-includeHEADERS \
++	install-exec install-exec-am install-theoraincludeHEADERS \
+ 	install-info install-info-am install-man install-strip \
+ 	installcheck installcheck-am installdirs maintainer-clean \
+ 	maintainer-clean-generic mostlyclean mostlyclean-generic \
+ 	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+-	uninstall-am uninstall-includeHEADERS uninstall-info-am
++	uninstall-am uninstall-theoraincludeHEADERS uninstall-info-am
+ 
+ # Tell versions [3.59,3.63) of GNU make to not export all variables.
+ # Otherwise a system limit (for SysV at least) may be exceeded.

Added: trunk/rpms/libtheora/libtheora-1.0alpha3-mmx.patch
===================================================================
--- trunk/rpms/libtheora/libtheora-1.0alpha3-mmx.patch	2004-10-25 11:47:23 UTC (rev 2308)
+++ trunk/rpms/libtheora/libtheora-1.0alpha3-mmx.patch	2004-10-25 11:48:41 UTC (rev 2309)
@@ -0,0 +1,3586 @@
+diff -Naur libtheora-1.0alpha3/lib/blockmap.c libtheora-1.0alpha3.mmx/lib/blockmap.c
+--- libtheora-1.0alpha3/lib/blockmap.c	2003-12-03 09:59:39.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/blockmap.c	2004-10-06 17:48:22.202433112 +0200
+@@ -21,7 +21,7 @@
+                             ogg_uint32_t FirstSB,
+                             ogg_uint32_t FirstFrag, ogg_uint32_t HFrags,
+                             ogg_uint32_t VFrags ){
+-  ogg_uint32_t i, j;
++  ogg_uint32_t i, j = 0;
+   ogg_uint32_t xpos;
+   ogg_uint32_t ypos;
+   ogg_uint32_t SBrow, SBcol;
+diff -Naur libtheora-1.0alpha3/lib/cpu.c libtheora-1.0alpha3.mmx/lib/cpu.c
+--- libtheora-1.0alpha3/lib/cpu.c	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/cpu.c	2004-10-06 17:48:22.203432960 +0200
+@@ -0,0 +1,107 @@
++/********************************************************************
++ *                                                                  *
++ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
++ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
++ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
++ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
++ *                                                                  *
++ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2003                *
++ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
++ *                                                                  *
++ ********************************************************************
++
++  function:
++  last mod: $Id: mcomp.c,v 1.8 2003/12/03 08:59:41 arc Exp $
++
++ ********************************************************************/
++
++#include &quot;cpu.h&quot;
++
++ogg_uint32_t cpu_flags = 0;
++
++#if 1
++static ogg_uint32_t cpu_get_flags (void)
++{
++  ogg_uint32_t eax, ebx, ecx, edx;
++  ogg_uint32_t flags;
++
++#define cpuid(op,eax,ebx,ecx,edx)      \
++  asm volatile (&quot;pushl %%ebx   \n\t&quot;   \
++                &quot;cpuid         \n\t&quot;   \
++                &quot;movl %%ebx,%1 \n\t&quot;   \
++                &quot;popl %%ebx&quot;           \
++              : &quot;=a&quot; (eax),            \
++                &quot;=r&quot; (ebx),            \
++                &quot;=c&quot; (ecx),            \
++                &quot;=d&quot; (edx)             \
++              : &quot;a&quot; (op)               \
++              : &quot;cc&quot;)
++
++  asm volatile (&quot;pushfl              \n\t&quot;
++                &quot;pushfl              \n\t&quot;
++                &quot;popl %0             \n\t&quot;
++                &quot;movl %0,%1          \n\t&quot;
++                &quot;xorl $0x200000,%0   \n\t&quot;
++                &quot;pushl %0            \n\t&quot;
++                &quot;popfl               \n\t&quot;
++                &quot;pushfl              \n\t&quot;
++                &quot;popl %0             \n\t&quot;
++                &quot;popfl&quot;
++              : &quot;=r&quot; (eax),
++                &quot;=r&quot; (ebx)
++              :
++              : &quot;cc&quot;);
++         
++  if (eax == ebx)             /* no cpuid */
++    return 0;
++
++  cpuid(0, eax, ebx, ecx, edx);
++
++  if (ebx == 0x756e6547 &amp;&amp;
++      edx == 0x49656e69 &amp;&amp;
++      ecx == 0x6c65746e) {
++    /* intel */
++
++  inteltest:
++    cpuid(1, eax, ebx, ecx, edx);
++    if ((edx &amp; 0x00800000) == 0)
++      return 0;
++    flags = CPU_X86_MMX;
++    if (edx &amp; 0x02000000)
++      flags |= CPU_X86_MMXEXT | CPU_X86_SSE;
++    if (edx &amp; 0x04000000)
++      flags |= CPU_X86_SSE2;
++    return flags;
++  } else if (ebx == 0x68747541 &amp;&amp;
++             edx == 0x69746e65 &amp;&amp;
++             ecx == 0x444d4163) {
++    /* AMD */
++    cpuid(0x80000000, eax, ebx, ecx, edx);
++    if ((unsigned)eax &lt; 0x80000001)
++      goto inteltest;
++    cpuid(0x80000001, eax, ebx, ecx, edx);
++    if ((edx &amp; 0x00800000) == 0)
++      return 0;
++    flags = CPU_X86_MMX;
++    if (edx &amp; 0x80000000)
++      flags |= CPU_X86_3DNOW;
++    if (edx &amp; 0x00400000)
++      flags |= CPU_X86_MMXEXT;
++    return flags;
++  }
++  else {
++    /* implement me */
++  }
++
++  return flags;
++}
++#else
++static ogg_uint32_t cpu_get_flags (void) {
++  return 0;
++}
++#endif
++
++void cpu_init () 
++{
++  cpu_flags = cpu_get_flags();
++}
+diff -Naur libtheora-1.0alpha3/lib/cpu.h libtheora-1.0alpha3.mmx/lib/cpu.h
+--- libtheora-1.0alpha3/lib/cpu.h	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/cpu.h	2004-10-06 17:48:22.243426880 +0200
+@@ -0,0 +1,28 @@
++/********************************************************************
++ *                                                                  *
++ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
++ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
++ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
++ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
++ *                                                                  *
++ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2003                *
++ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
++ *                                                                  *
++ ********************************************************************
++
++  function:
++  last mod: $Id: mcomp.c,v 1.8 2003/12/03 08:59:41 arc Exp $
++
++ ********************************************************************/
++
++#include &quot;encoder_internal.h&quot;
++
++extern ogg_uint32_t cpu_flags;
++
++#define CPU_X86_MMX	(1&lt;&lt;0)
++#define CPU_X86_3DNOW	(1&lt;&lt;1)
++#define CPU_X86_MMXEXT	(1&lt;&lt;2)
++#define CPU_X86_SSE	(1&lt;&lt;3)
++#define CPU_X86_SSE2	(1&lt;&lt;4)
++
++void cpu_init () ;
+diff -Naur libtheora-1.0alpha3/lib/dct.c libtheora-1.0alpha3.mmx/lib/dct.c
+--- libtheora-1.0alpha3/lib/dct.c	2003-12-03 09:59:39.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/dct.c	2004-10-06 17:48:22.244426728 +0200
+@@ -16,6 +16,7 @@
+  ********************************************************************/
+ 
+ #include &quot;encoder_internal.h&quot;
++#include &quot;cpu.h&quot;
+ 
+ static ogg_int32_t xC1S7 = 64277;
+ static ogg_int32_t xC2S6 = 60547;
+@@ -28,7 +29,7 @@
+ #define SIGNBITDUPPED(X) ((signed )(((X) &amp; 0x80000000)) &gt;&gt; 31)
+ #define DOROUND(X) ( (SIGNBITDUPPED(X) &amp; (0xffff)) + (X) )
+ 
+-void fdct_short ( ogg_int16_t * InputData, ogg_int16_t * OutputData ){
++static void fdct_short__c ( ogg_int16_t * InputData, ogg_int16_t * OutputData ){
+   int loop;
+ 
+   ogg_int32_t  is07, is12, is34, is56;
+@@ -251,3 +252,12 @@
+     op ++;
+   }
+ }
++
++void dsp_dct_init (DspFunctions *funcs)
++{
++  funcs-&gt;fdct_short = fdct_short__c;
++  if (cpu_flags &amp; CPU_X86_MMX) {
++    dsp_i386_mmx_fdct_init(&amp;dsp_funcs);
++  }
++}
++
+diff -Naur libtheora-1.0alpha3/lib/dct_decode.c libtheora-1.0alpha3.mmx/lib/dct_decode.c
+--- libtheora-1.0alpha3/lib/dct_decode.c	2004-03-18 18:10:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/dct_decode.c	2004-10-06 17:48:22.284420648 +0200
+@@ -18,6 +18,7 @@
+ #include &lt;stdlib.h&gt;
+ #include &lt;string.h&gt;
+ #include &quot;encoder_internal.h&quot;
++#include &quot;dsp.h&quot;
+ 
+ 
+ #define GOLDEN_FRAME_THRESH_Q   50
+@@ -112,22 +113,6 @@
+   SetupBoundingValueArray_Generic(pbi, FLimit);
+ }
+ 
+-void CopyBlock(unsigned char *src,
+-               unsigned char *dest,
+-               unsigned int srcstride){
+-  unsigned char *s = src;
+-  unsigned char *d = dest;
+-  unsigned int stride = srcstride;
+-
+-  int j;
+-  for ( j = 0; j &lt; 8; j++ ){
+-    ((ogg_uint32_t*)d)[0] = ((ogg_uint32_t*)s)[0];
+-    ((ogg_uint32_t*)d)[1] = ((ogg_uint32_t*)s)[1];
+-    s+=stride;
+-    d+=stride;
+-  }
+-}
+-
+ static void ExpandKFBlock ( PB_INSTANCE *pbi, ogg_int32_t FragmentNumber ){
+   ogg_uint32_t ReconPixelsPerLine;
+   ogg_int32_t     ReconPixelIndex;
+@@ -160,8 +145,8 @@
+   ReconPixelIndex = pbi-&gt;recon_pixel_index_table[FragmentNumber];
+ 
+   /* Get the pixel index for the first pixel in the fragment. */
+-  ReconIntra( pbi, (unsigned char *)(&amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex]),
+-              (ogg_uint16_t *)pbi-&gt;ReconDataBuffer, ReconPixelsPerLine );
++  dsp_static_recon_intra8x8 ((unsigned char *)(&amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex]),
++              (ogg_uint16_t *)pbi-&gt;ReconDataBuffer, ReconPixelsPerLine);
+ 
+ }
+ 
+@@ -237,10 +222,9 @@
+     /* Reconstruct the pixel data using the last frame reconstruction
+        and change data when the motion vector is (0,0), the recon is
+        based on the lastframe without loop filtering---- for testing */
+-    ReconInter( pbi, &amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
++    dsp_static_recon_inter8x8 (&amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
+                 &amp;pbi-&gt;LastFrameRecon[ReconPixelIndex],
+-                pbi-&gt;ReconDataBuffer, ReconPixelsPerLine );
+-
++                  pbi-&gt;ReconDataBuffer, ReconPixelsPerLine);
+   }else if ( ModeUsesMC[pbi-&gt;CodingMode] ) {
+     /* The mode uses a motion vector. */
+     /* Get vector from list */
+@@ -287,29 +271,30 @@
+     if ( (int)(LastFrameRecPtr - LastFrameRecPtr2) == 0 ) {
+       /* Reconstruct the pixel dats from the reference frame and change data
+          (no half pixel in this case as the two references were the same. */
+-      ReconInter( pbi, &amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
++      dsp_static_recon_inter8x8 (
++		  &amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
+                   LastFrameRecPtr, pbi-&gt;ReconDataBuffer,
+-                  ReconPixelsPerLine );
++                  ReconPixelsPerLine);
+     }else{
+       /* Fractional pixel reconstruction. */
+       /* Note that we only use two pixels per reconstruction even for
+          the diagonal. */
+-      ReconInterHalfPixel2( pbi,&amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
++      dsp_static_recon_inter8x8_half(&amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
+                             LastFrameRecPtr, LastFrameRecPtr2,
+-                            pbi-&gt;ReconDataBuffer, ReconPixelsPerLine );
++                            pbi-&gt;ReconDataBuffer, ReconPixelsPerLine);
+     }
+   } else if ( pbi-&gt;CodingMode == CODE_USING_GOLDEN ){
+     /* Golden frame with motion vector */
+     /* Reconstruct the pixel data using the golden frame
+        reconstruction and change data */
+-    ReconInter( pbi, &amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
++    dsp_static_recon_inter8x8 (&amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
+                 &amp;pbi-&gt;GoldenFrame[ ReconPixelIndex ],
+-                pbi-&gt;ReconDataBuffer, ReconPixelsPerLine );
++                  pbi-&gt;ReconDataBuffer, ReconPixelsPerLine);
+   } else {
+     /* Simple Intra coding */
+     /* Get the pixel index for the first pixel in the fragment. */
+-    ReconIntra( pbi, &amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
+-                pbi-&gt;ReconDataBuffer, ReconPixelsPerLine );
++    dsp_static_recon_intra8x8 (&amp;pbi-&gt;ThisFrameRecon[ReconPixelIndex],
++              pbi-&gt;ReconDataBuffer, ReconPixelsPerLine);
+   }
+ }
+ 
+@@ -464,7 +449,7 @@
+       SrcPtr = &amp;SrcReconPtr[ PixelIndex ];
+       DestPtr = &amp;DestReconPtr[ PixelIndex ];
+ 
+-      CopyBlock(SrcPtr, DestPtr, PlaneLineStep);
++      dsp_static_copy8x8 (SrcPtr, DestPtr, PlaneLineStep);
+     }
+   }
+ 
+@@ -476,7 +461,7 @@
+       SrcPtr = &amp;SrcReconPtr[ PixelIndex ];
+       DestPtr = &amp;DestReconPtr[ PixelIndex ];
+ 
+-      CopyBlock(SrcPtr, DestPtr, PlaneLineStep);
++      dsp_static_copy8x8 (SrcPtr, DestPtr, PlaneLineStep);
+ 
+     }
+   }
+@@ -505,7 +490,7 @@
+       SrcPtr = &amp;SrcReconPtr[ PixelIndex ];
+       DestPtr = &amp;DestReconPtr[ PixelIndex ];
+ 
+-      CopyBlock(SrcPtr, DestPtr, PlaneLineStep);
++      dsp_static_copy8x8 (SrcPtr, DestPtr, PlaneLineStep);
+     }
+   }
+ 
+@@ -517,7 +502,7 @@
+       SrcPtr = &amp;SrcReconPtr[ PixelIndex ];
+       DestPtr = &amp;DestReconPtr[ PixelIndex ];
+ 
+-      CopyBlock(SrcPtr, DestPtr, PlaneLineStep);
++      dsp_static_copy8x8 (SrcPtr, DestPtr, PlaneLineStep);
+ 
+     }
+   }
+diff -Naur libtheora-1.0alpha3/lib/dct_encode.c libtheora-1.0alpha3.mmx/lib/dct_encode.c
+--- libtheora-1.0alpha3/lib/dct_encode.c	2003-06-10 03:31:33.000000000 +0200
++++ libtheora-1.0alpha3.mmx/lib/dct_encode.c	2004-10-06 17:48:22.285420496 +0200
+@@ -17,110 +17,10 @@
+ 
+ #include &lt;stdlib.h&gt;
+ #include &quot;encoder_internal.h&quot;
++#include &quot;dsp.h&quot;
+ 
+ static int ModeUsesMC[MAX_MODES] = { 0, 0, 1, 1, 1, 0, 1, 1 };
+ 
+-static void Sub8 (unsigned char *FiltPtr, unsigned char *ReconPtr,
+-                  ogg_int16_t *DctInputPtr, unsigned char *old_ptr1,
+-                  unsigned char *new_ptr1, ogg_uint32_t PixelsPerLine,
+-                  ogg_uint32_t ReconPixelsPerLine ) {
+-  int i;
+-
+-  /* For each block row */
+-  for ( i=0; i&lt;BLOCK_HEIGHT_WIDTH; i++ ){
+-    DctInputPtr[0] = (ogg_int16_t)((int)(FiltPtr[0]) - ((int)ReconPtr[0]) );
+-    DctInputPtr[1] = (ogg_int16_t)((int)(FiltPtr[1]) - ((int)ReconPtr[1]) );
+-    DctInputPtr[2] = (ogg_int16_t)((int)(FiltPtr[2]) - ((int)ReconPtr[2]) );
+-    DctInputPtr[3] = (ogg_int16_t)((int)(FiltPtr[3]) - ((int)ReconPtr[3]) );
+-    DctInputPtr[4] = (ogg_int16_t)((int)(FiltPtr[4]) - ((int)ReconPtr[4]) );
+-    DctInputPtr[5] = (ogg_int16_t)((int)(FiltPtr[5]) - ((int)ReconPtr[5]) );
+-    DctInputPtr[6] = (ogg_int16_t)((int)(FiltPtr[6]) - ((int)ReconPtr[6]) );
+-    DctInputPtr[7] = (ogg_int16_t)((int)(FiltPtr[7]) - ((int)ReconPtr[7]) );
+-
+-    /* Update the screen canvas in one step*/
+-    ((ogg_uint32_t*)old_ptr1)[0] = ((ogg_uint32_t*)new_ptr1)[0];
+-    ((ogg_uint32_t*)old_ptr1)[1] = ((ogg_uint32_t*)new_ptr1)[1];
+-
+-    /* Start next row */
+-    new_ptr1 += PixelsPerLine;
+-    old_ptr1 += PixelsPerLine;
+-    FiltPtr += PixelsPerLine;
+-    ReconPtr += ReconPixelsPerLine;
+-    DctInputPtr += BLOCK_HEIGHT_WIDTH;
+-  }
+-}
+-
+-static void Sub8_128 (unsigned char *FiltPtr, ogg_int16_t *DctInputPtr,
+-                      unsigned char *old_ptr1, unsigned char *new_ptr1,
+-                      ogg_uint32_t PixelsPerLine ) {
+-  int i;
+-  /* For each block row */
+-  for ( i=0; i&lt;BLOCK_HEIGHT_WIDTH; i++ ){
+-    /* INTRA mode so code raw image data */
+-    /* We convert the data to 8 bit signed (by subtracting 128) as
+-       this reduces the internal precision requirments in the DCT
+-       transform. */
+-    DctInputPtr[0] = (ogg_int16_t)((int)(FiltPtr[0]) - 128);
+-    DctInputPtr[1] = (ogg_int16_t)((int)(FiltPtr[1]) - 128);
+-    DctInputPtr[2] = (ogg_int16_t)((int)(FiltPtr[2]) - 128);
+-    DctInputPtr[3] = (ogg_int16_t)((int)(FiltPtr[3]) - 128);
+-    DctInputPtr[4] = (ogg_int16_t)((int)(FiltPtr[4]) - 128);
+-    DctInputPtr[5] = (ogg_int16_t)((int)(FiltPtr[5]) - 128);
+-    DctInputPtr[6] = (ogg_int16_t)((int)(FiltPtr[6]) - 128);
+-    DctInputPtr[7] = (ogg_int16_t)((int)(FiltPtr[7]) - 128);
+-
+-    /* Update the screen canvas in one step */
+-    ((ogg_uint32_t*)old_ptr1)[0] = ((ogg_uint32_t*)new_ptr1)[0];
+-    ((ogg_uint32_t*)old_ptr1)[1] = ((ogg_uint32_t*)new_ptr1)[1];
+-
+-    /* Start next row */
+-    new_ptr1 += PixelsPerLine;
+-    old_ptr1 += PixelsPerLine;
+-    FiltPtr += PixelsPerLine;
+-    DctInputPtr += BLOCK_HEIGHT_WIDTH;
+-  }
+-}
+-
+-static void Sub8Av2 (unsigned char *FiltPtr, unsigned char *ReconPtr1,
+-                     unsigned char *ReconPtr2, ogg_int16_t *DctInputPtr,
+-                     unsigned char *old_ptr1, unsigned char *new_ptr1,
+-                     ogg_uint32_t PixelsPerLine,
+-                     ogg_uint32_t ReconPixelsPerLine ) {
+-  int i;
+-
+-  /* For each block row */
+-  for ( i=0; i&lt;BLOCK_HEIGHT_WIDTH; i++ ) {
+-    DctInputPtr[0] = (ogg_int16_t)
+-      ((int)(FiltPtr[0]) - (((int)ReconPtr1[0] + (int)ReconPtr2[0]) / 2) );
+-    DctInputPtr[1] = (ogg_int16_t)
+-      ((int)(FiltPtr[1]) - (((int)ReconPtr1[1] + (int)ReconPtr2[1]) / 2) );
+-    DctInputPtr[2] = (ogg_int16_t)
+-      ((int)(FiltPtr[2]) - (((int)ReconPtr1[2] + (int)ReconPtr2[2]) / 2) );
+-    DctInputPtr[3] = (ogg_int16_t)
+-      ((int)(FiltPtr[3]) - (((int)ReconPtr1[3] + (int)ReconPtr2[3]) / 2) );
+-    DctInputPtr[4] = (ogg_int16_t)
+-      ((int)(FiltPtr[4]) - (((int)ReconPtr1[4] + (int)ReconPtr2[4]) / 2) );
+-    DctInputPtr[5] = (ogg_int16_t)
+-      ((int)(FiltPtr[5]) - (((int)ReconPtr1[5] + (int)ReconPtr2[5]) / 2) );
+-    DctInputPtr[6] = (ogg_int16_t)
+-      ((int)(FiltPtr[6]) - (((int)ReconPtr1[6] + (int)ReconPtr2[6]) / 2) );
+-    DctInputPtr[7] = (ogg_int16_t)
+-      ((int)(FiltPtr[7]) - (((int)ReconPtr1[7] + (int)ReconPtr2[7]) / 2) );
+-
+-    /* Update the screen canvas in one step */
+-    ((ogg_uint32_t*)old_ptr1)[0] = ((ogg_uint32_t*)new_ptr1)[0];
+-    ((ogg_uint32_t*)old_ptr1)[1] = ((ogg_uint32_t*)new_ptr1)[1];
+-
+-    /* Start next row */
+-    new_ptr1 += PixelsPerLine;
+-    old_ptr1 += PixelsPerLine;
+-    FiltPtr += PixelsPerLine;
+-    ReconPtr1 += ReconPixelsPerLine;
+-    ReconPtr2 += ReconPixelsPerLine;
+-    DctInputPtr += BLOCK_HEIGHT_WIDTH;
+-  }
+-}
+-
+ static unsigned char TokenizeDctValue (ogg_int16_t DataValue,
+                                        ogg_uint32_t * TokenListPtr ){
+   unsigned char tokens_added = 0;
+@@ -452,13 +352,15 @@
+ 
+   /* Is the MV offset exactly pixel alligned */
+   if ( AbsRefOffset == 0 ){
+-    Sub8( FiltPtr, ReconPtr1, DctInputPtr, old_ptr1, new_ptr1,
+-               PixelsPerLine, ReconPixelsPerLine );
++    dsp_static_sub8x8( FiltPtr, ReconPtr1, DctInputPtr,
++               PixelsPerLine, ReconPixelsPerLine);
++    dsp_static_copy8x8 (new_ptr1, old_ptr1, PixelsPerLine);
+   } else {
+     /* Fractional pixel MVs. */
+     /* Note that we only use two pixel values even for the diagonal */
+-    Sub8Av2(FiltPtr, ReconPtr1,ReconPtr2,DctInputPtr, old_ptr1,
+-                 new_ptr1, PixelsPerLine, ReconPixelsPerLine );
++    dsp_static_sub8x8avg2(FiltPtr, ReconPtr1,ReconPtr2,DctInputPtr,
++                 PixelsPerLine, ReconPixelsPerLine);
++    dsp_static_copy8x8 (new_ptr1, old_ptr1, PixelsPerLine);
+   }
+ }
+ 
+@@ -534,17 +436,18 @@
+         pb.GoldenFrame[cpi-&gt;pb.recon_pixel_index_table[FragIndex]];
+     }
+ 
+-    Sub8( FiltPtr, ReconPtr1, DctInputPtr, old_ptr1, new_ptr1,
+-               PixelsPerLine, ReconPixelsPerLine );
++    dsp_static_sub8x8( FiltPtr, ReconPtr1, DctInputPtr,
++               PixelsPerLine, ReconPixelsPerLine);
++    dsp_static_copy8x8 (new_ptr1, old_ptr1, PixelsPerLine);
+   } else if ( cpi-&gt;pb.CodingMode==CODE_INTRA ) {
+-    Sub8_128(FiltPtr, DctInputPtr, old_ptr1, new_ptr1, PixelsPerLine);
+-
++    dsp_static_sub8x8_128(FiltPtr, DctInputPtr, PixelsPerLine);
++    dsp_static_copy8x8 (new_ptr1, old_ptr1, PixelsPerLine);
+   }
+ 
+   /* Proceed to encode the data into the encode buffer if the encoder
+      is enabled. */
+   /* Perform a 2D DCT transform on the data. */
+-  fdct_short( cpi-&gt;DCTDataBuffer, cpi-&gt;DCT_codes );
++  dsp_static_fdct_short( cpi-&gt;DCTDataBuffer, cpi-&gt;DCT_codes );
+ 
+   /* Quantize that transform data. */
+   quantize ( &amp;cpi-&gt;pb, cpi-&gt;DCT_codes, cpi-&gt;pb.QFragData[FragIndex] );
+diff -Naur libtheora-1.0alpha3/lib/decode.c libtheora-1.0alpha3.mmx/lib/decode.c
+--- libtheora-1.0alpha3/lib/decode.c	2003-12-06 19:06:20.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/decode.c	2004-10-06 17:48:22.324414568 +0200
+@@ -796,6 +796,8 @@
+   /* Make a not of the number of coded blocks this frame */
+   pbi-&gt;CodedBlocksThisFrame = pbi-&gt;CodedBlockIndex;
+ 
++  dsp_static_save_fpu();
++
+   /* Decode the modes data */
+   DecodeModes( pbi, pbi-&gt;YSBRows, pbi-&gt;YSBCols);
+ 
+@@ -808,6 +810,7 @@
+   /* Reconstruct and display the frame */
+   ReconRefFrames(pbi);
+ 
++  dsp_static_restore_fpu();
+ }
+ 
+ 
+diff -Naur libtheora-1.0alpha3/lib/dsp.c libtheora-1.0alpha3.mmx/lib/dsp.c
+--- libtheora-1.0alpha3/lib/dsp.c	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/dsp.c	2004-10-06 17:48:22.363408640 +0200
+@@ -0,0 +1,416 @@
++/********************************************************************
++ *                                                                  *
++ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
++ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
++ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
++ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
++ *                                                                  *
++ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2003                *
++ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
++ *                                                                  *
++ ********************************************************************
++
++  function:
++  last mod: $Id: mcomp.c,v 1.8 2003/12/03 08:59:41 arc Exp $
++
++ ********************************************************************/
++
++#include &lt;stdlib.h&gt;
++#include &quot;cpu.h&quot;
++#include &quot;encoder_internal.h&quot;
++
++#define DSP_OP_AVG(a,b) ((((int)(a)) + ((int)(b)))/2)
++#define DSP_OP_DIFF(a,b) (((int)(a)) - ((int)(b)))
++#define DSP_OP_ABS_DIFF(a,b) abs((((int)(a)) - ((int)(b))))
++
++DspFunctions dsp_funcs;
++
++static void sub8x8__c (unsigned char *FiltPtr, unsigned char *ReconPtr,
++                  ogg_int16_t *DctInputPtr, ogg_uint32_t PixelsPerLine,
++                  ogg_uint32_t ReconPixelsPerLine) {
++  int i;
++
++  /* For each block row */
++  for (i=8; i; i--) {
++    DctInputPtr[0] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[0], ReconPtr[0]);
++    DctInputPtr[1] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[1], ReconPtr[1]);
++    DctInputPtr[2] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[2], ReconPtr[2]);
++    DctInputPtr[3] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[3], ReconPtr[3]);
++    DctInputPtr[4] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[4], ReconPtr[4]);
++    DctInputPtr[5] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[5], ReconPtr[5]);
++    DctInputPtr[6] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[6], ReconPtr[6]);
++    DctInputPtr[7] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[7], ReconPtr[7]);
++
++    /* Start next row */
++    FiltPtr += PixelsPerLine;
++    ReconPtr += ReconPixelsPerLine;
++    DctInputPtr += 8;
++  }
++}
++
++static void sub8x8_128__c (unsigned char *FiltPtr, ogg_int16_t *DctInputPtr,
++                      ogg_uint32_t PixelsPerLine) {
++  int i;
++  /* For each block row */
++  for (i=8; i; i--) {
++    /* INTRA mode so code raw image data */
++    /* We convert the data to 8 bit signed (by subtracting 128) as
++       this reduces the internal precision requirments in the DCT
++       transform. */
++    DctInputPtr[0] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[0], 128);
++    DctInputPtr[1] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[1], 128);
++    DctInputPtr[2] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[2], 128);
++    DctInputPtr[3] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[3], 128);
++    DctInputPtr[4] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[4], 128);
++    DctInputPtr[5] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[5], 128);
++    DctInputPtr[6] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[6], 128);
++    DctInputPtr[7] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[7], 128);
++
++    /* Start next row */
++    FiltPtr += PixelsPerLine;
++    DctInputPtr += 8;
++  }
++}
++
++static void sub8x8avg2__c (unsigned char *FiltPtr, unsigned char *ReconPtr1,
++                     unsigned char *ReconPtr2, ogg_int16_t *DctInputPtr,
++                     ogg_uint32_t PixelsPerLine,
++                     ogg_uint32_t ReconPixelsPerLine) 
++{
++  int i;
++
++  /* For each block row */
++  for (i=8; i; i--) {
++    DctInputPtr[0] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[0], DSP_OP_AVG (ReconPtr1[0], ReconPtr2[0]));
++    DctInputPtr[1] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[1], DSP_OP_AVG (ReconPtr1[1], ReconPtr2[1]));
++    DctInputPtr[2] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[2], DSP_OP_AVG (ReconPtr1[2], ReconPtr2[2]));
++    DctInputPtr[3] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[3], DSP_OP_AVG (ReconPtr1[3], ReconPtr2[3]));
++    DctInputPtr[4] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[4], DSP_OP_AVG (ReconPtr1[4], ReconPtr2[4]));
++    DctInputPtr[5] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[5], DSP_OP_AVG (ReconPtr1[5], ReconPtr2[5]));
++    DctInputPtr[6] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[6], DSP_OP_AVG (ReconPtr1[6], ReconPtr2[6]));
++    DctInputPtr[7] = (ogg_int16_t) DSP_OP_DIFF (FiltPtr[7], DSP_OP_AVG (ReconPtr1[7], ReconPtr2[7]));
++
++    /* Start next row */
++    FiltPtr += PixelsPerLine;
++    ReconPtr1 += ReconPixelsPerLine;
++    ReconPtr2 += ReconPixelsPerLine;
++    DctInputPtr += 8;
++  }
++}
++
++static ogg_uint32_t row_sad8__c (unsigned char *Src1, unsigned char *Src2)
++{
++  ogg_uint32_t SadValue;
++  ogg_uint32_t SadValue1;
++
++  SadValue    = DSP_OP_ABS_DIFF (Src1[0], Src2[0]) + 
++	        DSP_OP_ABS_DIFF (Src1[1], Src2[1]) +
++	        DSP_OP_ABS_DIFF (Src1[2], Src2[2]) +
++	        DSP_OP_ABS_DIFF (Src1[3], Src2[3]);
++
++  SadValue1   = DSP_OP_ABS_DIFF (Src1[4], Src2[4]) + 
++	        DSP_OP_ABS_DIFF (Src1[5], Src2[5]) +
++	        DSP_OP_ABS_DIFF (Src1[6], Src2[6]) +
++	        DSP_OP_ABS_DIFF (Src1[7], Src2[7]);
++
++  SadValue = ( SadValue &gt; SadValue1 ) ? SadValue : SadValue1;
++
++  return SadValue;
++}
++
++static ogg_uint32_t col_sad8x8__c (unsigned char *Src1, unsigned char *Src2,
++		                    ogg_uint32_t stride)
++{
++  ogg_uint32_t SadValue[8] = {0,0,0,0,0,0,0,0};
++  ogg_uint32_t SadValue2[8] = {0,0,0,0,0,0,0,0};
++  ogg_uint32_t MaxSad = 0;
++  ogg_uint32_t i;
++
++  for ( i = 0; i &lt; 4; i++ ){
++    SadValue[0] += abs(Src1[0] - Src2[0]);
++    SadValue[1] += abs(Src1[1] - Src2[1]);
++    SadValue[2] += abs(Src1[2] - Src2[2]);
++    SadValue[3] += abs(Src1[3] - Src2[3]);
++    SadValue[4] += abs(Src1[4] - Src2[4]);
++    SadValue[5] += abs(Src1[5] - Src2[5]);
++    SadValue[6] += abs(Src1[6] - Src2[6]);
++    SadValue[7] += abs(Src1[7] - Src2[7]);
++    
++    Src1 += stride;
++    Src2 += stride;
++  }
++
++  for ( i = 0; i &lt; 4; i++ ){
++    SadValue2[0] += abs(Src1[0] - Src2[0]);
++    SadValue2[1] += abs(Src1[1] - Src2[1]);
++    SadValue2[2] += abs(Src1[2] - Src2[2]);
++    SadValue2[3] += abs(Src1[3] - Src2[3]);
++    SadValue2[4] += abs(Src1[4] - Src2[4]);
++    SadValue2[5] += abs(Src1[5] - Src2[5]);
++    SadValue2[6] += abs(Src1[6] - Src2[6]);
++    SadValue2[7] += abs(Src1[7] - Src2[7]);
++    
++    Src1 += stride;
++    Src2 += stride;
++  }
++    
++  for ( i = 0; i &lt; 8; i++ ){
++    if ( SadValue[i] &gt; MaxSad )
++      MaxSad = SadValue[i];
++    if ( SadValue2[i] &gt; MaxSad )
++      MaxSad = SadValue2[i];
++  }
++    
++  return MaxSad;
++}
++
++static ogg_uint32_t sad8x8__c (unsigned char *ptr1, ogg_uint32_t stride1,
++		       	    unsigned char *ptr2, ogg_uint32_t stride2)
++{
++  ogg_uint32_t  i;
++  ogg_uint32_t  sad = 0;
++
++  for (i=8; i; i--) {
++    sad += DSP_OP_ABS_DIFF(ptr1[0], ptr2[0]);
++    sad += DSP_OP_ABS_DIFF(ptr1[1], ptr2[1]);
++    sad += DSP_OP_ABS_DIFF(ptr1[2], ptr2[2]);
++    sad += DSP_OP_ABS_DIFF(ptr1[3], ptr2[3]);
++    sad += DSP_OP_ABS_DIFF(ptr1[4], ptr2[4]);
++    sad += DSP_OP_ABS_DIFF(ptr1[5], ptr2[5]);
++    sad += DSP_OP_ABS_DIFF(ptr1[6], ptr2[6]);
++    sad += DSP_OP_ABS_DIFF(ptr1[7], ptr2[7]);
++
++    /* Step to next row of block. */
++    ptr1 += stride1;
++    ptr2 += stride2;
++  }
++
++  return sad;
++}
++
++static ogg_uint32_t sad8x8_thres__c (unsigned char *ptr1, ogg_uint32_t stride1,
++		       		  unsigned char *ptr2, ogg_uint32_t stride2, 
++			   	  ogg_uint32_t thres)
++{
++  ogg_uint32_t  i;
++  ogg_uint32_t  sad = 0;
++
++  for (i=8; i; i--) {
++    sad += DSP_OP_ABS_DIFF(ptr1[0], ptr2[0]);
++    sad += DSP_OP_ABS_DIFF(ptr1[1], ptr2[1]);
++    sad += DSP_OP_ABS_DIFF(ptr1[2], ptr2[2]);
++    sad += DSP_OP_ABS_DIFF(ptr1[3], ptr2[3]);
++    sad += DSP_OP_ABS_DIFF(ptr1[4], ptr2[4]);
++    sad += DSP_OP_ABS_DIFF(ptr1[5], ptr2[5]);
++    sad += DSP_OP_ABS_DIFF(ptr1[6], ptr2[6]);
++    sad += DSP_OP_ABS_DIFF(ptr1[7], ptr2[7]);
++
++    if (sad &gt; thres )
++      break;
++
++    /* Step to next row of block. */
++    ptr1 += stride1;
++    ptr2 += stride2;
++  }
++
++  return sad;
++}
++
++static ogg_uint32_t sad8x8_xy2_thres__c (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                      unsigned char *RefDataPtr1,
++			              unsigned char *RefDataPtr2, ogg_uint32_t RefStride,
++			              ogg_uint32_t thres)
++{
++  ogg_uint32_t  i;
++  ogg_uint32_t  sad = 0;
++
++  for (i=8; i; i--) {
++    sad += DSP_OP_ABS_DIFF(SrcData[0], DSP_OP_AVG (RefDataPtr1[0], RefDataPtr2[0]));
++    sad += DSP_OP_ABS_DIFF(SrcData[1], DSP_OP_AVG (RefDataPtr1[1], RefDataPtr2[1]));
++    sad += DSP_OP_ABS_DIFF(SrcData[2], DSP_OP_AVG (RefDataPtr1[2], RefDataPtr2[2]));
++    sad += DSP_OP_ABS_DIFF(SrcData[3], DSP_OP_AVG (RefDataPtr1[3], RefDataPtr2[3]));
++    sad += DSP_OP_ABS_DIFF(SrcData[4], DSP_OP_AVG (RefDataPtr1[4], RefDataPtr2[4]));
++    sad += DSP_OP_ABS_DIFF(SrcData[5], DSP_OP_AVG (RefDataPtr1[5], RefDataPtr2[5]));
++    sad += DSP_OP_ABS_DIFF(SrcData[6], DSP_OP_AVG (RefDataPtr1[6], RefDataPtr2[6]));
++    sad += DSP_OP_ABS_DIFF(SrcData[7], DSP_OP_AVG (RefDataPtr1[7], RefDataPtr2[7]));
++
++    if ( sad &gt; thres )
++      break;
++
++    /* Step to next row of block. */
++    SrcData += SrcStride;
++    RefDataPtr1 += RefStride;
++    RefDataPtr2 += RefStride;
++  }
++
++  return sad;
++}
++
++static ogg_uint32_t intra8x8_err__c (unsigned char *DataPtr, ogg_uint32_t Stride)
++{
++  ogg_uint32_t  i;
++  ogg_uint32_t  XSum=0;
++  ogg_uint32_t  XXSum=0;
++
++  for (i=8; i; i--) {
++     /* Examine alternate pixel locations. */
++     XSum += DataPtr[0];
++     XXSum += DataPtr[0]*DataPtr[0];
++     XSum += DataPtr[1];
++     XXSum += DataPtr[1]*DataPtr[1];
++     XSum += DataPtr[2];
++     XXSum += DataPtr[2]*DataPtr[2];
++     XSum += DataPtr[3];
++     XXSum += DataPtr[3]*DataPtr[3];
++     XSum += DataPtr[4];
++     XXSum += DataPtr[4]*DataPtr[4];
++     XSum += DataPtr[5];
++     XXSum += DataPtr[5]*DataPtr[5];
++     XSum += DataPtr[6];
++     XXSum += DataPtr[6]*DataPtr[6];
++     XSum += DataPtr[7];
++     XXSum += DataPtr[7]*DataPtr[7];
++
++     /* Step to next row of block. */
++     DataPtr += Stride;
++   }
++
++   /* Compute population variance as mis-match metric. */
++   return (( (XXSum&lt;&lt;6) - XSum*XSum ) );
++}
++
++static ogg_uint32_t inter8x8_err__c (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                 unsigned char *RefDataPtr, ogg_uint32_t RefStride)
++{
++  ogg_uint32_t  i;
++  ogg_uint32_t  XSum=0;
++  ogg_uint32_t  XXSum=0;
++  ogg_int32_t   DiffVal;
++
++  for (i=8; i; i--) {
++    DiffVal = DSP_OP_DIFF (SrcData[0], RefDataPtr[0]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF (SrcData[1], RefDataPtr[1]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF (SrcData[2], RefDataPtr[2]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF (SrcData[3], RefDataPtr[3]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++        
++    DiffVal = DSP_OP_DIFF (SrcData[4], RefDataPtr[4]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++        
++    DiffVal = DSP_OP_DIFF (SrcData[5], RefDataPtr[5]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++        
++    DiffVal = DSP_OP_DIFF (SrcData[6], RefDataPtr[6]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++        
++    DiffVal = DSP_OP_DIFF (SrcData[7], RefDataPtr[7]);
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++        
++    /* Step to next row of block. */
++    SrcData += SrcStride;
++    RefDataPtr += RefStride;
++  }
++
++  /* Compute and return population variance as mis-match metric. */
++  return (( (XXSum&lt;&lt;6) - XSum*XSum ));
++}
++
++static ogg_uint32_t inter8x8_err_xy2__c (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                     unsigned char *RefDataPtr1,
++				     unsigned char *RefDataPtr2, ogg_uint32_t RefStride)
++{
++  ogg_uint32_t  i;
++  ogg_uint32_t  XSum=0;
++  ogg_uint32_t  XXSum=0;
++  ogg_int32_t   DiffVal;
++
++  for (i=8; i; i--) {
++    DiffVal = DSP_OP_DIFF(SrcData[0], DSP_OP_AVG (RefDataPtr1[0], RefDataPtr2[0]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF(SrcData[1], DSP_OP_AVG (RefDataPtr1[1], RefDataPtr2[1]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF(SrcData[2], DSP_OP_AVG (RefDataPtr1[2], RefDataPtr2[2]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF(SrcData[3], DSP_OP_AVG (RefDataPtr1[3], RefDataPtr2[3]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF(SrcData[4], DSP_OP_AVG (RefDataPtr1[4], RefDataPtr2[4]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF(SrcData[5], DSP_OP_AVG (RefDataPtr1[5], RefDataPtr2[5]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF(SrcData[6], DSP_OP_AVG (RefDataPtr1[6], RefDataPtr2[6]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    DiffVal = DSP_OP_DIFF(SrcData[7], DSP_OP_AVG (RefDataPtr1[7], RefDataPtr2[7]));
++    XSum += DiffVal;
++    XXSum += DiffVal*DiffVal;
++
++    /* Step to next row of block. */
++    SrcData += SrcStride;
++    RefDataPtr1 += RefStride;
++    RefDataPtr2 += RefStride;
++  }
++
++  /* Compute and return population variance as mis-match metric. */
++  return (( (XXSum&lt;&lt;6) - XSum*XSum ));
++}
++
++static void nop (void) { /* NOP */ }
++
++void dsp_init(DspFunctions *funcs)
++{
++  funcs-&gt;save_fpu = nop;
++  funcs-&gt;restore_fpu = nop;
++  funcs-&gt;sub8x8 = sub8x8__c;
++  funcs-&gt;sub8x8_128 = sub8x8_128__c;
++  funcs-&gt;sub8x8avg2 = sub8x8avg2__c;
++  funcs-&gt;row_sad8 = row_sad8__c;
++  funcs-&gt;col_sad8x8 = col_sad8x8__c;
++  funcs-&gt;sad8x8 = sad8x8__c;
++  funcs-&gt;sad8x8_thres = sad8x8_thres__c;
++  funcs-&gt;sad8x8_xy2_thres = sad8x8_xy2_thres__c;
++  funcs-&gt;intra8x8_err = intra8x8_err__c;
++  funcs-&gt;inter8x8_err = inter8x8_err__c;
++  funcs-&gt;inter8x8_err_xy2 = inter8x8_err_xy2__c;
++}
++
++void dsp_static_init(void)
++{
++  cpu_init ();
++  dsp_init (&amp;dsp_funcs);
++  dsp_recon_init (&amp;dsp_funcs);
++  dsp_dct_init (&amp;dsp_funcs);
++  if (cpu_flags &amp; CPU_X86_MMX) {
++    dsp_i386_mmx_init(&amp;dsp_funcs);
++  }
++  if (cpu_flags &amp; CPU_X86_MMXEXT) {
++    dsp_i386_mmxext_init(&amp;dsp_funcs);
++  }
++}
++
+diff -Naur libtheora-1.0alpha3/lib/dsp.h libtheora-1.0alpha3.mmx/lib/dsp.h
+--- libtheora-1.0alpha3/lib/dsp.h	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/dsp.h	2004-10-06 17:48:22.364408488 +0200
+@@ -0,0 +1,154 @@
++/********************************************************************
++ *                                                                  *
++ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
++ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
++ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
++ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
++ *                                                                  *
++ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2003                *
++ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
++ *                                                                  *
++ ********************************************************************
++
++  function:
++  last mod: $Id: mcomp.c,v 1.8 2003/12/03 08:59:41 arc Exp $
++
++ ********************************************************************/
++
++#ifndef DSP_H
++#define DSP_H
++
++#include &lt;theora/theora.h&gt;
++
++typedef struct
++{
++  void   (*save_fpu)            (void);
++  void   (*restore_fpu)         (void);
++
++  void   (*sub8x8)  		(unsigned char *FiltPtr, unsigned char *ReconPtr,
++	                   	 ogg_int16_t *DctInputPtr, ogg_uint32_t PixelsPerLine,
++				 ogg_uint32_t ReconPixelsPerLine);
++
++  void   (*sub8x8_128) 		(unsigned char *FiltPtr, ogg_int16_t *DctInputPtr,
++			         ogg_uint32_t PixelsPerLine);
++
++  void   (*sub8x8avg2) 		(unsigned char *FiltPtr, unsigned char *ReconPtr1,
++		                 unsigned char *ReconPtr2, ogg_int16_t *DctInputPtr,
++			         ogg_uint32_t PixelsPerLine,
++			         ogg_uint32_t ReconPixelsPerLine); 
++
++  void   (*copy8x8)  		(unsigned char *src, unsigned char *dest, 
++		                 ogg_uint32_t stride);
++
++  void   (*recon_intra8x8)  	(unsigned char *ReconPtr, ogg_int16_t *ChangePtr, 
++		                 ogg_uint32_t LineStep);
++
++  void   (*recon_inter8x8)  	(unsigned char *ReconPtr, unsigned char *RefPtr, 
++		                 ogg_int16_t *ChangePtr, ogg_uint32_t LineStep);
++
++  void   (*recon_inter8x8_half)	(unsigned char *ReconPtr, unsigned char *RefPtr1, 
++		  		 unsigned char *RefPtr2, ogg_int16_t *ChangePtr, 
++				 ogg_uint32_t LineStep);
++
++  void   (*fdct_short)          (ogg_int16_t *InputData, ogg_int16_t *OutputData);
++
++  ogg_uint32_t (*row_sad8)	(unsigned char *Src1, unsigned char *Src2);
++
++  ogg_uint32_t (*col_sad8x8)	(unsigned char *Src1, unsigned char *Src2,
++		  		 ogg_uint32_t stride);
++
++  ogg_uint32_t (*sad8x8)	(unsigned char *ptr1, ogg_uint32_t stride1,
++		        	 unsigned char *ptr2, ogg_uint32_t stride2);
++
++  ogg_uint32_t (*sad8x8_thres)	(unsigned char *ptr1, ogg_uint32_t stride1,
++		       		 unsigned char *ptr2, ogg_uint32_t stride2, 
++				 ogg_uint32_t thres);
++
++  ogg_uint32_t (*sad8x8_xy2_thres)(unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                 unsigned char *RefDataPtr1,
++			         unsigned char *RefDataPtr2, ogg_uint32_t RefStride,
++				 ogg_uint32_t thres);
++
++  ogg_uint32_t (*intra8x8_err)	(unsigned char *DataPtr, ogg_uint32_t Stride);
++
++  ogg_uint32_t (*inter8x8_err)	(unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                 unsigned char *RefDataPtr, ogg_uint32_t RefStride);
++
++  ogg_uint32_t (*inter8x8_err_xy2)(unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                 unsigned char *RefDataPtr1,
++			         unsigned char *RefDataPtr2, ogg_uint32_t RefStride);
++} DspFunctions;
++
++extern DspFunctions dsp_funcs;
++
++extern void dsp_recon_init (DspFunctions *funcs);
++
++void dsp_init(DspFunctions *funcs);
++void dsp_static_init(void);
++
++#define dsp_save_fpu(funcs) (funcs.save_fpu ())
++#define dsp_static_save_fpu() dsp_save_fpu(dsp_funcs)
++
++#define dsp_restore_fpu(funcs) (funcs.restore_fpu ())
++#define dsp_static_restore_fpu() dsp_restore_fpu(dsp_funcs)
++
++#define dsp_sub8x8(funcs,a1,a2,a3,a4,a5) (funcs.sub8x8 (a1,a2,a3,a4,a5))
++#define dsp_static_sub8x8(a1,a2,a3,a4,a5) dsp_sub8x8(dsp_funcs,a1,a2,a3,a4,a5)
++
++#define dsp_sub8x8_128(funcs,a1,a2,a3) (funcs.sub8x8_128 (a1,a2,a3))
++#define dsp_static_sub8x8_128(a1,a2,a3) dsp_sub8x8_128(dsp_funcs,a1,a2,a3)
++
++#define dsp_sub8x8avg2(funcs,a1,a2,a3,a4,a5,a6) (funcs.sub8x8avg2 (a1,a2,a3,a4,a5,a6))
++#define dsp_static_sub8x8avg2(a1,a2,a3,a4,a5,a6) dsp_sub8x8avg2(dsp_funcs,a1,a2,a3,a4,a5,a6)
++
++#define dsp_copy8x8(funcs,ptr1,ptr2,str1) (funcs.copy8x8 (ptr1,ptr2,str1))
++#define dsp_static_copy8x8(ptr1,ptr2,str1) dsp_copy8x8(dsp_funcs,ptr1,ptr2,str1)
++
++#define dsp_recon_intra8x8(funcs,ptr1,ptr2,str1) (funcs.recon_intra8x8 (ptr1,ptr2,str1))
++#define dsp_static_recon_intra8x8(ptr1,ptr2,str1) dsp_recon_intra8x8(dsp_funcs,ptr1,ptr2,str1)
++
++#define dsp_recon_inter8x8(funcs,ptr1,ptr2,ptr3,str1) \
++	(funcs.recon_inter8x8 (ptr1,ptr2,ptr3,str1))
++#define dsp_static_recon_inter8x8(ptr1,ptr2,ptr3,str1) \
++	dsp_recon_inter8x8(dsp_funcs,ptr1,ptr2,ptr3,str1)
++
++#define dsp_recon_inter8x8_half(funcs,ptr1,ptr2,ptr3,ptr4,str1) \
++	(funcs.recon_inter8x8_half (ptr1,ptr2,ptr3,ptr4,str1))
++#define dsp_static_recon_inter8x8_half(ptr1,ptr2,ptr3,ptr4,str1) \
++	dsp_recon_inter8x8_half(dsp_funcs,ptr1,ptr2,ptr3,ptr4,str1)
++
++#define dsp_fdct_short(funcs,in,out) (funcs.fdct_short (in,out))
++#define dsp_static_fdct_short(in,out) dsp_fdct_short(dsp_funcs,in,out)
++
++#define dsp_row_sad8(funcs,ptr1,ptr2) (funcs.row_sad8 (ptr1,ptr2))
++#define dsp_static_row_sad8(ptr1,ptr2) dsp_row_sad8(dsp_funcs,ptr1,ptr2)
++
++#define dsp_col_sad8x8(funcs,ptr1,ptr2,str1) (funcs.col_sad8x8 (ptr1,ptr2,str1))
++#define dsp_static_col_sad8x8(ptr1,ptr2,str1) dsp_col_sad8x8(dsp_funcs,ptr1,ptr2,str1)
++
++#define dsp_sad8x8(funcs,ptr1,str1,ptr2,str2) (funcs.sad8x8 (ptr1,str1,ptr2,str2))
++#define dsp_static_sad8x8(ptr1,str1,ptr2,str2) dsp_sad8x8(dsp_funcs,ptr1,str1,ptr2,str2)
++
++#define dsp_sad8x8_thres(funcs,ptr1,str1,ptr2,str2,t) (funcs.sad8x8_thres (ptr1,str1,ptr2,str2,t))
++#define dsp_static_sad8x8_thres(ptr1,str1,ptr2,str2,t) dsp_sad8x8_thres(dsp_funcs,ptr1,str1,ptr2,str2,t)
++
++#define dsp_sad8x8_xy2_thres(funcs,ptr1,str1,ptr2,ptr3,str2,t) \
++	(funcs.sad8x8_xy2_thres (ptr1,str1,ptr2,ptr3,str2,t))
++#define dsp_static_sad8x8_xy2_thres(ptr1,str1,ptr2,ptr3,str2,t) \
++	dsp_sad8x8_xy2_thres(dsp_funcs,ptr1,str1,ptr2,ptr3,str2,t)
++
++#define dsp_intra8x8_err(funcs,ptr1,str1) (funcs.intra8x8_err (ptr1,str1))
++#define dsp_static_intra8x8_err(ptr1,str1) dsp_intra8x8_err(dsp_funcs,ptr1,str1)
++
++#define dsp_inter8x8_err(funcs,ptr1,str1,ptr2,str2) \
++	(funcs.inter8x8_err (ptr1,str1,ptr2,str2))
++#define dsp_static_inter8x8_err(ptr1,str1,ptr2,str2) \
++	dsp_inter8x8_err(dsp_funcs,ptr1,str1,ptr2,str2)
++
++#define dsp_inter8x8_err_xy2(funcs,ptr1,str1,ptr2,ptr3,str2) \
++	(funcs.inter8x8_err_xy2 (ptr1,str1,ptr2,ptr3,str2))
++#define dsp_static_inter8x8_err_xy2(ptr1,str1,ptr2,ptr3,str2) \
++	dsp_inter8x8_err_xy2(dsp_funcs,ptr1,str1,ptr2,ptr3,str2)
++
++
++#endif /* DSP_H */
+diff -Naur libtheora-1.0alpha3/lib/encode.c libtheora-1.0alpha3.mmx/lib/encode.c
+--- libtheora-1.0alpha3/lib/encode.c	2004-03-18 15:25:25.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/encode.c	2004-10-06 17:48:22.401402864 +0200
+@@ -531,8 +531,7 @@
+ 
+ static ogg_uint32_t GetBlockReconErrorSlow( CP_INSTANCE *cpi,
+                                      ogg_int32_t BlockIndex ) {
+-  ogg_uint32_t  i;
+-  ogg_uint32_t  ErrorVal = 0;
++  ogg_uint32_t  ErrorVal;
+ 
+   unsigned char * SrcDataPtr =
+     &amp;cpi-&gt;ConvDestBuffer[cpi-&gt;pb.pixel_index_table[BlockIndex]];
+@@ -550,21 +549,8 @@
+     RecStride = cpi-&gt;pb.UVStride;
+   }
+ 
++  ErrorVal = dsp_static_sad8x8 (SrcDataPtr, SrcStride, RecDataPtr, RecStride);
+ 
+-  /* Decide on standard or MMX implementation */
+-  for ( i=0; i &lt; BLOCK_HEIGHT_WIDTH; i++ ) {
+-    ErrorVal += abs( ((int)SrcDataPtr[0]) - ((int)RecDataPtr[0]) );
+-    ErrorVal += abs( ((int)SrcDataPtr[1]) - ((int)RecDataPtr[1]) );
+-    ErrorVal += abs( ((int)SrcDataPtr[2]) - ((int)RecDataPtr[2]) );
+-    ErrorVal += abs( ((int)SrcDataPtr[3]) - ((int)RecDataPtr[3]) );
+-    ErrorVal += abs( ((int)SrcDataPtr[4]) - ((int)RecDataPtr[4]) );
+-    ErrorVal += abs( ((int)SrcDataPtr[5]) - ((int)RecDataPtr[5]) );
+-    ErrorVal += abs( ((int)SrcDataPtr[6]) - ((int)RecDataPtr[6]) );
+-    ErrorVal += abs( ((int)SrcDataPtr[7]) - ((int)RecDataPtr[7]) );
+-    /* Step to next row of block. */
+-    SrcDataPtr += SrcStride;
+-    RecDataPtr += RecStride;
+-  }
+   return ErrorVal;
+ }
+ 
+@@ -933,9 +919,13 @@
+     /* Zero Decoder EOB run count */
+     cpi-&gt;pb.EOB_Run = 0;
+ 
++    dsp_static_save_fpu ();
++
+     /* Encode any fragments coded using DCT. */
+     coded_pixels += QuadCodeDisplayFragments (cpi);
+ 
++    dsp_static_restore_fpu ();
++
+     return coded_pixels;
+ 
+ }
+diff -Naur libtheora-1.0alpha3/lib/encoder_internal.h libtheora-1.0alpha3.mmx/lib/encoder_internal.h
+--- libtheora-1.0alpha3/lib/encoder_internal.h	2004-03-09 03:02:56.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/encoder_internal.h	2004-10-06 17:48:22.436397544 +0200
+@@ -24,6 +24,7 @@
+ 
+ #include &lt;theora/theora.h&gt;
+ #include &quot;huffman.h&quot;
++#include &quot;dsp.h&quot;
+ 
+ #ifndef LIBOGG2
+ #define theora_read(x,y,z) ( *z = oggpackB_read(x,y) )
+@@ -689,23 +690,9 @@
+                    ogg_int16_t *QuantMatrix,
+                    ogg_int16_t * OutputData );
+ 
+-extern void ReconIntra( PB_INSTANCE *pbi, unsigned char * ReconPtr,
+-                        ogg_int16_t * ChangePtr, ogg_uint32_t LineStep );
+-
+-extern void ReconInter( PB_INSTANCE *pbi, unsigned char * ReconPtr,
+-                        unsigned char * RefPtr, ogg_int16_t * ChangePtr,
+-                        ogg_uint32_t LineStep ) ;
+-
+-extern void ReconInterHalfPixel2( PB_INSTANCE *pbi, unsigned char * ReconPtr,
+-                                  unsigned char * RefPtr1,
+-                                  unsigned char * RefPtr2,
+-                                  ogg_int16_t * ChangePtr,
+-                                  ogg_uint32_t LineStep ) ;
++extern void dsp_recon_init (DspFunctions *funcs);
+ 
+ extern void SetupLoopFilter(PB_INSTANCE *pbi);
+-extern void CopyBlock(unsigned char *src,
+-                      unsigned char *dest,
+-                      unsigned int srcstride);
+ extern void LoopFilter(PB_INSTANCE *pbi);
+ extern void ReconRefFrames (PB_INSTANCE *pbi);
+ extern void ExpandToken( Q_LIST_ENTRY * ExpandedBlock,
+diff -Naur libtheora-1.0alpha3/lib/i386/dsp_mmx.c libtheora-1.0alpha3.mmx/lib/i386/dsp_mmx.c
+--- libtheora-1.0alpha3/lib/i386/dsp_mmx.c	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/i386/dsp_mmx.c	2004-10-06 17:48:22.472392072 +0200
+@@ -0,0 +1,642 @@
++/********************************************************************
++ *                                                                  *
++ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
++ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
++ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
++ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
++ *                                                                  *
++ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2003                *
++ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
++ *                                                                  *
++ ********************************************************************
++
++  function:
++  last mod: $Id: mcomp.c,v 1.8 2003/12/03 08:59:41 arc Exp $
++
++ ********************************************************************/
++
++#include &lt;stdlib.h&gt;
++#include &quot;dsp.h&quot;
++
++static const __attribute__ ((aligned(8),used)) ogg_int64_t V128w = 0x0080008000800080LL;
++
++#if defined(__MINGW32__) || defined(__CYGWIN__) || \
++    defined(__OS2__) || (defined (__OpenBSD__) &amp;&amp; !defined(__ELF__))
++# define M(a) &quot;_&quot; #a
++#else
++# define M(a) #a
++#endif
++
++#define DSP_OP_AVG(a,b) ((((int)(a)) + ((int)(b)))/2)
++#define DSP_OP_DIFF(a,b) (((int)(a)) - ((int)(b)))
++#define DSP_OP_ABS_DIFF(a,b) abs((((int)(a)) - ((int)(b))))
++
++static void sub8x8__mmx (unsigned char *FiltPtr, unsigned char *ReconPtr,
++                  ogg_int16_t *DctInputPtr, ogg_uint32_t PixelsPerLine,
++                  ogg_uint32_t ReconPixelsPerLine) 
++{
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 
++
++    &quot;.rept 8                        \n\t&quot;
++    &quot;  movq        (%0), %%mm0      \n\t&quot; /* mm0 = FiltPtr */
++    &quot;  movq        (%1), %%mm1      \n\t&quot; /* mm1 = ReconPtr */
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot; /* dup to prepare for up conversion */
++    &quot;  movq        %%mm1, %%mm3     \n\t&quot; /* dup to prepare for up conversion */
++    /* convert from UINT8 to INT16 */
++    &quot;  punpcklbw   %%mm7, %%mm0     \n\t&quot; /* mm0 = INT16(FiltPtr) */
++    &quot;  punpcklbw   %%mm7, %%mm1     \n\t&quot; /* mm1 = INT16(ReconPtr) */
++    &quot;  punpckhbw   %%mm7, %%mm2     \n\t&quot; /* mm2 = INT16(FiltPtr) */
++    &quot;  punpckhbw   %%mm7, %%mm3     \n\t&quot; /* mm3 = INT16(ReconPtr) */
++    /* start calculation */
++    &quot;  psubw       %%mm1, %%mm0     \n\t&quot; /* mm0 = FiltPtr - ReconPtr */
++    &quot;  psubw       %%mm3, %%mm2     \n\t&quot; /* mm2 = FiltPtr - ReconPtr */
++    &quot;  movq        %%mm0,  (%2)     \n\t&quot; /* write answer out */
++    &quot;  movq        %%mm2, 8(%2)     \n\t&quot; /* write answer out */
++    /* Increment pointers */
++    &quot;  add         $16, %2           \n\t&quot;
++    &quot;  add         %3, %0           \n\t&quot;
++    &quot;  add         %4, %1           \n\t&quot;
++    &quot;.endr                          \n\t&quot;
++
++     : &quot;+r&quot; (FiltPtr),
++       &quot;+r&quot; (ReconPtr),
++       &quot;+r&quot; (DctInputPtr)
++     : &quot;m&quot; (PixelsPerLine),
++       &quot;m&quot; (ReconPixelsPerLine) 
++     : &quot;memory&quot;
++  );
++}
++
++static void sub8x8_128__mmx (unsigned char *FiltPtr, ogg_int16_t *DctInputPtr,
++                      ogg_uint32_t PixelsPerLine) 
++{
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 
++    &quot;  movq      &quot;M(V128w)&quot;, %%mm1  \n\t&quot;
++
++    &quot;.rept 8                        \n\t&quot;
++    &quot;  movq        (%0), %%mm0      \n\t&quot; /* mm0 = FiltPtr */
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot; /* dup to prepare for up conversion */
++    /* convert from UINT8 to INT16 */
++    &quot;  punpcklbw   %%mm7, %%mm0     \n\t&quot; /* mm0 = INT16(FiltPtr) */
++    &quot;  punpckhbw   %%mm7, %%mm2     \n\t&quot; /* mm2 = INT16(FiltPtr) */
++    /* start calculation */
++    &quot;  psubw       %%mm1, %%mm0     \n\t&quot; /* mm0 = FiltPtr - 128 */
++    &quot;  psubw       %%mm1, %%mm2     \n\t&quot; /* mm2 = FiltPtr - 128 */
++    &quot;  movq        %%mm0,  (%1)     \n\t&quot; /* write answer out */
++    &quot;  movq        %%mm2, 8(%1)     \n\t&quot; /* write answer out */
++    /* Increment pointers */
++    &quot;  add         $16, %1           \n\t&quot;
++    &quot;  add         %2, %0           \n\t&quot;
++    &quot;.endr                          \n\t&quot;
++
++     : &quot;+r&quot; (FiltPtr),
++       &quot;+r&quot; (DctInputPtr)
++     : &quot;r&quot; (PixelsPerLine)
++     : &quot;memory&quot;
++  );
++}
++
++static void sub8x8avg2__mmx (unsigned char *FiltPtr, unsigned char *ReconPtr1,
++                     unsigned char *ReconPtr2, ogg_int16_t *DctInputPtr,
++                     ogg_uint32_t PixelsPerLine,
++                     ogg_uint32_t ReconPixelsPerLine) 
++{
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 
++
++    &quot;.rept 8                        \n\t&quot;
++    &quot;  movq        (%0), %%mm0      \n\t&quot; /* mm0 = FiltPtr */
++    &quot;  movq        (%1), %%mm1      \n\t&quot; /* mm1 = ReconPtr1 */
++    &quot;  movq        (%2), %%mm4      \n\t&quot; /* mm1 = ReconPtr2 */
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot; /* dup to prepare for up conversion */
++    &quot;  movq        %%mm1, %%mm3     \n\t&quot; /* dup to prepare for up conversion */
++    &quot;  movq        %%mm4, %%mm5     \n\t&quot; /* dup to prepare for up conversion */
++    /* convert from UINT8 to INT16 */
++    &quot;  punpcklbw   %%mm7, %%mm0     \n\t&quot; /* mm0 = INT16(FiltPtr) */
++    &quot;  punpcklbw   %%mm7, %%mm1     \n\t&quot; /* mm1 = INT16(ReconPtr1) */
++    &quot;  punpcklbw   %%mm7, %%mm4     \n\t&quot; /* mm1 = INT16(ReconPtr2) */
++    &quot;  punpckhbw   %%mm7, %%mm2     \n\t&quot; /* mm2 = INT16(FiltPtr) */
++    &quot;  punpckhbw   %%mm7, %%mm3     \n\t&quot; /* mm3 = INT16(ReconPtr1) */
++    &quot;  punpckhbw   %%mm7, %%mm5     \n\t&quot; /* mm3 = INT16(ReconPtr2) */
++    /* average ReconPtr1 and ReconPtr2 */
++    &quot;  paddw       %%mm4, %%mm1     \n\t&quot; /* mm1 = ReconPtr1 + ReconPtr2 */
++    &quot;  paddw       %%mm5, %%mm3     \n\t&quot; /* mm3 = ReconPtr1 + ReconPtr2 */
++    &quot;  psrlw       $1, %%mm1        \n\t&quot; /* mm1 = (ReconPtr1 + ReconPtr2) / 2 */
++    &quot;  psrlw       $1, %%mm3        \n\t&quot; /* mm3 = (ReconPtr1 + ReconPtr2) / 2 */
++    &quot;  psubw       %%mm1, %%mm0     \n\t&quot; /* mm0 = FiltPtr - ((ReconPtr1 + ReconPtr2) / 2) */
++    &quot;  psubw       %%mm3, %%mm2     \n\t&quot; /* mm2 = FiltPtr - ((ReconPtr1 + ReconPtr2) / 2) */
++    &quot;  movq        %%mm0,  (%3)     \n\t&quot; /* write answer out */
++    &quot;  movq        %%mm2, 8(%3)     \n\t&quot; /* write answer out */
++    /* Increment pointers */
++    &quot;  add         $16, %3           \n\t&quot;
++    &quot;  add         %4, %0           \n\t&quot;
++    &quot;  add         %5, %1           \n\t&quot;
++    &quot;  add         %5, %2           \n\t&quot;
++    &quot;.endr                          \n\t&quot;
++
++     : &quot;+r&quot; (FiltPtr),
++       &quot;+r&quot; (ReconPtr1),
++       &quot;+r&quot; (ReconPtr2),
++       &quot;+r&quot; (DctInputPtr)
++     : &quot;m&quot; (PixelsPerLine),
++       &quot;m&quot; (ReconPixelsPerLine) 
++     : &quot;memory&quot;
++  );
++}
++
++static ogg_uint32_t row_sad8__mmx (unsigned char *Src1, unsigned char *Src2)
++{
++  ogg_uint32_t MaxSad;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;	/* zero out mm6 for unpack */
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 	/* zero out mm7 for unpack */
++    &quot;  movq        (%1), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        (%2), %%mm1      \n\t&quot;
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  psubusb     %%mm1, %%mm0     \n\t&quot; 	/* A - B */
++    &quot;  psubusb     %%mm2, %%mm1     \n\t&quot;	/* B - A */
++    &quot;  por         %%mm1, %%mm0     \n\t&quot;      	/* and or gives abs difference */
++
++    &quot;  movq        %%mm0, %%mm1     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm6, %%mm0     \n\t&quot;       /* ; unpack low four bytes to higher precision */
++    &quot;  punpckhbw   %%mm7, %%mm1     \n\t&quot;       /* ; unpack high four bytes to higher precision */
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  movq        %%mm1, %%mm3     \n\t&quot;
++    &quot;  psrlq       $32, %%mm2       \n\t&quot;	/* fold and add */
++    &quot;  psrlq       $32, %%mm3       \n\t&quot;
++    &quot;  paddw       %%mm2, %%mm0     \n\t&quot;
++    &quot;  paddw       %%mm3, %%mm1     \n\t&quot;
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  movq        %%mm1, %%mm3     \n\t&quot;
++    &quot;  psrlq       $16, %%mm2       \n\t&quot;
++    &quot;  psrlq       $16, %%mm3       \n\t&quot;
++    &quot;  paddw       %%mm2, %%mm0     \n\t&quot;
++    &quot;  paddw       %%mm3, %%mm1     \n\t&quot;
++
++    &quot;  psubusw     %%mm0, %%mm1     \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm1     \n\t&quot; 	/* mm1 = max(mm1, mm0) */
++    &quot;  movd        %%mm1, %0        \n\t&quot;
++    &quot;  andl        $0xffff, %0      \n\t&quot;
++
++     : &quot;=m&quot; (MaxSad),
++       &quot;+r&quot; (Src1), 
++       &quot;+r&quot; (Src2) 
++     :
++     : &quot;memory&quot;
++  );
++  return MaxSad;
++}
++
++static ogg_uint32_t col_sad8x8__mmx (unsigned char *Src1, unsigned char *Src2,
++		                    ogg_uint32_t stride)
++{
++  ogg_uint32_t MaxSad;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm3, %%mm3     \n\t&quot;	/* zero out mm3 for unpack */
++    &quot;  pxor        %%mm4, %%mm4     \n\t&quot;	/* mm4 low sum */
++    &quot;  pxor        %%mm5, %%mm5     \n\t&quot; 	/* mm5 high sum */
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;	/* mm6 low sum */
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 	/* mm7 high sum */
++    &quot;  mov         $4, %%edi        \n\t&quot;	/* 4 rows */
++    &quot;1:                             \n\t&quot;
++    &quot;  movq        (%1), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        (%2), %%mm1      \n\t&quot;	/* take 8 bytes */
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  psubusb     %%mm1, %%mm0     \n\t&quot; 	/* A - B */
++    &quot;  psubusb     %%mm2, %%mm1     \n\t&quot;	/* B - A */
++    &quot;  por         %%mm1, %%mm0     \n\t&quot;      	/* and or gives abs difference */
++    &quot;  movq        %%mm0, %%mm1     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm3, %%mm0     \n\t&quot;	/* unpack to higher precision for accumulation */
++    &quot;  paddw       %%mm0, %%mm4     \n\t&quot;	/* accumulate difference... */
++    &quot;  punpckhbw   %%mm3, %%mm1     \n\t&quot;	/* unpack high four bytes to higher precision */
++    &quot;  paddw       %%mm1, %%mm5     \n\t&quot;	/* accumulate difference... */
++    &quot;  add         %3, %1           \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  add         %3, %2           \n\t&quot;	/* Inc pointer into the new data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 1b                       \n\t&quot;
++
++    &quot;  mov         $4, %%edi        \n\t&quot;	/* 4 rows */
++    &quot;2:                             \n\t&quot;
++    &quot;  movq        (%1), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        (%2), %%mm1      \n\t&quot;	/* take 8 bytes */
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  psubusb     %%mm1, %%mm0     \n\t&quot; 	/* A - B */
++    &quot;  psubusb     %%mm2, %%mm1     \n\t&quot;	/* B - A */
++    &quot;  por         %%mm1, %%mm0     \n\t&quot;      	/* and or gives abs difference */
++    &quot;  movq        %%mm0, %%mm1     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm3, %%mm0     \n\t&quot;	/* unpack to higher precision for accumulation */
++    &quot;  paddw       %%mm0, %%mm6     \n\t&quot;	/* accumulate difference... */
++    &quot;  punpckhbw   %%mm3, %%mm1     \n\t&quot;	/* unpack high four bytes to higher precision */
++    &quot;  paddw       %%mm1, %%mm7     \n\t&quot;	/* accumulate difference... */
++    &quot;  add         %3, %1           \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  add         %3, %2           \n\t&quot;	/* Inc pointer into the new data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 2b                       \n\t&quot;
++
++    &quot;  psubusw     %%mm6, %%mm7     \n\t&quot;
++    &quot;  paddw       %%mm6, %%mm7     \n\t&quot; 	/* mm7 = max(mm7, mm6) */
++    &quot;  psubusw     %%mm4, %%mm5     \n\t&quot; 	
++    &quot;  paddw       %%mm4, %%mm5     \n\t&quot; 	/* mm5 = max(mm5, mm4) */
++    &quot;  psubusw     %%mm5, %%mm7     \n\t&quot; 	
++    &quot;  paddw       %%mm5, %%mm7     \n\t&quot; 	/* mm7 = max(mm5, mm7) */
++    &quot;  movq        %%mm7, %%mm6     \n\t&quot;
++    &quot;  psrlq       $32, %%mm6       \n\t&quot;
++    &quot;  psubusw     %%mm6, %%mm7     \n\t&quot; 	
++    &quot;  paddw       %%mm6, %%mm7     \n\t&quot; 	/* mm7 = max(mm5, mm7) */
++    &quot;  movq        %%mm7, %%mm6     \n\t&quot;
++    &quot;  psrlq       $16, %%mm6       \n\t&quot;
++    &quot;  psubusw     %%mm6, %%mm7     \n\t&quot; 	
++    &quot;  paddw       %%mm6, %%mm7     \n\t&quot; 	/* mm7 = max(mm5, mm7) */
++    &quot;  movd        %%mm7, %0        \n\t&quot;
++    &quot;  andl        $0xffff, %0      \n\t&quot;
++
++     : &quot;=r&quot; (MaxSad),
++       &quot;+r&quot; (Src1), 
++       &quot;+r&quot; (Src2) 
++     : &quot;r&quot; (stride)
++     : &quot;memory&quot;, &quot;edi&quot;
++  );
++
++  return MaxSad;
++}
++
++static ogg_uint32_t sad8x8__mmx (unsigned char *ptr1, ogg_uint32_t stride1,
++		       	    unsigned char *ptr2, ogg_uint32_t stride2)
++{
++  ogg_uint32_t  DiffVal;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;	/* zero out mm6 for unpack */
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 	/* mm7 contains the result */
++    &quot;.rept 8                         \n\t&quot;
++    &quot;  movq        (%1), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        (%2), %%mm1      \n\t&quot;
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++
++    &quot;  psubusb     %%mm1, %%mm0     \n\t&quot; 	/* A - B */
++    &quot;  psubusb     %%mm2, %%mm1     \n\t&quot;	/* B - A */
++    &quot;  por         %%mm1, %%mm0     \n\t&quot;      	/* and or gives abs difference */
++    &quot;  movq        %%mm0, %%mm1     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm6, %%mm0     \n\t&quot;	/* unpack to higher precision for accumulation */
++    &quot;  paddw       %%mm0, %%mm7     \n\t&quot;	/* accumulate difference... */
++    &quot;  punpckhbw   %%mm6, %%mm1     \n\t&quot;	/* unpack high four bytes to higher precision */
++    &quot;  add         %3, %1           \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  paddw       %%mm1, %%mm7     \n\t&quot;	/* accumulate difference... */
++    &quot;  add         %4, %2           \n\t&quot;	/* Inc pointer into ref data */
++    &quot;.endr                          \n\t&quot;
++
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm7       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $16, %%mm7       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movd        %%mm7, %0        \n\t&quot;
++    &quot;  andl        $0xffff, %0      \n\t&quot;
++
++     : &quot;=m&quot; (DiffVal),
++       &quot;+r&quot; (ptr1), 
++       &quot;+r&quot; (ptr2) 
++     : &quot;r&quot; (stride1),
++       &quot;r&quot; (stride2)
++     : &quot;memory&quot;
++  );
++
++  return DiffVal;
++}
++
++static ogg_uint32_t sad8x8_thres__mmx (unsigned char *ptr1, ogg_uint32_t stride1,
++		       		  unsigned char *ptr2, ogg_uint32_t stride2, 
++			   	  ogg_uint32_t thres)
++{
++  return sad8x8__mmx (ptr1, stride1, ptr2, stride2);
++}
++
++static ogg_uint32_t sad8x8_xy2_thres__mmx (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                      unsigned char *RefDataPtr1,
++			              unsigned char *RefDataPtr2, ogg_uint32_t RefStride,
++			              ogg_uint32_t thres)
++{
++  ogg_uint32_t  DiffVal;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pcmpeqd     %%mm5, %%mm5     \n\t&quot;	/* fefefefefefefefe in mm5 */
++    &quot;  paddb       %%mm5, %%mm5     \n\t&quot;
++   
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;	/* zero out mm6 for unpack */
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 	/* mm7 contains the result */
++    &quot;  mov         $8, %%edi        \n\t&quot;	/* 8 rows */
++    &quot;1:                             \n\t&quot;
++    &quot;  movq        (%1), %%mm0      \n\t&quot;	/* take 8 bytes */
++
++    &quot;  movq        (%2), %%mm2      \n\t&quot;
++    &quot;  movq        (%3), %%mm3      \n\t&quot;	/* take average of mm2 and mm3 */
++    &quot;  movq        %%mm2, %%mm1     \n\t&quot;
++    &quot;  pand        %%mm3, %%mm1     \n\t&quot;
++    &quot;  pxor        %%mm2, %%mm3     \n\t&quot;
++    &quot;  pand        %%mm5, %%mm3     \n\t&quot;
++    &quot;  psrlq       $1, %%mm3        \n\t&quot;
++    &quot;  paddb       %%mm3, %%mm1     \n\t&quot;
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++
++    &quot;  psubusb     %%mm1, %%mm0     \n\t&quot; 	/* A - B */
++    &quot;  psubusb     %%mm2, %%mm1     \n\t&quot;	/* B - A */
++    &quot;  por         %%mm1, %%mm0     \n\t&quot;    	/* and or gives abs difference */
++    &quot;  movq        %%mm0, %%mm1     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm6, %%mm0     \n\t&quot;	/* unpack to higher precision for accumulation */
++    &quot;  paddw       %%mm0, %%mm7     \n\t&quot;	/* accumulate difference... */
++    &quot;  punpckhbw   %%mm6, %%mm1     \n\t&quot;	/* unpack high four bytes to higher precision */
++    &quot;  add         %4, %1           \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  paddw       %%mm1, %%mm7     \n\t&quot;	/* accumulate difference... */
++    &quot;  add         %5, %2           \n\t&quot;	/* Inc pointer into ref data */
++    &quot;  add         %5, %3           \n\t&quot;	/* Inc pointer into ref data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 1b                       \n\t&quot;
++
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm7       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $16, %%mm7       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movd        %%mm7, %0        \n\t&quot;
++    &quot;  andl        $0xffff, %0      \n\t&quot;
++
++     : &quot;=m&quot; (DiffVal),
++       &quot;+r&quot; (SrcData), 
++       &quot;+r&quot; (RefDataPtr1), 
++       &quot;+r&quot; (RefDataPtr2) 
++     : &quot;m&quot; (SrcStride),
++       &quot;m&quot; (RefStride)
++     : &quot;edi&quot;, &quot;memory&quot;
++  );
++
++  return DiffVal;
++}
++
++static ogg_uint32_t intra8x8_err__mmx (unsigned char *DataPtr, ogg_uint32_t Stride)
++{
++  ogg_uint32_t  XSum;
++  ogg_uint32_t  XXSum;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm5, %%mm5     \n\t&quot;
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot;
++    &quot;  mov         $8, %%edi        \n\t&quot;
++    &quot;1:                             \n\t&quot;
++    &quot;  movq        (%2), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm6, %%mm0     \n\t&quot;
++    &quot;  punpckhbw   %%mm6, %%mm2     \n\t&quot;
++
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  paddw       %%mm2, %%mm5     \n\t&quot;
++
++    &quot;  pmaddwd     %%mm0, %%mm0     \n\t&quot;
++    &quot;  pmaddwd     %%mm2, %%mm2     \n\t&quot;
++    
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  paddd       %%mm2, %%mm7     \n\t&quot;
++
++    &quot;  add         %3, %2           \n\t&quot;	/* Inc pointer into src data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 1b                       \n\t&quot;
++
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $16, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movd        %%mm5, %%edi     \n\t&quot;
++    &quot;  movsx       %%di, %%edi      \n\t&quot;
++    &quot;  movl        %%edi, %0        \n\t&quot;
++
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm7       \n\t&quot;
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movd        %%mm7, %1        \n\t&quot;
++
++     : &quot;=r&quot; (XSum),
++       &quot;=r&quot; (XXSum),
++       &quot;+r&quot; (DataPtr) 
++     : &quot;r&quot; (Stride)
++     : &quot;edi&quot;, &quot;memory&quot;
++  );
++
++  /* Compute population variance as mis-match metric. */
++  return (( (XXSum&lt;&lt;6) - XSum*XSum ) );
++}
++
++static ogg_uint32_t inter8x8_err__mmx (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                 unsigned char *RefDataPtr, ogg_uint32_t RefStride)
++{
++  ogg_uint32_t  XSum;
++  ogg_uint32_t  XXSum;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm5, %%mm5     \n\t&quot;
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot;
++    &quot;  mov         $8, %%edi        \n\t&quot;
++    &quot;1:                             \n\t&quot;
++    &quot;  movq        (%2), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        (%3), %%mm1      \n\t&quot;
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  movq        %%mm1, %%mm3     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm6, %%mm0     \n\t&quot;
++    &quot;  punpcklbw   %%mm6, %%mm1     \n\t&quot;
++    &quot;  punpckhbw   %%mm6, %%mm2     \n\t&quot;
++    &quot;  punpckhbw   %%mm6, %%mm3     \n\t&quot;
++
++    &quot;  psubsw      %%mm1, %%mm0     \n\t&quot;
++    &quot;  psubsw      %%mm3, %%mm2     \n\t&quot;
++
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  paddw       %%mm2, %%mm5     \n\t&quot;
++
++    &quot;  pmaddwd     %%mm0, %%mm0     \n\t&quot;
++    &quot;  pmaddwd     %%mm2, %%mm2     \n\t&quot;
++    
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  paddd       %%mm2, %%mm7     \n\t&quot;
++
++    &quot;  add         %4, %2           \n\t&quot;	/* Inc pointer into src data */
++    &quot;  add         %5, %3           \n\t&quot;	/* Inc pointer into ref data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 1b                       \n\t&quot;
++
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $16, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movd        %%mm5, %%edi     \n\t&quot;
++    &quot;  movsx       %%di, %%edi      \n\t&quot;
++    &quot;  movl        %%edi, %0        \n\t&quot;
++
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm7       \n\t&quot;
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movd        %%mm7, %1        \n\t&quot;
++
++     : &quot;=m&quot; (XSum),
++       &quot;=m&quot; (XXSum),
++       &quot;+r&quot; (SrcData), 
++       &quot;+r&quot; (RefDataPtr) 
++     : &quot;m&quot; (SrcStride),
++       &quot;m&quot; (RefStride)
++     : &quot;edi&quot;, &quot;memory&quot;
++  );
++
++  /* Compute and return population variance as mis-match metric. */
++  return (( (XXSum&lt;&lt;6) - XSum*XSum ));
++}
++
++static ogg_uint32_t inter8x8_err_xy2__mmx (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                     unsigned char *RefDataPtr1,
++				     unsigned char *RefDataPtr2, ogg_uint32_t RefStride)
++{
++  ogg_uint32_t XSum;
++  ogg_uint32_t XXSum;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pcmpeqd     %%mm4, %%mm4     \n\t&quot;	/* fefefefefefefefe in mm4 */
++    &quot;  paddb       %%mm4, %%mm4     \n\t&quot;
++    &quot;  pxor        %%mm5, %%mm5     \n\t&quot;
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot;
++    &quot;  mov         $8, %%edi        \n\t&quot;
++    &quot;1:                             \n\t&quot;
++    &quot;  movq        (%2), %%mm0      \n\t&quot;	/* take 8 bytes */
++
++    &quot;  movq        (%3), %%mm2      \n\t&quot;
++    &quot;  movq        (%4), %%mm3      \n\t&quot;	/* take average of mm2 and mm3 */
++    &quot;  movq        %%mm2, %%mm1     \n\t&quot;
++    &quot;  pand        %%mm3, %%mm1     \n\t&quot;
++    &quot;  pxor        %%mm2, %%mm3     \n\t&quot;
++    &quot;  pand        %%mm4, %%mm3     \n\t&quot;
++    &quot;  psrlq       $1, %%mm3        \n\t&quot;
++    &quot;  paddb       %%mm3, %%mm1     \n\t&quot;
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  movq        %%mm1, %%mm3     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm6, %%mm0     \n\t&quot;
++    &quot;  punpcklbw   %%mm6, %%mm1     \n\t&quot;
++    &quot;  punpckhbw   %%mm6, %%mm2     \n\t&quot;
++    &quot;  punpckhbw   %%mm6, %%mm3     \n\t&quot;
++
++    &quot;  psubsw      %%mm1, %%mm0     \n\t&quot;
++    &quot;  psubsw      %%mm3, %%mm2     \n\t&quot;
++
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  paddw       %%mm2, %%mm5     \n\t&quot;
++
++    &quot;  pmaddwd     %%mm0, %%mm0     \n\t&quot;
++    &quot;  pmaddwd     %%mm2, %%mm2     \n\t&quot;
++    
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  paddd       %%mm2, %%mm7     \n\t&quot;
++
++    &quot;  add         %5, %2           \n\t&quot;	/* Inc pointer into src data */
++    &quot;  add         %6, %3           \n\t&quot;	/* Inc pointer into ref data */
++    &quot;  add         %6, %4           \n\t&quot;	/* Inc pointer into ref data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 1b                       \n\t&quot;
++
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $16, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movd        %%mm5, %%edi     \n\t&quot;
++    &quot;  movsx       %%di, %%edi      \n\t&quot;
++    &quot;  movl        %%edi, %0        \n\t&quot;
++
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm7       \n\t&quot;
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movd        %%mm7, %1        \n\t&quot;
++
++     : &quot;=m&quot; (XSum),
++       &quot;=m&quot; (XXSum),
++       &quot;+r&quot; (SrcData), 
++       &quot;+r&quot; (RefDataPtr1),
++       &quot;+r&quot; (RefDataPtr2) 
++     : &quot;m&quot; (SrcStride),
++       &quot;m&quot; (RefStride)
++     : &quot;edi&quot;, &quot;memory&quot;
++  );
++
++  /* Compute and return population variance as mis-match metric. */
++  return (( (XXSum&lt;&lt;6) - XSum*XSum ));
++}
++
++static void restore_fpu (void)
++{
++  __asm__ __volatile__ (
++    &quot;  emms                         \n\t&quot;
++  );
++}
++
++void dsp_i386_mmx_init(DspFunctions *funcs)
++{
++  funcs-&gt;restore_fpu = restore_fpu;
++  funcs-&gt;sub8x8 = sub8x8__mmx;
++  funcs-&gt;sub8x8_128 = sub8x8_128__mmx;
++  funcs-&gt;sub8x8avg2 = sub8x8avg2__mmx;
++  funcs-&gt;row_sad8 = row_sad8__mmx;
++  funcs-&gt;col_sad8x8 = col_sad8x8__mmx;
++  funcs-&gt;sad8x8 = sad8x8__mmx;
++  funcs-&gt;sad8x8_thres = sad8x8_thres__mmx;
++  funcs-&gt;sad8x8_xy2_thres = sad8x8_xy2_thres__mmx;
++  funcs-&gt;intra8x8_err = intra8x8_err__mmx;
++  funcs-&gt;inter8x8_err = inter8x8_err__mmx;
++  funcs-&gt;inter8x8_err_xy2 = inter8x8_err_xy2__mmx;
++}
++
+diff -Naur libtheora-1.0alpha3/lib/i386/dsp_mmxext.c libtheora-1.0alpha3.mmx/lib/i386/dsp_mmxext.c
+--- libtheora-1.0alpha3/lib/i386/dsp_mmxext.c	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/i386/dsp_mmxext.c	2004-10-06 17:48:22.474391768 +0200
+@@ -0,0 +1,316 @@
++/********************************************************************
++ *                                                                  *
++ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
++ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
++ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
++ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
++ *                                                                  *
++ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2003                *
++ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
++ *                                                                  *
++ ********************************************************************
++
++  function:
++  last mod: $Id: mcomp.c,v 1.8 2003/12/03 08:59:41 arc Exp $
++
++ ********************************************************************/
++
++#include &lt;stdlib.h&gt;
++#include &quot;dsp.h&quot;
++
++static ogg_uint32_t sad8x8__mmxext (unsigned char *ptr1, ogg_uint32_t stride1,
++		       	    unsigned char *ptr2, ogg_uint32_t stride2)
++{
++  ogg_uint32_t  DiffVal;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++    &quot;  pxor %%mm7, %%mm7            \n\t&quot; 	/* mm7 contains the result */
++
++    &quot;.rept 7                        \n\t&quot;
++    &quot;  movq (%1), %%mm0             \n\t&quot;	/* take 8 bytes */
++    &quot;  movq (%2), %%mm1             \n\t&quot;
++    &quot;  psadbw %%mm1, %%mm0          \n\t&quot;
++    &quot;  add %3, %1                   \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  paddw %%mm0, %%mm7           \n\t&quot;	/* accumulate difference... */
++    &quot;  add %4, %2                   \n\t&quot;	/* Inc pointer into ref data */
++    &quot;.endr                          \n\t&quot;
++
++    &quot;  movq (%1), %%mm0             \n\t&quot;	/* take 8 bytes */
++    &quot;  movq (%2), %%mm1             \n\t&quot;
++    &quot;  psadbw %%mm1, %%mm0          \n\t&quot;
++    &quot;  paddw %%mm0, %%mm7           \n\t&quot;	/* accumulate difference... */
++    &quot;  movd %%mm7, %0               \n\t&quot;
++
++     : &quot;=r&quot; (DiffVal),
++       &quot;+r&quot; (ptr1), 
++       &quot;+r&quot; (ptr2) 
++     : &quot;r&quot; (stride1),
++       &quot;r&quot; (stride2)
++     : &quot;memory&quot;
++  );
++
++  return DiffVal;
++}
++
++static ogg_uint32_t sad8x8_thres__mmxext (unsigned char *ptr1, ogg_uint32_t stride1,
++		       		  unsigned char *ptr2, ogg_uint32_t stride2, 
++			   	  ogg_uint32_t thres)
++{
++  ogg_uint32_t  DiffVal;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++    &quot;  pxor %%mm7, %%mm7            \n\t&quot; 	/* mm7 contains the result */
++
++    &quot;.rept 8                        \n\t&quot;
++    &quot;  movq (%1), %%mm0             \n\t&quot;	/* take 8 bytes */
++    &quot;  movq (%2), %%mm1             \n\t&quot;
++    &quot;  psadbw %%mm1, %%mm0          \n\t&quot;
++    &quot;  add %3, %1                   \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  paddw %%mm0, %%mm7           \n\t&quot;	/* accumulate difference... */
++    &quot;  add %4, %2                   \n\t&quot;	/* Inc pointer into ref data */
++    &quot;.endr                          \n\t&quot;
++
++    &quot;  movd %%mm7, %0               \n\t&quot;
++
++     : &quot;=r&quot; (DiffVal),
++       &quot;+r&quot; (ptr1), 
++       &quot;+r&quot; (ptr2) 
++     : &quot;r&quot; (stride1),
++       &quot;r&quot; (stride2)
++     : &quot;memory&quot;
++  );
++
++  return DiffVal;
++}
++
++static ogg_uint32_t sad8x8_xy2_thres__mmxext (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                      unsigned char *RefDataPtr1,
++			              unsigned char *RefDataPtr2, ogg_uint32_t RefStride,
++			              ogg_uint32_t thres)
++{
++  ogg_uint32_t  DiffVal;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++    &quot;  pxor %%mm7, %%mm7            \n\t&quot; 	/* mm7 contains the result */
++    &quot;.rept 8                        \n\t&quot;
++    &quot;  movq (%1), %%mm0             \n\t&quot;	/* take 8 bytes */
++    &quot;  movq (%2), %%mm1             \n\t&quot;
++    &quot;  movq (%3), %%mm2             \n\t&quot;
++    &quot;  pavgb %%mm2, %%mm1           \n\t&quot;
++    &quot;  psadbw %%mm1, %%mm0          \n\t&quot;
++
++    &quot;  add %4, %1                   \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  paddw %%mm0, %%mm7           \n\t&quot;	/* accumulate difference... */
++    &quot;  add %5, %2                   \n\t&quot;	/* Inc pointer into ref data */
++    &quot;  add %5, %3                   \n\t&quot;	/* Inc pointer into ref data */
++    &quot;.endr                          \n\t&quot;
++
++    &quot;  movd %%mm7, %0               \n\t&quot;
++     : &quot;=m&quot; (DiffVal),
++       &quot;+r&quot; (SrcData), 
++       &quot;+r&quot; (RefDataPtr1), 
++       &quot;+r&quot; (RefDataPtr2) 
++     : &quot;m&quot; (SrcStride),
++       &quot;m&quot; (RefStride)
++     : &quot;memory&quot;
++  );
++
++  return DiffVal;
++}
++		
++static ogg_uint32_t row_sad8__mmxext (unsigned char *Src1, unsigned char *Src2)
++{
++  ogg_uint32_t MaxSad;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  movd        (%1), %%mm0      \n\t&quot;
++    &quot;  movd        (%2), %%mm1      \n\t&quot;
++    &quot;  psadbw      %%mm0, %%mm1     \n\t&quot;
++    &quot;  movd        4(%1), %%mm2     \n\t&quot;
++    &quot;  movd        4(%2), %%mm3     \n\t&quot;
++    &quot;  psadbw      %%mm2, %%mm3     \n\t&quot;
++
++    &quot;  pmaxsw      %%mm1, %%mm3     \n\t&quot;
++    &quot;  movd        %%mm3, %0        \n\t&quot;
++    &quot;  andl        $0xffff, %0      \n\t&quot;
++
++     : &quot;=m&quot; (MaxSad),
++       &quot;+r&quot; (Src1), 
++       &quot;+r&quot; (Src2) 
++     :
++     : &quot;memory&quot;
++  );
++
++  return MaxSad;
++}
++
++static ogg_uint32_t col_sad8x8__mmxext (unsigned char *Src1, unsigned char *Src2,
++		                    ogg_uint32_t stride)
++{
++  ogg_uint32_t MaxSad;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm3, %%mm3     \n\t&quot;	/* zero out mm3 for unpack */
++    &quot;  pxor        %%mm4, %%mm4     \n\t&quot;	/* mm4 low sum */
++    &quot;  pxor        %%mm5, %%mm5     \n\t&quot; 	/* mm5 high sum */
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;	/* mm6 low sum */
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot; 	/* mm7 high sum */
++    &quot;  mov         $4, %%edi        \n\t&quot;	/* 4 rows */
++    &quot;1:                             \n\t&quot;
++    &quot;  movq        (%1), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        (%2), %%mm1      \n\t&quot;	/* take 8 bytes */
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  psubusb     %%mm1, %%mm0     \n\t&quot; 	/* A - B */
++    &quot;  psubusb     %%mm2, %%mm1     \n\t&quot;	/* B - A */
++    &quot;  por         %%mm1, %%mm0     \n\t&quot;      	/* and or gives abs difference */
++    &quot;  movq        %%mm0, %%mm1     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm3, %%mm0     \n\t&quot;	/* unpack to higher precision for accumulation */
++    &quot;  paddw       %%mm0, %%mm4     \n\t&quot;	/* accumulate difference... */
++    &quot;  punpckhbw   %%mm3, %%mm1     \n\t&quot;	/* unpack high four bytes to higher precision */
++    &quot;  paddw       %%mm1, %%mm5     \n\t&quot;	/* accumulate difference... */
++    &quot;  add         %3, %1           \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  add         %3, %2           \n\t&quot;	/* Inc pointer into the new data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 1b                       \n\t&quot;
++
++    &quot;  mov         $4, %%edi        \n\t&quot;	/* 4 rows */
++    &quot;2:                             \n\t&quot;
++    &quot;  movq        (%1), %%mm0      \n\t&quot;	/* take 8 bytes */
++    &quot;  movq        (%2), %%mm1      \n\t&quot;	/* take 8 bytes */
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  psubusb     %%mm1, %%mm0     \n\t&quot; 	/* A - B */
++    &quot;  psubusb     %%mm2, %%mm1     \n\t&quot;	/* B - A */
++    &quot;  por         %%mm1, %%mm0     \n\t&quot;      	/* and or gives abs difference */
++    &quot;  movq        %%mm0, %%mm1     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm3, %%mm0     \n\t&quot;	/* unpack to higher precision for accumulation */
++    &quot;  paddw       %%mm0, %%mm6     \n\t&quot;	/* accumulate difference... */
++    &quot;  punpckhbw   %%mm3, %%mm1     \n\t&quot;	/* unpack high four bytes to higher precision */
++    &quot;  paddw       %%mm1, %%mm7     \n\t&quot;	/* accumulate difference... */
++    &quot;  add         %3, %1           \n\t&quot;	/* Inc pointer into the new data */
++    &quot;  add         %3, %2           \n\t&quot;	/* Inc pointer into the new data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 2b                       \n\t&quot;
++
++    &quot;  pmaxsw      %%mm6, %%mm7     \n\t&quot;
++    &quot;  pmaxsw      %%mm4, %%mm5     \n\t&quot;
++    &quot;  pmaxsw      %%mm5, %%mm7     \n\t&quot;
++    &quot;  movq        %%mm7, %%mm6     \n\t&quot;
++    &quot;  psrlq       $32, %%mm6       \n\t&quot;
++    &quot;  pmaxsw      %%mm6, %%mm7     \n\t&quot;
++    &quot;  movq        %%mm7, %%mm6     \n\t&quot;
++    &quot;  psrlq       $16, %%mm6       \n\t&quot;
++    &quot;  pmaxsw      %%mm6, %%mm7     \n\t&quot;
++    &quot;  movd        %%mm7, %0        \n\t&quot;
++    &quot;  andl        $0xffff, %0      \n\t&quot;
++
++     : &quot;=r&quot; (MaxSad),
++       &quot;+r&quot; (Src1), 
++       &quot;+r&quot; (Src2) 
++     : &quot;r&quot; (stride)
++     : &quot;memory&quot;, &quot;edi&quot;
++  );
++
++  return MaxSad;
++}
++
++static ogg_uint32_t inter8x8_err_xy2__mmxext (unsigned char *SrcData, ogg_uint32_t SrcStride,
++		                     unsigned char *RefDataPtr1,
++				     unsigned char *RefDataPtr2, ogg_uint32_t RefStride)
++{
++  ogg_uint32_t XSum;
++  ogg_uint32_t XXSum;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++
++    &quot;  pxor        %%mm4, %%mm4     \n\t&quot;
++    &quot;  pxor        %%mm5, %%mm5     \n\t&quot;
++    &quot;  pxor        %%mm6, %%mm6     \n\t&quot;
++    &quot;  pxor        %%mm7, %%mm7     \n\t&quot;
++    &quot;  mov         $8, %%edi        \n\t&quot;
++    &quot;1:                             \n\t&quot;
++    &quot;  movq        (%2), %%mm0      \n\t&quot;	/* take 8 bytes */
++
++    &quot;  movq        (%3), %%mm2      \n\t&quot;
++    &quot;  movq        (%4), %%mm1      \n\t&quot;	/* take average of mm2 and mm1 */
++    &quot;  pavgb       %%mm2, %%mm1     \n\t&quot;
++
++    &quot;  movq        %%mm0, %%mm2     \n\t&quot;
++    &quot;  movq        %%mm1, %%mm3     \n\t&quot;
++
++    &quot;  punpcklbw   %%mm6, %%mm0     \n\t&quot;
++    &quot;  punpcklbw   %%mm4, %%mm1     \n\t&quot;
++    &quot;  punpckhbw   %%mm6, %%mm2     \n\t&quot;
++    &quot;  punpckhbw   %%mm4, %%mm3     \n\t&quot;
++
++    &quot;  psubsw      %%mm1, %%mm0     \n\t&quot;
++    &quot;  psubsw      %%mm3, %%mm2     \n\t&quot;
++
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  paddw       %%mm2, %%mm5     \n\t&quot;
++
++    &quot;  pmaddwd     %%mm0, %%mm0     \n\t&quot;
++    &quot;  pmaddwd     %%mm2, %%mm2     \n\t&quot;
++    
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  paddd       %%mm2, %%mm7     \n\t&quot;
++
++    &quot;  add         %5, %2           \n\t&quot;	/* Inc pointer into src data */
++    &quot;  add         %6, %3           \n\t&quot;	/* Inc pointer into ref data */
++    &quot;  add         %6, %4           \n\t&quot;	/* Inc pointer into ref data */
++
++    &quot;  dec         %%edi            \n\t&quot;
++    &quot;  jnz 1b                       \n\t&quot;
++
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movq        %%mm5, %%mm0     \n\t&quot;
++    &quot;  psrlq       $16, %%mm5       \n\t&quot;
++    &quot;  paddw       %%mm0, %%mm5     \n\t&quot;
++    &quot;  movd        %%mm5, %%edi     \n\t&quot;
++    &quot;  movsx       %%di, %%edi      \n\t&quot;
++    &quot;  movl        %%edi, %0        \n\t&quot;
++
++    &quot;  movq        %%mm7, %%mm0     \n\t&quot;
++    &quot;  psrlq       $32, %%mm7       \n\t&quot;
++    &quot;  paddd       %%mm0, %%mm7     \n\t&quot;
++    &quot;  movd        %%mm7, %1        \n\t&quot;
++
++     : &quot;=m&quot; (XSum),
++       &quot;=m&quot; (XXSum),
++       &quot;+r&quot; (SrcData), 
++       &quot;+r&quot; (RefDataPtr1),
++       &quot;+r&quot; (RefDataPtr2) 
++     : &quot;m&quot; (SrcStride),
++       &quot;m&quot; (RefStride)
++     : &quot;edi&quot;, &quot;memory&quot;
++  );
++
++  /* Compute and return population variance as mis-match metric. */
++  return (( (XXSum&lt;&lt;6) - XSum*XSum ));
++}
++
++void dsp_i386_mmxext_init(DspFunctions *funcs)
++{
++  funcs-&gt;row_sad8 = row_sad8__mmxext;
++  funcs-&gt;col_sad8x8 = col_sad8x8__mmxext;
++  funcs-&gt;sad8x8 = sad8x8__mmxext;
++  funcs-&gt;sad8x8_thres = sad8x8_thres__mmxext;
++  funcs-&gt;sad8x8_xy2_thres = sad8x8_xy2_thres__mmxext;
++  funcs-&gt;inter8x8_err_xy2 = inter8x8_err_xy2__mmxext;
++}
++
+diff -Naur libtheora-1.0alpha3/lib/i386/fdct_mmx.c libtheora-1.0alpha3.mmx/lib/i386/fdct_mmx.c
+--- libtheora-1.0alpha3/lib/i386/fdct_mmx.c	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/i386/fdct_mmx.c	2004-10-06 17:48:22.509386448 +0200
+@@ -0,0 +1,340 @@
++;//==========================================================================
++;//
++;//  THIS CODE AND INFORMATION IS PROVIDED &quot;AS IS&quot; WITHOUT WARRANTY OF ANY
++;//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
++;//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
++;//  PURPOSE.
++;//
++;//  Copyright (c) 1999 - 2001  On2 Technologies Inc. All Rights Reserved.
++;//
++;//--------------------------------------------------------------------------
++
++#include &lt;theora/theora.h&gt;
++#include &quot;dsp.h&quot;
++
++static const __attribute__ ((aligned(8),used)) ogg_int64_t xC1S7 = 0x0fb15fb15fb15fb15LL;
++static const __attribute__ ((aligned(8),used)) ogg_int64_t xC2S6 = 0x0ec83ec83ec83ec83LL;
++static const __attribute__ ((aligned(8),used)) ogg_int64_t xC3S5 = 0x0d4dbd4dbd4dbd4dbLL;
++static const __attribute__ ((aligned(8),used)) ogg_int64_t xC4S4 = 0x0b505b505b505b505LL;
++static const __attribute__ ((aligned(8),used)) ogg_int64_t xC5S3 = 0x08e3a8e3a8e3a8e3aLL;
++static const __attribute__ ((aligned(8),used)) ogg_int64_t xC6S2 = 0x061f861f861f861f8LL;
++static const __attribute__ ((aligned(8),used)) ogg_int64_t xC7S1 = 0x031f131f131f131f1LL;
++
++#if defined(__MINGW32__) || defined(__CYGWIN__) || \
++    defined(__OS2__) || (defined (__OpenBSD__) &amp;&amp; !defined(__ELF__))
++# define M(a) &quot;_&quot; #a
++#else
++# define M(a) #a
++#endif
++
++/***********************************************************************
++ *	File:			fdct_m.asm
++ *
++ *	Description:
++ *					This function perform 2-D Forward DCT on a 8x8 block
++ *					
++ *
++ *	Input:			Pointers to input source data buffer and destination 
++ *					buffer.
++ *
++ *	Note:			none
++ *
++ *	Special Notes:	We try to do the truncation right to match the result 
++ *					of the c version. 
++ *
++ ************************************************************************/
++
++/* execute stage 1 of forward DCT */
++#define Fdct_mmx(ip0,ip1,ip2,ip3,ip4,ip5,ip6,ip7,temp)                        \
++  &quot;  movq      &quot; #ip0 &quot;, %%mm0      \n\t&quot;                                     \
++  &quot;  movq      &quot; #ip1 &quot;, %%mm1      \n\t&quot;                                     \
++  &quot;  movq      &quot; #ip3 &quot;, %%mm2      \n\t&quot;                                     \
++  &quot;  movq      &quot; #ip5 &quot;, %%mm3      \n\t&quot;                                     \
++  &quot;  movq        %%mm0, %%mm4       \n\t&quot;                                     \
++  &quot;  movq        %%mm1, %%mm5       \n\t&quot;                                     \
++  &quot;  movq        %%mm2, %%mm6       \n\t&quot;                                     \
++  &quot;  movq        %%mm3, %%mm7       \n\t&quot;                                     \
++                                                                              \
++  &quot;  paddsw    &quot; #ip7 &quot;, %%mm0      \n\t&quot; /* mm0 = ip0 + ip7 = is07 */        \
++  &quot;  paddsw    &quot; #ip2 &quot;, %%mm1      \n\t&quot; /* mm1 = ip1 + ip2 = is12 */        \
++  &quot;  paddsw    &quot; #ip4 &quot;, %%mm2      \n\t&quot; /* mm2 = ip3 + ip4 = is34 */        \
++  &quot;  paddsw    &quot; #ip6 &quot;, %%mm3      \n\t&quot; /* mm3 = ip5 + ip6 = is56 */        \
++  &quot;  psubsw    &quot; #ip7 &quot;, %%mm4      \n\t&quot; /* mm4 = ip0 - ip7 = id07 */        \
++  &quot;  psubsw    &quot; #ip2 &quot;, %%mm5      \n\t&quot; /* mm5 = ip1 - ip2 = id12 */        \
++                                                                              \
++  &quot;  psubsw      %%mm2, %%mm0       \n\t&quot; /* mm0 = is07 - is34 */             \
++                                                                              \
++  &quot;  paddsw      %%mm2, %%mm2       \n\t&quot;                                     \
++                                                                              \
++  &quot;  psubsw    &quot; #ip4 &quot;, %%mm6      \n\t&quot; /* mm6 = ip3 - ip4 = id34 */        \
++                                                                              \
++  &quot;  paddsw      %%mm0, %%mm2       \n\t&quot; /* mm2 = is07 + is34 = is0734 */    \
++  &quot;  psubsw      %%mm3, %%mm1       \n\t&quot; /* mm1 = is12 - is56 */             \
++  &quot;  movq        %%mm0,&quot; #temp &quot;    \n\t&quot; /* Save is07 - is34 to free mm0; */ \
++  &quot;  paddsw      %%mm3, %%mm3       \n\t&quot;                                     \
++  &quot;  paddsw      %%mm1, %%mm3       \n\t&quot; /* mm3 = is12 + 1s56	= is1256 */   \
++                                                                              \
++  &quot;  psubsw    &quot; #ip6 &quot;, %%mm7      \n\t&quot; /* mm7 = ip5 - ip6 = id56 */        \
++  /* ------------------------------------------------------------------- */   \
++  &quot;  psubsw      %%mm7, %%mm5       \n\t&quot; /* mm5 = id12 - id56 */             \
++  &quot;  paddsw      %%mm7, %%mm7       \n\t&quot;                                     \
++  &quot;  paddsw      %%mm5, %%mm7       \n\t&quot; /* mm7 = id12 + id56 */             \
++  /* ------------------------------------------------------------------- */   \
++  &quot;  psubsw      %%mm3, %%mm2       \n\t&quot; /* mm2 = is0734 - is1256 */         \
++  &quot;  paddsw      %%mm3, %%mm3       \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq        %%mm2, %%mm0       \n\t&quot; /* make a copy */                   \
++  &quot;  paddsw      %%mm2, %%mm3       \n\t&quot; /* mm3 = is0734 + is1256 */         \
++                                                                              \
++  &quot;  pmulhw   &quot;M(xC4S4)&quot;, %%mm0     \n\t&quot; /* mm0 = xC4S4 * ( is0734 - is1256 ) - ( is0734 - is1256 ) */ \
++  &quot;  paddw       %%mm2, %%mm0       \n\t&quot; /* mm0 = xC4S4 * ( is0734 - is1256 ) */ \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++  &quot;  paddw       %%mm2, %%mm0       \n\t&quot; /* Truncate mm0, now it is op[4] */ \
++                                                                              \
++  &quot;  movq        %%mm3, %%mm2       \n\t&quot;                                     \
++  &quot;  movq        %%mm0,&quot; #ip4 &quot;     \n\t&quot; /* save ip4, now mm0,mm2 are free */ \
++                                                                              \
++  &quot;  movq        %%mm3, %%mm0       \n\t&quot;                                     \
++  &quot;  pmulhw   &quot;M(xC4S4)&quot;, %%mm3     \n\t&quot; /* mm3 = xC4S4 * ( is0734 +is1256 ) - ( is0734 +is1256 ) */ \
++                                                                              \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++  &quot;  paddw       %%mm0, %%mm3       \n\t&quot; /* mm3 = xC4S4 * ( is0734 +is1256 )	 */ \
++  &quot;  paddw       %%mm2, %%mm3       \n\t&quot; /* Truncate mm3, now it is op[0] */ \
++                                                                              \
++  &quot;  movq        %%mm3,&quot; #ip0 &quot;     \n\t&quot;                                     \
++  /* ------------------------------------------------------------------- */   \
++  &quot;  movq      &quot; #temp &quot;, %%mm3     \n\t&quot; /* mm3 = irot_input_y */            \
++  &quot;  pmulhw   &quot;M(xC2S6)&quot;, %%mm3     \n\t&quot; /* mm3 = xC2S6 * irot_input_y - irot_input_y */ \
++                                                                              \
++  &quot;  movq      &quot; #temp &quot;, %%mm2     \n\t&quot;                                     \
++  &quot;  movq        %%mm2, %%mm0       \n\t&quot;                                     \
++                                                                              \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot; /* mm3 = xC2S6 * irot_input_y */    \
++  &quot;  paddw       %%mm0, %%mm3       \n\t&quot;                                     \
++                                                                              \
++  &quot;  paddw       %%mm2, %%mm3       \n\t&quot; /* Truncated */                     \
++  &quot;  movq        %%mm5, %%mm0       \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq        %%mm5, %%mm2       \n\t&quot;                                     \
++  &quot;  pmulhw   &quot;M(xC6S2)&quot;, %%mm0     \n\t&quot; /* mm0 = xC6S2 * irot_input_x */    \
++                                                                              \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++  &quot;  paddw       %%mm2, %%mm0       \n\t&quot; /* Truncated */                     \
++                                                                              \
++  &quot;  paddsw      %%mm0, %%mm3       \n\t&quot; /* ip[2] */                         \
++  &quot;  movq        %%mm3,&quot; #ip2 &quot;     \n\t&quot; /* Save ip2 */                      \
++                                                                              \
++  &quot;  movq        %%mm5, %%mm0       \n\t&quot;                                     \
++  &quot;  movq        %%mm5, %%mm2       \n\t&quot;                                     \
++                                                                              \
++  &quot;  pmulhw   &quot;M(xC2S6)&quot;, %%mm5     \n\t&quot; /* mm5 = xC2S6 * irot_input_x - irot_input_x */ \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq      &quot; #temp &quot;, %%mm3     \n\t&quot;                                     \
++  &quot;  paddw       %%mm0, %%mm5       \n\t&quot; /* mm5 = xC2S6 * irot_input_x */    \
++                                                                              \
++  &quot;  paddw       %%mm2, %%mm5       \n\t&quot; /* Truncated */                     \
++  &quot;  movq        %%mm3, %%mm2       \n\t&quot;                                     \
++                                                                              \
++  &quot;  pmulhw   &quot;M(xC6S2)&quot;, %%mm3     \n\t&quot; /* mm3 = xC6S2 * irot_input_y */    \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++                                                                              \
++  &quot;  paddw       %%mm2, %%mm3       \n\t&quot; /* Truncated */                     \
++  &quot;  psubsw      %%mm5, %%mm3       \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq        %%mm3,&quot; #ip6 &quot;     \n\t&quot;                                     \
++  /* ------------------------------------------------------------------- */   \
++  &quot;  movq     &quot;M(xC4S4)&quot;, %%mm0     \n\t&quot;                                     \
++  &quot;  movq        %%mm1, %%mm2       \n\t&quot;                                     \
++  &quot;  movq        %%mm1, %%mm3       \n\t&quot;                                     \
++                                                                              \
++  &quot;  pmulhw      %%mm0, %%mm1       \n\t&quot; /* mm0 = xC4S4 * ( is12 - is56 ) - ( is12 - is56 ) */ \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;				      \
++                                                                              \
++  &quot;  paddw       %%mm3, %%mm1       \n\t&quot; /* mm0 = xC4S4 * ( is12 - is56 ) */ \
++  &quot;  paddw       %%mm2, %%mm1       \n\t&quot; /* Truncate mm1, now it is icommon_product1 */ \
++                                                                              \
++  &quot;  movq        %%mm7, %%mm2       \n\t&quot;                                     \
++  &quot;  movq        %%mm7, %%mm3       \n\t&quot;			              \
++                                                                              \
++  &quot;  pmulhw      %%mm0, %%mm7       \n\t&quot; /* mm7 = xC4S4 * ( id12 + id56 ) - ( id12 + id56 ) */ \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;			              \
++                                                                              \
++  &quot;  paddw       %%mm3, %%mm7       \n\t&quot; /* mm7 = xC4S4 * ( id12 + id56 ) */ \
++  &quot;  paddw       %%mm2, %%mm7       \n\t&quot; /* Truncate mm7, now it is icommon_product2 */ \
++  /* ------------------------------------------------------------------- */   \
++  &quot;  pxor        %%mm0, %%mm0       \n\t&quot; /* Clear mm0 */                     \
++  &quot;  psubsw      %%mm6, %%mm0       \n\t&quot; /* mm0 = - id34 */                  \
++                                                                              \
++  &quot;  psubsw      %%mm7, %%mm0       \n\t&quot; /* mm0 = - ( id34 + idcommon_product2 ) */ \
++  &quot;  paddsw      %%mm6, %%mm6       \n\t&quot;                                     \
++  &quot;  paddsw      %%mm0, %%mm6       \n\t&quot; /* mm6 = id34 - icommon_product2 */ \
++                                                                              \
++  &quot;  psubsw      %%mm1, %%mm4       \n\t&quot; /* mm4 = id07 - icommon_product1 */ \
++  &quot;  paddsw      %%mm1, %%mm1       \n\t&quot;                                     \
++  &quot;  paddsw      %%mm4, %%mm1       \n\t&quot; /* mm1 = id07 + icommon_product1 */ \
++  /* ------------------------------------------------------------------- */   \
++  &quot;  movq     &quot;M(xC1S7)&quot;, %%mm7     \n\t&quot;                                     \
++  &quot;  movq        %%mm1, %%mm2       \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq        %%mm1, %%mm3       \n\t&quot;                                     \
++  &quot;  pmulhw      %%mm7, %%mm1       \n\t&quot; /* mm1 = xC1S7 * irot_input_x - irot_input_x */ \
++                                                                              \
++  &quot;  movq     &quot;M(xC7S1)&quot;, %%mm7     \n\t&quot;                                     \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++                                                                              \
++  &quot;  paddw       %%mm3, %%mm1       \n\t&quot; /* mm1 = xC1S7 * irot_input_x */    \
++  &quot;  paddw       %%mm2, %%mm1       \n\t&quot; /* Trucated */                      \
++                                                                              \
++  &quot;  pmulhw      %%mm7, %%mm3       \n\t&quot; /* mm3 = xC7S1 * irot_input_x */    \
++  &quot;  paddw       %%mm2, %%mm3       \n\t&quot; /* Truncated */                     \
++                                                                              \
++  &quot;  movq        %%mm0, %%mm5       \n\t&quot;                                     \
++  &quot;  movq        %%mm0, %%mm2       \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq     &quot;M(xC1S7)&quot;, %%mm7     \n\t&quot;                                     \
++  &quot;  pmulhw      %%mm7, %%mm0       \n\t&quot; /* mm0 = xC1S7 * irot_input_y - irot_input_y */ \
++                                                                              \
++  &quot;  movq     &quot;M(xC7S1)&quot;, %%mm7     \n\t&quot;                                     \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++                                                                              \
++  &quot;  paddw       %%mm5, %%mm0       \n\t&quot; /* mm0 = xC1S7 * irot_input_y */    \
++  &quot;  paddw       %%mm2, %%mm0       \n\t&quot; /* Truncated */                     \
++                                                                              \
++  &quot;  pmulhw      %%mm7, %%mm5       \n\t&quot; /* mm5 = xC7S1 * irot_input_y */    \
++  &quot;  paddw       %%mm2, %%mm5       \n\t&quot; /* Truncated */                     \
++                                                                              \
++  &quot;  psubsw      %%mm5, %%mm1       \n\t&quot; /* mm1 = xC1S7 * irot_input_x - xC7S1 * irot_input_y = ip1 */ \
++  &quot;  paddsw      %%mm0, %%mm3       \n\t&quot; /* mm3 = xC7S1 * irot_input_x - xC1S7 * irot_input_y = ip7 */ \
++                                                                              \
++  &quot;  movq        %%mm1,&quot; #ip1 &quot;     \n\t&quot;                                     \
++  &quot;  movq        %%mm3,&quot; #ip7 &quot;     \n\t&quot;                                     \
++  /* ------------------------------------------------------------------- */   \
++  &quot;  movq     &quot;M(xC3S5)&quot;, %%mm0     \n\t&quot;                                     \
++  &quot;  movq     &quot;M(xC5S3)&quot;, %%mm1     \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq        %%mm6, %%mm5       \n\t&quot;                                     \
++  &quot;  movq        %%mm6, %%mm7       \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq        %%mm4, %%mm2       \n\t&quot;                                     \
++  &quot;  movq        %%mm4, %%mm3       \n\t&quot;                                     \
++                                                                              \
++  &quot;  pmulhw      %%mm0, %%mm4       \n\t&quot; /* mm4 = xC3S5 * irot_input_x - irot_input_x */ \
++  &quot;  pmulhw      %%mm1, %%mm6       \n\t&quot; /* mm6 = xC5S3 * irot_input_y - irot_input_y */ \
++                                                                              \
++  &quot;  psrlw       $15, %%mm2         \n\t&quot;                                     \
++  &quot;  psrlw       $15, %%mm5         \n\t&quot;                                     \
++                                                                              \
++  &quot;  paddw       %%mm3, %%mm4       \n\t&quot; /* mm4 = xC3S5 * irot_input_x */    \
++  &quot;  paddw       %%mm7, %%mm6       \n\t&quot; /* mm6 = xC5S3 * irot_input_y */    \
++                                                                              \
++  &quot;  paddw       %%mm2, %%mm4       \n\t&quot; /* Truncated */                     \
++  &quot;  paddw       %%mm5, %%mm6       \n\t&quot; /* Truncated */                     \
++                                                                              \
++  &quot;  psubsw      %%mm6, %%mm4       \n\t&quot; /* ip3 */                           \
++  &quot;  movq        %%mm4,&quot; #ip3 &quot;     \n\t&quot;                                     \
++                                                                              \
++  &quot;  movq        %%mm3, %%mm4       \n\t&quot;                                     \
++  &quot;  movq        %%mm7, %%mm6       \n\t&quot;                                     \
++                                                                              \
++  &quot;  pmulhw      %%mm1, %%mm3       \n\t&quot; /* mm3 = xC5S3 * irot_input_x - irot_input_x */ \
++  &quot;  pmulhw      %%mm0, %%mm7       \n\t&quot; /* mm7 = xC3S5 * irot_input_y - irot_input_y */ \
++                                                                              \
++  &quot;  paddw       %%mm2, %%mm4       \n\t&quot;                                     \
++  &quot;  paddw       %%mm5, %%mm6       \n\t&quot;                                     \
++                                                                              \
++  &quot;  paddw       %%mm4, %%mm3       \n\t&quot; /* mm3 = xC5S3 * irot_input_x */    \
++  &quot;  paddw       %%mm6, %%mm7       \n\t&quot; /* mm7 = xC3S5 * irot_input_y */    \
++                                                                              \
++  &quot;  paddw       %%mm7, %%mm3       \n\t&quot; /* ip5 */                           \
++  &quot;  movq        %%mm3,&quot; #ip5 &quot;     \n\t&quot; 
++
++#define Transpose_mmx(ip0,ip1,ip2,ip3,ip4,ip5,ip6,ip7,                  \
++		      op0,op1,op2,op3,op4,op5,op6,op7)                  \
++  &quot;  movq      &quot; #ip0 &quot;, %%mm0      \n\t&quot; /* mm0 = a0 a1 a2 a3 */       \
++  &quot;  movq      &quot; #ip4 &quot;, %%mm4      \n\t&quot; /* mm4 = e4 e5 e6 e7 */       \
++  &quot;  movq      &quot; #ip1 &quot;, %%mm1      \n\t&quot; /* mm1 = b0 b1 b2 b3 */       \
++  &quot;  movq      &quot; #ip5 &quot;, %%mm5      \n\t&quot; /* mm5 = f4 f5 f6 f7 */       \
++  &quot;  movq      &quot; #ip2 &quot;, %%mm2      \n\t&quot; /* mm2 = c0 c1 c2 c3 */       \
++  &quot;  movq      &quot; #ip6 &quot;, %%mm6      \n\t&quot; /* mm6 = g4 g5 g6 g7 */       \
++  &quot;  movq      &quot; #ip3 &quot;, %%mm3      \n\t&quot; /* mm3 = d0 d1 d2 d3 */       \
++  &quot;  movq        %%mm1,&quot; #op1 &quot;     \n\t&quot; /* save  b0 b1 b2 b3 */       \
++  &quot;  movq      &quot; #ip7 &quot;, %%mm7      \n\t&quot; /* mm7 = h0 h1 h2 h3 */       \
++   /* Transpose 2x8 block */                                            \
++  &quot;  movq        %%mm4, %%mm1       \n\t&quot; /* mm1 = e3 e2 e1 e0 */       \
++  &quot;  punpcklwd   %%mm5, %%mm4       \n\t&quot; /* mm4 = f1 e1 f0 e0 */       \
++  &quot;  movq        %%mm0,&quot; #op0 &quot;     \n\t&quot; /* save a3 a2 a1 a0  */       \
++  &quot;  punpckhwd	 %%mm5, %%mm1       \n\t&quot; /* mm1 = f3 e3 f2 e2 */       \
++  &quot;  movq        %%mm6, %%mm0       \n\t&quot; /* mm0 = g3 g2 g1 g0 */       \
++  &quot;  punpcklwd	 %%mm7, %%mm6       \n\t&quot; /* mm6 = h1 g1 h0 g0 */       \
++  &quot;  movq        %%mm4, %%mm5       \n\t&quot; /* mm5 = f1 e1 f0 e0 */       \
++  &quot;  punpckldq   %%mm6, %%mm4       \n\t&quot; /* mm4 = h0 g0 f0 e0 = MM4 */ \
++  &quot;  punpckhdq   %%mm6, %%mm5       \n\t&quot; /* mm5 = h1 g1 f1 e1 = MM5 */ \
++  &quot;  movq        %%mm1, %%mm6       \n\t&quot; /* mm6 = f3 e3 f2 e2 */       \
++  &quot;  movq        %%mm4,&quot; #op4 &quot;     \n\t&quot;                               \
++  &quot;  punpckhwd   %%mm7, %%mm0       \n\t&quot; /* mm0 = h3 g3 h2 g2 */       \
++  &quot;  movq        %%mm5,&quot; #op5 &quot;     \n\t&quot;                               \
++  &quot;  punpckhdq   %%mm0, %%mm6       \n\t&quot; /* mm6 = h3 g3 f3 e3 = MM7 */ \
++  &quot;  movq      &quot; #op0 &quot;, %%mm4      \n\t&quot; /* mm4 = a3 a2 a1 a0 */       \
++  &quot;  punpckldq   %%mm0, %%mm1       \n\t&quot; /* mm1 = h2 g2 f2 e2 = MM6 */ \
++  &quot;  movq      &quot; #op1 &quot;, %%mm5      \n\t&quot; /* mm5 = b3 b2 b1 b0 */       \
++  &quot;  movq        %%mm4, %%mm0       \n\t&quot; /* mm0 = a3 a2 a1 a0 */       \
++  &quot;  movq        %%mm6,&quot; #op7 &quot;     \n\t&quot;                               \
++  &quot;  punpcklwd   %%mm5, %%mm0       \n\t&quot; /* mm0 = b1 a1 b0 a0 */       \
++  &quot;  movq        %%mm1,&quot; #op6 &quot;     \n\t&quot;                               \
++  &quot;  punpckhwd   %%mm5, %%mm4       \n\t&quot; /* mm4 = b3 a3 b2 a2 */       \
++  &quot;  movq        %%mm2, %%mm5       \n\t&quot; /* mm5 = c3 c2 c1 c0 */       \
++  &quot;  punpcklwd   %%mm3, %%mm2       \n\t&quot; /* mm2 = d1 c1 d0 c0 */       \
++  &quot;  movq        %%mm0, %%mm1       \n\t&quot; /* mm1 = b1 a1 b0 a0 */       \
++  &quot;  punpckldq   %%mm2, %%mm0       \n\t&quot; /* mm0 = d0 c0 b0 a0 = MM0 */ \
++  &quot;  punpckhdq   %%mm2, %%mm1       \n\t&quot; /* mm1 = d1 c1 b1 a1 = MM1 */ \
++  &quot;  movq        %%mm4, %%mm2       \n\t&quot; /* mm2 = b3 a3 b2 a2 */       \
++  &quot;  movq        %%mm0,&quot; #op0 &quot;     \n\t&quot;                               \
++  &quot;  punpckhwd   %%mm3, %%mm5       \n\t&quot; /* mm5 = d3 c3 d2 c2 */       \
++  &quot;  movq        %%mm1,&quot; #op1 &quot;     \n\t&quot;                               \
++  &quot;  punpckhdq   %%mm5, %%mm4       \n\t&quot; /* mm4 = d3 c3 b3 a3 = MM3 */ \
++  &quot;  punpckldq   %%mm5, %%mm2       \n\t&quot; /* mm2 = d2 c2 b2 a2 = MM2 */ \
++  &quot;  movq        %%mm4,&quot; #op3 &quot;     \n\t&quot;                               \
++  &quot;  movq        %%mm2,&quot; #op2 &quot;     \n\t&quot;
++
++
++static void fdct_short__mmx ( ogg_int16_t *InputData, ogg_int16_t *OutputData)
++{
++  ogg_int64_t __attribute__((aligned(8))) align_tmp[16];
++  ogg_int16_t *const temp= (int16_t*)align_tmp;
++
++  __asm__ __volatile__ (
++    &quot;  .balign 16                   \n\t&quot;
++    /*
++     * Input data is an 8x8 block.  To make processing of the data more efficent
++     * we will transpose the block of data to two 4x8 blocks???
++     */
++    Transpose_mmx (  (%0), 16(%0), 32(%0), 48(%0),  8(%0), 24(%0), 40(%0), 56(%0),
++		     (%1), 16(%1), 32(%1), 48(%1),  8(%1), 24(%1), 40(%1), 56(%1))
++    Fdct_mmx      (  (%1), 16(%1), 32(%1), 48(%1),  8(%1), 24(%1), 40(%1), 56(%1), (%2))
++
++    Transpose_mmx (64(%0), 80(%0), 96(%0),112(%0), 72(%0), 88(%0),104(%0),120(%0),
++		   64(%1), 80(%1), 96(%1),112(%1), 72(%1), 88(%1),104(%1),120(%1))
++    Fdct_mmx      (64(%1), 80(%1), 96(%1),112(%1), 72(%1), 88(%1),104(%1),120(%1), (%2))
++
++    Transpose_mmx ( 0(%1), 16(%1), 32(%1), 48(%1), 64(%1), 80(%1), 96(%1),112(%1),
++		    0(%1), 16(%1), 32(%1), 48(%1), 64(%1), 80(%1), 96(%1),112(%1))
++    Fdct_mmx      ( 0(%1), 16(%1), 32(%1), 48(%1), 64(%1), 80(%1), 96(%1),112(%1), (%2))
++
++    Transpose_mmx ( 8(%1), 24(%1), 40(%1), 56(%1), 72(%1), 88(%1),104(%1),120(%1),
++		    8(%1), 24(%1), 40(%1), 56(%1), 72(%1), 88(%1),104(%1),120(%1))
++    Fdct_mmx      ( 8(%1), 24(%1), 40(%1), 56(%1), 72(%1), 88(%1),104(%1),120(%1), (%2))
++
++    &quot;  emms                         \n\t&quot;
++    
++    : &quot;+r&quot; (InputData),
++      &quot;+r&quot; (OutputData)
++    : &quot;r&quot; (temp)
++    : &quot;memory&quot;
++  );
++}
++
++void dsp_i386_mmx_fdct_init(DspFunctions *funcs)
++{
++  funcs-&gt;fdct_short = fdct_short__mmx;
++}
+diff -Naur libtheora-1.0alpha3/lib/i386/recon_mmx.c libtheora-1.0alpha3.mmx/lib/i386/recon_mmx.c
+--- libtheora-1.0alpha3/lib/i386/recon_mmx.c	1970-01-01 01:00:00.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/i386/recon_mmx.c	2004-10-06 17:48:22.510386296 +0200
+@@ -0,0 +1,185 @@
++/********************************************************************
++ *                                                                  *
++ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
++ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
++ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
++ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
++ *                                                                  *
++ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2003                *
++ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
++ *                                                                  *
++ ********************************************************************
++
++  function:
++  last mod: $Id: reconstruct.c,v 1.6 2003/12/03 08:59:41 arc Exp $
++
++ ********************************************************************/
++
++#include &quot;encoder_internal.h&quot;
++
++static const __attribute__ ((aligned(8),used)) ogg_int64_t V128 = 0x8080808080808080LL;
++
++#if defined(__MINGW32__) || defined(__CYGWIN__) || \
++	    defined(__OS2__) || (defined (__OpenBSD__) &amp;&amp; !defined(__ELF__))
++# define M(a) &quot;_&quot; #a
++#else
++# define M(a) #a
++#endif
++
++static void copy8x8__mmx (unsigned char *src,
++	                unsigned char *dest,
++	                unsigned int stride)
++{
++  __asm__ __volatile__ (
++    &quot;  .balign 16                      \n\t&quot;
++
++    &quot;  lea         (%2, %2, 2), %%edi  \n\t&quot;
++
++    &quot;  movq        (%1), %%mm0         \n\t&quot;
++    &quot;  movq        (%1, %2), %%mm1     \n\t&quot;
++    &quot;  movq        (%1, %2, 2), %%mm2  \n\t&quot;
++    &quot;  movq        (%1, %%edi), %%mm3  \n\t&quot;
++
++    &quot;  lea         (%1, %2, 4), %1     \n\t&quot; 
++
++    &quot;  movq        %%mm0, (%0)         \n\t&quot;
++    &quot;  movq        %%mm1, (%0, %2)     \n\t&quot;
++    &quot;  movq        %%mm2, (%0, %2, 2)  \n\t&quot;
++    &quot;  movq        %%mm3, (%0, %%edi)  \n\t&quot;
++
++    &quot;  lea         (%0, %2, 4), %0     \n\t&quot; 
++
++    &quot;  movq        (%1), %%mm0         \n\t&quot;
++    &quot;  movq        (%1, %2), %%mm1     \n\t&quot;
++    &quot;  movq        (%1, %2, 2), %%mm2  \n\t&quot;
++    &quot;  movq        (%1, %%edi), %%mm3  \n\t&quot;
++
++    &quot;  movq        %%mm0, (%0)         \n\t&quot;
++    &quot;  movq        %%mm1, (%0, %2)     \n\t&quot;
++    &quot;  movq        %%mm2, (%0, %2, 2)  \n\t&quot;
++    &quot;  movq        %%mm3, (%0, %%edi)  \n\t&quot;
++      : &quot;+a&quot; (dest)
++      : &quot;c&quot; (src),
++        &quot;d&quot; (stride)
++      : &quot;memory&quot;, &quot;edi&quot;
++  );
++}
++
++static void recon_intra8x8__mmx (unsigned char *ReconPtr, ogg_int16_t *ChangePtr,
++		      ogg_uint32_t LineStep)
++{
++  __asm__ __volatile__ (
++    &quot;  .balign 16                      \n\t&quot;
++
++    &quot;  movq     &quot;M(V128)&quot;, %%mm0       \n\t&quot; /* Set mm0 to 0x8080808080808080 */
++
++    &quot;  lea         128(%1), %%edi      \n\t&quot; /* Endpoint in input buffer */
++    &quot;1:                                \n\t&quot; 
++    &quot;  movq         (%1), %%mm2        \n\t&quot; /* First four input values */
++
++    &quot;  packsswb    8(%1), %%mm2        \n\t&quot; /* pack with next(high) four values */
++    &quot;  por         %%mm0, %%mm0        \n\t&quot; 
++    &quot;  pxor        %%mm0, %%mm2        \n\t&quot; /* Convert result to unsigned (same as add 128) */
++    &quot;  lea         16(%1), %1          \n\t&quot; /* Step source buffer */
++    &quot;  cmp         %%edi, %1           \n\t&quot; /* are we done */
++
++    &quot;  movq        %%mm2, (%0)         \n\t&quot; /* store results */
++
++    &quot;  lea         (%0, %2), %0        \n\t&quot; /* Step output buffer */
++    &quot;  jc          1b                  \n\t&quot; /* Loop back if we are not done */
++      : &quot;+r&quot; (ReconPtr)
++      : &quot;r&quot; (ChangePtr),
++        &quot;r&quot; (LineStep)
++      : &quot;memory&quot;, &quot;edi&quot;
++  );
++}
++
++static void recon_inter8x8__mmx (unsigned char *ReconPtr, unsigned char *RefPtr,
++		      ogg_int16_t *ChangePtr, ogg_uint32_t LineStep)
++{
++  __asm__ __volatile__ (
++    &quot;  .balign 16                      \n\t&quot;
++
++    &quot;  pxor        %%mm0, %%mm0        \n\t&quot;
++    &quot;  lea         128(%1), %%edi      \n\t&quot;
++
++    &quot;1:                                \n\t&quot;
++    &quot;  movq        (%2), %%mm2         \n\t&quot; /* (+3 misaligned) 8 reference pixels */
++
++    &quot;  movq        (%1), %%mm4         \n\t&quot; /* first 4 changes */
++    &quot;  movq        %%mm2, %%mm3        \n\t&quot;
++    &quot;  movq        8(%1), %%mm5        \n\t&quot; /* last 4 changes */
++    &quot;  punpcklbw   %%mm0, %%mm2        \n\t&quot; /* turn first 4 refs into positive 16-bit #s */
++    &quot;  paddsw      %%mm4, %%mm2        \n\t&quot; /* add in first 4 changes */
++    &quot;  punpckhbw   %%mm0, %%mm3        \n\t&quot; /* turn last 4 refs into positive 16-bit #s */
++    &quot;  paddsw      %%mm5, %%mm3        \n\t&quot; /* add in last 4 changes */
++    &quot;  add         %3, %2              \n\t&quot; /* next row of reference pixels */
++    &quot;  packuswb    %%mm3, %%mm2        \n\t&quot; /* pack result to unsigned 8-bit values */
++    &quot;  lea         16(%1), %1          \n\t&quot; /* next row of changes */
++    &quot;  cmp         %%edi, %1            \n\t&quot; /* are we done? */
++
++    &quot;  movq        %%mm2, (%0)         \n\t&quot; /* store result */
++
++    &quot;  lea         (%0, %3), %0        \n\t&quot; /* next row of output */
++    &quot;  jc          1b                  \n\t&quot;
++      : &quot;+r&quot; (ReconPtr)
++      : &quot;r&quot; (ChangePtr),
++        &quot;r&quot; (RefPtr),
++        &quot;r&quot; (LineStep)
++      : &quot;memory&quot;, &quot;edi&quot;
++  );
++}
++
++static void recon_inter8x8_half__mmx (unsigned char *ReconPtr, unsigned char *RefPtr1,
++		           unsigned char *RefPtr2, ogg_int16_t *ChangePtr,
++			   ogg_uint32_t LineStep)
++{
++  __asm__ __volatile__ (
++    &quot;  .balign 16                      \n\t&quot;
++
++    &quot;  pxor        %%mm0, %%mm0        \n\t&quot;
++    &quot;  lea         128(%1), %%edi      \n\t&quot;
++
++    &quot;1:                                \n\t&quot;
++    &quot;  movq        (%2), %%mm2         \n\t&quot; /* (+3 misaligned) 8 reference pixels */
++    &quot;  movq        (%3), %%mm4         \n\t&quot; /* (+3 misaligned) 8 reference pixels */
++
++    &quot;  movq        %%mm2, %%mm3        \n\t&quot;
++    &quot;  punpcklbw   %%mm0, %%mm2        \n\t&quot; /* mm2 = start ref1 as positive 16-bit #s */
++    &quot;  movq        %%mm4, %%mm5        \n\t&quot;
++    &quot;  movq        (%1), %%mm6         \n\t&quot; /* first 4 changes */
++    &quot;  punpckhbw   %%mm0, %%mm3        \n\t&quot; /* mm3 = end ref1 as positive 16-bit #s */
++    &quot;  movq        8(%1), %%mm7        \n\t&quot; /* last 4 changes */
++    &quot;  punpcklbw   %%mm0, %%mm4        \n\t&quot; /* mm4 = start ref2 as positive 16-bit #s */
++    &quot;  punpckhbw   %%mm0, %%mm5        \n\t&quot; /* mm5 = end ref2 as positive 16-bit #s */
++    &quot;  paddw       %%mm4, %%mm2        \n\t&quot; /* mm2 = start (ref1 + ref2) */
++    &quot;  paddw       %%mm5, %%mm3        \n\t&quot; /* mm3 = end (ref1 + ref2) */
++    &quot;  psrlw       $1, %%mm2           \n\t&quot; /* mm2 = start (ref1 + ref2)/2 */
++    &quot;  psrlw       $1, %%mm3           \n\t&quot; /* mm3 = end (ref1 + ref2)/2 */
++    &quot;  paddw       %%mm6, %%mm2        \n\t&quot; /* add changes to start */
++    &quot;  paddw       %%mm7, %%mm3        \n\t&quot; /* add changes to end */
++    &quot;  lea         16(%1), %1          \n\t&quot; /* next row of changes */
++    &quot;  packuswb    %%mm3, %%mm2        \n\t&quot; /* pack start|end to unsigned 8-bit */
++    &quot;  add         %4, %2              \n\t&quot; /* next row of reference pixels */
++    &quot;  add         %4, %3              \n\t&quot; /* next row of reference pixels */
++    &quot;  movq        %%mm2, (%0)         \n\t&quot; /* store result */
++    &quot;  add         %4, %0              \n\t&quot; /* next row of output */
++    &quot;  cmp         %%edi, %1           \n\t&quot; /* are we done? */
++    &quot;  jc          1b                  \n\t&quot;
++      : &quot;+r&quot; (ReconPtr)
++      : &quot;r&quot; (ChangePtr),
++        &quot;r&quot; (RefPtr1),
++        &quot;r&quot; (RefPtr2),
++        &quot;m&quot; (LineStep)
++      : &quot;memory&quot;, &quot;edi&quot;
++  );
++}
++
++void dsp_i386_mmx_recon_init(DspFunctions *funcs)
++{
++  funcs-&gt;copy8x8 = copy8x8__mmx;
++  funcs-&gt;recon_intra8x8 = recon_intra8x8__mmx;
++  funcs-&gt;recon_inter8x8 = recon_inter8x8__mmx;
++  funcs-&gt;recon_inter8x8_half = recon_inter8x8_half__mmx;
++}
++
+diff -Naur libtheora-1.0alpha3/lib/Makefile.am libtheora-1.0alpha3.mmx/lib/Makefile.am
+--- libtheora-1.0alpha3/lib/Makefile.am	2003-06-15 02:56:42.000000000 +0200
++++ libtheora-1.0alpha3.mmx/lib/Makefile.am	2004-10-06 17:48:22.510386296 +0200
+@@ -6,7 +6,8 @@
+ 
+ libtheora_la_SOURCES = encode.c hufftables.h quant_lookup.h \
+ 	encoder_internal.h idct.c reconstruct.c block_inline.h \
+-	encoder_lookup.h mcomp.c scan.c blockmap.c misc_common.c \
++	encoder_lookup.h cpu.c dsp.h dsp.c i386/dsp_mmx.c i386/dsp_mmxext.c \
++	i386/recon_mmx.c i386/fdct_mmx.c mcomp.c scan.c blockmap.c misc_common.c \
+ 	dct.c frarray.c pb.c dct_decode.c frinit.c pp.c dct_encode.c \
+ 	huffman.c pp.h toplevel.c decode.c huffman.h quant.c \
+ 	comment.c toplevel_lookup.h mcomp.h
+diff -Naur libtheora-1.0alpha3/lib/mcomp.c libtheora-1.0alpha3.mmx/lib/mcomp.c
+--- libtheora-1.0alpha3/lib/mcomp.c	2003-12-03 09:59:41.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/mcomp.c	2004-10-06 17:48:22.543381280 +0200
+@@ -17,6 +17,7 @@
+ 
+ #include &lt;stdlib.h&gt;
+ #include &lt;stdio.h&gt;
++#include &quot;dsp.h&quot;
+ #include &quot;encoder_internal.h&quot;
+ 
+ /* Initialises motion compentsation. */
+@@ -100,161 +101,22 @@
+                           unsigned char * RefDataPtr1,
+                           unsigned char * RefDataPtr2,
+                           ogg_uint32_t PixelsPerLine ) {
+-  ogg_uint32_t  i;
+-  ogg_int32_t   XSum=0;
+-  ogg_int32_t   XXSum=0;
+   ogg_int32_t   DiffVal;
+-  ogg_int32_t   AbsRefOffset = abs((int)(RefDataPtr1 - RefDataPtr2));
++  ogg_int32_t   RefOffset = (int)(RefDataPtr1 - RefDataPtr2);
++  ogg_uint32_t  RefPixelsPerLine = PixelsPerLine + STRIDE_EXTRA;
+ 
+   /* Mode of interpolation chosen based upon on the offset of the
+      second reference pointer */
+-  if ( AbsRefOffset == 0 ) {
+-    for ( i=0; i&lt;BLOCK_HEIGHT_WIDTH; i++ ) {
+-      DiffVal = ((int)NewDataPtr[0]) - (int)RefDataPtr1[0];
+-      XSum += DiffVal;
+-
+-      /* negative array indexes are strictly forbidden by ANSI C and C99 */
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[1]) - (int)RefDataPtr1[1];
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[2]) - (int)RefDataPtr1[2];
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[3]) - (int)RefDataPtr1[3];
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[4]) - (int)RefDataPtr1[4];
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[5]) - (int)RefDataPtr1[5];
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[6]) - (int)RefDataPtr1[6];
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[7]) - (int)RefDataPtr1[7];
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      /* Step to next row of block. */
+-      NewDataPtr += PixelsPerLine;
+-      RefDataPtr1 += STRIDE_EXTRA + PixelsPerLine;
+-    }
+-
++  if ( RefOffset == 0 ) {
++    DiffVal = dsp_static_inter8x8_err (NewDataPtr, PixelsPerLine,
++		          RefDataPtr1, RefPixelsPerLine);
+   }else{
+-
+-    /* Simple two reference interpolation */
+-    for ( i=0; i&lt;BLOCK_HEIGHT_WIDTH; i++ ) {
+-      DiffVal = ((int)NewDataPtr[0]) -
+-        (((int)RefDataPtr1[0] + (int)RefDataPtr2[0]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[1]) -
+-        (((int)RefDataPtr1[1] + (int)RefDataPtr2[1]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[2]) -
+-        (((int)RefDataPtr1[2] + (int)RefDataPtr2[2]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[3]) -
+-        (((int)RefDataPtr1[3] + (int)RefDataPtr2[3]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[4]) -
+-        (((int)RefDataPtr1[4] + (int)RefDataPtr2[4]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[5]) -
+-        (((int)RefDataPtr1[5] + (int)RefDataPtr2[5]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[6]) -
+-        (((int)RefDataPtr1[6] + (int)RefDataPtr2[6]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      DiffVal = ((int)NewDataPtr[7]) -
+-        (((int)RefDataPtr1[7] + (int)RefDataPtr2[7]) / 2);
+-      XSum += DiffVal;
+-      XXSum += DiffVal*DiffVal;
+-
+-      /* Step to next row of block. */
+-      NewDataPtr += PixelsPerLine;
+-      RefDataPtr1 += STRIDE_EXTRA+PixelsPerLine;
+-      RefDataPtr2 += STRIDE_EXTRA+PixelsPerLine;
+-    }
++    DiffVal = dsp_static_inter8x8_err_xy2 (NewDataPtr, PixelsPerLine,
++		          RefDataPtr1, 
++		          RefDataPtr2, RefPixelsPerLine);
+   }
+ 
+   /* Compute and return population variance as mis-match metric. */
+-  return (( (XXSum&lt;&lt;6) - XSum*XSum ));
+-}
+-
+-static ogg_uint32_t GetSumAbsDiffs  (unsigned char * NewDataPtr,
+-                              unsigned char  * RefDataPtr,
+-                              ogg_uint32_t PixelsPerLine,
+-                              ogg_uint32_t ErrorSoFar) {
+-  ogg_uint32_t  i;
+-  ogg_uint32_t  DiffVal = ErrorSoFar;
+-
+-  /* Decide on standard or MMX implementation */
+-  for ( i=0; i &lt; BLOCK_HEIGHT_WIDTH; i++ ) {
+-    DiffVal += abs( ((int)NewDataPtr[0]) - ((int)RefDataPtr[0]) );
+-    DiffVal += abs( ((int)NewDataPtr[1]) - ((int)RefDataPtr[1]) );
+-    DiffVal += abs( ((int)NewDataPtr[2]) - ((int)RefDataPtr[2]) );
+-    DiffVal += abs( ((int)NewDataPtr[3]) - ((int)RefDataPtr[3]) );
+-    DiffVal += abs( ((int)NewDataPtr[4]) - ((int)RefDataPtr[4]) );
+-    DiffVal += abs( ((int)NewDataPtr[5]) - ((int)RefDataPtr[5]) );
+-    DiffVal += abs( ((int)NewDataPtr[6]) - ((int)RefDataPtr[6]) );
+-    DiffVal += abs( ((int)NewDataPtr[7]) - ((int)RefDataPtr[7]) );
+-
+-    /* Step to next row of block. */
+-    NewDataPtr += PixelsPerLine;
+-    RefDataPtr += STRIDE_EXTRA+PixelsPerLine;
+-  }
+-
+-  return DiffVal;
+-}
+-
+-static ogg_uint32_t GetNextSumAbsDiffs (unsigned char * NewDataPtr,
+-                                 unsigned char * RefDataPtr,
+-                                 ogg_uint32_t PixelsPerLine,
+-                                 ogg_uint32_t ErrorSoFar,
+-                                 ogg_uint32_t BestSoFar ) {
+-  ogg_uint32_t  i;
+-  ogg_uint32_t  DiffVal = ErrorSoFar;
+-
+-  for ( i=0; i &lt; BLOCK_HEIGHT_WIDTH; i++ ) {
+-    DiffVal += abs( ((int)NewDataPtr[0]) - ((int)RefDataPtr[0]) );
+-    DiffVal += abs( ((int)NewDataPtr[1]) - ((int)RefDataPtr[1]) );
+-    DiffVal += abs( ((int)NewDataPtr[2]) - ((int)RefDataPtr[2]) );
+-    DiffVal += abs( ((int)NewDataPtr[3]) - ((int)RefDataPtr[3]) );
+-    DiffVal += abs( ((int)NewDataPtr[4]) - ((int)RefDataPtr[4]) );
+-    DiffVal += abs( ((int)NewDataPtr[5]) - ((int)RefDataPtr[5]) );
+-    DiffVal += abs( ((int)NewDataPtr[6]) - ((int)RefDataPtr[6]) );
+-    DiffVal += abs( ((int)NewDataPtr[7]) - ((int)RefDataPtr[7]) );
+-
+-    if ( DiffVal &gt; BestSoFar )break;
+-
+-    /* Step to next row of block. */
+-    NewDataPtr += PixelsPerLine;
+-    RefDataPtr += STRIDE_EXTRA+PixelsPerLine;
+-  }
+-
+   return DiffVal;
+ }
+ 
+@@ -265,118 +127,60 @@
+                                       ogg_uint32_t ErrorSoFar,
+                                       ogg_uint32_t BestSoFar ) {
+ 
+-  ogg_uint32_t  i;
+   ogg_uint32_t  DiffVal = ErrorSoFar;
+   ogg_int32_t   RefOffset = (int)(RefDataPtr1 - RefDataPtr2);
+   ogg_uint32_t  RefPixelsPerLine = PixelsPerLine + STRIDE_EXTRA;
+ 
+   if ( RefOffset == 0 ) {
+     /* Simple case as for non 0.5 pixel */
+-    DiffVal += GetSumAbsDiffs( SrcData, RefDataPtr1, PixelsPerLine,
+-                               ErrorSoFar);
++    DiffVal += dsp_static_sad8x8 (SrcData, PixelsPerLine, 
++		               RefDataPtr1, RefPixelsPerLine);
+   } else  {
+-    for ( i=0; i &lt; BLOCK_HEIGHT_WIDTH; i++ ) {
+-      DiffVal += abs( ((int)SrcData[0]) - (((int)RefDataPtr1[0] +
+-                                            (int)RefDataPtr2[0]) / 2) );
+-      DiffVal += abs( ((int)SrcData[1]) - (((int)RefDataPtr1[1] +
+-                                            (int)RefDataPtr2[1]) / 2) );
+-      DiffVal += abs( ((int)SrcData[2]) - (((int)RefDataPtr1[2] +
+-                                            (int)RefDataPtr2[2]) / 2) );
+-      DiffVal += abs( ((int)SrcData[3]) - (((int)RefDataPtr1[3] +
+-                                            (int)RefDataPtr2[3]) / 2) );
+-      DiffVal += abs( ((int)SrcData[4]) - (((int)RefDataPtr1[4] +
+-                                            (int)RefDataPtr2[4]) / 2) );
+-      DiffVal += abs( ((int)SrcData[5]) - (((int)RefDataPtr1[5] +
+-                                            (int)RefDataPtr2[5]) / 2) );
+-      DiffVal += abs( ((int)SrcData[6]) - (((int)RefDataPtr1[6] +
+-                                            (int)RefDataPtr2[6]) / 2) );
+-      DiffVal += abs( ((int)SrcData[7]) - (((int)RefDataPtr1[7] +
+-                                            (int)RefDataPtr2[7]) / 2) );
+-
+-      if ( DiffVal &gt; BestSoFar ) break;
+-
+-      /* Step to next row of block. */
+-      SrcData += PixelsPerLine;
+-      RefDataPtr1 += RefPixelsPerLine;
+-      RefDataPtr2 += RefPixelsPerLine;
+-    }
++    DiffVal += dsp_static_sad8x8_xy2_thres (SrcData, PixelsPerLine, 
++		               RefDataPtr1, 
++		               RefDataPtr2, RefPixelsPerLine, BestSoFar);
+   }
+ 
+   return DiffVal;
+ }
+ 
+-static ogg_uint32_t GetIntraError (unsigned char * DataPtr,
+-                            ogg_uint32_t PixelsPerLine ) {
+-  ogg_uint32_t  i;
+-  ogg_uint32_t  XSum=0;
+-  ogg_uint32_t  XXSum=0;
+-  unsigned char *DiffPtr;
+-
+-  /* Loop expanded out for speed. */
+-  DiffPtr = DataPtr;
+-
+-  for ( i=0; i&lt;BLOCK_HEIGHT_WIDTH; i++ ) {
+-
+-    /* Examine alternate pixel locations. */
+-    XSum += DiffPtr[0];
+-    XXSum += DiffPtr[0]*DiffPtr[0];
+-    XSum += DiffPtr[1];
+-    XXSum += DiffPtr[1]*DiffPtr[1];
+-    XSum += DiffPtr[2];
+-    XXSum += DiffPtr[2]*DiffPtr[2];
+-    XSum += DiffPtr[3];
+-    XXSum += DiffPtr[3]*DiffPtr[3];
+-    XSum += DiffPtr[4];
+-    XXSum += DiffPtr[4]*DiffPtr[4];
+-    XSum += DiffPtr[5];
+-    XXSum += DiffPtr[5]*DiffPtr[5];
+-    XSum += DiffPtr[6];
+-    XXSum += DiffPtr[6]*DiffPtr[6];
+-    XSum += DiffPtr[7];
+-    XXSum += DiffPtr[7]*DiffPtr[7];
+-
+-    /* Step to next row of block. */
+-    DiffPtr += PixelsPerLine;
+-  }
+-
+-  /* Compute population variance as mis-match metric. */
+-  return (( (XXSum&lt;&lt;6) - XSum*XSum ) );
+-}
+-
+ ogg_uint32_t GetMBIntraError (CP_INSTANCE *cpi, ogg_uint32_t FragIndex,
+                               ogg_uint32_t PixelsPerLine ) {
+   ogg_uint32_t  LocalFragIndex = FragIndex;
+   ogg_uint32_t  IntraError = 0;
+ 
++  dsp_static_save_fpu ();
++
+   /* Add together the intra errors for those blocks in the macro block
+      that are coded (Y only) */
+   if ( cpi-&gt;pb.display_fragments[LocalFragIndex] )
+     IntraError +=
+-      GetIntraError(&amp;cpi-&gt;
++      dsp_static_intra8x8_err (&amp;cpi-&gt;
+                     ConvDestBuffer[cpi-&gt;pb.pixel_index_table[LocalFragIndex]],
+-                    PixelsPerLine );
+-
++                    PixelsPerLine);
+ 
+   LocalFragIndex++;
+   if ( cpi-&gt;pb.display_fragments[LocalFragIndex] )
+     IntraError +=
+-      GetIntraError(&amp;cpi-&gt;
++      dsp_static_intra8x8_err (&amp;cpi-&gt;
+                     ConvDestBuffer[cpi-&gt;pb.pixel_index_table[LocalFragIndex]],
+-                    PixelsPerLine );
++                    PixelsPerLine);
+ 
+   LocalFragIndex = FragIndex + cpi-&gt;pb.HFragments;
+   if ( cpi-&gt;pb.display_fragments[LocalFragIndex] )
+     IntraError +=
+-      GetIntraError(&amp;cpi-&gt;
++      dsp_static_intra8x8_err (&amp;cpi-&gt;
+                      ConvDestBuffer[cpi-&gt;pb.pixel_index_table[LocalFragIndex]],
+-                     PixelsPerLine );
++                    PixelsPerLine);
+ 
+   LocalFragIndex++;
+   if ( cpi-&gt;pb.display_fragments[LocalFragIndex] )
+     IntraError +=
+-      GetIntraError(&amp;cpi-&gt;
++      dsp_static_intra8x8_err (&amp;cpi-&gt;
+                     ConvDestBuffer[cpi-&gt;pb.pixel_index_table[LocalFragIndex]],
+-                    PixelsPerLine );
++                    PixelsPerLine);
++
++  dsp_static_restore_fpu ();
+ 
+   return IntraError;
+ }
+@@ -400,6 +204,8 @@
+   unsigned char * SrcPtr1;
+   unsigned char * RefPtr1;
+ 
++  dsp_static_save_fpu ();
++
+   /* Work out pixel offset into source buffer. */
+   PixelIndex = cpi-&gt;pb.pixel_index_table[LocalFragIndex];
+ 
+@@ -462,6 +268,9 @@
+     InterError += GetInterErr( SrcPtr1, RefPtr1,
+                                  &amp;RefPtr1[RefPtr2Offset], PixelsPerLine );
+   }
++
++  dsp_static_restore_fpu ();
++
+   return InterError;
+ }
+ 
+@@ -496,6 +305,8 @@
+   unsigned char * RefDataPtr1;
+   unsigned char * RefDataPtr2;
+ 
++  dsp_static_save_fpu ();
++
+   /* Note which of the four blocks in the macro block are to be
+      included in the search. */
+   MBlockDispFrags[0] =
+@@ -518,20 +329,20 @@
+ 
+   /* Check the 0,0 candidate. */
+   if ( MBlockDispFrags[0] ) {
+-    Error = GetSumAbsDiffs( SrcPtr[0], RefPtr,
+-                         PixelsPerLine, Error);
++    Error += dsp_static_sad8x8 (SrcPtr[0], PixelsPerLine, RefPtr,
++                         PixelsPerLine + STRIDE_EXTRA);
+   }
+   if ( MBlockDispFrags[1] ) {
+-    Error = GetSumAbsDiffs( SrcPtr[1], RefPtr + 8,
+-                         PixelsPerLine, Error);
++    Error += dsp_static_sad8x8 (SrcPtr[1], PixelsPerLine, RefPtr + 8,
++                         PixelsPerLine + STRIDE_EXTRA);
+   }
+   if ( MBlockDispFrags[2] ) {
+-    Error = GetSumAbsDiffs( SrcPtr[2], RefPtr + RefRow2Offset,
+-                         PixelsPerLine, Error);
++    Error += dsp_static_sad8x8 (SrcPtr[2], PixelsPerLine, RefPtr + RefRow2Offset,
++                         PixelsPerLine + STRIDE_EXTRA);
+   }
+   if ( MBlockDispFrags[3] ) {
+-    Error = GetSumAbsDiffs( SrcPtr[3], RefPtr + RefRow2Offset + 8,
+-                         PixelsPerLine, Error);
++    Error += dsp_static_sad8x8 (SrcPtr[3], PixelsPerLine, RefPtr + RefRow2Offset + 8,
++                         PixelsPerLine + STRIDE_EXTRA);
+   }
+ 
+   /* Set starting values to results of 0, 0 vector. */
+@@ -554,24 +365,23 @@
+ 
+       /* Get the score for the current offset */
+       if ( MBlockDispFrags[0] ) {
+-        Error = GetSumAbsDiffs( SrcPtr[0], CandidateBlockPtr,
+-                             PixelsPerLine, Error);
++        Error += dsp_static_sad8x8 (SrcPtr[0], PixelsPerLine, CandidateBlockPtr,
++                             PixelsPerLine + STRIDE_EXTRA);
+       }
+ 
+       if ( MBlockDispFrags[1] &amp;&amp; (Error &lt; MinError) ) {
+-        Error = GetNextSumAbsDiffs( SrcPtr[1], CandidateBlockPtr + 8,
+-                                 PixelsPerLine, Error, MinError );
++        Error += dsp_static_sad8x8_thres (SrcPtr[1], PixelsPerLine, CandidateBlockPtr + 8,
++                             PixelsPerLine + STRIDE_EXTRA, MinError);
+       }
+ 
+       if ( MBlockDispFrags[2] &amp;&amp; (Error &lt; MinError) ) {
+-        Error = GetNextSumAbsDiffs( SrcPtr[2], CandidateBlockPtr + RefRow2Offset,
+-                                 PixelsPerLine, Error, MinError );
++        Error += dsp_static_sad8x8_thres (SrcPtr[2], PixelsPerLine, CandidateBlockPtr + RefRow2Offset,
++                             PixelsPerLine + STRIDE_EXTRA, MinError);
+       }
+ 
+       if ( MBlockDispFrags[3] &amp;&amp; (Error &lt; MinError) ) {
+-        Error = GetNextSumAbsDiffs( SrcPtr[3],
+-                                 CandidateBlockPtr + RefRow2Offset + 8,
+-                                 PixelsPerLine, Error, MinError );
++        Error += dsp_static_sad8x8_thres (SrcPtr[3], PixelsPerLine, CandidateBlockPtr + RefRow2Offset + 8,
++                             PixelsPerLine + STRIDE_EXTRA, MinError);
+       }
+ 
+       if ( Error &lt; MinError ) {
+@@ -652,6 +462,8 @@
+   InterMVError = GetMBInterError( cpi, cpi-&gt;ConvDestBuffer, RefFramePtr,
+                                   FragIndex, MV-&gt;x, MV-&gt;y, PixelsPerLine );
+ 
++  dsp_static_restore_fpu ();
++
+   /* Return score of best matching block. */
+   return InterMVError;
+ }
+@@ -684,6 +496,8 @@
+   unsigned char * RefDataPtr1;
+   unsigned char * RefDataPtr2;
+ 
++  dsp_static_save_fpu ();
++
+   /* Note which of the four blocks in the macro block are to be
+      included in the search. */
+   MBlockDispFrags[0] = cpi-&gt;
+@@ -717,20 +531,20 @@
+ 
+       /* Summ errors for each block. */
+       if ( MBlockDispFrags[0] ) {
+-        Error = GetSumAbsDiffs( SrcPtr[0], CandidateBlockPtr,
+-                             PixelsPerLine, Error);
++        Error += dsp_static_sad8x8 (SrcPtr[0], PixelsPerLine, CandidateBlockPtr,
++                             PixelsPerLine + STRIDE_EXTRA);
+       }
+       if ( MBlockDispFrags[1] ){
+-        Error = GetSumAbsDiffs( SrcPtr[1], CandidateBlockPtr + 8,
+-                             PixelsPerLine, Error);
++        Error += dsp_static_sad8x8 (SrcPtr[1], PixelsPerLine, CandidateBlockPtr + 8,
++                             PixelsPerLine + STRIDE_EXTRA);
+       }
+       if ( MBlockDispFrags[2] ){
+-        Error = GetSumAbsDiffs( SrcPtr[2], CandidateBlockPtr + RefRow2Offset,
+-                             PixelsPerLine, Error);
++        Error += dsp_static_sad8x8 (SrcPtr[2], PixelsPerLine, CandidateBlockPtr + RefRow2Offset,
++                             PixelsPerLine + STRIDE_EXTRA);
+       }
+       if ( MBlockDispFrags[3] ){
+-        Error = GetSumAbsDiffs( SrcPtr[3], CandidateBlockPtr + RefRow2Offset + 8,
+-                             PixelsPerLine, Error);
++        Error += dsp_static_sad8x8 (SrcPtr[3], PixelsPerLine, CandidateBlockPtr + RefRow2Offset + 8,
++                             PixelsPerLine + STRIDE_EXTRA);
+       }
+ 
+       /* Was this the best so far */
+@@ -808,6 +622,8 @@
+   InterMVError = GetMBInterError( cpi, cpi-&gt;ConvDestBuffer, RefFramePtr,
+                                   FragIndex, MV-&gt;x, MV-&gt;y, PixelsPerLine );
+ 
++  dsp_static_restore_fpu ();
++
+   /* Return score of best matching block. */
+   return InterMVError;
+ }
+@@ -850,8 +666,8 @@
+ 
+     for ( j = 0; j &lt; (ogg_int32_t)MAX_MV_EXTENT; j++ ){
+       /* Get the block error score. */
+-      Error = GetSumAbsDiffs( SrcPtr, CandidateBlockPtr,
+-                           PixelsPerLine, 0);
++      Error = dsp_static_sad8x8 (SrcPtr, PixelsPerLine, CandidateBlockPtr,
++                             PixelsPerLine + STRIDE_EXTRA);
+ 
+       /* Was this the best so far */
+       if ( Error &lt; MinError ) {
+@@ -911,6 +727,8 @@
+                                         MOTION_VECTOR *MV ) {
+   ogg_uint32_t  InterMVError;
+ 
++  dsp_static_save_fpu ();
++
+   /* For the moment the 4MV mode is only deemd to be valid if all four
+      Y blocks are to be updated */
+   /* This May be adapted later. */
+@@ -941,6 +759,8 @@
+     InterMVError = HUGE_ERROR;
+   }
+ 
++  dsp_static_restore_fpu ();
++
+   /* Return score of best matching block. */
+   return InterMVError;
+ }
+diff -Naur libtheora-1.0alpha3/lib/pp.c libtheora-1.0alpha3.mmx/lib/pp.c
+--- libtheora-1.0alpha3/lib/pp.c	2003-12-03 09:59:41.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/pp.c	2004-10-06 17:48:22.545380976 +0200
+@@ -19,6 +19,7 @@
+ #include &lt;string.h&gt;
+ #include &quot;encoder_internal.h&quot;
+ #include &quot;pp.h&quot;
++#include &quot;dsp.h&quot;
+ 
+ #define MAX(a, b) ((a&gt;b)?a:b)
+ #define MIN(a, b) ((a&lt;b)?a:b)
+@@ -490,7 +491,7 @@
+ 
+       } else {
+ 
+-        CopyBlock(SrcPtr + 8 * col, DestPtr + 8 * col, LineLength);
++        dsp_static_copy8x8(SrcPtr + 8 * col, DestPtr + 8 * col, LineLength);
+ 
+       }
+ 
+@@ -529,7 +530,7 @@
+         DeringBlockWeak(SrcPtr + 8 * col, DestPtr + 8 * col,
+                         LineLength,Quality,QuantScale);
+       }else{
+-        CopyBlock(SrcPtr + 8 * col, DestPtr + 8 * col, LineLength);
++        dsp_static_copy8x8(SrcPtr + 8 * col, DestPtr + 8 * col, LineLength);
+       }
+ 
+       ++Block;
+@@ -565,7 +566,7 @@
+         DeringBlockWeak(SrcPtr + 8 * col, DestPtr + 8 * col,
+                         LineLength,Quality,QuantScale);
+       }else{
+-        CopyBlock(SrcPtr + 8 * col, DestPtr + 8 * col, LineLength);
++        dsp_static_copy8x8(SrcPtr + 8 * col, DestPtr + 8 * col, LineLength);
+       }
+ 
+       ++Block;
+@@ -913,7 +914,7 @@
+ }
+ 
+ void PostProcess(PB_INSTANCE *pbi){
+-
++  dsp_static_save_fpu ();
+   switch (pbi-&gt;PostProcessingLevel){
+   case 8:
+     /* on a slow machine, use a simpler and faster deblocking filter */
+@@ -947,5 +948,6 @@
+     DeringFrame(pbi, pbi-&gt;PostProcessBuffer, pbi-&gt;PostProcessBuffer);
+     break;
+   }
++  dsp_static_restore_fpu ();
+ }
+ 
+diff -Naur libtheora-1.0alpha3/lib/reconstruct.c libtheora-1.0alpha3.mmx/lib/reconstruct.c
+--- libtheora-1.0alpha3/lib/reconstruct.c	2003-12-03 09:59:41.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/reconstruct.c	2004-10-06 17:48:22.574376568 +0200
+@@ -16,12 +16,28 @@
+  ********************************************************************/
+ 
+ #include &quot;encoder_internal.h&quot;
++#include &quot;dsp.h&quot;
++#include &quot;cpu.h&quot;
+ 
+-void ReconIntra( PB_INSTANCE *pbi, unsigned char * ReconPtr,
+-                 ogg_int16_t * ChangePtr, ogg_uint32_t LineStep ) {
++static void copy8x8__c (unsigned char *src,
++	                unsigned char *dest,
++	                unsigned int stride)
++{
++  int j;
++  for ( j = 0; j &lt; 8; j++ ){
++    ((ogg_uint32_t*)dest)[0] = ((ogg_uint32_t*)src)[0];
++    ((ogg_uint32_t*)dest)[1] = ((ogg_uint32_t*)src)[1];
++    src+=stride;
++    dest+=stride;
++  }
++}
++
++static void recon_intra8x8__c (unsigned char *ReconPtr, ogg_int16_t *ChangePtr,
++		      ogg_uint32_t LineStep)
++{
+   ogg_uint32_t i;
+ 
+-  for ( i = 0; i &lt; BLOCK_HEIGHT_WIDTH; i++ ){
++  for (i = 8; i; i--){
+     /* Convert the data back to 8 bit unsigned */
+     /* Saturate the output to unsigend 8 bit values */
+     ReconPtr[0] = clamp255( ChangePtr[0] + 128 );
+@@ -34,17 +50,16 @@
+     ReconPtr[7] = clamp255( ChangePtr[7] + 128 );
+ 
+     ReconPtr += LineStep;
+-    ChangePtr += BLOCK_HEIGHT_WIDTH;
++    ChangePtr += 8;
+   }
+-
+ }
+ 
+-void ReconInter( PB_INSTANCE *pbi, unsigned char * ReconPtr,
+-                 unsigned char * RefPtr, ogg_int16_t * ChangePtr,
+-                 ogg_uint32_t LineStep ) {
++static void recon_inter8x8__c (unsigned char *ReconPtr, unsigned char *RefPtr,
++		      ogg_int16_t *ChangePtr, ogg_uint32_t LineStep)
++{
+   ogg_uint32_t i;
+ 
+-  for ( i = 0; i &lt; BLOCK_HEIGHT_WIDTH; i++) {
++  for (i = 8; i; i--){
+     ReconPtr[0] = clamp255(RefPtr[0] + ChangePtr[0]);
+     ReconPtr[1] = clamp255(RefPtr[1] + ChangePtr[1]);
+     ReconPtr[2] = clamp255(RefPtr[2] + ChangePtr[2]);
+@@ -54,19 +69,19 @@
+     ReconPtr[6] = clamp255(RefPtr[6] + ChangePtr[6]);
+     ReconPtr[7] = clamp255(RefPtr[7] + ChangePtr[7]);
+ 
+-    ChangePtr += BLOCK_HEIGHT_WIDTH;
++    ChangePtr += 8;
+     ReconPtr += LineStep;
+     RefPtr += LineStep;
+   }
+-
+ }
+ 
+-void ReconInterHalfPixel2( PB_INSTANCE *pbi, unsigned char * ReconPtr,
+-                           unsigned char * RefPtr1, unsigned char * RefPtr2,
+-                           ogg_int16_t * ChangePtr, ogg_uint32_t LineStep ) {
++static void recon_inter8x8_half__c (unsigned char *ReconPtr, unsigned char *RefPtr1,
++		           unsigned char *RefPtr2, ogg_int16_t *ChangePtr,
++			   ogg_uint32_t LineStep)
++{
+   ogg_uint32_t  i;
+ 
+-  for ( i = 0; i &lt; BLOCK_HEIGHT_WIDTH; i++ ){
++  for (i = 8; i; i--){
+     ReconPtr[0] = clamp255((((int)RefPtr1[0] + (int)RefPtr2[0]) &gt;&gt; 1) + ChangePtr[0] );
+     ReconPtr[1] = clamp255((((int)RefPtr1[1] + (int)RefPtr2[1]) &gt;&gt; 1) + ChangePtr[1] );
+     ReconPtr[2] = clamp255((((int)RefPtr1[2] + (int)RefPtr2[2]) &gt;&gt; 1) + ChangePtr[2] );
+@@ -76,10 +91,20 @@
+     ReconPtr[6] = clamp255((((int)RefPtr1[6] + (int)RefPtr2[6]) &gt;&gt; 1) + ChangePtr[6] );
+     ReconPtr[7] = clamp255((((int)RefPtr1[7] + (int)RefPtr2[7]) &gt;&gt; 1) + ChangePtr[7] );
+ 
+-    ChangePtr += BLOCK_HEIGHT_WIDTH;
++    ChangePtr += 8;
+     ReconPtr += LineStep;
+     RefPtr1 += LineStep;
+     RefPtr2 += LineStep;
+   }
++}
+ 
++void dsp_recon_init (DspFunctions *funcs)
++{
++  funcs-&gt;copy8x8 = copy8x8__c;
++  funcs-&gt;recon_intra8x8 = recon_intra8x8__c;
++  funcs-&gt;recon_inter8x8 = recon_inter8x8__c;
++  funcs-&gt;recon_inter8x8_half = recon_inter8x8_half__c;
++  if (cpu_flags &amp; CPU_X86_MMX) {
++    dsp_i386_mmx_recon_init(&amp;dsp_funcs);
++  }
+ }
+diff -Naur libtheora-1.0alpha3/lib/scan.c libtheora-1.0alpha3.mmx/lib/scan.c
+--- libtheora-1.0alpha3/lib/scan.c	2003-12-03 09:59:41.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/scan.c	2004-10-06 17:48:22.609371248 +0200
+@@ -19,9 +19,20 @@
+ #include &lt;math.h&gt;
+ #include &lt;string.h&gt;
+ #include &quot;encoder_internal.h&quot;
++#include &quot;dsp.h&quot;
+ 
+ #define MAX_SEARCH_LINE_LEN                   7
+ 
++#define SET8_0(ptr) \
++  ((ogg_uint32_t *)ptr)[0] = 0x00000000; \
++  ((ogg_uint32_t *)ptr)[1] = 0x00000000;
++#define SET8_1(ptr) \
++  ((ogg_uint32_t *)ptr)[0] = 0x01010101; \
++  ((ogg_uint32_t *)ptr)[1] = 0x01010101;
++#define SET8_8(ptr) \
++  ((ogg_uint32_t *)ptr)[0] = 0x08080808; \
++  ((ogg_uint32_t *)ptr)[1] = 0x08080808;
++
+ static ogg_uint32_t LineLengthScores[ MAX_SEARCH_LINE_LEN + 1 ] = {
+   0, 0, 0, 0, 2, 4, 12, 24
+ };
+@@ -384,69 +395,6 @@
+   ppi-&gt;KFIndicator = ((ppi-&gt;KFIndicator*100)/((ppi-&gt;ScanYPlaneFragments*3)/4));
+ }
+ 
+-static ogg_uint32_t ScalarRowSAD( unsigned char * Src1,
+-                                  unsigned char * Src2 ){
+-  ogg_uint32_t SadValue;
+-  ogg_uint32_t SadValue1;
+-
+-  SadValue    = abs( Src1[0] - Src2[0] ) + abs( Src1[1] - Src2[1] ) +
+-    abs( Src1[2] - Src2[2] ) + abs( Src1[3] - Src2[3] );
+-
+-  SadValue1   = abs( Src1[4] - Src2[4] ) + abs( Src1[5] - Src2[5] ) +
+-    abs( Src1[6] - Src2[6] ) + abs( Src1[7] - Src2[7] );
+-
+-  SadValue = ( SadValue &gt; SadValue1 ) ? SadValue : SadValue1;
+-
+-  return SadValue;
+-}
+-
+-static ogg_uint32_t ScalarColSAD( PP_INSTANCE *ppi,
+-                           unsigned char * Src1,
+-                           unsigned char * Src2 ){
+-  ogg_uint32_t SadValue[8] = {0,0,0,0,0,0,0,0};
+-  ogg_uint32_t SadValue2[8] = {0,0,0,0,0,0,0,0};
+-  ogg_uint32_t MaxSad = 0;
+-  ogg_uint32_t i;
+-
+-  for ( i = 0; i &lt; 4; i++ ){
+-    SadValue[0] += abs(Src1[0] - Src2[0]);
+-    SadValue[1] += abs(Src1[1] - Src2[1]);
+-    SadValue[2] += abs(Src1[2] - Src2[2]);
+-    SadValue[3] += abs(Src1[3] - Src2[3]);
+-    SadValue[4] += abs(Src1[4] - Src2[4]);
+-    SadValue[5] += abs(Src1[5] - Src2[5]);
+-    SadValue[6] += abs(Src1[6] - Src2[6]);
+-    SadValue[7] += abs(Src1[7] - Src2[7]);
+-
+-    Src1 += ppi-&gt;PlaneStride;
+-    Src2 += ppi-&gt;PlaneStride;
+-  }
+-
+-  for ( i = 0; i &lt; 4; i++ ){
+-    SadValue2[0] += abs(Src1[0] - Src2[0]);
+-    SadValue2[1] += abs(Src1[1] - Src2[1]);
+-    SadValue2[2] += abs(Src1[2] - Src2[2]);
+-    SadValue2[3] += abs(Src1[3] - Src2[3]);
+-    SadValue2[4] += abs(Src1[4] - Src2[4]);
+-    SadValue2[5] += abs(Src1[5] - Src2[5]);
+-    SadValue2[6] += abs(Src1[6] - Src2[6]);
+-    SadValue2[7] += abs(Src1[7] - Src2[7]);
+-
+-    Src1 += ppi-&gt;PlaneStride;
+-    Src2 += ppi-&gt;PlaneStride;
+-  }
+-
+-  for ( i = 0; i &lt; 8; i++ ){
+-    if ( SadValue[i] &gt; MaxSad )
+-      MaxSad = SadValue[i];
+-    if ( SadValue2[i] &gt; MaxSad )
+-      MaxSad = SadValue2[i];
+-  }
+-
+-  return MaxSad;
+-}
+-
+-
+ static int RowSadScan( PP_INSTANCE *ppi,
+                        unsigned char * YuvPtr1,
+                        unsigned char * YuvPtr2,
+@@ -475,7 +423,7 @@
+     for ( i = 0; i &lt; ppi-&gt;PlaneHFragments; i ++ ){
+       if ( *LocalDispFragPtr &lt;= BLOCK_NOT_CODED ){
+         /* Calculate the SAD score for the block row */
+-        GrpSad = ScalarRowSAD(LocalYuvPtr1,LocalYuvPtr2);
++        GrpSad = dsp_static_row_sad8(LocalYuvPtr1,LocalYuvPtr2);
+ 
+         /* Now test the group SAD score */
+         if ( GrpSad &gt; LocalGrpLowSadThresh ){
+@@ -532,7 +480,7 @@
+     /* Skip if block already marked to be coded. */
+     if ( *LocalDispFragPtr &lt;= BLOCK_NOT_CODED ){
+       /* Calculate the SAD score for the block column */
+-      MaxSad = ScalarColSAD( ppi, LocalYuvPtr1, LocalYuvPtr2 );
++      MaxSad = dsp_static_col_sad8x8(LocalYuvPtr1, LocalYuvPtr2, ppi-&gt;PlaneStride );
+ 
+       /* Now test the group SAD score */
+       if ( MaxSad &gt; LocalGrpLowSadThresh ){
+@@ -758,7 +706,7 @@
+       if (*DispFragPtr == CANDIDATE_BLOCK){
+ 
+         /* Clear down entries in changed locals array */
+-        memset(ChLocalsPtr,0,8);
++        SET8_0(ChLocalsPtr);
+ 
+         for ( j = 0; j &lt; HFRAGPIXELS; j++ ){
+           /* Take a local copy of the measured difference. */
+@@ -777,10 +725,10 @@
+       }else{
+         /* If we are breaking out here mark all pixels as changed. */
+         if ( *DispFragPtr &gt; BLOCK_NOT_CODED ){
+-          memset(bits_map_ptr,1,8);
+-          memset(ChLocalsPtr,8,8);
++          SET8_1(bits_map_ptr);
++          SET8_8(ChLocalsPtr);
+         }else{
+-          memset(ChLocalsPtr,0,8);
++          SET8_0(ChLocalsPtr);
+         }
+       }
+ 
+@@ -816,7 +764,7 @@
+     /* Test for break out conditions to save time. */
+     if (*DispFragPtr == CANDIDATE_BLOCK){
+       /* Clear down entries in changed locals array */
+-      memset(ChLocalsPtr,0,8);
++      SET8_0(ChLocalsPtr);
+ 
+       for ( j = 0; j &lt; HFRAGPIXELS; j++ ){
+         /* Take a local copy of the measured difference. */
+@@ -839,10 +787,10 @@
+     }else{
+       /* If we are breaking out here mark all pixels as changed. */
+       if ( *DispFragPtr &gt; BLOCK_NOT_CODED ){
+-        memset(bits_map_ptr,1,8);
+-        memset(ChLocalsPtr,8,8);
++        SET8_1(bits_map_ptr);
++        SET8_8(ChLocalsPtr);
+       }else{
+-        memset(ChLocalsPtr,0,8);
++        SET8_0(ChLocalsPtr);
+       }
+     }
+ 
+@@ -876,7 +824,7 @@
+       /* Test for break out conditions to save time. */
+       if (*DispFragPtr == CANDIDATE_BLOCK){
+         /* Clear down entries in changed locals array */
+-        memset(ChLocalsPtr,0,8);
++        SET8_0(ChLocalsPtr);
+         for ( j = 0; j &lt; HFRAGPIXELS; j++ ){
+           /* Take a local copy of the measured difference. */
+           Diff = (int)YuvPtr1[j] - (int)YuvPtr2[j];
+@@ -899,10 +847,10 @@
+       }else{
+         /* If we are breaking out here mark all pixels as changed. */
+         if ( *DispFragPtr &gt; BLOCK_NOT_CODED ){
+-          memset(bits_map_ptr,1,8);
+-          memset(ChLocalsPtr,8,8);
++          SET8_1(bits_map_ptr);
++          SET8_8(ChLocalsPtr);
+         }else{
+-          memset(ChLocalsPtr,0,8);
++          SET8_0(ChLocalsPtr);
+         }
+       }
+ 
+@@ -935,7 +883,7 @@
+     /* Test for break out conditions to save time. */
+     if (*DispFragPtr == CANDIDATE_BLOCK){
+       /* Clear down entries in changed locals array */
+-      memset(ChLocalsPtr,0,8);
++      SET8_0(ChLocalsPtr);
+ 
+       for ( j = 0; j &lt; HFRAGPIXELS; j++ ){
+         /* Take a local copy of the measured difference. */
+@@ -959,10 +907,10 @@
+     }else{
+       /* If we are breaking out here mark all pixels as changed.*/
+       if ( *DispFragPtr &gt; BLOCK_NOT_CODED ) {
+-          memset(bits_map_ptr,1,8);
+-          memset(ChLocalsPtr,8,8);
++          SET8_1(bits_map_ptr);
++          SET8_8(ChLocalsPtr);
+         }else{
+-          memset(ChLocalsPtr,0,8);
++          SET8_0(ChLocalsPtr);
+         }
+     }
+     /* If we have a lot of changed pixels for this fragment on this
+@@ -1071,7 +1019,7 @@
+         }
+       }else{
+         if ( *DispFragPtr &gt; BLOCK_NOT_CODED )
+-          memset(ChLocalsPtr,0,8);
++          SET8_0(ChLocalsPtr);
+ 
+         /* Step pointers */
+         ChLocalsPtr += HFRAGPIXELS;
+@@ -1133,7 +1081,7 @@
+         }
+       }else{
+         if ( *DispFragPtr &gt; BLOCK_NOT_CODED )
+-          memset(ChLocalsPtr,0,8);
++          SET8_0(ChLocalsPtr);
+ 
+         /* Step pointers */
+         ChLocalsPtr += HFRAGPIXELS;
+@@ -2126,10 +2074,12 @@
+     /* Fast break out test for obvious yes and no cases in this row of
+        blocks */
+     if ( i &lt; ppi-&gt;PlaneVFragments ){
++      dsp_static_save_fpu ();
+       UpdatedOrCandidateBlocks =
+         RowSadScan( ppi, RawPlanePtr0, RawPlanePtr1, DispFragPtr0 );
+-      if( ColSadScan( ppi, RawPlanePtr0, RawPlanePtr1, DispFragPtr0 ) )
+-        UpdatedOrCandidateBlocks = 1;
++      UpdatedOrCandidateBlocks |=
++        ColSadScan( ppi, RawPlanePtr0, RawPlanePtr1, DispFragPtr0 );
++      dsp_static_restore_fpu ();
+     }else{
+       /* Make sure we still call other functions if RowSadScan() disabled */
+       UpdatedOrCandidateBlocks = 1;
+diff -Naur libtheora-1.0alpha3/lib/toplevel.c libtheora-1.0alpha3.mmx/lib/toplevel.c
+--- libtheora-1.0alpha3/lib/toplevel.c	2004-03-18 03:00:30.000000000 +0100
++++ libtheora-1.0alpha3.mmx/lib/toplevel.c	2004-10-06 17:48:22.611370944 +0200
+@@ -787,6 +787,8 @@
+ 
+   CP_INSTANCE *cpi;
+ 
++  dsp_static_init ();
++
+   memset(th, 0, sizeof(*th));
+   th-&gt;internal_encode=cpi=_ogg_calloc(1,sizeof(*cpi));
+ 
+@@ -1446,6 +1448,8 @@
+   PB_INSTANCE *pbi;
+   codec_setup_info *ci;
+ 
++  dsp_static_init ();
++
+   ci=(codec_setup_info *)c-&gt;codec_setup;
+   th-&gt;internal_decode=pbi=_ogg_calloc(1,sizeof(*pbi));
+ 

Modified: trunk/rpms/libtheora/libtheora.spec
===================================================================
--- trunk/rpms/libtheora/libtheora.spec	2004-10-25 11:47:23 UTC (rev 2308)
+++ trunk/rpms/libtheora/libtheora.spec	2004-10-25 11:48:41 UTC (rev 2309)
@@ -6,15 +6,20 @@
 Summary: Theora video compression codec
 Name: libtheora
 Version: 1.0
-Release: %{?prever:0.%{prever}.}2
+Release: %{?prever:0.%{prever}.}4
 License: BSD
 URL: <A HREF="http://www.theora.org/">http://www.theora.org/</A>
 Source: <A HREF="http://www.theora.org/files/libtheora-%{version">http://www.theora.org/files/libtheora-%{version</A>}%{?prever}.tar.bz2
+Patch0: libtheora-1.0alpha3-autotools.patch
+Patch1: libtheora-1.0alpha3-mmx.patch
+Patch2: libtheora-1.0alpha3-include.patch
 Group: System Environment/Libraries
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
-BuildRequires: libogg-devel &gt;= 1.1, libvorbis-devel &gt;= 1.0.1, SDL-devel,gcc-c++
+BuildRequires: libogg-devel &gt;= 1.1, libvorbis-devel &gt;= 1.0.1, SDL-devel, gcc-c++
 # Fedora Core 2's SDL-devel forgot to require alsa-lib-devel
 %{!?_without_alsa:BuildRequires: alsa-lib-devel}
+# We patch Makefile.am, so we need to re-autotool
+BuildRequires: autoconf, automake, libtool
 
 %description
 Ogg Theora is a fully open, non-proprietary, patent-and-royalty-free,
@@ -24,43 +29,94 @@
 %package devel
 Summary: Headers for developing programs that will use libtheora
 Group: Development/Libraries
-Requires: libogg-devel &gt;= 1.0.1
+Requires: %{name} = %{version}, libogg-devel &gt;= 1.1
 
 %description devel
 This package contains the headers that programmers will need to develop
 applications which will use %{name}.
 
 
+%package -n theora-tools
+Summary: Command line tools for Theora videos
+Group: Applications/Multimedia
+Requires: %{name} = %{version}
+
+%description -n theora-tools
+The theora-tools package contains simple command line tools for use
+with theora bitstreams.
+
+
 %prep
 %setup -n %{name}-%{version}%{?prever}
+%patch0 -p1 -b .autotools
+%patch1 -p1 -b .mmx
+%patch2 -p1 -b .include
 
 
 %build
+# autoreconf or autogen.sh doesn't work, due to wrong libtool.m4
+aclocal
+autoconf
+libtoolize --force
+automake
 %configure \
-    --includedir=&quot;%{_includedir}/theora&quot; \
+    --enable-shared \
+    --enable-static \
     --with-pic
 %{__make} %{?_smp_mflags}
 
 
 %install
-%{__rm} -rf %{buildroot} installed-docs
-%makeinstall includedir=&quot;%{buildroot}%{_includedir}/theora&quot;
-%{__mv} %{buildroot}%{_datadir}/doc/libtheora* installed-docs
+%{__rm} -rf %{buildroot} _docs
+%makeinstall \
+    docdir=$(pwd)/_docs
 
+# Manually install tools
+%{__install} -m 0755 examples/.libs/dump_video \
+    %{buildroot}%{_bindir}/theora_dump_video
+%{__install} -m 0755 examples/.libs/encoder_example \
+    %{buildroot}%{_bindir}/theora_encode
+%{__install} -m 0755 examples/.libs/player_example
+    %{buildroot}%{_bindir}/theora_player
 
+
 %clean
 %{__rm} -rf %{buildroot}
 
 
+%post
+/sbin/ldconfig
+
+%postun
+/sbin/ldconfig
+
+
+%files
+%defattr(-, root, root, 0755)
+%doc README COPYING
+%{_libdir}/libtheora.so.*
+
 %files devel
 %defattr(-, root, root, 0755)
-%doc README COPYING installed-docs/*
+%doc _docs/*
 %{_includedir}/theora/
+%{_libdir}/libtheora.a
 %exclude %{_libdir}/libtheora.la
-%{_libdir}/libtheora.a
+%{_libdir}/libtheora.so
 
+%files -n theora-tools
+%defattr(-, root, root, 0755)
+%{_bindir}/*
 
+
 %changelog
+* Mon Oct 25 2004 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 1.0-0.alpha3.4
+- Include autotools and mmx patches from Thomasvs' GStreamer package.
+- Added theora-tools package to do like the main Fedora Core package.
+
+* Wed Sep 22 2004 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 1.0-0.alpha3.3
+- Enable shared library.
+
 * Tue Jul  6 2004 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 1.0-0.alpha3.2
 - Added --with-pic for x86_64 build.
 - Simplified setting of the proper include dir.

Modified: trunk/rpms/xmame/xmame.spec
===================================================================
--- trunk/rpms/xmame/xmame.spec	2004-10-25 11:47:23 UTC (rev 2308)
+++ trunk/rpms/xmame/xmame.spec	2004-10-25 11:48:41 UTC (rev 2309)
@@ -4,12 +4,16 @@
 #define rcver rc2
 %define targets %{?!_without_mame:mame} %{?!_without_mess:mess}
 
+%{!?_without_opengl: %{expand %%define opengl true}}
+%ifarch %{ix86}
+%{!?_without_3dfx:   %{expand %%define 3dfx true}}
+%endif
+
 Summary: The X Multi Arcade Machine Emulator
 Name: xmame
-Version: 0.87
+Version: 0.87cvs
 Release: %{?rcver:0.%{rcver}.}1
 Source0: <A HREF="http://x.mame.net/download/xmame-%{version">http://x.mame.net/download/xmame-%{version</A>}%{?rcver:-%{rcver}}.tar.bz2
-Source1: xmame.wrapper
 # <A HREF="http://cheat.retrogames.com/">http://cheat.retrogames.com/</A> 0.81 - 21/04/2004
 Source20: <A HREF="http://cheat.retrogames.com/cheat.zip">http://cheat.retrogames.com/cheat.zip</A>
 # <A HREF="http://www.mameworld.net/highscore/">http://www.mameworld.net/highscore/</A> 0.87 - 25/07/2004
@@ -24,8 +28,11 @@
 URL: <A HREF="http://x.mame.net/">http://x.mame.net/</A>
 Group: Applications/Emulators
 BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
-Requires: %{name}-bin = %{version}
-BuildRequires: unzip, XFree86-devel, zlib-devel
+Obsoletes: %{name}-x11 &lt;= 0.87
+Obsoletes: %{name}-xgl &lt;= 0.87
+BuildRequires: unzip, XFree86-devel, zlib-devel, expat-devel
+%{?opengl:BuildRequires: Mesa-devel, libjpeg-devel}
+%{?3dfx:BuildRequires: Glide3-devel}
 %{!?_without_alsa:BuildRequires: alsa-lib-devel}
 %{!?_without_esound:BuildRequires: esound-devel}
 %{!?_without_arts:BuildRequires: arts-devel}
@@ -45,58 +52,33 @@
 a package containing the main xmame binary though, from either the basic
 x11 version, the SDL version or the special OpenGL xgl version.
 
+This version has been compiled for X11 DGA and XV, and OpenGL displays.
+
 Available rpmbuild rebuild options :
---without mame mess x11 xgl SDL asm68000 mips3 mmxasm
+--without mame mess asm68000 mips3 effmmx opengl 3dfx
           alsa esound arts opts quietbuild
 
 
-%package x11
-Summary: X-Mame arcade game emulator compiled for X11 DGA or XV display
-Group: Applications/Emulators
-Provides: %{name}-bin = %{version}
+#package SDL
+#Summary: X-Mame arcade game emulator compiled for SDL display
+#Group: Applications/Emulators
+#Provides: %{name}-bin = %{version}
+#BuildRequires: SDL-devel
+#
+#description SDL
+#This the the *nix port of the almost legendary mame. Mame is an arcade
+#machine emulator, started in 1997 by Nicola Salmoria. It started out as a
+#series of emulators for individual games. This series of emulators was
+#combined into a single multi-game emulator.
+#
+#This version has been compiled for SDL display.
 
-%description x11
-This the the *nix port of the almost legendary mame. Mame is an arcade
-machine emulator, started in 1997 by Nicola Salmoria. It started out as a
-series of emulators for individual games. This series of emulators was
-combined into a single multi-game emulator.
 
-This version has been compiled for X11 DGA and XV displays.
-
-
-%package SDL
-Summary: X-Mame arcade game emulator compiled for SDL display
-Group: Applications/Emulators
-Provides: %{name}-bin = %{version}
-BuildRequires: SDL-devel
-
-%description SDL
-This the the *nix port of the almost legendary mame. Mame is an arcade
-machine emulator, started in 1997 by Nicola Salmoria. It started out as a
-series of emulators for individual games. This series of emulators was
-combined into a single multi-game emulator.
-
-This version has been compiled for SDL display.
-
-
-%package xgl
-Summary: X-Mame arcade game emulator compiled for OpenGL display
-Group: Applications/Emulators
-Provides: %{name}-bin = %{version}
-BuildRequires: Mesa-devel, libjpeg-devel
-
-%description xgl
-This the the *nix port of the almost legendary mame. Mame is an arcade
-machine emulator, started in 1997 by Nicola Salmoria. It started out as a
-series of emulators for individual games. This series of emulators was
-combined into a single multi-game emulator.
-
-This version has been compiled for OpenGL display.
-
-
 %package -n xmess
 Summary: The Multi Emulator Super System
 Group: Applications/Emulators
+Obsoletes: mess-x11 &lt;= 0.87
+Obsoletes: mess-xgl &lt;= 0.87
 
 %description -n xmess
 This is the *nix port of MESS. MESS is a free emulator which emulates a
@@ -105,53 +87,35 @@
 see <A HREF="http://www.mess.org/">http://www.mess.org/</A>
 
 
-%package -n xmess-x11
-Summary: The Multi Emulator Super System compiled for X11 DGA or XV display
-Group: Applications/Emulators
+#package -n xmess-SDL
+#Summary: The Multi Emulator Super System compiled for SDL display
+#Group: Applications/Emulators
+#BuildRequires: SDL-devel
+#
+#description -n xmess-SDL
+#This is the *nix port of MESS. MESS is a free emulator which emulates a
+#large variety of different systems, including old Atari, Apple, BBC,
+#Commodore, MSX, ZX Spectrum computers. For full list of supported systems
+#see <A HREF="http://www.mess.org/">http://www.mess.org/</A>
+#
+#This version has been compiled for SDL display.
 
-%description -n xmess-x11
-This is the *nix port of MESS. MESS is a free emulator which emulates a
-large variety of different systems, including old Atari, Apple, BBC,
-Commodore, MSX, ZX Spectrum computers. For full list of supported systems
-see <A HREF="http://www.mess.org/">http://www.mess.org/</A>
 
-This version has been compiled for X11 DGA or XV display.
-
-
-%package -n xmess-SDL
-Summary: The Multi Emulator Super System compiled for SDL display
-Group: Applications/Emulators
-BuildRequires: SDL-devel
-
-%description -n xmess-SDL
-This is the *nix port of MESS. MESS is a free emulator which emulates a
-large variety of different systems, including old Atari, Apple, BBC,
-Commodore, MSX, ZX Spectrum computers. For full list of supported systems
-see <A HREF="http://www.mess.org/">http://www.mess.org/</A>
-
-This version has been compiled for SDL display.
-
-
-%package -n xmess-xgl
-Summary: The Multi Emulator Super System compiled for OpenGL display
-Group: Applications/Emulators
-BuildRequires: Mesa-devel, libjpeg-devel
-
-%description -n xmess-xgl
-This is the *nix port of MESS. MESS is a free emulator which emulates a
-large variety of different systems, including old Atari, Apple, BBC,
-Commodore, MSX, ZX Spectrum computers. For full list of supported systems
-see <A HREF="http://www.mess.org/">http://www.mess.org/</A>
-
-This version has been compiled for OpenGL display.
-
-
 %prep
 %setup -n %{name}-%{version}%{?rcver:-%{rcver}}
 
 
 %build
-test -e Makefile || %{__cp} -a makefile.unix Makefile
+%{__rm} -f makefile Makefile; %{__cp} -a makefile.unix Makefile
+
+# For CVS snapshots, there are empty instead of symlinks, so fix that
+for dir in contrib doc; do
+    if test -d ${dir}; then
+        %{__rm} -rf ${dir}
+        %{__ln_s} src/unix/${dir}
+    fi
+done
+
 # Comment out the defaults, to enable overriding with the env variables
 %{__perl} -pi -e 's/^CFLAGS/# CFLAGS/g' Makefile
 %{__perl} -pi -e 's/^MY_CPU/# MY_CPU/g' Makefile
@@ -159,6 +123,9 @@
 # Replace lib with lib64 when required
 %{__perl} -pi -e 's|/usr/X11R6/lib|/usr/X11R6/%{_lib}|g' Makefile
 
+# Use system expat library
+%{__perl} -pi -e 's/^BUILD_EXPAT/# BUILD_EXPAT/g' Makefile
+
 # Make the package build verbose by default (to see opts etc.)
 %{?_without_quietbuild: %{__perl} -pi -e 's/^QUIET/# QUIET/g' src/unix/unix.mak}
 
@@ -166,6 +133,7 @@
 export PREFIX=%{_prefix}
 export CFLAGS=&quot;%{optflags}&quot;
 export JOY_I386=1
+export JOY_PAD=1
 %{!?_without_alsa:export SOUND_ALSA=1}
 %{!?_without_esound:export SOUND_ESOUND=1}
 %{!?_without_arts:export SOUND_ARTS_SMOTEK=1; export SOUND_ARTS_TEIRA=1}
@@ -173,48 +141,50 @@
 # Optimization flags, CPU type and defaults for the makefile
 %ifarch %{ix86}
     export MY_CPU=&quot;i386&quot;
-    %{!?_without_opts: export CFLAGS=&quot;%{optflags} -O3 -Wall&quot;}
+    # With FC3 gcc, -mtune is preferred as -mcpu is marked obsolete
+    %{!?_without_opts: export CFLAGS=&quot;-O3 -g -pipe -march=i386 -mcpu=pentium4 -Wall -fno-merge-constants&quot;}
     %{!?_without_asm68000: export X86_ASM_68000=1}
     %{!?_without_mips3: export X86_MIPS3_DRC=1}
-    %{!?_without_mmxasm: export EFFECT_MMX_ASM=1}
+    %{!?_without_effmmx: export EFFECT_MMX_ASM=1}
 %endif
 
+%ifarch i686
+    %{!?_without_opts: export CFLAGS=&quot;-O3 -g -pipe -march=pentium4 -msse2 -mfpmath=sse -Wall -fno-merge-constants&quot;}
+%endif
+
+%ifarch athlon
+    %{!?_without_opts: export CFLAGS=&quot;-O3 -g -pipe -march=athlon-4 -msse2 -mfpmath=sse -Wall -fno-merge-constants&quot;}
+%endif
+
 %ifarch ppc
     export MY_CPU=&quot;risc&quot;
-    %{!?_without_opts: export CFLAGS=&quot;%{optflags} -O3 -Wall&quot;}
+    %{!?_without_opts: export CFLAGS=&quot;-O3 -g -pipe -march=powerpc -Wall -mlongcall -fno-merge-constants&quot;}
 %endif
 
 %ifarch x86_64
     export MY_CPU=&quot;amd64&quot;
-    %{!?_without_opts: export CFLAGS=&quot;%{optflags} -O3 -Wall&quot;}
+    %{!?_without_opts: export CFLAGS=&quot;-O3 -g -pipe -march=k8 -m64 -Wall -fno-merge-constants&quot;}
     %{!?_without_asm68000: export X86_ASM_68000=1}
     %{!?_without_mips3: export X86_MIPS3_DRC=1}
-    %{!?_without_mmxasm: export EFFECT_MMX_ASM=1}
+    %{!?_without_effmmx: export EFFECT_MMX_ASM=1}
 %endif
 
-%ifarch sparc sparcv8 sparcv9 sparc64
-    export MY_CPU=&quot;risc&quot;
-    # Sparc platform fails to compile with -O2, so override it.
-    %{!?_without_opts: export CFLAGS=&quot;%{optflags} -O -fomit-frame-pointer -funroll-loops -fstrength-reduce -ffast-math -finline-functions -fforce-mem -fforce-addr -fthread-jumps -fcse-follow-jumps -fcse-skip-blocks -frerun-cse-after-loop -felide-constructors -fexpensive-optimizations -fdelayed-branch -fschedule-insns -fschedule-insns2 -pipe&quot;}
-%endif
-
-# Prepare all the extra .dat files
-%{__mkdir} datfiles
-for file in %{SOURCE20} %{SOURCE21} %{SOURCE22} %{SOURCE23}; do
-    %{__unzip} -o -d datfiles/ $file
-done
-
 # Now, do all the building (this is long!)
 for target in %{targets}; do
-    %{!?_without_x11: %{__make} %{?_smp_mflags} DISPLAY_METHOD=x11 X11_DGA=1 X11_XV=1 TARGET=$target}
-    %{!?_without_SDL: %{__make} %{?_smp_mflags} DISPLAY_METHOD=SDL TARGET=$target}
-    %{!?_without_xgl: %{__make} %{?_smp_mflags} DISPLAY_METHOD=xgl TARGET=$target}
+    %{__make} %{?_smp_mflags} %{?opengl:X11_OPENGL=1} %{?3dfx:X11_GLIDE=1} TARGET=$target
+#   %{!?_without_SDL: %{__make} %{?_smp_mflags} DISPLAY_METHOD=SDL TARGET=$target}
 done
 
 
 %install
-%{__rm} -rf %{buildroot} _doc
+%{__rm} -rf %{buildroot} _doc _datfiles
 
+# Prepare all the extra .dat files
+%{__mkdir} _datfiles
+for file in %{SOURCE20} %{SOURCE21} %{SOURCE22} %{SOURCE23}; do
+    %{__unzip} -o -d _datfiles/ $file
+done
+
 for target in %{targets}; do
     %{__make} install-man \
         INSTALL_USER=`id -un` \
@@ -225,10 +195,8 @@
 
 %{__mkdir_p} %{buildroot}%{_bindir}
 for target in %{targets}; do
-    %{__install} -m 755 %{SOURCE1} %{buildroot}%{_bindir}/x${target}
-    %{!?_without_x11: %{__install} -m 755 x${target}.x11 %{buildroot}%{_bindir}/}
-    %{!?_without_SDL: %{__install} -m 755 x${target}.SDL %{buildroot}%{_bindir}/}
-    %{!?_without_xgl: %{__install} -m 755 x${target}.xgl %{buildroot}%{_bindir}/}
+    %{__install} -m 755 x${target}.x11 %{buildroot}%{_bindir}/x${target}
+#   %{!?_without_SDL: %{__install} -m 755 x${target}.SDL %{buildroot}%{_bindir}/}
 done
 %{?!_without_mame: %{__install} -m 755 chdman romcmp xml2info %{buildroot}%{_bindir}/}
 
@@ -241,25 +209,22 @@
     %{__cp} -a xmessrc.dist mess/* ../../../_doc/xmess/
 popd
 
-
 %if %{?_without_mame:0}%{!?_without_mame:1}
 # Add all directories
 %{__mkdir_p} %{buildroot}%{_datadir}/xmame/{artwork,roms,samples,snap}
 
 # The extra dat files
-%{__install} -m 664 datfiles/*.dat %{buildroot}%{_datadir}/xmame/
+%{__install} -m 0664 _datfiles/*.dat %{buildroot}%{_datadir}/xmame/
 
 # Install the OpenGL cabinets
 %{!?_without_xgl: %{__cp} -a src/unix/cab %{buildroot}%{_datadir}/xmame/}
 %endif
 
-
 %if %{?_without_mess:0}%{!?_without_mess:1}
 # Add all directories
 %{__mkdir_p} %{buildroot}%{_datadir}/xmess/{artwork,bios,crc,samples,snap,software}
 %endif
 
-
 # Uncompress catver.ini (will be in the docs)
 %{__unzip} -o %{SOURCE30}
 
@@ -275,10 +240,11 @@
 %doc catver.ini
 %{_bindir}/chdman
 %{_bindir}/romcmp
-%{_bindir}/xmame
+%attr(2755, root, games) %{_bindir}/xmame
 %{_bindir}/xml2info
 %dir %attr(2775, root, games) %{_datadir}/xmame
 %dir %attr(2775, root, games) %{_datadir}/xmame/artwork
+%attr(-, root, root) %{_datadir}/xmame/cab
 %dir %attr(2775, root, games) %{_datadir}/xmame/roms
 %dir %attr(2775, root, games) %{_datadir}/xmame/samples
 %dir %attr(2775, root, games) %{_datadir}/xmame/snap
@@ -286,27 +252,17 @@
 %{_mandir}/man6/xmame.6*
 %endif
 
-%if %{?_without_x11:0}%{!?_without_x11:%{?_without_mame:0}%{!?_without_mame:1}}
-%files x11
-%attr(2755, root, games) %{_bindir}/xmame.x11
-%endif
+#if %{?_without_SDL:0}%{!?_without_SDL:%{?_without_mame:0}%{!?_without_mame:1}}
+#files SDL
+#attr(2755, root, games) %{_bindir}/xmame.SDL
+#endif
 
-%if %{?_without_SDL:0}%{!?_without_SDL:%{?_without_mame:0}%{!?_without_mame:1}}
-%files SDL
-%attr(2755, root, games) %{_bindir}/xmame.SDL
-%endif
 
-%if %{?_without_xgl:0}%{!?_without_xgl:%{?_without_mame:0}%{!?_without_mame:1}}
-%files xgl
-%attr(2755, root, games) %{_bindir}/xmame.xgl
-%attr(-, root, root) %{_datadir}/xmame/cab
-%endif
-
-
 %if %{?_without_mess:0}%{!?_without_mess:1}
 %files -n xmess
 %defattr(-, root, root, 0755)
 %doc README _doc/xmess/*
+%attr(2755, root, games) %{_bindir}/xmess
 %dir %attr(2775, root, games) %{_datadir}/xmess
 %dir %attr(2775, root, games) %{_datadir}/xmess/artwork
 %dir %attr(2775, root, games) %{_datadir}/xmess/bios
@@ -314,27 +270,27 @@
 %dir %attr(2775, root, games) %{_datadir}/xmess/samples
 %dir %attr(2775, root, games) %{_datadir}/xmess/snap
 %dir %attr(2775, root, games) %{_datadir}/xmess/software
-%{_bindir}/xmess
 %{_mandir}/man6/xmess.6.*
 %endif
 
-%if %{?_without_x11:0}%{!?_without_x11:%{?_without_mess:0}%{!?_without_mess:1}}
-%files -n xmess-x11
-%attr(2755, root, games) %{_bindir}/xmess.x11
-%endif
+#if %{?_without_SDL:0}%{!?_without_SDL:%{?_without_mess:0}%{!?_without_mess:1}}
+#files -n xmess-SDL
+#attr(2755, root, games) %{_bindir}/xmess.SDL
+#endif
 
-%if %{?_without_SDL:0}%{!?_without_SDL:%{?_without_mess:0}%{!?_without_mess:1}}
-%files -n xmess-SDL
-%attr(2755, root, games) %{_bindir}/xmess.SDL
-%endif
 
-%if %{?_without_xgl:0}%{!?_without_xgl:%{?_without_mess:0}%{!?_without_mess:1}}
-%files -n xmess-xgl
-%attr(2755, root, games) %{_bindir}/xmess.xgl
-%endif
-
-
 %changelog
+* Sun Oct 24 2004 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.87cvs-1
+- Removed specific sparc opts, please report if broken.
+- Removed xgl target, as the OpenGL support is now built in the x11 one.
+- Moved the main mame/mess binary into the main pakage, remove wrapper.
+- Reworked gcc options, added some for i686 and athlon rebuilds.
+- Renamed mmxasm build option to effmmx to be more explicit.
+- Disable SDL build for now, as this way, we only have one pakage left!
+- Removed x11 DGA, does anyone use that anymore?
+- Added Glide3 support to the x11 target.
+- Added -fno-merge-constants cflag to workaround unsorted coinage errors.
+
 * Sun Oct  3 2004 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.87-1
 - Update to 0.87, with the usual related files too.
 - Now enable both aRts drivers are they can co-exist.

Deleted: trunk/rpms/xmame/xmame.wrapper
===================================================================
--- trunk/rpms/xmame/xmame.wrapper	2004-10-25 11:47:23 UTC (rev 2308)
+++ trunk/rpms/xmame/xmame.wrapper	2004-10-25 11:48:41 UTC (rev 2309)
@@ -1,14 +0,0 @@
-#!/bin/sh
-
-PROG=`basename $0`
-if [ -x /usr/bin/$PROG.xgl ]; then
-	RUN=$PROG.xgl
-elif [ -x /usr/bin/$PROG.SDL ]; then
-	RUN=$PROG.SDL
-elif [ -x /usr/bin/$PROG.x11 ]; then
-	RUN=$PROG.x11
-else
-	echo &quot;No suitable binary for $PROG found?!?&quot;
-	exit 1
-fi
-exec $RUN $*


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001114.html">[SVN] r2308 - in trunk/rpms: asterisk asterisk-sounds fftw plone	python-imaging rhythmbox rpmlint xmms-acme zope
</A></li>
	<LI>Next message: <A HREF="001116.html">[SVN] r2310 - trunk/rpms/libtheora
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1115">[ date ]</a>
              <a href="thread.html#1115">[ thread ]</a>
              <a href="subject.html#1115">[ subject ]</a>
              <a href="author.html#1115">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
