<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [SVN] r1785 - in trunk/rpms: gstreamer-ffmpeg gstreamer-plugins	gstreamer-plugins-extras
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5BSVN%5D%20r1785%20-%20in%20trunk/rpms%3A%20gstreamer-ffmpeg%20gstreamer-plugins%0A%09gstreamer-plugins-extras&In-Reply-To=%3C20040729112329.299B01FCAA%40server01.nl.egwn.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000593.html">
   <LINK REL="Next"  HREF="000595.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[SVN] r1785 - in trunk/rpms: gstreamer-ffmpeg gstreamer-plugins	gstreamer-plugins-extras</H1>
    <B>svn-commits at rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5BSVN%5D%20r1785%20-%20in%20trunk/rpms%3A%20gstreamer-ffmpeg%20gstreamer-plugins%0A%09gstreamer-plugins-extras&In-Reply-To=%3C20040729112329.299B01FCAA%40server01.nl.egwn.net%3E"
       TITLE="[SVN] r1785 - in trunk/rpms: gstreamer-ffmpeg gstreamer-plugins	gstreamer-plugins-extras">svn-commits at rpmforge.net
       </A><BR>
    <I>Thu Jul 29 13:23:29 CEST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000593.html">[SVN] r1784 - trunk/rpms/thunderbird
</A></li>
        <LI>Next message: <A HREF="000595.html">[SVN] r1786 - trunk/rpms/kannel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#594">[ date ]</a>
              <a href="thread.html#594">[ thread ]</a>
              <a href="subject.html#594">[ subject ]</a>
              <a href="author.html#594">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dude
Date: 2004-07-29 13:23:26 +0200 (Thu, 29 Jul 2004)
New Revision: 1785

Added:
   trunk/rpms/gstreamer-plugins/gst-fionread.m4
   trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.7.5-alsa.patch
   trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.8.2-alsa-fixes.patch
Removed:
   trunk/rpms/gstreamer-plugins/gst-plugins-0.4.2-pthread-includes.patch
Modified:
   trunk/rpms/gstreamer-ffmpeg/gstreamer-ffmpeg.spec
   trunk/rpms/gstreamer-plugins-extras/gstreamer-plugins-extras.spec
   trunk/rpms/gstreamer-plugins/gstreamer-plugins.spec
Log:
Updates.


Modified: trunk/rpms/gstreamer-ffmpeg/gstreamer-ffmpeg.spec
===================================================================
--- trunk/rpms/gstreamer-ffmpeg/gstreamer-ffmpeg.spec	2004-07-28 13:42:34 UTC (rev 1784)
+++ trunk/rpms/gstreamer-ffmpeg/gstreamer-ffmpeg.spec	2004-07-29 11:23:26 UTC (rev 1785)
@@ -5,23 +5,23 @@
 %define		register	%{_bindir}/gst-register-%{majorminor} &gt; /dev/null 2&gt;&amp;1 || :
 
 Name: 		%{gstreamer}-ffmpeg
-Version: 	0.8.0
+Version: 	0.8.1
 Release: 	0
 Summary: 	GStreamer FFmpeg-based streaming media framework plugin
 
 Group: 		Applications/Multimedia
 License: 	LGPL
 URL:		<A HREF="http://gstreamer.net/">http://gstreamer.net/</A>
-Source: 	<A HREF="http://freedesktop.org/~gstreamer/src/gst-ffmpeg/gst-ffmpeg-%{version">http://freedesktop.org/~gstreamer/src/gst-ffmpeg/gst-ffmpeg-%{version</A>}.tar.gz
+Source: 	<A HREF="http://gstreamer.freedesktop.org/src/gst-ffmpeg/gst-ffmpeg-%{version">http://gstreamer.freedesktop.org/src/gst-ffmpeg/gst-ffmpeg-%{version</A>}.tar.bz2
 BuildRoot:	%{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
 
 Requires(pre):	%{_bindir}/gst-register-%{majorminor}
 Requires(post):	%{_bindir}/gst-register-%{majorminor}
 Requires:	%{gstreamer}-plugins &gt;= %{gstp_minver}
 
-BuildRequires: 	%{gstreamer}-devel &gt;= %{gst_minver}
+BuildRequires:	%{gstreamer}-devel &gt;= %{gst_minver}
 # libtool needs this, sigh
-BuildRequires: 	gcc-c++
+BuildRequires:	gcc-c++
 
 # all of the FFmpeg dependencies we need to get the codecs we want
 BuildRequires:	freetype-devel
@@ -65,6 +65,7 @@
 
 %post
 %{register}
+
 %postun
 %{register}
 
@@ -73,6 +74,9 @@
 %{_libdir}/gstreamer-%{majorminor}/libgstffmpeg.so
 
 %changelog
+* Thu Jul 29 2004 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.8.1-0
+- Update to 0.8.1.
+
 * Fri May 21 2004 Thomas Vander Stichele &lt;thomas at apestaart dot org&gt;
 - 0.8.0-0.lvn.2: update for FC2 and SDL-devel not requiring alsa-lib-devel
 

Added: trunk/rpms/gstreamer-plugins/gst-fionread.m4
===================================================================
--- trunk/rpms/gstreamer-plugins/gst-fionread.m4	2004-07-28 13:42:34 UTC (rev 1784)
+++ trunk/rpms/gstreamer-plugins/gst-fionread.m4	2004-07-29 11:23:26 UTC (rev 1785)
@@ -0,0 +1,42 @@
+AC_DEFUN([GST_CHECK_FIONREAD], [
+
+  AC_MSG_CHECKING(for FIONREAD in sys/ioctl.h)
+  AC_CACHE_VAL(GST_FIONREAD_IN_SYS_IOCTL, [
+    AC_TRY_COMPILE([
+#include &lt;sys/types.h&gt;
+#include &lt;sys/ioctl.h&gt;
+], [
+int x = FIONREAD;
+if ( x )
+  return 0;
+    ], GST_FIONREAD_IN_SYS_IOCTL=&quot;yes&quot;,GST_FIONREAD_IN_SYS_IOCTL=&quot;no&quot;)
+  ])
+
+  AC_MSG_RESULT($GST_FIONREAD_IN_SYS_IOCTL)
+
+  if test &quot;$GST_FIONREAD_IN_SYS_IOCTL&quot; = &quot;yes&quot;; then
+    AC_DEFINE([HAVE_FIONREAD_IN_SYS_IOCTL], 1, [FIONREAD ioctl found in sys/ioclt.h])
+
+  else
+
+    AC_MSG_CHECKING(for FIONREAD in sys/filio.h)
+    AC_CACHE_VAL(GST_FIONREAD_IN_SYS_FILIO, [
+      AC_TRY_COMPILE([
+  #include &lt;sys/types.h&gt;
+  #include &lt;sys/filio.h&gt;
+  ], [
+  int x = FIONREAD;
+  if ( x )
+    return 0;
+      ], GST_FIONREAD_IN_SYS_FILIO=&quot;yes&quot;,GST_FIONREAD_IN_SYS_FILIO=&quot;no&quot;)
+    ])
+
+    AC_MSG_RESULT($GST_FIONREAD_IN_SYS_FILIO)
+
+    if test &quot;$GST_FIONREAD_IN_SYS_FILIO&quot; = &quot;yes&quot;; then   
+      AC_DEFINE([HAVE_FIONREAD_IN_SYS_FILIO], 1, [FIONREAD ioctl found in sys/filio.h])
+    fi
+
+  fi
+
+])

Deleted: trunk/rpms/gstreamer-plugins/gst-plugins-0.4.2-pthread-includes.patch
===================================================================

Added: trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.7.5-alsa.patch
===================================================================
--- trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.7.5-alsa.patch	2004-07-28 13:42:34 UTC (rev 1784)
+++ trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.7.5-alsa.patch	2004-07-29 11:23:26 UTC (rev 1785)
@@ -0,0 +1,20 @@
+--- gst-plugins-0.7.5/gconf/gstreamer.schemas.in.alsa	2004-03-01 09:10:40.000000000 +0100
++++ gst-plugins-0.7.5/gconf/gstreamer.schemas.in	2004-03-01 09:11:12.000000000 +0100
+@@ -5,7 +5,7 @@
+       &lt;applyto&gt;/system/<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gstreamer- at GST_MAJORMINOR</A>@/default/audiosink&lt;/applyto&gt;
+       &lt;owner&gt;gstreamer&lt;/owner&gt;
+       &lt;type&gt;string&lt;/type&gt;
+-      &lt;default&gt;osssink&lt;/default&gt;
++      &lt;default&gt;alsasink&lt;/default&gt;
+       &lt;locale name=&quot;C&quot;&gt;
+         &lt;short&gt;default GStreamer audiosink&lt;/short&gt;
+         &lt;long&gt;GStreamer can play audio using any number of output elements.  Some possible choices are osssink, esdsink and alsasink.  The audiosink can be a partial pipeline instead of just one element.&lt;/long&gt;
+@@ -27,7 +27,7 @@
+       &lt;applyto&gt;/system/<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gstreamer- at GST_MAJORMINOR</A>@/default/audiosrc&lt;/applyto&gt;
+       &lt;owner&gt;gstreamer&lt;/owner&gt;
+       &lt;type&gt;string&lt;/type&gt;
+-      &lt;default&gt;osssrc&lt;/default&gt;
++      &lt;default&gt;alsasrc&lt;/default&gt;
+       &lt;locale name=&quot;C&quot;&gt;
+         &lt;short&gt;default GStreamer audio source&lt;/short&gt;
+         &lt;long&gt;GStreamer can record audio using any number of input elements.  Some possible choices are osssrc, esdsrc and alsasrc.  The audio source can be a partial pipeline instead of just one element.&lt;/long&gt;

Added: trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.8.2-alsa-fixes.patch
===================================================================
--- trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.8.2-alsa-fixes.patch	2004-07-28 13:42:34 UTC (rev 1784)
+++ trunk/rpms/gstreamer-plugins/gstreamer-plugins-0.8.2-alsa-fixes.patch	2004-07-29 11:23:26 UTC (rev 1785)
@@ -0,0 +1,690 @@
+--- gst-plugins-0.8.2/ext/alsa/gstalsa.c	2004-06-23 08:31:58.000000000 -0400
++++ gst-plugins/ext/alsa/gstalsa.c	2004-07-14 12:13:01.000000000 -0400
+@@ -1085,7 +1085,8 @@
+       if (!(GST_FLAG_IS_SET (element, GST_ALSA_RUNNING) ||
+               gst_alsa_start_audio (this)))
+         return GST_STATE_FAILURE;
+-      this-&gt;transmitted = 0;
++      this-&gt;played = 0;
++      this-&gt;captured = 0;
+       break;
+     case GST_STATE_PAUSED_TO_PLAYING:
+       if (snd_pcm_state (this-&gt;handle) == SND_PCM_STATE_PAUSED) {
+@@ -1130,7 +1131,7 @@
+       break;
+ 
+     default:
+-      g_assert_not_reached ();
++      break;
+   }
+ 
+   if (GST_ELEMENT_CLASS (parent_class)-&gt;change_state)
+@@ -1212,6 +1213,7 @@
+       ERROR_CHECK (snd_pcm_prepare (this-&gt;handle), &quot;error preparing: %s&quot;);
+     case SND_PCM_STATE_SUSPENDED:
+     case SND_PCM_STATE_PREPARED:
++      this-&gt;captured = 0;
+       ERROR_CHECK (snd_pcm_start (this-&gt;handle), &quot;error starting playback: %s&quot;);
+       break;
+     case SND_PCM_STATE_PAUSED:
+@@ -1249,8 +1251,6 @@
+     gettimeofday (&amp;now, 0);
+     snd_pcm_status_get_trigger_tstamp (status, &amp;tstamp);
+     timersub (&amp;now, &amp;tstamp, &amp;diff);
+-    GST_INFO_OBJECT (this, &quot;alsa: xrun of at least %.3f msecs&quot;,
+-        diff.tv_sec * 1000 + diff.tv_usec / 1000.0);
+ 
+     /* if we're allowed to recover, ... */
+     if (this-&gt;autorecover) {
+@@ -1264,12 +1264,11 @@
+         this-&gt;period_count *= 2;
+       }
+     }
+-  }
+-
+-  if (!(gst_alsa_stop_audio (this) &amp;&amp; gst_alsa_start_audio (this))) {
+-    GST_ELEMENT_ERROR (this, RESOURCE, FAILED, (NULL),
+-        (&quot;Error restarting audio after xrun&quot;));
+-    return FALSE;
++    if (!(gst_alsa_stop_audio (this) &amp;&amp; gst_alsa_start_audio (this))) {
++      GST_ELEMENT_ERROR (this, RESOURCE, FAILED, (NULL),
++          (&quot;Error restarting audio after xrun&quot;));
++      return FALSE;
++    }
+   }
+ 
+   return TRUE;
+@@ -1580,6 +1579,7 @@
+       break;
+   }
+ 
++  GST_DEBUG (&quot;stopped alsa&quot;);
+   GST_FLAG_UNSET (this, GST_ALSA_RUNNING);
+   return TRUE;
+ }
+--- gst-plugins-0.8.2/ext/alsa/gstalsa.h	2004-06-23 08:31:58.000000000 -0400
++++ gst-plugins/ext/alsa/gstalsa.h	2004-07-14 12:13:01.000000000 -0400
+@@ -156,11 +156,12 @@
+ 
+   /* clocking */
+   GstAlsaClock *		clock;		/* our provided clock */
+-  snd_pcm_uframes_t		transmitted; 	/* samples transmitted since last sync 
++  snd_pcm_uframes_t		played; 	/* samples transmitted since last sync 
+ 						   This thing actually is our master clock.
+ 						   We will event insert silent samples or
+ 						   drop some to sync to incoming timestamps.
+ 						 */
++  snd_pcm_uframes_t		captured;
+   GstClockTime			max_discont;	/* max difference between current
+   						   playback timestamp and buffers timestamps
+ 						 */
+--- gst-plugins-0.8.2/ext/alsa/gstalsaplugin.c	2004-06-23 08:31:58.000000000 -0400
++++ gst-plugins/ext/alsa/gstalsaplugin.c	2004-07-14 12:13:02.000000000 -0400
+@@ -34,6 +34,7 @@
+ gst_alsa_error_wrapper (const char *file, int line, const char *function,
+     int err, const char *fmt, ...)
+ {
++#ifndef GST_DISABLE_GST_DEBUG
+   va_list args;
+   gchar *str;
+ 
+@@ -47,6 +48,7 @@
+       &quot;alsalib error: %s%s%s&quot;, str, err ? &quot;: &quot; : &quot;&quot;,
+       err ? snd_strerror (err) : &quot;&quot;);
+   g_free (str);
++#endif
+ }
+ 
+ static gboolean
+--- gst-plugins-0.8.2/ext/alsa/gstalsasink.c	2004-06-23 09:19:48.000000000 -0400
++++ gst-plugins/ext/alsa/gstalsasink.c	2004-07-14 12:13:02.000000000 -0400
+@@ -160,18 +160,21 @@
+ static inline void
+ gst_alsa_sink_flush_one_pad (GstAlsaSink * sink, gint i)
+ {
++  GST_DEBUG_OBJECT (sink, &quot;flushing pad %d&quot;, i);
+   switch (sink-&gt;behaviour[i]) {
+     case 0:
+-      if (sink-&gt;buf[i])
+-        gst_data_unref (GST_DATA (sink-&gt;buf[i]));
+-      sink-&gt;buf[i] = NULL;
+-      sink-&gt;data[i] = NULL;
++      if (sink-&gt;gst_data[i]) {
++        GST_DEBUG_OBJECT (sink, &quot;unreffing gst data %p&quot;, sink-&gt;gst_data[i]);
++        gst_data_unref (GST_DATA (sink-&gt;gst_data[i]));
++      }
++      sink-&gt;gst_data[i] = NULL;
++      sink-&gt;buf_data[i] = NULL;
+       sink-&gt;behaviour[i] = 0;
+       sink-&gt;size[i] = 0;
+       break;
+     case 1:
+-      g_free (sink-&gt;data[i]);
+-      sink-&gt;data[i] = NULL;
++      g_free (sink-&gt;buf_data[i]);
++      sink-&gt;buf_data[i] = NULL;
+       sink-&gt;behaviour[i] = 0;
+       sink-&gt;size[i] = 0;
+       break;
+@@ -196,9 +199,14 @@
+ gst_alsa_sink_check_event (GstAlsaSink * sink, gint pad_nr)
+ {
+   gboolean cont = TRUE;
+-  GstEvent *event = GST_EVENT (sink-&gt;buf[pad_nr]);
++  GstEvent *event;
+   GstAlsa *this = GST_ALSA (sink);
+ 
++  /* we get the event from our internal buffer and clear the internal one */
++  event = GST_EVENT (sink-&gt;gst_data[pad_nr]);
++  sink-&gt;gst_data[pad_nr] = 0;
++  GST_LOG_OBJECT (sink, &quot;checking event %p of type %d on sink pad %d&quot;,
++      event, GST_EVENT_TYPE (event), pad_nr);
+   if (event) {
+     switch (GST_EVENT_TYPE (event)) {
+       case GST_EVENT_EOS:
+@@ -217,16 +225,18 @@
+           break;
+         }
+         delay = (this-&gt;format == NULL) ? 0 :
+-            GST_SECOND * this-&gt;transmitted / this-&gt;format-&gt;rate -
++            GST_SECOND * this-&gt;played / this-&gt;format-&gt;rate -
+             gst_alsa_sink_get_time (this);
+         if (gst_event_discont_get_value (event, GST_FORMAT_TIME, &amp;value)) {
+-          gst_element_set_time_delay (GST_ELEMENT (this), MIN (value, delay), delay);
+-        } else if (this-&gt;format &amp;&amp;
+-            (gst_event_discont_get_value (event, GST_FORMAT_DEFAULT, &amp;value) ||
+-                gst_event_discont_get_value (event, GST_FORMAT_BYTES,
++          gst_element_set_time_delay (GST_ELEMENT (this), value,
++              MIN (value, delay));
++        } else if (this-&gt;format
++            &amp;&amp; (gst_event_discont_get_value (event, GST_FORMAT_DEFAULT, &amp;value)
++                || gst_event_discont_get_value (event, GST_FORMAT_BYTES,
+                     &amp;value))) {
+           value = gst_alsa_samples_to_timestamp (this, value);
+-          gst_element_set_time_delay (GST_ELEMENT (this), MIN (value, delay), delay);
++          gst_element_set_time_delay (GST_ELEMENT (this), value, MIN (value,
++                  delay));
+         } else {
+           GST_WARNING_OBJECT (this,
+               &quot;couldn't extract time from discont event. Bad things might happen!&quot;);
+@@ -239,8 +249,10 @@
+             GST_EVENT_TYPE (event));
+         break;
+     }
++    GST_LOG_OBJECT (sink, &quot;unreffing event %p of type %d with refcount %d&quot;,
++        event, GST_EVENT_TYPE (event), GST_DATA_REFCOUNT (event));
+     gst_event_unref (event);
+-    sink-&gt;buf[pad_nr] = NULL;
++    sink-&gt;gst_data[pad_nr] = NULL;
+   } else {
+     /* the element at the top of the chain did not emit an event. */
+     g_assert_not_reached ();
+@@ -264,14 +276,14 @@
+   if (((GstElement *) this)-&gt;numpads == 1) {
+     /* interleaved */
+     for (i = 0; i &lt; this-&gt;format-&gt;channels; i++) {
+-      src[i].addr = sink-&gt;data[0];
++      src[i].addr = sink-&gt;buf_data[0];
+       src[i].first = i * width;
+       src[i].step = this-&gt;format-&gt;channels * width;
+     }
+   } else {
+     /* noninterleaved */
+     for (i = 0; i &lt; this-&gt;format-&gt;channels; i++) {
+-      src[i].addr = sink-&gt;data[i];
++      src[i].addr = sink-&gt;buf_data[i];
+       src[i].first = 0;
+       src[i].step = width;
+     }
+@@ -307,11 +319,11 @@
+ 
+   if (((GstElement *) this)-&gt;numpads == 1) {
+     /* interleaved */
+-    err = snd_pcm_writei (this-&gt;handle, sink-&gt;data[0], *avail);
++    err = snd_pcm_writei (this-&gt;handle, sink-&gt;buf_data[0], *avail);
+   } else {
+     /* noninterleaved */
+     for (i = 0; i &lt; this-&gt;format-&gt;channels; i++) {
+-      channels[i] = sink-&gt;data[i];
++      channels[i] = sink-&gt;buf_data[i];
+     }
+     err = snd_pcm_writen (this-&gt;handle, channels, *avail);
+   }
+@@ -352,43 +364,54 @@
+     }
+ 
+     /* check how many bytes we still have in all our bytestreams */
+-    /* initialize this value to a somewhat sane state, we might alloc this much data below (which would be a bug, but who knows)... */
++    /* initialize this value to a somewhat sane state, we might alloc
++     * this much data below (which would be a bug, but who knows)... */
+     bytes = this-&gt;period_size * this-&gt;period_count * element-&gt;numpads * 8;      /* must be &gt; max sample size in bytes */
+     for (i = 0; i &lt; element-&gt;numpads; i++) {
++      GstBuffer *buf;
++
+       g_assert (this-&gt;pad[i] != NULL);
+       while (sink-&gt;size[i] == 0) {
+-        if (!sink-&gt;buf[i])
+-          sink-&gt;buf[i] = GST_BUFFER (gst_pad_pull (this-&gt;pad[i]));
+-        if (GST_IS_EVENT (sink-&gt;buf[i])) {
++        if (!sink-&gt;gst_data[i]) {
++          sink-&gt;gst_data[i] = gst_pad_pull (this-&gt;pad[i]);
++          GST_LOG_OBJECT (sink, &quot;pulled data %p from pad %d&quot;,
++              sink-&gt;gst_data[i], i);
++        }
++
++        if (GST_IS_EVENT (sink-&gt;gst_data[i])) {
++          GST_LOG_OBJECT (sink, &quot;pulled data %p is an event, checking&quot;,
++              sink-&gt;gst_data[i]);
+           if (gst_alsa_sink_check_event (sink, i))
+             continue;
+           return;
+         }
+-        /* caps nego failed somewhere */
++        /* it's a buffer */
++        g_return_if_fail (GST_IS_BUFFER (sink-&gt;gst_data[i]));
++        buf = GST_BUFFER (sink-&gt;gst_data[i]);
++        /* check if caps nego failed somewhere */
+         if (this-&gt;format == NULL) {
+           GST_ELEMENT_ERROR (this, CORE, NEGOTIATION, (NULL),
+               (&quot;ALSA format not negotiated&quot;));
+         }
+-        samplestamp =
+-            gst_alsa_timestamp_to_samples (this,
+-            GST_BUFFER_TIMESTAMP (sink-&gt;buf[i]));
++        samplestamp = gst_alsa_timestamp_to_samples (this,
++            GST_BUFFER_TIMESTAMP (buf));
+         max_discont = gst_alsa_timestamp_to_samples (this, this-&gt;max_discont);
+         /* optimization: check if we're using our own clock
+-         * This optimization is important because if we're using our own clock 
+-         * gst_element_get_time calls snd_pcm_delay and the following code assumes
+-         * that both calls return the same value. However they can be wildly 
+-         * different, since snd_pcm_delay goes deep into the kernel.
++         * This optimization is important because if we're using our own clock
++         * gst_element_get_time calls snd_pcm_delay and the following code
++         * assumes that both calls return the same value. However they can be
++         * wildly different, since snd_pcm_delay goes deep into the kernel.
+          */
+         if (gst_element_get_clock (element) == GST_CLOCK (this-&gt;clock)) {
+-          /* FIXME: this is ugly because of the variables it uses but I don't know a 
+-           * better way to get this info */
++          /* FIXME: this is ugly because of the variables it uses but I
++           * don't know a better way to get this info */
+           if (element-&gt;base_time &gt; this-&gt;clock-&gt;start_time) {
+             expected =
+-                this-&gt;transmitted - gst_alsa_timestamp_to_samples (this,
++                this-&gt;played - gst_alsa_timestamp_to_samples (this,
+                 element-&gt;base_time - this-&gt;clock-&gt;start_time);
+           } else {
+             expected =
+-                this-&gt;transmitted + gst_alsa_timestamp_to_samples (this,
++                this-&gt;played + gst_alsa_timestamp_to_samples (this,
+                 this-&gt;clock-&gt;start_time - element-&gt;base_time);
+           }
+         } else {
+@@ -402,13 +425,13 @@
+         }
+         sample_diff = samplestamp - expected;
+ 
+-        if ((!GST_BUFFER_TIMESTAMP_IS_VALID (sink-&gt;buf[i])) ||
++        if ((!GST_BUFFER_TIMESTAMP_IS_VALID (buf)) ||
+             (-max_discont &lt;= sample_diff &amp;&amp; sample_diff &lt;= max_discont)) {
+ 
+           /* difference between expected and current is &lt; GST_ALSA_DEVIATION */
+         no_difference:
+-          sink-&gt;size[i] = sink-&gt;buf[i]-&gt;size;
+-          sink-&gt;data[i] = sink-&gt;buf[i]-&gt;data;
++          sink-&gt;size[i] = GST_BUFFER_SIZE (buf);
++          sink-&gt;buf_data[i] = GST_BUFFER_DATA (buf);
+           sink-&gt;behaviour[i] = 0;
+         } else if (sample_diff &gt; 0) {
+           /* there are empty samples in front of us, fill them with silence */
+@@ -420,28 +443,28 @@
+           GST_INFO_OBJECT (this,
+               &quot;Allocating %d bytes (%ld samples) now to resync: sample %lu expected, but got %ld&quot;,
+               size, MIN (bytes, sample_diff), expected, samplestamp);
+-          sink-&gt;data[i] = g_try_malloc (size);
+-          if (!sink-&gt;data[i]) {
++          sink-&gt;buf_data[i] = g_try_malloc (size);
++          if (!sink-&gt;buf_data[i]) {
+             GST_WARNING_OBJECT (this,
+                 &quot;error allocating %d bytes, buffers unsynced now.&quot;, size);
+             goto no_difference;
+           }
+           sink-&gt;size[i] = size;
+           if (0 != snd_pcm_format_set_silence (this-&gt;format-&gt;format,
+-                  sink-&gt;data[i], samples)) {
++                  sink-&gt;buf_data[i], samples)) {
+             GST_WARNING_OBJECT (this,
+                 &quot;error silencing buffer, enjoy the noise.&quot;);
+           }
+           sink-&gt;behaviour[i] = 1;
+-        } else if (gst_alsa_samples_to_bytes (this,
+-                -sample_diff) &gt;= sink-&gt;buf[i]-&gt;size) {
++        } else if (gst_alsa_samples_to_bytes (this, -sample_diff) &gt;=
++            GST_BUFFER_SIZE (buf)) {
+           GST_INFO_OBJECT (this,
+               &quot;Skipping %lu samples to resync (complete buffer): sample %lu expected, but got %ld&quot;,
+-              gst_alsa_bytes_to_samples (this, sink-&gt;buf[i]-&gt;size), expected,
++              gst_alsa_bytes_to_samples (this, GST_BUFFER_SIZE (buf)), expected,
+               samplestamp);
+           /* this buffer is way behind */
+-          gst_buffer_unref (sink-&gt;buf[i]);
+-          sink-&gt;buf[i] = NULL;
++          gst_buffer_unref (buf);
++          sink-&gt;gst_data[i] = NULL;
+           continue;
+         } else if (sample_diff &lt; 0) {
+           gint difference = gst_alsa_samples_to_bytes (this, -sample_diff);
+@@ -450,8 +473,8 @@
+               &quot;Skipping %lu samples to resync: sample %lu expected, but got %ld&quot;,
+               (gulong) - sample_diff, expected, samplestamp);
+           /* this buffer is only a bit behind */
+-          sink-&gt;size[i] = sink-&gt;buf[i]-&gt;size - difference;
+-          sink-&gt;data[i] = sink-&gt;buf[i]-&gt;data + difference;
++          sink-&gt;size[i] = GST_BUFFER_SIZE (buf) - difference;
++          sink-&gt;buf_data[i] = GST_BUFFER_DATA (buf) + difference;
+           sink-&gt;behaviour[i] = 0;
+         } else {
+           g_assert_not_reached ();
+@@ -477,13 +500,14 @@
+         return;
+     }
+ 
+-    /* FIXME: lotsa stuff can have happened while fetching data. Do we need to check something? */
++    /* FIXME: lotsa stuff can have happened while fetching data.
++     * Do we need to check something? */
+ 
+     /* put this data into alsa */
+     if ((copied = this-&gt;transmit (this, &amp;avail)) &lt; 0)
+       return;
+     /* update our clock */
+-    this-&gt;transmitted += copied;
++    this-&gt;played += copied;
+     /* flush the data */
+     bytes = gst_alsa_samples_to_bytes (this, copied);
+     for (i = 0; i &lt; element-&gt;numpads; i++) {
+@@ -493,7 +517,7 @@
+       }
+       g_assert (sink-&gt;size[i] &gt; 0);
+       if (sink-&gt;behaviour[i] != 1)
+-        sink-&gt;data[i] += bytes;
++        sink-&gt;buf_data[i] += bytes;
+     }
+   }
+ 
+@@ -524,7 +548,7 @@
+     case GST_STATE_READY_TO_NULL:
+       break;
+     default:
+-      g_assert_not_reached ();
++      break;
+   }
+ 
+   if (GST_ELEMENT_CLASS (sink_parent_class)-&gt;change_state)
+@@ -541,11 +565,11 @@
+   if (!this-&gt;format)
+     return 0;
+   if (snd_pcm_delay (this-&gt;handle, &amp;delay) != 0) {
+-    return this-&gt;transmitted / this-&gt;format-&gt;rate;
++    return this-&gt;played / this-&gt;format-&gt;rate;
+   }
+-  if (this-&gt;transmitted &lt;= delay) {
++  if (this-&gt;played &lt;= delay) {
+     return 0;
+   }
+ 
+-  return GST_SECOND * (this-&gt;transmitted - delay) / this-&gt;format-&gt;rate;
++  return GST_SECOND * (this-&gt;played - delay) / this-&gt;format-&gt;rate;
+ }
+--- gst-plugins-0.8.2/ext/alsa/gstalsasink.h	2004-06-23 08:31:58.000000000 -0400
++++ gst-plugins/ext/alsa/gstalsasink.h	2004-07-14 12:13:02.000000000 -0400
+@@ -39,9 +39,9 @@
+   GstAlsaMixer parent;
+ 
+   /* array of the data on the channels */
+-  guint8    *data[GST_ALSA_MAX_TRACKS];      /* pointer into buffer */
++  guint8    *buf_data[GST_ALSA_MAX_TRACKS];  /* pointer into buffer */
+   guint      size[GST_ALSA_MAX_TRACKS];      /* sink: bytes left in buffer */
+-  GstBuffer *buf[GST_ALSA_MAX_TRACKS];       /* current buffer */
++  GstData   *gst_data[GST_ALSA_MAX_TRACKS];  /* current data */
+   guint      behaviour[GST_ALSA_MAX_TRACKS]; /* 0 = data points into buffer (so unref when size == 0),
+                                                   1 = data should be freed, use buffer after that */
+ };
+--- gst-plugins-0.8.2/ext/alsa/gstalsasrc.c	2004-06-23 11:43:53.000000000 -0400
++++ gst-plugins/ext/alsa/gstalsasrc.c	2004-07-14 12:13:02.000000000 -0400
+@@ -43,7 +43,6 @@
+ static void gst_alsa_src_loop (GstElement * element);
+ static void gst_alsa_src_flush (GstAlsaSrc * src);
+ static GstElementStateReturn gst_alsa_src_change_state (GstElement * element);
+-
+ static GstClockTime gst_alsa_src_get_time (GstAlsa * this);
+ 
+ static GstAlsa *src_parent_class = NULL;
+@@ -118,6 +117,7 @@
+ 
+   element_class-&gt;change_state = gst_alsa_src_change_state;
+ }
++
+ static void
+ gst_alsa_src_init (GstAlsaSrc * src)
+ {
+@@ -134,8 +134,53 @@
+   gst_object_ref (GST_OBJECT (this-&gt;clock));
+   gst_object_sink (GST_OBJECT (this-&gt;clock));
+ 
++  src-&gt;status = NULL;
+   gst_element_set_loop_function (GST_ELEMENT (this), gst_alsa_src_loop);
+ }
++
++/* alsasrc provides a clock starting from the trigger tstamp
++ * (last play/pause/stop), and added to that the time for the currently
++ * processed samples, and the current fill state of the buffer */
++static GstClockTime
++gst_alsa_src_get_time (GstAlsa * this)
++{
++  struct timeval trigger;
++  snd_pcm_sframes_t delay;
++  GstClockTime gct_trigger, gct_captured, gct_delay, retval =
++      GST_CLOCK_TIME_NONE;
++  int err;
++  GstAlsaSrc *src = GST_ALSA_SRC (this);
++
++  GTimeVal now;
++
++  g_get_current_time (&amp;now);
++  return GST_TIMEVAL_TO_TIME (now);
++
++  if (src-&gt;status == NULL)
++    return GST_CLOCK_TIME_NONE;
++
++  if ((err = snd_pcm_status (this-&gt;handle, src-&gt;status)) &lt; 0) {
++    GST_ERROR_OBJECT (this, &quot;status error: %s&quot;, snd_strerror (err));
++    return GST_CLOCK_TIME_NONE;
++  }
++
++  /* trigger tstamp is the last time the device got started/stopped/paused */
++  snd_pcm_status_get_trigger_tstamp (src-&gt;status, &amp;trigger);
++  gct_trigger = GST_TIMEVAL_TO_TIME (trigger);
++
++  /* captured is the number of samples already sent out as buffers */
++  gct_captured = gst_alsa_samples_to_timestamp (this, this-&gt;captured);
++
++  /* delay is the number of samples in the buffer not yet processed */
++  delay = snd_pcm_status_get_delay (src-&gt;status);
++  gct_delay = gst_alsa_samples_to_timestamp (this, delay);
++
++  retval = gct_trigger + gct_captured + gct_delay;
++  GST_LOG_OBJECT (src, &quot;returning clock time of %&quot; GST_TIME_FORMAT,
++      GST_TIME_ARGS (retval));
++  return retval;
++}
++
+ static int
+ gst_alsa_src_mmap (GstAlsa * this, snd_pcm_sframes_t * avail)
+ {
+@@ -311,6 +356,30 @@
+   return FALSE;
+ }
+ 
++inline snd_pcm_sframes_t
++gst_alsa_src_update_avail (GstAlsa * this)
++{
++  snd_pcm_sframes_t avail = -1;
++
++  while (avail &lt; 0) {
++    avail = snd_pcm_avail_update (this-&gt;handle);
++    if (avail &lt; 0) {
++      if (avail == -EPIPE) {
++        gst_alsa_xrun_recovery (this);
++      } else {
++        GST_WARNING_OBJECT (this, &quot;unknown ALSA avail_update return value (%d)&quot;,
++            (int) avail);
++      }
++    }
++    if (snd_pcm_state (this-&gt;handle) != SND_PCM_STATE_RUNNING) {
++      if (!gst_alsa_start (this)) {
++        return 0;
++      }
++    }
++  }
++  return avail;
++}
++
+ /* we transmit buffers of period_size frames */
+ static void
+ gst_alsa_src_loop (GstElement * element)
+@@ -331,22 +400,7 @@
+ 
+   /* the cast to long is explicitly needed;
+    * with avail = -32 and period_size = 100, avail &lt; period_size is false */
+-  while ((avail = gst_alsa_update_avail (this)) &lt; (long) this-&gt;period_size) {
+-    if (avail == -EPIPE) {
+-      GST_DEBUG_OBJECT (this, &quot;got EPIPE when checking for available bytes&quot;);
+-      continue;
+-    }
+-    if (avail &lt; 0) {
+-      GST_DEBUG_OBJECT (this,
+-          &quot;got error %s (%d) when checking for available bytes&quot;,
+-          snd_strerror (avail));
+-      return;
+-    }
+-    if (snd_pcm_state (this-&gt;handle) != SND_PCM_STATE_RUNNING) {
+-      if (!gst_alsa_start (this))
+-        return;
+-      continue;
+-    };
++  while ((avail = gst_alsa_src_update_avail (this)) &lt; this-&gt;period_size) {
+     /* wait */
+     if (gst_alsa_pcm_wait (this) == FALSE)
+       return;
+@@ -359,28 +413,73 @@
+     src-&gt;buf[i] =
+         gst_buffer_new_and_alloc (gst_alsa_samples_to_bytes (this, avail));
+   }
++
+   /* fill buffer with data */
+   if ((copied = this-&gt;transmit (this, &amp;avail)) &lt;= 0)
+     return;
+-  /* push the buffers out and let them have fun */
+-  for (i = 0; i &lt; element-&gt;numpads; i++) {
+-    GstBuffer *buf;
+ 
+-    if (!src-&gt;buf[i])
+-      return;
+-    if (copied != this-&gt;period_size)
+-      GST_BUFFER_SIZE (src-&gt;buf[i]) = gst_alsa_samples_to_bytes (this, copied);
+-    GST_BUFFER_TIMESTAMP (src-&gt;buf[i]) =
+-        gst_alsa_samples_to_timestamp (this, this-&gt;transmitted);
+-    GST_BUFFER_DURATION (src-&gt;buf[i]) =
+-        gst_alsa_samples_to_timestamp (this, copied);
+-    GST_BUFFER_OFFSET (src-&gt;buf[i]) = this-&gt;transmitted;
+-    GST_BUFFER_OFFSET_END (src-&gt;buf[i]) = this-&gt;transmitted + copied;
+-    buf = src-&gt;buf[i];
+-    src-&gt;buf[i] = NULL;
+-    gst_pad_push (this-&gt;pad[i], GST_DATA (buf));
++  {
++    gint outsize;
++    GstClockTime outtime, outdur, outreal, outideal, startalsa, outalsa;
++    gint64 diff, offset;
++    struct timeval tstamp;
++    int err;
++
++
++    if ((err = snd_pcm_status (this-&gt;handle, src-&gt;status)) &lt; 0)
++      GST_ERROR_OBJECT (this, &quot;status error: %s&quot;, snd_strerror (err));
++
++    offset = this-&gt;captured;
++
++    /* duration of buffer is just the time of the samples */
++    outdur = gst_alsa_samples_to_timestamp (this, copied);
++
++    /* The real capture time is the time of the clock minus the duration and
++     * what is now in the buffer */
++    outreal = gst_element_get_time (GST_ELEMENT (this)) - outdur;
++    /* ideal time is counting samples */
++    outideal = gst_alsa_samples_to_timestamp (this, offset);
++
++    snd_pcm_status_get_trigger_tstamp (src-&gt;status, &amp;tstamp);
++    startalsa = GST_TIMEVAL_TO_TIME (tstamp) - element-&gt;base_time;
++    outalsa = startalsa + outideal;
++
++    outsize = gst_alsa_samples_to_bytes (this, copied);
++    outtime = GST_CLOCK_TIME_NONE;
++
++    if (GST_ELEMENT_CLOCK (this)) {
++      if (GST_CLOCK (GST_ALSA (this)-&gt;clock) == GST_ELEMENT_CLOCK (this)) {
++        outtime = outalsa;
++        diff = outideal - outreal;
++        GST_DEBUG_OBJECT (this, &quot;ideal %lld, real %lld, diff %lld\n&quot;, outideal,
++            outreal, diff);
++        offset = gst_alsa_timestamp_to_samples (this, outtime);
++      } else {
++        outtime = outreal;
++        offset = gst_alsa_timestamp_to_samples (this, outtime);
++      }
++    }
++
++    /* push the buffers out and let them have fun */
++    for (i = 0; i &lt; element-&gt;numpads; i++) {
++      GstBuffer *buf;
++
++      if (!src-&gt;buf[i])
++        return;
++      if (copied != this-&gt;period_size)
++        GST_BUFFER_SIZE (src-&gt;buf[i]) = outsize;
++
++      GST_BUFFER_TIMESTAMP (src-&gt;buf[i]) = outtime;
++      GST_BUFFER_DURATION (src-&gt;buf[i]) = outdur;
++      GST_BUFFER_OFFSET (src-&gt;buf[i]) = offset;
++      GST_BUFFER_OFFSET_END (src-&gt;buf[i]) = offset + copied;
++
++      buf = src-&gt;buf[i];
++      src-&gt;buf[i] = NULL;
++      gst_pad_push (this-&gt;pad[i], GST_DATA (buf));
++    }
++    this-&gt;captured += copied;
+   }
+-  this-&gt;transmitted += copied;
+ }
+ 
+ static void
+@@ -395,6 +494,7 @@
+     }
+   }
+ }
++
+ static GstElementStateReturn
+ gst_alsa_src_change_state (GstElement * element)
+ {
+@@ -405,17 +505,23 @@
+ 
+   switch (GST_STATE_TRANSITION (element)) {
+     case GST_STATE_NULL_TO_READY:
++      break;
+     case GST_STATE_READY_TO_PAUSED:
++      snd_pcm_status_malloc (&amp;src-&gt;status);
++      break;
+     case GST_STATE_PAUSED_TO_PLAYING:
++      break;
+     case GST_STATE_PLAYING_TO_PAUSED:
+       break;
+     case GST_STATE_PAUSED_TO_READY:
++      snd_pcm_status_free (src-&gt;status);
++      src-&gt;status = NULL;
+       gst_alsa_src_flush (src);
+       break;
+     case GST_STATE_READY_TO_NULL:
+       break;
+     default:
+-      g_assert_not_reached ();
++      break;
+   }
+ 
+   if (GST_ELEMENT_CLASS (src_parent_class)-&gt;change_state)
+@@ -423,15 +529,3 @@
+ 
+   return GST_STATE_SUCCESS;
+ }
+-
+-static GstClockTime
+-gst_alsa_src_get_time (GstAlsa * this)
+-{
+-  snd_pcm_sframes_t delay;
+-
+-  if (snd_pcm_delay (this-&gt;handle, &amp;delay) == 0 &amp;&amp; this-&gt;format) {
+-    return GST_SECOND * (this-&gt;transmitted + delay) / this-&gt;format-&gt;rate;
+-  } else {
+-    return 0;
+-  }
+-}
+--- gst-plugins-0.8.2/ext/alsa/gstalsasrc.h	2004-06-23 08:31:58.000000000 -0400
++++ gst-plugins/ext/alsa/gstalsasrc.h	2004-07-14 12:13:02.000000000 -0400
+@@ -38,6 +38,8 @@
+ struct _GstAlsaSrc {
+   GstAlsaMixer   parent;
+   GstBuffer     *buf[GST_ALSA_MAX_TRACKS];
++  snd_pcm_status_t *status;
++  GstClockTime  base_time; /* FIXME: move this up ? already present in element ? */
+ };
+ 
+ struct _GstAlsaSrcClass {

Modified: trunk/rpms/gstreamer-plugins/gstreamer-plugins.spec
===================================================================
--- trunk/rpms/gstreamer-plugins/gstreamer-plugins.spec	2004-07-28 13:42:34 UTC (rev 1784)
+++ trunk/rpms/gstreamer-plugins/gstreamer-plugins.spec	2004-07-29 11:23:26 UTC (rev 1785)
@@ -3,10 +3,10 @@
 
 Summary: GStreamer Streaming-media framework plugins
 Name: gstreamer-plugins
-Version: 0.8.2.1
+Version: 0.8.2
 %define majmin 0.8
 %define po_package gst-plugins-%{majmin}
-Release: 0
+Release: 2.1
 License: LGPL
 Group: Applications/Multimedia
 Source: gst-plugins-%{version}.tar.bz2
@@ -17,6 +17,7 @@
 BuildRoot: %{_tmppath}/%{name}-%{version}-root
 
 Patch1: gstreamer-plugins-0.7.5-alsa.patch
+Patch2: gstreamer-plugins-0.8.2-alsa-fixes.patch
 
 Requires: glib2 &gt;= %_glib2
 Requires: gstreamer &gt;= %{version}
@@ -81,9 +82,8 @@
 %prep
 %setup -q -n gst-plugins-%{version} -a 4
 %patch1 -p1 -b .alsa
+%patch2 -p1 -b .alsa-fixes
 
-mkdir gst-libs/ext/ffmpeg
-
 for docfile in AUTHORS COPYING README ; do
 	cp Hermes-%{hermes_version}/${docfile} ${docfile}.Hermes
 done
@@ -175,8 +175,9 @@
 %{_libdir}/*so
 
 %changelog
-* Tue Jul 05 2004 Colin Walters &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">walters at redhat.com</A>&gt; - 0.8.2-3
-- Another rebuild to placate beehive!
+* Fri Jul 16 2004 Colin Walters &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">walters at redhat.com</A>&gt; - 0.8.2-2.1
+- Rebuild for FC2
+- Backported ALSA fixes from CVS HEAD
 
 * Tue Jul 05 2004 Colin Walters &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">walters at redhat.com</A>&gt; - 0.8.2-2
 - Rebuild to placate beehive

Modified: trunk/rpms/gstreamer-plugins-extras/gstreamer-plugins-extras.spec
===================================================================
--- trunk/rpms/gstreamer-plugins-extras/gstreamer-plugins-extras.spec	2004-07-28 13:42:34 UTC (rev 1784)
+++ trunk/rpms/gstreamer-plugins-extras/gstreamer-plugins-extras.spec	2004-07-29 11:23:26 UTC (rev 1785)
@@ -4,20 +4,20 @@
 %define		gstreamer	gstreamer
 %define		register	%{_bindir}/gst-register-%{majorminor} &gt; /dev/null 2&gt;&amp;1 || :
 
-Name: 		%{gstreamer}-plugins-extra
-Version: 	0.8.1
-Release: 	0
-Summary: 	GStreamer extra streaming media framework plugins
+Name:		%{gstreamer}-plugins-extra
+Version:	0.8.2
+Release:	0
+Summary:	GStreamer extra streaming media framework plugins
 
-Group: 		Applications/Multimedia
-License: 	LGPL
+Group:		Applications/Multimedia
+License:	LGPL
 URL:		<A HREF="http://gstreamer.net/">http://gstreamer.net/</A>
-Source: 	<A HREF="http://freedesktop.org/~gstreamer/src/gst-plugins/gst-plugins-%{version">http://freedesktop.org/~gstreamer/src/gst-plugins/gst-plugins-%{version</A>}.tar.gz
+Source:		<A HREF="http://gstreamer.freedesktop.org/src/gst-plugins/gst-plugins-%{version">http://gstreamer.freedesktop.org/src/gst-plugins/gst-plugins-%{version</A>}.tar.bz2
 BuildRoot:	%{_tmppath}/%{name}-%{version}-%{release}-root-%(%{__id_u} -n)
 
-BuildRequires: 	%{gstreamer}-devel &gt;= %{gst_minver}
+BuildRequires:	%{gstreamer}-devel &gt;= %{gst_minver}
 # libtool needs this, sigh
-BuildRequires: 	gcc-c++
+BuildRequires:	gcc-c++
 # so gst-libs can build
 BuildRequires:	XFree86-devel
 
@@ -29,14 +29,12 @@
 types or processing capabilities can be added simply by installing new 
 plugins.
 
-This package provides extra plugins currently hosted on <A HREF="http://rpm.livna.org/">http://rpm.livna.org/</A>
-
 %package audio
-Summary: 	extra audio plugins for GStreamer
-Group: 		Applications/Multimedia
+Summary:	Extra audio plugins for GStreamer
+Group:		Applications/Multimedia
 
 BuildRequires:	faad2-devel &gt;= 2.0
-BuildRequires:  gsm-devel &gt;= 1.0.10
+BuildRequires:	gsm-devel &gt;= 1.0.10
 BuildRequires:	lame-devel &gt;= 3.89
 BuildRequires:	libid3tag-devel &gt;= 0.15.0
 BuildRequires:	libmad-devel &gt;= 0.15.0
@@ -70,8 +68,8 @@
 %{_libdir}/gstreamer-%{majorminor}/libgstmad.so
 
 %package dvd
-Summary: 	DVD plugins for GStreamer
-Group: 		Applications/Multimedia
+Summary:	DVD plugins for GStreamer
+Group:		Applications/Multimedia
 
 BuildRequires:	a52dec-devel &gt;= 0.7.3
 BuildRequires:	libdvdnav-devel &gt;= 0.1.3
@@ -105,8 +103,8 @@
 %{_libdir}/gstreamer-%{majorminor}/libgstdvdreadsrc.so
 
 %package video
-Summary: 	extra video plugins for GStreamer
-Group: 		Applications/Multimedia
+Summary:	Extra video plugins for GStreamer
+Group:		Applications/Multimedia
 
 BuildRequires:	libfame-devel &gt;= 0.9.0
 BuildRequires:	mpeg2dec-devel &gt;= 0.4.0
@@ -188,6 +186,9 @@
 rm -rf $RPM_BUILD_ROOT
 
 %changelog
+* Thu Jul 29 2004 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.8.2-0
+- Update to 0.8.2.
+
 * Thu Apr 15 2004 Thomas Vander Stichele &lt;thomas at apestaart dot org&gt;
 - 0.8.1-0.lvn.1: new source release
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000593.html">[SVN] r1784 - trunk/rpms/thunderbird
</A></li>
	<LI>Next message: <A HREF="000595.html">[SVN] r1786 - trunk/rpms/kannel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#594">[ date ]</a>
              <a href="thread.html#594">[ thread ]</a>
              <a href="subject.html#594">[ subject ]</a>
              <a href="author.html#594">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
