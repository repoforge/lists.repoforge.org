<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r5946 - in trunk/rpms: . alpine cacti cacti-spine collectd	dhcp-ldap drupal4 drupal5 fuse-smb phpmyadmin shntool tcpreplay
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5946%20-%20in%20trunk/rpms%3A%20.%20alpine%20cacti%20cacti-spine%20collectd%0A%09dhcp-ldap%20drupal4%20drupal5%20fuse-smb%20phpmyadmin%20shntool%20tcpreplay&In-Reply-To=%3C20071029163003.965A1944A92%40pooch.vmhosting.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004744.html">
   <LINK REL="Next"  HREF="004746.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r5946 - in trunk/rpms: . alpine cacti cacti-spine collectd	dhcp-ldap drupal4 drupal5 fuse-smb phpmyadmin shntool tcpreplay</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5946%20-%20in%20trunk/rpms%3A%20.%20alpine%20cacti%20cacti-spine%20collectd%0A%09dhcp-ldap%20drupal4%20drupal5%20fuse-smb%20phpmyadmin%20shntool%20tcpreplay&In-Reply-To=%3C20071029163003.965A1944A92%40pooch.vmhosting.org%3E"
       TITLE="[svn] r5946 - in trunk/rpms: . alpine cacti cacti-spine collectd	dhcp-ldap drupal4 drupal5 fuse-smb phpmyadmin shntool tcpreplay">packagers at lists.rpmforge.net
       </A><BR>
    <I>Mon Oct 29 17:30:03 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004744.html">[svn] r5945 - in trunk/rpms: aria2 clex csockets gnofract4d kbibtex	mcabber
</A></li>
        <LI>Next message: <A HREF="004746.html">[svn] r5947 - in trunk/rpms: . collectd ipmiutil libnet
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4745">[ date ]</a>
              <a href="thread.html#4745">[ thread ]</a>
              <a href="subject.html#4745">[ subject ]</a>
              <a href="author.html#4745">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2007-10-29 17:29:56 +0100 (Mon, 29 Oct 2007)
New Revision: 5946

Added:
   trunk/rpms/cacti-spine/cacti-spine.spec
   trunk/rpms/collectd/
   trunk/rpms/collectd/collectd.spec
   trunk/rpms/dhcp-ldap/
   trunk/rpms/dhcp-ldap/dhcp-3.0-alignment.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0-jbuild.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1-change_resolv_conf.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1-check-empty-new-routers.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1-default_gateway.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1-host_dereference.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1-mis_host.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1-new-host.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1-restrict-unconfigured-IF.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1.preserve-sent-options.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-RHscript.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-inherit-leases.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-pie.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-staticroutes.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-dhcpctlman.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-noexpr.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.1rc14-noconfig.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.3-alignment.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.3-host_dereference.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.3-ldap-patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.3-mis_host.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-Makefile.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-client.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-common.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-dhcpctl.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-dst.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-extended-new-option-info.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-fix-warnings.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-includes.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-ldap-patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-libdhcp4client.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-minires.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-omapip.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-server.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-timeouts.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0.5-version.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0pl1-minires.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0pl1-miscfixes.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0pl2-initialize.patch
   trunk/rpms/dhcp-ldap/dhcp-3.0pl2-selinux.patch
   trunk/rpms/dhcp-ldap/dhcp-ldap-3.0.3.spec
   trunk/rpms/dhcp-ldap/dhcp-ldap.spec
   trunk/rpms/dhcp-ldap/dhcpd-manpage.patch
   trunk/rpms/dhcp-ldap/dhcpd.conf
   trunk/rpms/dhcp-ldap/dhcpd.conf.sample
   trunk/rpms/dhcp-ldap/dhcpd.init
   trunk/rpms/dhcp-ldap/dhcptables.pl
   trunk/rpms/dhcp-ldap/dhcrelay.init
   trunk/rpms/dhcp-ldap/libdhcp4client.pc
Removed:
   trunk/rpms/cacti-spine/cacti-cactid.spec
Modified:
   trunk/rpms/alpine/alpine.spec
   trunk/rpms/cacti/cacti.spec
   trunk/rpms/drupal4/drupal4.spec
   trunk/rpms/drupal5/drupal5.spec
   trunk/rpms/fuse-smb/fuse-smb.spec
   trunk/rpms/phpmyadmin/phpmyadmin.spec
   trunk/rpms/shntool/shntool.spec
   trunk/rpms/tcpreplay/tcpreplay.spec
Log:
Updates

Modified: trunk/rpms/alpine/alpine.spec
===================================================================
--- trunk/rpms/alpine/alpine.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/alpine/alpine.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -4,7 +4,7 @@
 Summary: Alternative Pine mail user agent implementation
 Name: alpine
 Version: 0.9999
-Release: 1
+Release: 2
 License: Apache License
 Group: Applications/Internet
 URL: <A HREF="http://www.washington.edu/alpine/">http://www.washington.edu/alpine/</A>
@@ -33,7 +33,9 @@
 
 %build
 touch imap/ip6
-%configure --with-spellcheck-prog=&quot;aspell&quot;
+%configure \
+    --with-passfile=&quot;.pinepwd&quot; \
+    --with-spellcheck-prog=&quot;aspell&quot;
 %{__make} %{?_smp_mflags}
 
 %install
@@ -81,6 +83,9 @@
 %{_sbindir}/mlock
 
 %changelog
+* Sun Oct 28 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.9999-2
+- Enabled passfile support.
+
 * Sun Sep 30 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.9999-1
 - Updated to release 0.9999.
 

Modified: trunk/rpms/cacti/cacti.spec
===================================================================
--- trunk/rpms/cacti/cacti.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/cacti/cacti.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -11,7 +11,7 @@
 
 Summary: Complete network graphing solution designed on top of RRDTool
 Name: cacti
-Version: 0.8.6j
+Version: 0.8.7
 Release: 1
 License: GPL
 Group: Applications/System
@@ -126,6 +126,9 @@
 %doc docs/*
 
 %changelog
+* Fri Oct 26 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.7-1
+- Updated to release 0.8.7.
+
 * Thu Jan 18 2007 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.8.6j-1
 - Make package noarch, as it should be.
 

Deleted: trunk/rpms/cacti-spine/cacti-cactid.spec
===================================================================
--- trunk/rpms/cacti-spine/cacti-cactid.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/cacti-spine/cacti-cactid.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -1,78 +0,0 @@
-# $Id$
-# Authority: dag
-# Upstream: &lt;cacti-user$lists,sf,net&gt;
-
-%{?dist: %{expand: %%define %dist 1}}
-%{?rh7:%define _without_net_snmp 1}
-%{?el2:%define _without_net_snmp 1}
-%{?rh6:%define _without_net_snmp 1}
-
-Summary: Fast c-based poller for the cacti graphing solution
-Name: cacti-cactid
-Version: 0.8.6i
-Release: 1
-License: LGPL
-Group: Applications/System
-URL: <A HREF="http://www.cacti.net/">http://www.cacti.net/</A>
-
-Source: <A HREF="http://www.cacti.net/downloads/cactid/cacti-cactid-%{version">http://www.cacti.net/downloads/cactid/cacti-cactid-%{version</A>}.tar.gz
-BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
-
-BuildRequires: mysql-devel, openssl-devel
-
-%{!?_without_net_snmp:BuildRequires: net-snmp-devel, net-snmp-utils}
-%{?_without_net_snmp:BuildRequires: ucd-snmp-devel, ucd-snmp-utils}
-
-Requires: cacti
-
-%description
-Cactid is a supplemental poller for Cacti that makes use of pthreads
-to achieve excellent performance.
-
-%prep
-%setup
-
-### FIXME: Patch to use /usr/lib64 on 64bit (Please fix upstream)
-%{__perl} -pi.orig -e 's|/lib\b|/%{_lib}|g' configure
-
-%build
-%configure
-%{__make} %{?_smp_mflags}
-
-%install
-%{__rm} -rf %{buildroot}
-%{__install} -Dp -m0755 cactid %{buildroot}%{_bindir}/cactid
-%{__install} -Dp -m0600 cactid.conf %{buildroot}%{_sysconfdir}/cactid.conf
-
-%clean
-%{__rm} -rf %{buildroot}
-
-%files
-%defattr(-, root, root, 0755)
-%doc AUTHORS ChangeLog LICENSE* README
-%{_bindir}/cactid
-
-%defattr(-, cacti, cacti, 0755)
-%config(noreplace) %{_sysconfdir}/cactid.conf
-
-%changelog
-* Thu Jan 18 2007 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.8.6i-1
-- Update to 0.8.6i.
-- Include only relevant documentation.
-
-* Sat Apr 08 2006 Dries Verachtert &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dries at ulyssis.org</A>&gt; - 0.8.6g-1.2
-- Rebuild for Fedora Core 5.
-
-* Mon Jan 30 2006 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.6g-1
-- Updated to release 0.8.6g.
-
-* Tue Aug 09 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.6e-1
-- Updated to release 0.8.6e.
-
-* Thu May 19 2005 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.8.6d-2
-- Make the config file mode 0600 (it contains the mysql db password) and owned
-  by the cacti user (he executes the cron job).
-- Add missing openssl-devel build requirement (at least on RHEL4).
-
-* Mon Apr 04 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.6d-1
-- Initial package. (using DAR)

Copied: trunk/rpms/cacti-spine/cacti-spine.spec (from rev 5943, trunk/rpms/cacti-spine/cacti-cactid.spec)
===================================================================
--- trunk/rpms/cacti-spine/cacti-spine.spec	                        (rev 0)
+++ trunk/rpms/cacti-spine/cacti-spine.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,84 @@
+# $Id$
+# Authority: dag
+# Upstream: &lt;cacti-user$lists,sf,net&gt;
+
+%{?dist: %{expand: %%define %dist 1}}
+%{?rh7:%define _without_net_snmp 1}
+%{?el2:%define _without_net_snmp 1}
+%{?rh6:%define _without_net_snmp 1}
+
+Summary: Fast c-based poller for the cacti graphing solution
+Name: cacti-spine
+Version: 0.8.7
+Release: 1
+License: LGPL
+Group: Applications/System
+URL: <A HREF="http://www.cacti.net/">http://www.cacti.net/</A>
+
+Source: <A HREF="http://www.cacti.net/downloads/spine/cacti-spine-%{version">http://www.cacti.net/downloads/spine/cacti-spine-%{version</A>}.tar.gz
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+BuildRequires: mysql-devel, openssl-devel
+
+%{!?_without_net_snmp:BuildRequires: net-snmp-devel, net-snmp-utils}
+%{?_without_net_snmp:BuildRequires: ucd-snmp-devel, ucd-snmp-utils}
+
+Requires: cacti
+
+Obsoletes: cacti-cactid &lt;= %{version}-%{release}
+Provides: cacti-cactid = %{version}-%{release}
+
+%description
+Spine is a supplemental poller for Cacti that makes use of pthreads
+to achieve excellent performance.
+
+%prep
+%setup
+
+### FIXME: Patch to use /usr/lib64 on 64bit (Please fix upstream)
+%{__perl} -pi.orig -e 's|/lib\b|/%{_lib}|g' configure
+
+%build
+%{__aclocal} --force
+%{__libtoolize} --force --copy
+%configure
+%{__make} %{?_smp_mflags}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__install} -Dp -m0755 spine %{buildroot}%{_bindir}/spine
+%{__install} -Dp -m0600 spine.conf %{buildroot}%{_sysconfdir}/spine.conf
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%doc AUTHORS ChangeLog COPYING LICENSE* NEWS README
+%{_bindir}/spine
+
+%defattr(-, cacti, cacti, 0755)
+%config(noreplace) %{_sysconfdir}/spine.conf
+
+%changelog
+* Mon Oct 29 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.7-1
+- Updated to release 0.8.7.
+- Rename package from cacti-cactid to cacti-spine.
+
+* Thu Jan 18 2007 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.8.6i-1
+- Update to 0.8.6i.
+- Include only relevant documentation.
+
+* Mon Jan 30 2006 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.6g-1
+- Updated to release 0.8.6g.
+
+* Tue Aug 09 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.6e-1
+- Updated to release 0.8.6e.
+
+* Thu May 19 2005 Matthias Saou &lt;<A HREF="http://freshrpms.net/">http://freshrpms.net/</A>&gt; 0.8.6d-2
+- Make the config file mode 0600 (it contains the mysql db password) and owned
+  by the cacti user (he executes the cron job).
+- Add missing openssl-devel build requirement (at least on RHEL4).
+
+* Mon Apr 04 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.6d-1
+- Initial package. (using DAR)

Added: trunk/rpms/collectd/collectd.spec
===================================================================
--- trunk/rpms/collectd/collectd.spec	                        (rev 0)
+++ trunk/rpms/collectd/collectd.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,77 @@
+# $Id$
+# Authority: dag
+
+%{?dist: %{expand: %%define %dist 1}}
+
+%{?el3:%define _without_lmsensors 1}
+
+Summary: Statistics collection daemon for filling RRD files
+Name: collectd
+Version: 3.11.5
+Release: 1
+License: GPL
+Group: System Environment/Daemons
+URL: <A HREF="http://collectd.org/">http://collectd.org/</A>
+
+Source: <A HREF="http://collectd.org/files/collectd-%{version">http://collectd.org/files/collectd-%{version</A>}.tar.gz
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+BuildRequires: mysql-devel, rrdtool-devel
+%{!?_without_lmsensors:BuildRequires: lm_sensors-devel}
+
+Obsoletes: collectd-apache &lt;= %{version}-%{release}
+Provides: collectd-apache = %{version}-%{release}
+Obsoletes: collectd-mysql &lt;= %{version}-%{release}
+Provides: collectd-mysql = %{version}-%{release}
+Obsoletes: collectd-sensors &lt;= %{version}-%{release}
+Provides: collectd-sensors = %{version}-%{release}
+
+%description
+collectd is a small daemon written in C for performance.  It reads various
+system  statistics  and updates  RRD files,  creating  them if neccessary.
+Since the daemon doesn't need to startup every time it wants to update the
+files it's very fast and easy on the system. Also, the statistics are very
+fine grained since the files are updated every 10 seconds.
+
+%prep
+%setup
+
+%{__perl} -pi.orig -e 's|-Werror||g' Makefile.in */Makefile.in
+
+%build
+### FIXME: --with-libmysql support not working
+%configure \
+    --disable-static \
+    --with-libmysql=&quot;%{_libdir}/mysql/&quot;
+%{__make} %{?_smp_mflags}
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+
+%{__install} -Dp -m0644 src/collectd.conf %{buildroot}%{_sysconfdir}/collectd.conf
+%{__install} -Dp -m0755 contrib/init.d-rh7 %{buildroot}%{_initrddir}/collectd
+
+%{__install} -d -m0755 %{buildroot}%{_localstatedir}/lib/collectd/
+
+### Clean up docs
+find contrib/ -type f -exec %{__chmod} a-x {} \;
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%files
+%defattr(-, root, root, 0755)
+%doc AUTHORS ChangeLog COPYING INSTALL NEWS README contrib/
+%doc %{_mandir}/man1/*.1*
+%doc %{_mandir}/man5/*.5*
+%config(noreplace) %{_sysconfdir}/collectd.conf
+%config %{_initrddir}/collectd
+%{_libdir}/collectd/
+%{_sbindir}/collectd
+%dir %{_localstatedir}/lib/collectd/
+%exclude %{_libdir}/collectd/*.la
+
+%changelog
+* Mon Oct 29 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.11.5-1
+- Initial package. (using DAR)


Property changes on: trunk/rpms/collectd/collectd.spec
___________________________________________________________________
Name: svn:keywords
   + Id Revision
Name: svn:eol-style
   + native

Added: trunk/rpms/dhcp-ldap/dhcp-3.0-alignment.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0-alignment.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0-alignment.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,24 @@
+--- dhcp-3.0pl1/common/packet.c.sopwith	2002-07-12 16:41:48.000000000 -0400
++++ dhcp-3.0pl1/common/packet.c	2002-07-12 17:45:52.000000000 -0400
+@@ -227,8 +227,8 @@
+ 	unsigned char *data;
+ 	unsigned buflen;
+ {
+-  struct ip *ip;
+-  struct udphdr *udp;
++  struct ip ipdat, *ip = &amp;ipdat;
++  struct udphdr udpdat, *udp = &amp;udpdat;
+   u_int32_t ip_len = (buf [bufix] &amp; 0xf) &lt;&lt; 2;
+   u_int32_t sum, usum;
+   static int ip_packets_seen;
+@@ -241,8 +241,8 @@
+   unsigned ulen;
+   int ignore = 0;
+ 
+-  ip = (struct ip *)(buf + bufix);
+-  udp = (struct udphdr *)(buf + bufix + ip_len);
++  memcpy(ip, (struct ip *)(buf + bufix), sizeof(ipdat));
++  memcpy(udp, (struct udphdr *)(buf + bufix + ip_len), sizeof(udpdat));
+ 
+ #ifdef USERLAND_FILTER
+   /* Is it a UDP packet? */

Added: trunk/rpms/dhcp-ldap/dhcp-3.0-jbuild.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0-jbuild.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0-jbuild.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,37 @@
+--- dhcp-3.0/Makefile.sopwith	Thu Dec 20 19:28:07 2001
++++ dhcp-3.0/Makefile	Thu Dec 20 19:28:30 2001
+@@ -43,7 +43,7 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make all); \
++	   (cd work.$$sysname; $(MAKE) all); \
+ 	fi
+ 
+ install:
+@@ -51,7 +51,7 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make install); \
++	   (cd work.$$sysname; $(MAKE) install); \
+ 	fi
+ 
+ depend:
+@@ -59,7 +59,7 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make depend); \
++	   (cd work.$$sysname; $(MAKE) depend); \
+ 	fi
+ 
+ clean:
+@@ -91,6 +91,6 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make links); \
++	   (cd work.$$sysname; $(MAKE) links); \
+ 	fi
+ 

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1-change_resolv_conf.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1-change_resolv_conf.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1-change_resolv_conf.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,28 @@
+--- dhcp-3.0.1/client/scripts/linux.change_resolv_conf	2004-08-02 10:45:38.818235000 -0400
++++ dhcp-3.0.1/client/scripts/linux	2004-08-02 10:46:25.359647000 -0400
+@@ -37,18 +37,20 @@
+ 
+   if [ -n &quot;$new_domain_name&quot; ] || [ -n &quot;$new_domain_name_servers&quot; ]; then
+     save_previous /etc/resolv.conf
+-    echo '; generated by /sbin/dhclient-script' &gt; /etc/resolv.conf
++    rscf=`mktemp /tmp/XXXXXX`;
++    echo '; generated by /sbin/dhclient-script' &gt; $rscf
+     if [ -n &quot;$SEARCH&quot; ]; then
+- 	echo search $SEARCH &gt;&gt; /etc/resolv.conf
++ 	echo search $SEARCH &gt;&gt; $rscf
+     else
+ 	if [ -n &quot;$new_domain_name&quot; ]; then
+- 	    echo search $new_domain_name &gt;&gt; /etc/resolv.conf
++ 	    echo search $new_domain_name &gt;&gt; $rscf
+         fi
+     fi
+-    chmod 644 /etc/resolv.conf
+     for nameserver in $new_domain_name_servers; do
+-      echo nameserver $nameserver &gt;&gt;/etc/resolv.conf
++      echo nameserver $nameserver &gt;&gt; $rscf
+     done
++    change_resolv_conf $rscf
++    rm -f $rscf
+   fi
+ }
+ 

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1-check-empty-new-routers.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1-check-empty-new-routers.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1-check-empty-new-routers.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,20 @@
+--- dhcp-3.0.1/client/scripts/linux.check-empty-new-routers	2004-11-16 14:31:05.083158000 -0500
++++ dhcp-3.0.1/client/scripts/linux	2004-11-16 14:39:38.542185000 -0500
+@@ -264,7 +264,7 @@
+   exit_with_hooks 0
+ fi
+ 
+-if [ x$reason = xTIMEOUT ]; then
++if [ x$reason = xTIMEOUT ] &amp;&amp; [ &quot;x$new_routers&quot; != 'x' ]; then
+   if [ x$alias_ip_address != x ]; then
+     ifconfig $interface:0- inet 0
+   fi
+@@ -291,6 +291,8 @@
+   fi
+   ifconfig $interface inet 0 down
+   exit_with_hooks 1
++elif [ x$reason = xTIMEOUT ]; then
++  exit_with_hooks 1
+ fi
+ 
+ exit_with_hooks 0

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1-default_gateway.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1-default_gateway.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1-default_gateway.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,33 @@
+--- dhcp-3.0.1/client/scripts/linux.default_gateway	2004-08-02 10:39:00.000000000 -0400
++++ dhcp-3.0.1/client/scripts/linux	2004-08-03 15:43:45.184792000 -0400
+@@ -120,6 +120,7 @@
+   exit_with_hooks 0
+ fi
+ 
++added_old_broadcast_route=0;
+ if [ x$reason = xPREINIT ]; then
+   if [ x$alias_ip_address != x ]; then
+     # Bring down alias interface. Its routes will disappear too.
+@@ -131,7 +132,7 @@
+     ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
+ 		broadcast 255.255.255.255 up
+     # Add route to make broadcast work. Do not omit netmask.
+-    route add default dev $interface netmask 0.0.0.0
++    route add default dev $interface netmask 0.0.0.0 &amp;&amp; added_old_broadcast_route=1;
+   else
+     ifconfig $interface 0 up
+   fi
+@@ -216,9 +217,12 @@
+     if [ $relmajor -lt 2 ] || \
+ 		( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] ); then
+       route add -net $new_network_number $new_subnet_arg dev $interface
++      if [ $added_old_broadcast_route -eq 1 ]; then
++	  route del default;
++      fi;
+     fi
+     for router in $new_routers; do
+-      route add default gw $router
++      route add default gw $router &amp;&amp; break; # there can be only one !
+     done
+     # static routes
+     if [ &quot;x$new_static_routes&quot; != x ]; then

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1-host_dereference.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1-host_dereference.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1-host_dereference.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,56 @@
+--- dhcp-3.0.1/server/dhcp.c.host-dereference	2004-10-06 15:44:50.580294000 -0400
++++ dhcp-3.0.1/server/dhcp.c	2004-10-06 15:45:44.413407000 -0400
+@@ -1718,6 +1718,8 @@
+ 					  d1.data [0]);
+ 				data_string_forget (&amp;d1, MDL);
+ 				free_lease_state (state, MDL);
++				if( host )
++				    host_dereference (&amp;host, MDL);
+ 				return;
+ 			}
+ 			data_string_forget (&amp;d1, MDL);
+@@ -1791,6 +1793,8 @@
+ 		if (!ignorep)
+ 			log_info (&quot;%s: unknown client&quot;, msg);
+ 		free_lease_state (state, MDL);
++		if( host )
++		    host_dereference (&amp;host, MDL);
+ 		return;
+ 	} 
+ 
+@@ -1807,6 +1811,8 @@
+ 		if (!ignorep)
+ 			log_info (&quot;%s: bootp disallowed&quot;, msg);
+ 		free_lease_state (state, MDL);
++		if( host )
++		    host_dereference (&amp;host, MDL);
+ 		return;
+ 	} 
+ 
+@@ -1823,6 +1829,8 @@
+ 		if (!ignorep)
+ 			log_info (&quot;%s: booting disallowed&quot;, msg);
+ 		free_lease_state (state, MDL);
++		if( host )
++		    host_dereference (&amp;host, MDL);
+ 		return;
+ 	}
+ 
+@@ -1859,6 +1867,8 @@
+ 						  msg);
+ 					free_lease_state (state, MDL);
+ 					/* XXX probably not necessary: */
++					if( host )
++					    host_dereference (&amp;host, MDL);
+ 					return;
+ 				}
+ 			}
+@@ -1891,6 +1901,8 @@
+ 		log_info (&quot;%s: can't allocate temporary lease structure: %s&quot;,
+ 			  msg, isc_result_totext (result));
+ 		free_lease_state (state, MDL);
++		if( host )
++		    host_dereference (&amp;host, MDL);
+ 		return;
+ 	}
+ 		

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1-mis_host.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1-mis_host.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1-mis_host.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,23 @@
+--- dhcp-3.0.1/server/dhcp.c.mis_host	2004-06-17 16:54:40.000000000 -0400
++++ dhcp-3.0.1/server/dhcp.c	2004-08-30 13:21:56.409501000 -0400
+@@ -1719,11 +1719,18 @@
+ 		}
+ 	}
+ 
+-	/* Try to find a matching host declaration for this lease. */
+-	if (!lease -&gt; host) {
++	/* Try to find a matching host declaration for this lease.
++	 * If this is an offer, then verify our host for the lease is the
++	 * right one for the host we're offering to...by dereffing and
++	 * re-finding.
++	 */
++	if ((offer == DHCPOFFER) ||(!lease -&gt; host)) {
+ 		struct host_decl *hp = (struct host_decl *)0;
+ 		struct host_decl *h;
+ 
++		if (lease -&gt; host)
++			host_dereference (&amp;lease -&gt; host, MDL);
++
+ 		/* Try to find a host_decl that matches the client
+ 		   identifier or hardware address on the packet, and
+ 		   has no fixed IP address.   If there is one, hang

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1-new-host.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1-new-host.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1-new-host.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,106 @@
+--- dhcp-3.0.1/server/dhcp.c.new-host	2004-09-27 18:56:38.241406000 -0400
++++ dhcp-3.0.1/server/dhcp.c	2004-09-27 19:01:11.007933000 -0400
+@@ -1483,6 +1483,7 @@
+ 	struct lease *lt;
+ 	struct lease_state *state;
+ 	struct lease *next;
++	struct host_decl *host = (struct host_decl *)0;
+ 	TIME lease_time;
+ 	TIME offered_lease_time;
+ 	struct data_string d1;
+@@ -1505,6 +1506,10 @@
+ 	if (lease -&gt; state)
+ 		return;
+ 
++	/* If the lease carries a host record, remember it. */
++	if (lease -&gt; host)
++	    host_reference (&amp;host, lease -&gt; host, MDL);	
++
+ 	/* Allocate a lease state structure... */
+ 	state = new_lease_state (MDL);
+ 	if (!state)
+@@ -1646,8 +1651,8 @@
+ 		} while (1);
+ 	    }
+ 	    if (!lease -&gt; uid_len ||
+-		(lease -&gt; host &amp;&amp;
+-		 !lease -&gt; host -&gt; client_identifier.len &amp;&amp;
++		( host &amp;&amp;
++		 !host -&gt; client_identifier.len &amp;&amp;
+ 		 (oc = lookup_option (&amp;server_universe, state -&gt; options,
+ 				      SV_DUPLICATES)) &amp;&amp;
+ 		 !evaluate_boolean_option_cache (&amp;ignorep, packet, lease,
+@@ -1720,17 +1725,11 @@
+ 	}
+ 
+ 	/* Try to find a matching host declaration for this lease.
+-	 * If this is an offer, then verify our host for the lease is the
+-	 * right one for the host we're offering to...by dereffing and
+-	 * re-finding.
+ 	 */
+-	if ((offer == DHCPOFFER) ||(!lease -&gt; host)) {
++	if (!host) {
+ 		struct host_decl *hp = (struct host_decl *)0;
+ 		struct host_decl *h;
+ 
+-		if (lease -&gt; host)
+-			host_dereference (&amp;lease -&gt; host, MDL);
+-
+ 		/* Try to find a host_decl that matches the client
+ 		   identifier or hardware address on the packet, and
+ 		   has no fixed IP address.   If there is one, hang
+@@ -1746,7 +1745,7 @@
+ 			find_hosts_by_uid (&amp;hp, d1.data, d1.len, MDL);
+ 			data_string_forget (&amp;d1, MDL);
+ 			if (hp)
+-				host_reference (&amp;lease -&gt; host, hp, MDL);
++				host_reference (&amp;host, hp, MDL);
+ 		}
+ 		if (!hp) {
+ 			find_hosts_by_haddr (&amp;hp,
+@@ -1759,7 +1758,7 @@
+ 					break;
+ 			}
+ 			if (h)
+-				host_reference (&amp;lease -&gt; host, h, MDL);
++				host_reference (&amp;host, h, MDL);
+ 		}
+ 		if (hp)
+ 			host_dereference (&amp;hp, MDL);
+@@ -1767,20 +1766,20 @@
+ 
+ 	/* If we have a host_decl structure, run the options associated
+ 	   with its group.  Wether the host decl struct is old or not. */
+-	if (lease -&gt; host)
++	if (host)
+ 		execute_statements_in_scope ((struct binding_value **)0,
+ 					     packet, lease,
+ 					     (struct client_state *)0,
+ 					     packet -&gt; options,
+ 					     state -&gt; options, &amp;lease -&gt; scope,
+-					     lease -&gt; host -&gt; group,
++					     host -&gt; group,
+ 					     (lease -&gt; pool
+ 					      ? lease -&gt; pool -&gt; group
+ 					      : lease -&gt; subnet -&gt; group));
+ 
+ 	/* Drop the request if it's not allowed for this client.   By
+ 	   default, unknown clients are allowed. */
+-	if (!lease -&gt; host &amp;&amp;
++	if (!host &amp;&amp;
+ 	    (oc = lookup_option (&amp;server_universe, state -&gt; options,
+ 				 SV_BOOT_UNKNOWN_CLIENTS)) &amp;&amp;
+ 	    !evaluate_boolean_option_cache (&amp;ignorep,
+@@ -2120,8 +2119,10 @@
+ 		data_string_forget (&amp;d1, MDL);
+ 	}
+ 
+-	if (lease -&gt; host)
+-		host_reference (&amp;lt -&gt; host, lease -&gt; host, MDL);
++	if (host) {
++		host_reference (&amp;lt -&gt; host, host, MDL);
++		host_dereference (&amp;host, MDL);
++	}
+ 	if (lease -&gt; subnet)
+ 		subnet_reference (&amp;lt -&gt; subnet, lease -&gt; subnet, MDL);
+ 	if (lease -&gt; billing_class)

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1-restrict-unconfigured-IF.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1-restrict-unconfigured-IF.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1-restrict-unconfigured-IF.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,25 @@
+--- dhcp-3.0.1/common/discover.c.restrict-unconfigured-IF	2004-06-10 13:59:16.000000000 -0400
++++ dhcp-3.0.1/common/discover.c	2004-11-16 14:17:35.515537000 -0500
+@@ -392,6 +392,22 @@
+ 			if (tmp)
+ 				continue;
+ 
++			/*+++       Red Hat patch for bug #138181        +++*/
++			/* See if this is the sort of interface we want to
++			   deal with. */
++			strncpy (ifr.ifr_name, name, IFNAMSIZ);
++
++			/* Skip non broadcast interfaces (plus loopback and
++			   point-to-point in case an OS incorrectly marks them
++			   as broadcast).
++			*/
++			 if (  (ioctl (sock, SIOCGIFFLAGS, &amp;ifr) &lt; 0)
++			     ||(!(ifr.ifr_flags &amp; IFF_BROADCAST))
++			     ||(ifr.ifr_flags &amp; IFF_LOOPBACK )
++			     ||(ifr.ifr_flags &amp; IFF_POINTOPOINT)
++		            ) continue;
++			/*---  END  Red Hat patch for bug #138181        ---*/
++
+ 			/* Otherwise, allocate one. */
+ 			tmp = (struct interface_info *)0;
+ 			status = interface_allocate (&amp;tmp, MDL);

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1.preserve-sent-options.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1.preserve-sent-options.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1.preserve-sent-options.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,22 @@
+--- dhcp-3.0.1/client/dhclient.c.preserve-sent-options	2004-08-16 14:52:21.525206000 -0400
++++ dhcp-3.0.1/client/dhclient.c	2004-08-16 16:10:59.258812000 -0400
+@@ -1955,7 +1955,10 @@
+ 				    DHO_DHCP_SERVER_IDENTIFIER);
+ 	else
+ 		oc = (struct option_cache *)0;
+-
++	
++	if( client-&gt;sent_options != 0L )
++	    option_state_dereference (&amp;client -&gt; sent_options, MDL);	    
++	
+ 	make_client_options (client, lease, &amp;request, oc,
+ 			     ((client -&gt; state == S_REQUESTING ||
+ 			       client -&gt; state == S_REBOOTING)
+@@ -1978,7 +1981,6 @@
+ 			      (struct data_string *)0,
+ 			      client -&gt; config -&gt; vendor_space_name);
+ 
+-	option_state_dereference (&amp;client -&gt; sent_options, MDL);
+ 	if (client -&gt; packet_length &lt; BOOTP_MIN_LEN)
+ 		client -&gt; packet_length = BOOTP_MIN_LEN;
+ 

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-RHscript.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-RHscript.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-RHscript.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,146 @@
+--- dhcp-3.0.1rc12/client/scripts/linux.RHscript	2002-11-14 20:09:09.000000000 -0500
++++ dhcp-3.0.1rc12/client/scripts/linux	2004-01-24 08:49:54.829793151 -0500
+@@ -19,12 +19,32 @@
+ # address if it is not supplied. This might be much more easily done
+ # by the dhclient C code, and passed on.
+ 
+-# 4. TIMEOUT not tested. ping has a flag I don't know, and I'm suspicious
+-# of the $1 in its args.
+-
++function save_previous() {
++  if [ -e $1 -a ! -e $1.predhclient ]; then
++    mv $1 $1.predhclient 
++  fi
++}
+ make_resolv_conf() {
+-  if [ &quot;x$new_domain_name&quot; != x ] &amp;&amp; [ x&quot;$new_domain_name_servers&quot; != x ]; then
+-    echo search $new_domain_name &gt;/etc/resolv.conf
++  if [ &quot;${PEERDNS}&quot; == &quot;no&quot; ]; then  
++      return 
++  fi
++
++  if [ x$reason == xRENEW ]; then 
++      if [ &quot;$new_domain_name&quot; == &quot;$old_domain_name&quot; ] &amp;&amp; [ &quot;$new_domain_servers&quot; == &quot;$old_domain_servers&quot; ]; then
++	  return
++      fi
++  fi
++
++  if [ -n &quot;$new_domain_name&quot; ] || [ -n &quot;$new_domain_name_servers&quot; ]; then
++    save_previous /etc/resolv.conf
++    echo '; generated by /sbin/dhclient-script' &gt; /etc/resolv.conf
++    if [ -n &quot;$SEARCH&quot; ]; then
++ 	echo search $SEARCH &gt;&gt; /etc/resolv.conf
++    else
++	if [ -n &quot;$new_domain_name&quot; ]; then
++ 	    echo search $new_domain_name &gt;&gt; /etc/resolv.conf
++        fi
++    fi
+     chmod 644 /etc/resolv.conf
+     for nameserver in $new_domain_name_servers; do
+       echo nameserver $nameserver &gt;&gt;/etc/resolv.conf
+@@ -53,6 +73,25 @@
+   fi
+ fi
+ 
++# Import Red Hat Linux configuration
++cd /etc/sysconfig/network-scripts;
++. /etc/sysconfig/network-scripts/network-functions
++. /etc/rc.d/init.d/functions
++
++[ -f ../network ] &amp;&amp; . ../network
++[ -f ../networking/network ] &amp;&amp; . ../networking/network
++
++CONFIG=$interface
++
++need_config ${CONFIG}
++
++[ -f &quot;${CONFIG}&quot; ] || {
++    echo $&quot;$0: configuration for $interface not found.&quot; &gt;&amp;2
++    exit_with_hooks 1
++}   
++
++source_config
++
+ release=`uname -r`
+ release=`expr $release : '\(.*\)\..*'`
+ relminor=`echo $release |sed -e 's/[0-9]*\.\([0-9][0-9]*\)\(\..*\)*$/\1/'`
+@@ -106,13 +145,52 @@
+   
+ if [ x$reason = xBOUND ] || [ x$reason = xRENEW ] || \
+    [ x$reason = xREBIND ] || [ x$reason = xREBOOT ]; then
+-  current_hostname=`hostname`
+-  if [ x$current_hostname = x ] || \
+-     [ x$current_hostname = x$old_host_name ]; then
+-    if [ x$current_hostname = x ] || \
+-       [ x$new_host_name != x$old_host_name ]; then
++
++  if [ &quot;${PEERNIS}&quot; = no ]; then
++    :
++  elif [ -n &quot;$new_nis_domain&quot; ]; then
++	domainname &quot;$new_nis_domain&quot;
++	save_previous /etc/yp.conf
++	echo '# generated by /sbin/dhclient-script' &gt; /etc/yp.conf
++	if [ -n &quot;$new_nis_servers&quot; ]; then
++	    for I in $new_nis_servers; do
++		echo &quot;domain $new_nis_domain server $I&quot; &gt;&gt; /etc/yp.conf
++	    done
++	else
++	    echo &quot;domain $new_nis_domain broadcast&quot; &gt;&gt; /etc/yp.conf
++	fi
++  elif [ -n &quot;$new_nis_servers&quot; ]; then
++      save_previous /etc/yp.conf
++      echo '# generated by /sbin/dhclient-script' &gt; /etc/yp.conf
++      for I in $new_nis_servers; do
++	  echo &quot;ypserver $I&quot; &gt;&gt; /etc/yp.conf
++      done
++  fi
++
++  if [ &quot;${PEERNTP}&quot; = no ]; then
++    :
++  elif [ -n &quot;$new_ntp_servers&quot; ] &amp;&amp; [ -e /etc/ntp.conf ]; then
++      save_previous /etc/ntp.conf
++      cat &lt;&lt;EOF &gt; /etc/ntp.conf
++# generated by /sbin/dhclient-script
++restrict default ignore
++restrict 127.0.0.1
++driftfile /var/lib/ntp/drift
++broadcastdelay 0.008
++authenticate yes
++keys /etc/ntp/keys
++EOF
++      save_previous /etc/ntp/step-tickers
++      echo '# generated by /sbin/dhclient-script' &gt; /etc/ntp/step-tickers
++      for I in $new_ntp_servers; do
++          echo &quot;restrict $I nomodify notrap noquery&quot; &gt;&gt; /etc/ntp.conf
++	  echo &quot;server $I&quot; &gt;&gt; /etc/ntp.conf
++	  echo &quot;$I&quot; &gt;&gt; /etc/ntp/step-tickers
++      done
++  fi
++
++  if [ -n &quot;$new_host_name&quot; ] &amp;&amp; need_hostname; then
+       hostname $new_host_name
+-    fi
+   fi
+     
+   if [ x$old_ip_address != x ] &amp;&amp; [ x$alias_ip_address != x ] &amp;&amp; \
+@@ -174,8 +252,7 @@
+   ifconfig $interface inet $new_ip_address $new_subnet_arg \
+ 					$new_broadcast_arg
+   set $new_routers
+-  ############## what is -w in ping?
+-  if ping -q -c 1 $1; then
++  if ping -q -c 1 -w 10 $1; then
+     if [ x$new_ip_address != x$alias_ip_address ] &amp;&amp; \
+ 			[ x$alias_ip_address != x ]; then
+       ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
+@@ -188,7 +265,9 @@
+     for router in $new_routers; do
+       route add default gw $router
+     done
+-    make_resolv_conf
++    if [ &quot;${PEERDNS}&quot; != &quot;no&quot; ]; then 
++      make_resolv_conf
++    fi
+     exit_with_hooks 0
+   fi
+   ifconfig $interface inet 0 down

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-inherit-leases.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-inherit-leases.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-inherit-leases.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,33 @@
+--- dhcp-3.0.1rc14/client/scripts/linux.inherit-leases	2004-06-23 17:41:17.576048392 -0400
++++ dhcp-3.0.1rc14/client/scripts/linux	2004-06-23 17:42:14.788350800 -0400
+@@ -123,8 +123,9 @@
+     # Bring down alias interface. Its routes will disappear too.
+     ifconfig $interface:0- inet 0
+   fi
+-  if [ $relmajor -lt 2 ] || ( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] )
+-   then
++  if [ x$keep_old_ip == xyes ]; then
++    ifconfig $interface up
++  elif [ $relmajor -lt 2 ] || ( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] )   then
+     ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
+ 		broadcast 255.255.255.255 up
+     # Add route to make broadcast work. Do not omit netmask.
+--- dhcp-3.0.1rc14/client/dhclient.c.inherit-leases	2004-06-23 17:41:17.474063896 -0400
++++ dhcp-3.0.1rc14/client/dhclient.c	2004-06-23 17:41:17.647037600 -0400
+@@ -378,6 +378,16 @@
+ 				continue;
+ 			script_init (ip -&gt; client,
+ 				     &quot;PREINIT&quot;, (struct string_list *)0);
++			if (/* Has an active lease */
++			    ip -&gt; client -&gt; active &amp;&amp;
++			    !ip -&gt; client -&gt; active -&gt; is_bootp &amp;&amp;
++			    ip -&gt; client -&gt; active -&gt; expiry &gt; cur_time &amp;&amp;
++			    /* Which is same as current ip */
++			    ip -&gt; primary_address.s_addr != 0 &amp;&amp;
++			    ip -&gt; client -&gt; active -&gt; address.len == 4 &amp;&amp;
++			    memcmp (ip -&gt; client -&gt; active -&gt; address.iabuf,
++				    &amp;ip-&gt;primary_address, 4) == 0)
++				client_envadd (ip -&gt; client, &quot;&quot;, &quot;keep_old_ip&quot;, &quot;%s&quot;, &quot;yes&quot;);
+ 			if (ip -&gt; client -&gt; alias)
+ 				script_write_params (ip -&gt; client, &quot;alias_&quot;,
+ 						     ip -&gt; client -&gt; alias);

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-pie.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-pie.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-pie.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,10 @@
+--- dhcp-3.0.1rc12/server/Makefile.dist.pie	2002-11-17 03:29:30.000000000 +0100
++++ dhcp-3.0.1rc12/server/Makefile.dist	2004-05-17 16:13:30.085925200 +0200
+@@ -98,6 +98,6 @@
+ 		-e &quot;s#RUNDIR#$(VARRUN)#g&quot; &lt; dhcpd.leases.5 &gt;dhcpd.leases.man5
+ 
+ dhcpd:	$(OBJS) $(COBJ) $(DHCPLIB)
+-	$(CC) $(LFLAGS) -o dhcpd $(OBJS) $(DHCPLIB) $(LIBS)
++	$(CC) $(LFLAGS) -pie -o dhcpd $(OBJS) $(DHCPLIB) $(LIBS)
+ 
+ # Dependencies (semi-automatically-generated)

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-staticroutes.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-staticroutes.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1rc12-staticroutes.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,21 @@
+--- dhcp-3.0.1rc12/client/scripts/linux.staticroutes	2004-03-25 14:53:20.740651072 -0500
++++ dhcp-3.0.1rc12/client/scripts/linux	2004-03-25 14:53:20.747650008 -0500
+@@ -217,6 +217,18 @@
+     for router in $new_routers; do
+       route add default gw $router
+     done
++    # static routes
++    if [ &quot;x$new_static_routes&quot; != x ]; then
++      len=`echo $new_static_routes | awk '{print NF}'`
++      i=1
++      while [ $i -lt $len ]; do
++        target=`echo $new_static_routes | awk &quot;{print \\$$i}&quot;`
++        let i=i+1
++        gateway=`echo $new_static_routes | awk &quot;{print \\$$i}&quot;`
++        let i=i+1
++        route add -host $target gw $gateway $interface
++      done
++    fi
+   fi
+   if [ x$new_ip_address != x$alias_ip_address ] &amp;&amp; [ x$alias_ip_address != x ];
+    then

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-dhcpctlman.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-dhcpctlman.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-dhcpctlman.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,21 @@
+--- dhcp-3.0.1/dhcpctl/dhcpctl.3.dhcpctlman	2004-06-10 13:59:23.000000000 -0400
++++ dhcp-3.0.1/dhcpctl/dhcpctl.3	2004-06-15 15:07:41.800138192 -0400
+@@ -43,7 +43,8 @@
+ .\&quot;
+ .\&quot;
+ .Sh SYNOPSIS
+-.Fd #include &lt;dhcpctl/dhcpctl.h&gt;
++.Fd #include &lt;dhcpctl.h&gt;
++.sp
+ .Ft dhcpctl_status
+ .Fo dhcpctl_initialize
+ .Fa void
+@@ -424,7 +425,7 @@
+ #include &lt;netinet/in.h&gt;
+ 
+ #include &lt;isc/result.h&gt;
+-#include &lt;dhcpctl/dhcpctl.h&gt;
++#include &lt;dhcpctl.h&gt;
+ 
+ int main (int argc, char **argv) {
+ 	dhcpctl_data_string ipaddrstring = NULL;

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-noexpr.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-noexpr.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1rc13-noexpr.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,16 @@
+--- dhcp-3.0.1/client/scripts/linux.noexp	2004-06-21 11:37:13.630140936 -0400
++++ dhcp-3.0.1/client/scripts/linux	2004-06-21 11:37:13.670134856 -0400
+@@ -92,10 +92,9 @@
+ 
+ source_config
+ 
+-release=`uname -r`
+-release=`expr $release : '\(.*\)\..*'`
+-relminor=`echo $release |sed -e 's/[0-9]*\.\([0-9][0-9]*\)\(\..*\)*$/\1/'`
+-relmajor=`echo $release |sed -e 's/\([0-9][0-9]*\)\..*$/\1/'`
++release=`uname -r`
++relmajor=`echo $release |/bin/cut -f1 -d'.'`
++relminor=`echo $release |/bin/cut -f2 -d'.'`
+ 
+ if [ x$new_broadcast_address != x ]; then
+   new_broadcast_arg=&quot;broadcast $new_broadcast_address&quot;

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.1rc14-noconfig.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.1rc14-noconfig.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.1rc14-noconfig.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,18 @@
+--- dhcp-3.0.1rc14/client/scripts/linux.noconfig	2004-06-23 17:43:11.000000000 -0400
++++ dhcp-3.0.1rc14/client/scripts/linux	2004-06-24 14:41:27.857538440 -0400
+@@ -85,10 +85,11 @@
+ 
+ need_config ${CONFIG}
+ 
+-[ -f &quot;${CONFIG}&quot; ] || {
+-    echo $&quot;$0: configuration for $interface not found.&quot; &gt;&amp;2
+-    exit_with_hooks 1
+-}   
++if [ -f &quot;${CONFIG}&quot; ]; then 
++    source_config
++else
++    echo $&quot;$0: configuration for $interface not found. Continuing with defaults.&quot; &gt;&amp;2
++fi
+ 
+ source_config
+ 

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.3-alignment.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.3-alignment.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.3-alignment.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,24 @@
+--- common/packet.c.orig	2005-08-10 00:03:29.942311824 +0200
++++ common/packet.c	2005-08-10 00:05:31.223874224 +0200
+@@ -218,8 +218,8 @@
+ 	unsigned buflen;
+ {
+   unsigned char *data;
+-  struct ip ip;
+-  struct udphdr *udp;
++  struct ip ipdat, *ip = &amp;ipdat;
++  struct udphdr udpdat, *udp = &amp;udpdat;
+   u_int32_t ip_len = (buf [bufix] &amp; 0xf) &lt;&lt; 2;
+   u_int32_t sum, usum;
+   static int ip_packets_seen;
+@@ -232,8 +232,8 @@
+   unsigned ulen;
+   int ignore = 0;
+ 
+-  memcpy(&amp;ip, buf + bufix, sizeof (struct ip));
+-  udp = (struct udphdr *)(buf + bufix + ip_len);
++  memcpy(ip, (struct ip *)(buf + bufix), sizeof(ipdat));
++  memcpy(udp, (struct udphdr *)(buf + bufix + ip_len), sizeof(udpdat));
+ 
+ #ifdef USERLAND_FILTER
+   /* Is it a UDP packet? */

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.3-host_dereference.patch
===================================================================

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.3-ldap-patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.3-ldap-patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.3-ldap-patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,4657 @@
+diff -Naur dhcp-3.0.3/Changelog-LDAP dhcp-3.0.3-ldap/Changelog-LDAP
+--- dhcp-3.0.3/Changelog-LDAP	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/Changelog-LDAP	2005-07-25 08:14:43.000000000 -0400
+@@ -0,0 +1,125 @@
++2005-5-24 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_parse_host) - allow dhcpHost entries that do
++	not have a hardware address associated with them
++
++2005-4-11 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* README.ldap - updated directions on how to use LDAP over SSL on
++	non-Linux machines
++
++2005-2-23 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_generate_config_string) - do a case insensitive
++	string comparsion when comparing the object classes
++
++2004-11-8 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* debian/control - updated the depends and build-depends line
++	(from Andrew Pollock &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">me at andrew.net.au</A>&gt;)
++
++2004-10-13 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_start) - allow doing an anonymous bind to the
++	LDAP server
++
++2004-9-27 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* contrib/dhcpd-conf-to-ldap.pl - make sure the DHCP hardware address
++	is always lowercased
++
++2004-7-30 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c - added more debbuging statements. Fixed possible crash
++	that could occur whenever more than 1 external DN is added to an LDAP
++	entry. Fixed possible infinite loop when reading the external DNs.
++	(from Sebastian Hetze &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">s.hetze at linux-ag.de</A>&gt;)
++
++2004-7-1 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* README.ldap - updated build instructions paragraph
++	(from Mason Schmitt &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sysadmin at sunwave.net</A>&gt;)
++
++2004-6-29 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* debian/control - set the minimum required version of the DHCP server
++	to be 3.0.1rc9
++
++	* configure - fix for sed when configure was run from an older shell
++
++2004-6-22 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* Updated patch to use ISC DHCP 3.0.1rc14
++
++2004-5-24 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c - don't append a ; to the end of a dhcpStatement if it
++	ends in }
++
++	* server/ldap.c contrib/dhcpd-conf-to-ldap.pl - support having multiple
++	dhcpRange statements (from Marco D'Ettorre &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">marco.dettorre at sys-net.it</A>&gt;)
++
++2004-5-5 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c - added more debugging statements when
++	it is compiled in to help troubleshoot parsing errors. Don't free
++	a LDAP connection prematurely when there is a reference to another
++	LDAP tree. If the config entry ends in }, make sure a ; gets tacked
++	on
++
++	* debian/* - Updated version number. Renamed package from
++	dhcp3-ldap-ntelos to dhcp3-server-ldap.
++
++	* server/ldap.c - enclose the shared-network name in quotes so
++	that there can be shared network statements in LDAP that have spaces
++	in them
++
++	* configure - after the work directory is setup, add -lldap -llber
++	to the server Makefile
++
++Wed Apr 21 15:09:08 CEST 2004 - <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>
++	* contrib/dhcpd-conf-to-ldap.pl:
++	  - added &quot;--conf=file&quot; option usable instead of stdin
++	  - added &quot;--ldif=file&quot; option usable instead of stdout
++	  - added &quot;--second=host|dn&quot; option usefull for failover
++	  - added &quot;--use=feature&quot; option to enable extended features;
++	    currently used to enable failover (default is disabled).
++	  - extended remaining_line() to support block statements
++	  - fixed / improved failover support, added notes about
++
++	* server/ldap.c:
++	  - moved code checking statement ends to check_statement_end()
++	  - moved parsing of entry options/statements to
++	    ldap_parse_entry_options()
++	  - moved code closing debug fd into ldap_close_debug_fd()
++	  - moved code writing to debug fd into ldap_write_debug()
++	  - added support for full hostname in dhcpServer search filter
++	  - added support for multiple dhcpService entries in dhcpServer object
++	  - added parsing of options and statements for dhcpServer object
++	  - added verify if dhcpService contains server dn as primary or
++	    secondary
++	  - changed to search for dhcpHost,dhcpSubClass bellow of all
++	    dhcpService trees instead of base-dn (avoids finding of hosts in
++	    foreign configs)
++	  - fixes to free all dn's fetched by ldap_get_dn (e.g. debug output)
++	  - fixes to free ldap results, mainly in cases where no LDAP_SUCCESS
++	    returned or other error conditions happened
++	  - fixed/improved some log messages
++
++2004-3-30 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* contrib/dhcpd-conf-to-ldap.pl - added option to control the
++	DHCP Config DN. Wrap the DHCP Statements in { }
++	This patch was contributed by Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;
++
++	* server/ldap.c - changed ldap_username and ldap_password to
++	be optional (anonymous bind is used then). Added {} block support
++	to dhcpStatements. (no &quot;;&quot; at end if statement ends with a &quot;}&quot;).
++	Fixed writing to ldap-debug-file. Changed find_haddr_in_ldap() to
++	use dhcpHost objectClass in its filter
++	This patch was contributed by Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;
++
++2004-3-23 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* contrib/dhcpd-conf-to-ldap.pl - added options for server, basedn
++	options and usage message (Net::Domain instead of SYS::Hostname).
++	Added handling of zone, authoritative and failover (config and
++	pool-refs) statements. Added numbering of groups and pools per
++	subnet. This patch was contributed by Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;
++
++2004-2-26 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* fixed an instance where the LDAP server would restart, but the DHCP
++	server would not reconnect
++
++2004-2-18 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* allow multiple dhcp*DN entries in the LDAP entry.
++
++2003-9-11 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* updated patch to work with 3.0.1rc12
++
+diff -Naur dhcp-3.0.3/common/conflex.c dhcp-3.0.3-ldap/common/conflex.c
+--- dhcp-3.0.3/common/conflex.c	2005-03-03 11:55:22.000000000 -0500
++++ dhcp-3.0.3-ldap/common/conflex.c	2005-07-25 08:14:43.000000000 -0400
+@@ -47,6 +47,7 @@
+ static enum dhcp_token read_number PROTO ((int, struct parse *));
+ static enum dhcp_token read_num_or_name PROTO ((int, struct parse *));
+ static enum dhcp_token intern PROTO ((char *, enum dhcp_token));
++static char read_function PROTO ((struct parse *));
+ 
+ isc_result_t new_parse (cfile, file, inbuf, buflen, name, eolp)
+ 	struct parse **cfile;
+@@ -74,6 +75,10 @@
+ 	tmp -&gt; file = file;
+ 	tmp -&gt; eol_token = eolp;
+ 
++	if (file != -1) {
++		tmp -&gt; read_function = read_function;;
++	}
++
+ 	tmp -&gt; bufix = 0;
+ 	tmp -&gt; buflen = buflen;
+ 	if (inbuf) {
+@@ -109,22 +114,11 @@
+ 	int c;
+ 
+ 	if (cfile -&gt; bufix == cfile -&gt; buflen) {
+-		if (cfile -&gt; file != -1) {
+-			cfile -&gt; buflen =
+-				read (cfile -&gt; file,
+-				      cfile -&gt; inbuf, cfile -&gt; bufsiz);
+-			if (cfile -&gt; buflen == 0) {
+-				c = EOF;
+-				cfile -&gt; bufix = 0;
+-			} else if (cfile -&gt; buflen &lt; 0) {
+-				c = EOF;
+-				cfile -&gt; bufix = cfile -&gt; buflen = 0;
+-			} else {
+-				c = cfile -&gt; inbuf [0];
+-				cfile -&gt; bufix = 1;
+-			}
+-		} else
++		if (cfile -&gt; read_function) {
++			c = cfile -&gt; read_function (cfile);
++		} else {
+ 			c = EOF;
++		}
+ 	} else {
+ 		c = cfile -&gt; inbuf [cfile -&gt; bufix];
+ 		cfile -&gt; bufix++;
+@@ -1122,3 +1116,25 @@
+ 	}
+ 	return dfv;
+ }
++
++
++static char
++read_function (struct parse * cfile)
++{
++  char c;
++
++	cfile -&gt; buflen = read (cfile -&gt; file, cfile -&gt; inbuf, cfile -&gt; bufsiz);
++	if (cfile -&gt; buflen == 0) {
++		c = EOF;
++		cfile -&gt; bufix = 0;
++	} else if (cfile -&gt; buflen &lt; 0) {
++		c = EOF;
++		cfile -&gt; bufix = cfile -&gt; buflen = 0;
++	} else {
++		c = cfile -&gt; inbuf [0];
++		cfile -&gt; bufix = 1;
++	}
++
++	return c;
++}
++
+diff -Naur dhcp-3.0.3/common/print.c dhcp-3.0.3-ldap/common/print.c
+--- dhcp-3.0.3/common/print.c	2004-06-17 16:54:39.000000000 -0400
++++ dhcp-3.0.3-ldap/common/print.c	2005-07-25 08:14:44.000000000 -0400
+@@ -166,9 +166,9 @@
+ }
+ 
+ char *print_hw_addr (htype, hlen, data)
+-	int htype;
+-	int hlen;
+-	unsigned char *data;
++	const int htype;
++	const int hlen;
++	const unsigned char *data;
+ {
+ 	static char habuf [49];
+ 	char *s;
+diff -Naur dhcp-3.0.3/configure dhcp-3.0.3-ldap/configure
+--- dhcp-3.0.3/configure	2004-09-10 17:02:30.000000000 -0400
++++ dhcp-3.0.3-ldap/configure	2005-07-25 08:14:44.000000000 -0400
+@@ -269,4 +269,8 @@
+   make links
+ fi
+ 
++mv $workname/server/Makefile $workname/server/Makefile.noldap
++cat $workname/server/Makefile.noldap | sed 's/^LIBS =/LIBS=-lldap -llber/' &gt; $workname/server/Makefile.ldap
++ln $workname/server/Makefile.ldap $workname/server/Makefile
++
+ exit 0
+diff -Naur dhcp-3.0.3/contrib/dhcpd-conf-to-ldap.pl dhcp-3.0.3-ldap/contrib/dhcpd-conf-to-ldap.pl
+--- dhcp-3.0.3/contrib/dhcpd-conf-to-ldap.pl	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/contrib/dhcpd-conf-to-ldap.pl	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,752 @@
++#!/usr/bin/perl -w
++
++# Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++# To use this script, set your base DN below. Then run 
++# ./dhcpd-conf-to-ldap.pl &lt; /path-to-dhcpd-conf/dhcpd.conf &gt; output-file
++# The output of this script will generate entries in LDIF format. You can use
++# the slapadd command to add these entries into your LDAP server. You will
++# definately want to double check that your LDAP entries are correct before
++# you load them into LDAP.
++
++# This script does not do much error checking. Make sure before you run this
++# that the DHCP server doesn't give any errors about your config file
++
++# FailOver notes:
++#   Failover is disabled by default, since it may need manually intervention.
++#   You can try the '--use=failover' option to see what happens :-)
++#
++#   If enabled, the failover pool references will be written to LDIF output.
++#   The failover configs itself will be added to the dhcpServer statements
++#   and not to the dhcpService object (since this script uses only one and
++#   it may be usefull to have multiple service containers in failover mode).
++#   Further, this script does not check if primary or secondary makes sense,
++#   it simply converts what it gets...
++
++use Net::Domain qw(hostname hostfqdn hostdomain);
++use Getopt::Long;
++
++my $domain = hostdomain();           # your.domain
++my $basedn = &quot;dc=&quot;.$domain;
++   $basedn =~ s/\./,dc=/g;           # dc=your,dc=domain
++my $server = hostname();             # hostname (nodename)
++my $dhcpcn = 'DHCP Config';          # CN of DHCP config tree
++my $dhcpdn = &quot;cn=$dhcpcn, $basedn&quot;;  # DHCP config tree DN
++my $second = '';                     # secondary server DN / hostname
++my $i_conf = '';                     # dhcp.conf file to read or stdin
++my $o_ldif = '';                     # output ldif file name or stdout
++my @use    = ();                     # extended flags (failover)
++
++sub usage($;$)
++{
++  my $rc = shift;
++  my $err= shift;
++
++  print STDERR &quot;Error: $err\n\n&quot; if(defined $err);
++  print STDERR &lt;&lt;__EOF_USAGE__;
++usage: 
++  $0 [options] &lt; dhcpd.conf &gt; dhcpd.ldif
++
++options:
++
++  --basedn  &quot;dc=your,dc=domain&quot;        (&quot;$basedn&quot;)
++
++  --dhcpdn  &quot;dhcp config DN&quot;           (&quot;$dhcpdn&quot;)
++
++  --server  &quot;dhcp server name&quot;         (&quot;$server&quot;)
++
++  --second  &quot;secondary server or DN&quot;   (&quot;$second&quot;)
++
++  --conf    &quot;/path/to/dhcpd.conf&quot;      (default is stdin)
++  --ldif    &quot;/path/to/output.ldif&quot;     (default is stdout)
++
++  --use     &quot;extended features&quot;        (see source comments)
++__EOF_USAGE__
++  exit($rc);
++}
++
++
++sub next_token
++{
++  local ($lowercase) = @_;
++  local ($token, $newline);
++
++  do 
++    {
++      if (!defined ($line) || length ($line) == 0)
++        {
++          $line = &lt;&gt;;
++          return undef if !defined ($line);
++          chop $line;
++          $line_number++;
++          $token_number = 0;
++        }
++
++      $line =~ s/#.*//;
++      $line =~ s/^\s+//;
++      $line =~ s/\s+$//;
++    }
++  while (length ($line) == 0);
++
++  if (($token, $newline) = $line =~ /^(.*?)\s+(.*)/)
++    {
++      $line = $newline;
++    }
++  else
++    {
++      $token = $line;
++      $line = '';
++    }
++  $token_number++;
++
++  $token =~ y/[A-Z]/[a-z]/ if $lowercase;
++
++  return ($token);
++}
++
++
++sub remaining_line
++{
++  local ($block) = shift || 0;
++  local ($tmp, $str);
++
++  $str = &quot;&quot;;
++  while (defined($tmp = next_token (0)))
++    {
++      $str .= ' ' if !($str eq &quot;&quot;);
++      $str .= $tmp;
++      last if $tmp =~ /;\s*$/;
++      last if($block and $tmp =~ /\s*[}{]\s*$/);
++    }
++
++  $str =~ s/;$//;
++  return ($str);
++}
++
++
++sub
++add_dn_to_stack
++{
++  local ($dn) = @_;
++
++  $current_dn = &quot;$dn, $current_dn&quot;;
++}
++
++
++sub
++remove_dn_from_stack
++{
++  $current_dn =~ s/^.*?,\s*//;
++}
++
++
++sub
++parse_error
++{
++  print &quot;Parse error on line number $line_number at token number $token_number\n&quot;;
++  exit (1);
++}
++
++
++sub
++print_entry
++{
++  return if (scalar keys %curentry == 0);
++
++  if (!defined ($curentry{'type'}))
++    {
++      $hostdn = &quot;cn=$server, $basedn&quot;;
++      print &quot;dn: $hostdn\n&quot;;
++      print &quot;cn: $server\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpServer\n&quot;;
++      print &quot;dhcpServiceDN: $current_dn\n&quot;;
++      if(grep(/FaIlOvEr/i, @use))
++        {
++          foreach my $fo_peer (keys %failover)
++            {
++              next if(scalar(@{$failover{$fo_peer}}) &lt;= 1);
++              print &quot;dhcpStatements: failover peer $fo_peer { &quot;,
++                    join('; ', @{$failover{$fo_peer}}), &quot;; }\n&quot;;
++            }
++        }
++      print &quot;\n&quot;;
++
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: $dhcpcn\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpService\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++      print &quot;dhcpPrimaryDN: $hostdn\n&quot;;
++      if(grep(/FaIlOvEr/i, @use) and ($second ne ''))
++        {
++          print &quot;dhcpSecondaryDN: $second\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'subnet')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'ip'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpSubnet\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++      
++      print &quot;dhcpNetMask: &quot; . $curentry{'netmask'} . &quot;\n&quot;;
++      if (defined ($curentry{'ranges'}))
++        {
++          foreach $statement (@{$curentry{'ranges'}})
++            {
++              print &quot;dhcpRange: $statement\n&quot;;
++            }
++        }
++    }
++  elsif ($curentry{'type'} eq 'shared-network')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'descr'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpSharedNetwork\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'group')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: group&quot;, $curentry{'idx'}, &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpGroup\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'host')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'host'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpHost\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++
++      if (defined ($curentry{'hwaddress'}))
++        {
++          $curentry{'hwaddress'} =~ y/[A-Z]/[a-z]/;
++          print &quot;dhcpHWAddress: &quot; . $curentry{'hwaddress'} . &quot;\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'pool')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: pool&quot;, $curentry{'idx'}, &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpPool\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++
++      if (defined ($curentry{'ranges'}))
++        {
++          foreach $statement (@{$curentry{'ranges'}})
++            {
++              print &quot;dhcpRange: $statement\n&quot;;
++            }
++        }
++    }
++  elsif ($curentry{'type'} eq 'class')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'class'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpClass\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'subclass')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'subclass'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpSubClass\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++      print &quot;dhcpClassData: &quot; . $curentry{'class'} . &quot;\n&quot;;
++    }
++
++  if (defined ($curentry{'statements'}))
++    {
++      foreach $statement (@{$curentry{'statements'}})
++        {
++          print &quot;dhcpStatements: $statement\n&quot;;
++        }
++    }
++
++  if (defined ($curentry{'options'}))
++    {
++      foreach $statement (@{$curentry{'options'}})
++        {
++          print &quot;dhcpOption: $statement\n&quot;;
++        }
++    }
++
++  print &quot;\n&quot;;
++  undef (%curentry);
++}
++
++
++sub parse_netmask
++{
++  local ($netmask) = @_;
++  local ($i);
++
++  if ((($a, $b, $c, $d) = $netmask =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) != 4)
++    {
++      parse_error ();
++    }
++
++  $num = (($a &amp; 0xff) &lt;&lt; 24) |
++         (($b &amp; 0xff) &lt;&lt; 16) |
++         (($c &amp; 0xff) &lt;&lt; 8) |
++          ($d &amp; 0xff);
++
++  for ($i=1; $i&lt;=32 &amp;&amp; $num &amp; (1 &lt;&lt; (32 - $i)); $i++)
++    {
++    }
++  $i--;
++
++  return ($i);
++}
++
++
++sub parse_subnet
++{
++  local ($ip, $tmp, $netmask);
++
++  print_entry () if %curentry;
++    
++  $ip = next_token (0);
++  parse_error () if !defined ($ip);
++
++  $tmp = next_token (1);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq 'netmask');
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  $netmask = parse_netmask ($tmp);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$ip&quot;);
++  $curentry{'type'} = 'subnet';
++  $curentry{'ip'} = $ip;
++  $curentry{'netmask'} = $netmask;
++  $cursubnet = $ip;
++  $curcounter{$ip} = { pool  =&gt; 0, group =&gt; 0 };
++}
++
++
++sub parse_shared_network
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $descr = next_token (0);
++  parse_error () if !defined ($descr);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$descr&quot;);
++  $curentry{'type'} = 'shared-network';
++  $curentry{'descr'} = $descr;
++}
++
++
++sub parse_host
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $host = next_token (0);
++  parse_error () if !defined ($host);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$host&quot;);
++  $curentry{'type'} = 'host';
++  $curentry{'host'} = $host;
++}
++
++
++sub parse_group
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  my $idx;
++  if(exists($curcounter{$cursubnet})) {
++    $idx = ++$curcounter{$cursubnet}-&gt;{'group'};
++  } else {
++    $idx = ++$curcounter{''}-&gt;{'group'};
++  }
++
++  add_dn_to_stack (&quot;cn=group&quot;.$idx);
++  $curentry{'type'} = 'group';
++  $curentry{'idx'} = $idx;
++}
++
++
++sub parse_pool
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  my $idx;
++  if(exists($curcounter{$cursubnet})) {
++    $idx = ++$curcounter{$cursubnet}-&gt;{'pool'};
++  } else {
++    $idx = ++$curcounter{''}-&gt;{'pool'};
++  }
++
++  add_dn_to_stack (&quot;cn=pool&quot;.$idx);
++  $curentry{'type'} = 'pool';
++  $curentry{'idx'} = $idx;
++}
++
++
++sub parse_class
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $class = next_token (0);
++  parse_error () if !defined ($class);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  $class =~ s/\&quot;//g;
++  add_dn_to_stack (&quot;cn=$class&quot;);
++  $curentry{'type'} = 'class';
++  $curentry{'class'} = $class;
++}
++
++
++sub parse_subclass
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $class = next_token (0);
++  parse_error () if !defined ($class);
++
++  $subclass = next_token (0);
++  parse_error () if !defined ($subclass);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$subclass&quot;);
++  $curentry{'type'} = 'subclass';
++  $curentry{'class'} = $class;
++  $curentry{'subclass'} = $subclass;
++}
++
++
++sub parse_hwaddress
++{
++  local ($type, $hw, $tmp);
++
++  $type = next_token (1);
++  parse_error () if !defined ($type);
++
++  $hw = next_token (1);
++  parse_error () if !defined ($hw);
++  $hw =~ s/;$//;
++
++  $curentry{'hwaddress'} = &quot;$type $hw&quot;;
++}
++
++    
++sub parse_range
++{
++  local ($tmp, $str);
++
++  $str = remaining_line ();
++
++  if (!($str eq ''))
++    {
++      $str =~ s/;$//;
++      push (@{$curentry{'ranges'}}, $str);
++    }
++}
++
++
++sub parse_statement
++{
++  local ($token) = shift;
++  local ($str);
++
++  if ($token eq 'option')
++    {
++      $str = remaining_line ();
++      push (@{$curentry{'options'}}, $str);
++    }
++  elsif($token eq 'failover')
++    {
++      $str = remaining_line (1); # take care on block
++      if($str =~ /[{]/)
++        {
++          my ($peername, @statements);
++
++          parse_error() if($str !~ /^\s*peer\s+(.+?)\s+[{]\s*$/);
++          parse_error() if(($peername = $1) !~ /^\&quot;?[^\&quot;]+\&quot;?$/);
++
++          #
++          # failover config block found:
++          # e.g. 'failover peer &quot;some-name&quot; {'
++          #
++          if(not grep(/FaIlOvEr/i, @use))
++            {
++              print STDERR &quot;Warning: Failover config 'peer $peername' found!\n&quot;;
++              print STDERR &quot;         Skipping it, since failover disabled!\n&quot;;
++              print STDERR &quot;         You may try out --use=failover option.\n&quot;;
++            }
++
++          until($str =~ /[}]/ or $str eq &quot;&quot;)
++            {
++                $str = remaining_line (1);
++                # collect all statements, except ending '}'
++                push(@statements, $str) if($str !~ /[}]/);
++            }
++          $failover{$peername} = [@statements];
++        }
++      else
++        {
++          #
++          # pool reference to failover config is fine
++          # e.g. 'failover peer &quot;some-name&quot;;'
++          #
++          if(not grep(/FaIlOvEr/i, @use))
++            {
++              print STDERR &quot;Warning: Failover reference '$str' found!\n&quot;;
++              print STDERR &quot;         Skipping it, since failover disabled!\n&quot;;
++              print STDERR &quot;         You may try out --use=failover option.\n&quot;;
++            }
++          else
++            {
++              push (@{$curentry{'statements'}}, $token. &quot; &quot; . $str);
++            }
++        }
++    }
++  elsif($token eq 'zone')
++    {
++      $str = $token;
++      while($str !~ /}$/) {
++        $str .= ' ' . next_token (0);
++      }
++      push (@{$curentry{'statements'}}, $str);
++    }
++  elsif($token =~ /^(authoritative)[;]*$/)
++    {
++      push (@{$curentry{'statements'}}, $1);
++    }
++  else
++    {
++      $str = $token . &quot; &quot; . remaining_line ();
++      push (@{$curentry{'statements'}}, $str);
++    }
++}
++
++
++my $ok = GetOptions(
++    'basedn=s'      =&gt; \$basedn,
++    'dhcpdn=s'      =&gt; \$dhcpdn,
++    'server=s'      =&gt; \$server,
++    'second=s'      =&gt; \$second,
++    'conf=s'        =&gt; \$i_conf,
++    'ldif=s'        =&gt; \$o_ldif,
++    'use=s'         =&gt; \@use,
++    'h|help|usage'  =&gt; sub { usage(0); },
++);
++
++unless($server =~ /^\w+/)
++  {
++    usage(1, &quot;invalid server name '$server'&quot;);
++  }
++unless($basedn =~ /^\w+=[^,]+/)
++  {
++    usage(1, &quot;invalid base dn '$basedn'&quot;);
++  }
++
++if($dhcpdn =~ /^cn=([^,]+)/i)
++  {
++    $dhcpcn = &quot;$1&quot;;
++  }
++$second = '' if not defined $second;
++unless($second eq '' or $second =~ /^cn=[^,]+\s*,\s*\w+=[^,]+/i)
++  {
++    if($second =~ /^cn=[^,]+$/i)
++      {
++        # relative DN 'cn=name'
++        $second = &quot;$second, $basedn&quot;;
++      }
++    elsif($second =~ /^\w+/)
++      {
++        # assume hostname only
++        $second = &quot;cn=$second, $basedn&quot;;
++      }
++    else
++      {
++        usage(1, &quot;invalid secondary '$second'&quot;)
++      }
++  }
++
++usage(1) unless($ok);
++
++if($i_conf ne &quot;&quot; and -f $i_conf)
++  {
++    if(not open(STDIN, '&lt;', $i_conf))
++      {
++        print STDERR &quot;Error: can't open conf file '$i_conf': $!\n&quot;;
++        exit(1);
++      }
++  }
++if($o_ldif ne &quot;&quot;)
++  {
++    if(-e $o_ldif)
++      {
++        print STDERR &quot;Error: output ldif name '$o_ldif' already exists!\n&quot;;
++        exit(1);
++      }
++    if(not open(STDOUT, '&gt;', $o_ldif))
++      {
++        print STDERR &quot;Error: can't open ldif file '$o_ldif': $!\n&quot;;
++        exit(1);
++      }
++  }
++
++
++print STDERR &quot;Creating LDAP Configuration with the following options:\n&quot;;
++print STDERR &quot;\tBase DN: $basedn\n&quot;;
++print STDERR &quot;\tDHCP DN: $dhcpdn\n&quot;;
++print STDERR &quot;\tServer DN: cn=$server, $basedn\n&quot;;
++print STDERR &quot;\tSecondary DN: $second\n&quot;
++             if(grep(/FaIlOvEr/i, @use) and $second ne '');
++print STDERR &quot;\n&quot;;
++
++my $token;
++my $token_number = 0;
++my $line_number = 0;
++my %curentry;
++my $cursubnet = '';
++my %curcounter = ( '' =&gt; { pool =&gt; 0, group =&gt; 0 } );
++
++$current_dn = &quot;$dhcpdn&quot;;
++$curentry{'descr'} = $dhcpcn;
++$line = '';
++%failover = ();
++
++while (($token = next_token (1)))
++  {
++    if ($token eq '}')
++      {
++        print_entry () if %curentry;
++        if($current_dn =~ /.+?,\s*${dhcpdn}$/) {
++          # don't go below dhcpdn ...
++          remove_dn_from_stack ();
++        }
++      }
++    elsif ($token eq 'subnet')
++      {
++        parse_subnet ();
++        next;
++      }
++    elsif ($token eq 'shared-network')
++      {
++        parse_shared_network ();
++        next;
++      }
++    elsif ($token eq 'class')
++      {
++        parse_class ();
++        next;
++      }
++    elsif ($token eq 'subclass')
++      {
++        parse_subclass ();
++        next;
++      }
++    elsif ($token eq 'pool')
++      {
++        parse_pool ();
++        next;
++      }
++    elsif ($token eq 'group')
++      {
++        parse_group ();
++        next;
++      }
++    elsif ($token eq 'host')
++      {
++        parse_host ();
++        next;
++      }
++    elsif ($token eq 'hardware')
++      {
++        parse_hwaddress ();
++        next;
++      }
++    elsif ($token eq 'range')
++      {
++        parse_range ();
++        next;
++      }
++    else
++      {
++        parse_statement ($token);
++        next;
++      }
++  }
++
++close(STDIN)  if($i_conf);
++close(STDOUT) if($o_ldif);
++
++print STDERR &quot;Done.\n&quot;;
++
+diff -Naur dhcp-3.0.3/contrib/dhcp.schema dhcp-3.0.3-ldap/contrib/dhcp.schema
+--- dhcp-3.0.3/contrib/dhcp.schema	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/contrib/dhcp.schema	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,343 @@
++attributetype ( 2.16.840.1.113719.1.203.4.1 
++	NAME 'dhcpPrimaryDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The DN of the dhcpServer which is the primary server for the configuration.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.2 
++	NAME 'dhcpSecondaryDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The DN of dhcpServer(s) which provide backup service for the configuration.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.3 
++	NAME 'dhcpStatements' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Flexible storage for specific data depending on what object this exists in. Like conditional statements, server parameters, etc. This allows the standard to evolve without needing to adjust the schema.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.4 
++	NAME 'dhcpRange' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'The starting &amp; ending IP Addresses in the range (inclusive), separated by a hyphen; if the range only contains one address, then just the address can be specified with no hyphen.  Each range is defined as a separate value.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.5 
++	NAME 'dhcpPermitList' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This attribute contains the permit lists associated with a pool. Each permit list is defined as a separate value.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.6 
++	NAME 'dhcpNetMask' 
++	EQUALITY integerMatch
++	DESC 'The subnet mask length for the subnet.  The mask can be easily computed from this length.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.7 
++	NAME 'dhcpOption' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Encoded option values to be sent to clients.  Each value represents a single option and contains (OptionTag, Length, OptionValue) encoded in the format used by DHCP.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.8 
++	NAME 'dhcpClassData' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Encoded text string or list of bytes expressed in hexadecimal, separated by colons.  Clients match subclasses based on matching the class data with the results of match or spawn with statements in the class name declarations.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.9 
++	NAME 'dhcpOptionsDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of the dhcpOption objects containing the configuration options provided by the server.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.10 
++	NAME 'dhcpHostDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'the distinguished name(s) of the dhcpHost objects.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 ) 
++
++attributetype ( 2.16.840.1.113719.1.203.4.11 
++	NAME 'dhcpPoolDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of pools.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.12 
++	NAME 'dhcpGroupDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s)   of the groups.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.13 
++	NAME 'dhcpSubnetDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of the subnets.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.14 
++	NAME 'dhcpLeaseDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name of a client address.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE)
++
++attributetype ( 2.16.840.1.113719.1.203.4.15 NAME 'dhcpLeasesDN' 
++	DESC 'The distinguished name(s) client addresses.' 
++	EQUALITY distinguishedNameMatch
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.16 
++	NAME 'dhcpClassesDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of a class(es) in a subclass.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.17 
++	NAME 'dhcpSubclassesDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of subclass(es).' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.18 
++	NAME 'dhcpSharedNetworkDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of sharedNetworks.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.19 
++	NAME 'dhcpServiceDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The DN of dhcpService object(s)which contain the configuration information. Each dhcpServer object has this attribute identifying the DHCP configuration(s) that the server is associated with.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.20 
++	NAME 'dhcpVersion' DESC 'The version attribute of this object.' 
++	EQUALITY caseIgnoreIA5Match
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.21 
++	NAME 'dhcpImplementation' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Description of the DHCP Server implementation e.g. DHCP Servers vendor.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.22 
++	NAME 'dhcpAddressState' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This stores information about the current binding-status of an address.  For dynamic addresses managed by DHCP, the values should be restricted to the following: &quot;FREE&quot;, &quot;ACTIVE&quot;, &quot;EXPIRED&quot;, &quot;RELEASED&quot;, &quot;RESET&quot;, &quot;ABANDONED&quot;, &quot;BACKUP&quot;.  For other addresses, it SHOULD be one of the following: &quot;UNKNOWN&quot;, &quot;RESERVED&quot; (an address that is managed by DHCP that is reserved for a specific client), &quot;RESERVED-ACTIVE&quot; (same as reserved, but address is currently in use), &quot;ASSIGNED&quot; (assigned manually or by some other mechanism), &quot;UNASSIGNED&quot;, &quot;NOTASSIGNABLE&quot;.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.23 
++	NAME 'dhcpExpirationTime' 
++	EQUALITY generalizedTimeMatch 
++	DESC 'This is the time the current lease for an address expires.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.24 
++	NAME 'dhcpStartTimeOfState' 
++	EQUALITY generalizedTimeMatch 
++	DESC 'This is the time of the last state change for a leased address.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.25 
++	NAME 'dhcpLastTransactionTime' 
++	EQUALITY generalizedTimeMatch 
++	DESC 'This is the last time a valid DHCP packet was received from the client.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.26 
++	NAME 'dhcpBootpFlag' 
++	EQUALITY booleanMatch 
++	DESC 'This indicates whether the address was assigned via BOOTP.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.7 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.27 
++	NAME 'dhcpDomainName' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This is the name of the domain sent to the client by the server.  It is essentially the same as the value for DHCP option 15 sent to the client, and represents only the domain - not the full FQDN.  To obtain the full FQDN assigned to the client you must prepend the &quot;dhcpAssignedHostName&quot; to this value with a &quot;.&quot;.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.28 
++	NAME 'dhcpDnsStatus' 
++	EQUALITY integerMatch
++	DESC 'This indicates the status of updating DNS resource records on behalf of the client by the DHCP server for this address.  The value is a 16-bit bitmask.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.29 
++	NAME 'dhcpRequestedHostName' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This is the hostname that was requested by the client.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.30 
++	NAME 'dhcpAssignedHostName' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This is the actual hostname that was assigned to a client. It may not be the name that was requested by the client.  The fully qualified domain name can be determined by appending the value of &quot;dhcpDomainName&quot; (with a dot separator) to this name.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.31 
++	NAME 'dhcpReservedForClient' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name of a &quot;dhcpClient&quot; that an address is reserved for.  This may not be the same as the &quot;dhcpAssignedToClient&quot; attribute if the address is being reassigned but the current lease has not yet expired.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.32 
++	NAME 'dhcpAssignedToClient' 
++	EQUALITY distinguishedNameMatch
++	DESC 'This is the distinguished name of a &quot;dhcpClient&quot; that an address is currently assigned to.  This attribute is only present in the class when the address is leased.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.33 
++	NAME 'dhcpRelayAgentInfo' 
++	EQUALITY octetStringMatch
++	DESC 'If the client request was received via a relay agent, this contains information about the relay agent that was available from the DHCP request.  This is a hex-encoded option value.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.34 
++	NAME 'dhcpHWAddress' 
++	EQUALITY octetStringMatch
++	DESC 'The clients hardware address that requested this IP address.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.35 
++	NAME 'dhcpHashBucketAssignment' 
++	EQUALITY octetStringMatch
++	DESC 'HashBucketAssignment bit map for the DHCP Server, as defined in DHC Load Balancing Algorithm [RFC 3074].' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.36 
++	NAME 'dhcpDelayedServiceParameter' 
++	EQUALITY integerMatch
++	DESC 'Delay in seconds corresponding to Delayed Service Parameter configuration, as defined in  DHC Load Balancing Algorithm [RFC 3074]. '
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.37 
++	NAME 'dhcpMaxClientLeadTime' 
++	EQUALITY integerMatch
++	DESC 'Maximum Client Lead Time configuration in seconds, as defined in DHCP Failover Protocol [FAILOVR]' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.38 
++	NAME 'dhcpFailOverEndpointState' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Server (Failover Endpoint) state, as defined in DHCP Failover Protocol [FAILOVR]' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.39 
++	NAME 'dhcpErrorLog' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Generic error log attribute that allows logging error conditions within a dhcpService or a dhcpSubnet, like no IP addresses available for lease.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++# Classes
++
++objectclass ( 2.16.840.1.113719.1.203.6.1 
++	NAME 'dhcpService' 
++	DESC 'Service object that represents the actual DHCP Service configuration. This is a container object.' 
++	SUP top 
++	MUST (cn $ dhcpPrimaryDN) 
++	MAY ( dhcpSecondaryDN $ dhcpSharedNetworkDN $ dhcpSubnetDN $ 
++		dhcpGroupDN $ dhcpHostDN $  dhcpClassesDN $ dhcpOptionsDN $ 
++		dhcpStatements ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.2 
++	NAME 'dhcpSharedNetwork' 
++	DESC 'This stores configuration information for a shared network.' 
++	SUP top 
++	MUST cn 
++	MAY ( dhcpSubnetDN $ dhcpPoolDN $ dhcpOptionsDN $ dhcpStatements) 
++	X-NDS_CONTAINMENT ('dhcpService' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.3 
++	NAME 'dhcpSubnet' 
++	DESC 'This class defines a subnet. This is a container object.' 
++	SUP top 
++	MUST ( cn $ dhcpNetMask ) 
++	MAY ( dhcpRange $ dhcpPoolDN $ dhcpGroupDN $ dhcpHostDN $ 
++		dhcpClassesDN $ dhcpLeasesDN $ dhcpOptionsDN $ dhcpStatements) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSharedNetwork') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.4 
++	NAME 'dhcpPool' 
++	DESC 'This stores configuration information about a pool.' 
++	SUP top 
++	MUST ( cn $ dhcpRange ) 
++	MAY (dhcpClassesDN $ dhcpPermitList $ dhcpLeasesDN $ dhcpOptionsDN $ 
++		dhcpStatements) 
++	X-NDS_CONTAINMENT ('dhcpSubnet' 'dhcpSharedNetwork') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.5 
++	NAME 'dhcpGroup' 
++	DESC 'Group object that lists host DNs and parameters. This is a container object.' 
++	SUP top 
++	MUST cn 
++	MAY ( dhcpHostDN $ dhcpOptionsDN $ dhcpStatements ) 
++	X-NDS_CONTAINMENT ('dhcpSubnet' 'dhcpService' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.6 
++	NAME 'dhcpHost' 
++	DESC 'This represents information about a particular client' 
++	SUP top 
++	MUST cn 
++	MAY  (dhcpLeaseDN $ dhcpHWAddress $ dhcpOptionsDN $ dhcpStatements) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSubnet' 'dhcpGroup') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.7 
++	NAME 'dhcpClass' 
++	DESC 'Represents information about a collection of related clients.' 
++	SUP top 
++	MUST cn 
++	MAY (dhcpSubClassesDN $ dhcpOptionsDN $ dhcpStatements) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSubnet' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.8 
++	NAME 'dhcpSubClass' 
++	DESC 'Represents information about a collection of related classes.' 
++	SUP top 
++	MUST cn 
++	MAY (dhcpClassData $ dhcpOptionsDN $ dhcpStatements) 
++	X-NDS_CONTAINMENT 'dhcpClass' ) 
++
++objectclass ( 2.16.840.1.113719.1.203.6.9 
++	NAME 'dhcpOptions' 
++	DESC 'Represents information about a collection of options defined.' 
++	SUP top AUXILIARY
++	MUST cn 
++	MAY ( dhcpOption ) 
++	X-NDS_CONTAINMENT  ('dhcpService' 'dhcpSharedNetwork' 'dhcpSubnet' 
++			'dhcpPool' 'dhcpGroup' 'dhcpHost' 'dhcpClass' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.10 
++	NAME 'dhcpLeases' 
++	DESC 'This class represents an IP Address, which may or may not have been leased.' 
++	SUP top 
++	MUST ( cn $ dhcpAddressState ) 
++	MAY ( dhcpExpirationTime $ dhcpStartTimeOfState $ 
++		dhcpLastTransactionTime $ dhcpBootpFlag $ dhcpDomainName $ 
++		dhcpDnsStatus $ dhcpRequestedHostName $ dhcpAssignedHostName $ 
++		dhcpReservedForClient $ dhcpAssignedToClient $ 
++		dhcpRelayAgentInfo $ dhcpHWAddress ) 
++	X-NDS_CONTAINMENT ( 'dhcpService' 'dhcpSubnet' 'dhcpPool') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.11 
++	NAME 'dhcpLog' 
++	DESC 'This is the object that holds past information about the IP address. The cn is the time/date stamp when the address was assigned or released, the address state at the time, if the address was assigned or released.' 
++	SUP top 
++	MUST ( cn ) 
++	MAY ( dhcpAddressState $ dhcpExpirationTime $ dhcpStartTimeOfState $ 
++		dhcpLastTransactionTime $ dhcpBootpFlag $ dhcpDomainName $ 
++		dhcpDnsStatus $ dhcpRequestedHostName $ dhcpAssignedHostName $ 
++		dhcpReservedForClient $ dhcpAssignedToClient $ 
++		dhcpRelayAgentInfo $ dhcpHWAddress $ dhcpErrorLog) 
++	X-NDS_CONTAINMENT ('dhcpLeases' 'dhcpPool' 'dhcpSubnet' 
++					'dhcpSharedNetwork' 'dhcpService' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.12 
++	NAME 'dhcpServer' 
++	DESC 'DHCP Server Object' 
++	SUP top 
++	MUST (cn $ dhcpServiceDN) 
++	MAY (dhcpVersion $ dhcpImplementation $ dhcpHashBucketAssignment $ dhcpDelayedServiceParameter $ dhcpMaxClientLeadTime $ dhcpFailOverEndpointState $ dhcpStatements)
++	X-NDS_CONTAINMENT ('o' 'ou' 'dc') )
++
+diff -Naur dhcp-3.0.3/debian/changelog dhcp-3.0.3-ldap/debian/changelog
+--- dhcp-3.0.3/debian/changelog	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/changelog	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,25 @@
++dhcp3-server-ldap (3.0.1rc14-1) unstable; urgency=low
++
++  * See ChangeLog-LDAP for changes in this release
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Tue, 22 Jun 2004 15:29:07 -0400
++
++dhcp3-server-ldap (3.0.1rc13-1) unstable; urgency=low
++
++  * See ChangeLog-LDAP for changes in this release
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Wed, 05 May 2004 07:20:13 -0400
++
++dhcp3-server-ldap (3.0.1rc12-1) unstable; urgency=low
++
++  * Updated patch to work against ISC DHCPD 3.0.1rc12
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Mon, 08 Sep 2003 16:34:00 -0400
++
++dhcp3-server-ldap (3.0.1rc11-2) unstable; urgency=low
++
++  * Added these Debian files. They are mostly from the existing dhcp3-server
++    package in Debian.
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Mon, 04 Aug 2003 13:34:00 -0400
++
+diff -Naur dhcp-3.0.3/debian/control dhcp-3.0.3-ldap/debian/control
+--- dhcp-3.0.3/debian/control	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/control	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,12 @@
++Source: dhcp3-server-ldap
++Section: net
++Priority: optional
++Maintainer: Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;
++Build-Depends: debhelper (&gt;= 2.1.18), dpkg-dev (&gt;= 1.7.0), groff, libldap2-dev
++Standards-Version: 2.4.0.0
++
++Package: dhcp3-server-ldap
++Architecture: any
++Depends: ${shlibs:Depends}, debconf, debianutils (&gt;= 1.7), dhcp3-server (&gt;= 3.0+3.0.1rc9)
++Conflicts: dhcp, dhcp3-ldap-ntelos
++Description: This is the DHCP server with LDAP patches applied to it
+diff -Naur dhcp-3.0.3/debian/copyright dhcp-3.0.3-ldap/debian/copyright
+--- dhcp-3.0.3/debian/copyright	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/copyright	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,30 @@
++/*
++ * Copyright (c) 1996, 1997 The Internet Software Consortium.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of The Internet Software Consortium nor the names of its
++ *    contributors may be used to endorse or promote products derived
++ *    from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
++ * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
++ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
++ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
++ * THE INTERNET SOFTWARE CONSORTIUM OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
++ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
++ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
++ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
++ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
++ * OF THE POSSIBILITY OF SUCH DAMAGE.
++ */
+diff -Naur dhcp-3.0.3/debian/dhcp3-server-ldap.files dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.files
+--- dhcp-3.0.3/debian/dhcp3-server-ldap.files	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.files	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1 @@
++usr/sbin/dhcpd3
+diff -Naur dhcp-3.0.3/debian/dhcp3-server-ldap.postinst dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.postinst
+--- dhcp-3.0.3/debian/dhcp3-server-ldap.postinst	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.postinst	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,13 @@
++#!/bin/sh
++
++set -e 
++
++# Removes the left over diversions of the old package
++
++if [ &quot;$1&quot; = remove -o &quot;$1&quot; = upgrade ]; then
++	for v in `list_versions`; do
++	        dpkg-divert --package dhcp3-server-ldap --remove \
++			--rename --divert /usr/sbin/dhcpd3-noldap \
++			/usr/sbin/dhcpd3
++	done
++fi
+diff -Naur dhcp-3.0.3/debian/dhcp3-server-ldap.postrm dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.postrm
+--- dhcp-3.0.3/debian/dhcp3-server-ldap.postrm	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.postrm	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,8 @@
++#!/bin/sh
++
++set -e 
++
++if [ &quot;$1&quot; = remove ]; then
++	dpkg-divert --package dhcp3-server-ldap --remove --rename \
++		--divert /usr/sbin/dhcpd3-noldap /usr/sbin/dhcpd3
++fi
+diff -Naur dhcp-3.0.3/debian/dhcp3-server-ldap.preinst dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.preinst
+--- dhcp-3.0.3/debian/dhcp3-server-ldap.preinst	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.preinst	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,14 @@
++#!/bin/sh
++
++set -e 
++
++if [ &quot;$1&quot; = install -o &quot;$1&quot; = upgrade ]; then
++	if dpkg-divert --list /usr/sbin/dhcpd3 \
++		| grep -q &quot;by dhcp3-server-ldap&quot;;
++	then
++		exit 0
++	fi
++		
++	dpkg-divert --package dhcp3-server-ldap --add --rename \
++		--divert /usr/sbin/dhcpd3-noldap /usr/sbin/dhcpd3
++fi
+diff -Naur dhcp-3.0.3/debian/dhcp3-server-ldap.substvars dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.substvars
+--- dhcp-3.0.3/debian/dhcp3-server-ldap.substvars	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/dhcp3-server-ldap.substvars	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1 @@
++shlibs:Depends=libc6 (&gt;= 2.3.2.ds1-4), libldap2 (&gt;= 2.1.17-1)
+diff -Naur dhcp-3.0.3/debian/dirs dhcp-3.0.3-ldap/debian/dirs
+--- dhcp-3.0.3/debian/dirs	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/dirs	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1 @@
++usr/sbin
+diff -Naur dhcp-3.0.3/debian/files dhcp-3.0.3-ldap/debian/files
+--- dhcp-3.0.3/debian/files	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/files	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1 @@
++dhcp3-server-ldap_3.0.1rc13-1_i386.deb net optional
+diff -Naur dhcp-3.0.3/debian/rules dhcp-3.0.3-ldap/debian/rules
+--- dhcp-3.0.3/debian/rules	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/debian/rules	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,87 @@
++#!/usr/bin/make -f
++# Made with the iad of dh_make, by Craig Small
++# Sample debian/rules that uses debhelper. GNU copyright 1997 by Joey Hess.
++# Also some stuff taken from debmake scripts, by Cristopt Lameter.
++
++# Uncomment this to turn on verbose mode.
++#export DH_VERBOSE=1
++
++export DH_COMPAT=3
++
++DESTDIR = `pwd`/debian/tmp
++
++IVARS = DESTDIR=$(DESTDIR)
++
++BVARS = PREDEFINES='-D_PATH_DHCPD_DB=\&quot;/var/lib/dhcp3/dhcpd.leases\&quot; \
++	-D_PATH_DHCLIENT_DB=\&quot;/var/lib/dhcp3/dhclient.leases\&quot; \
++	-D_PATH_DHCLIENT_SCRIPT=\&quot;/etc/dhcp3/dhclient-script\&quot; \
++	-D_PATH_DHCPD_CONF=\&quot;/etc/dhcp3/dhcpd.conf\&quot; \
++        -D_PATH_DHCLIENT_CONF=\&quot;/etc/dhcp3/dhclient.conf\&quot;'
++
++build: build-stamp
++build-stamp:
++	dh_testdir
++
++	./configure
++	$(MAKE) $(BVARS)
++
++	touch build-stamp
++
++clean: 
++	dh_testdir
++	rm -f build-stamp install-stamp
++
++	# Add here commands to clean up after the build process.
++	-$(MAKE) distclean
++
++	# Remove leftover junk...
++	rm -Rf work.linux-2.2/
++
++	dh_clean
++
++install: install-stamp
++install-stamp: build-stamp
++	dh_testdir
++	dh_testroot
++	dh_clean -k
++	dh_installdirs
++
++	# Add here commands to install the package into debian/tmp.
++	$(MAKE) install $(IVARS)
++
++	mv $(DESTDIR)/usr/sbin/dhcpd $(DESTDIR)/usr/sbin/dhcpd3
++
++	dh_movefiles
++
++	# Remove unwanted directories that dh_movefiles leaves around
++	rmdir $(DESTDIR)/etc
++	rm -Rf $(DESTDIR)/sbin/
++	rm -Rf $(DESTDIR)/usr/bin/
++	rm -Rf $(DESTDIR)/usr/include/
++	rm -Rf $(DESTDIR)/usr/lib/
++	rm -Rf $(DESTDIR)/usr/local/
++	rm -Rf $(DESTDIR)/usr/man/
++	rm -Rf $(DESTDIR)/var/
++	rm -f $(DESTDIR)/usr/sbin/dhcrelay
++
++	touch install-stamp
++
++# Build architecture-dependent files here (this package does not contain
++#	architecture-independent files).
++binary-arch: build install
++	dh_testdir -a
++	dh_testroot -a
++	dh_strip -a
++	dh_compress -a
++	dh_fixperms -a
++	dh_installdeb -a
++	dh_shlibdeps -a
++	dh_gencontrol -a
++	dh_md5sums -a
++	dh_builddeb -a
++
++source diff:                                                                  
++	@echo &gt;&amp;2 'source and diff are obsolete - use dpkg-source -b'; false
++
++binary: binary-arch
++.PHONY: build clean binary-indep binary-arch binary
+diff -Naur dhcp-3.0.3/doc/draft-ietf-dhc-ldap-schema-01.txt dhcp-3.0.3-ldap/doc/draft-ietf-dhc-ldap-schema-01.txt
+--- dhcp-3.0.3/doc/draft-ietf-dhc-ldap-schema-01.txt	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/doc/draft-ietf-dhc-ldap-schema-01.txt	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,1089 @@
++
++
++
++
++
++Network Working Group                                  M. Meredith,
++Internet Draft                                         V. Nanjundaswamy,
++Document: &lt;draft-ietf-dhc-ldap-schema-00.txt&gt;          M. Hinckley
++Category: Proposed Standard                            Novell Inc.
++Expires: 15th December 2001                            16th June 2001
++
++
++                          LDAP Schema for DHCP
++
++Status of this Memo
++
++This document is an Internet-Draft and is in full conformance with all
++provisions of Section 10 of RFC2026 [ ].
++
++Internet-Drafts are working documents of the Internet Engineering Task
++Force (IETF), its areas, and its working groups.  Note that other groups
++may also distribute working documents as Internet-Drafts. Internet-
++Drafts are draft documents valid for a maximum of six months and may be
++updated, replaced, or obsolete by other documents at any time.  It is
++inappropriate to use Internet-Drafts as reference material or to cite
++them other than as &quot;work in progress.&quot;  The list of current Internet-
++Drafts can be accessed at <A HREF="http://www.ietf.org/ietf/1id-abstracts.txt">http://www.ietf.org/ietf/1id-abstracts.txt</A> The
++list of Internet-Draft Shadow Directories can be accessed at
++<A HREF="http://www.ietf.org/shadow.html.">http://www.ietf.org/shadow.html.</A>
++
++1. Abstract
++
++This document defines a schema for representing DHCP configuration in an
++LDAP directory. It can be used to represent the DHCP Service
++configuration(s) for an entire enterprise network, a subset of the
++network, or even a single server. Representing DHCP configuration in an
++LDAP directory enables centralized management of DHCP services offered
++by one or more DHCP Servers within the enterprise.
++
++2. Conventions used in this document
++
++The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
++&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
++document are to be interpreted as described in RFC-2119 [ ].
++
++In places where different sets of terminology are commonly used to
++represent similar DHCP concepts, this schema uses the terminology of the
++Internet Software Consortium's DHCP server reference implementation.
++For more information see www.isc.org.
++
++3. Design Considerations
++
++The DHCP LDAP schema is designed to be a simple multi-server schema. The
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 1]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++intent of this schema is to provide a basic framework for representing
++the most common elements used in the configuration of DHCP Server.  This
++should allow other network services to obtain and use basic DHCP
++configuration information in a server-independent but knowledgeable way.
++
++It is expected that some implementations may need to extend the schema
++objects, in order to implement all of their features or needs. It is
++recommended that you use the schema defined in this draft to represent
++DHCP configuration information in an LDAP directory.  Conforming to a
++standard schema improves interoperability between DHCP implementations
++from different vendors.
++
++Some implementations may choose not to support all of the objects
++defined here.
++
++Two decisions are explicitly left up to each implementation:
++
++First, implementations may choose not to store the lease information in
++the directory, so those objects would not be used.
++
++Second, implementations may choose not to implement the auditing
++information.
++
++It is up to the implementation to determine if the data in the directory
++is considered &quot;authoritative&quot;, or if it is simply a copy of data from an
++authoritative source. Validity of the information if used as a copy is
++to be ensured by the implementation.
++
++Primarily two types of applications will use the information in this
++schema: 1. DHCP servers (for loading their configuration) 2. Management
++Interfaces (for defining/editing configurations).
++
++The schema should be efficient for the needs of both types of
++applications.  The schema is designed to allow objects managed by DHCP
++(such as computers, subnets, etc) to be present anywhere in a directory
++hierarchy (to allow those objects to be placed in the directory for
++managing administrative control and access to the objects).
++
++The schema uses a few naming conventions - all object classes and
++attributes are prefixed with &quot;dhcp&quot; to decrease the chance that object
++classes and attributes will have the same name.  The schema also uses
++standard naming attributes (&quot;cn&quot;, &quot;ou&quot;, etc) for all objects.
++
++4. Common DHCP Configuration Attributes
++
++Although DHCP manages several different types of objects, the
++configuration of those objects is often similar.  Consequently, most of
++these objects have a common set of attributes, which are defined below.
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 2]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++4.1. Attributes Definitions
++
++The schema definitions listed below are for readability.  The LDIF
++layout for this schema will follow in section 8.
++
++Name: dhcpPrimaryDN Description: The Distinguished Name of the
++dhcpServer object, which is the primary server for the configuration.
++Syntax: DN Flags: SINGLE-VALUE
++
++Named: dhcpSecondaryDN Description: The Distinguished Name(s) of the
++dhcpServer object(s), which are secondary servers for the configuration.
++Syntax: DN
++
++Name: dhcpStatements Description: Flexible storage for representing any
++specific data depending on the object to which it is attached. Examples
++include conditional statements, Server parameters, etc.  This also
++serves as a 'catch-all' attribute that allows the standard to evolve
++without needing to update the schema.  Syntax: IA5String
++
++Name: dhcpRange Description: The starting and ending IP Addresses in the
++range (inclusive), separated by a hyphen; if the range only contains one
++address, then just the address can be specified with no hyphen.  Each
++range is defined as a separate value.  Syntax: IA5String
++
++Name: dhcpPermitList Description: This attribute contains the permit
++lists associated with a pool. Each permit list is defined as a separate
++value.  Syntax: IA5String
++
++Name: dhcpNetMask Description: The subnet mask length for the subnet.
++The mask can be easily computed from this length.  Syntax: Integer
++Flags: SINGLE-VALUE
++
++Name: dhcpOption Description: Encoded option values to be sent to
++clients.  Each value represents a single option and contains (OptionTag,
++Length, OptionData) encoded in the format used by DHCP.  For more
++information see [DHCPOPT].  Syntax: OctetString
++
++Name: dhcpClassData Description: Encoded text string or list of bytes
++expressed in hexadecimal, separated by colons. Clients match subclasses
++based on matching the class data with the results of a 'match' or 'spawn
++with' statement in the class name declarations.  Syntax: IA5String
++Flags: SINGLE-VALUE
++
++Name: dhcpSubclassesDN Description: List of subclasses, these are the
++actual DN of each subclass object.  Syntax: DN
++
++Name: dhcpClassesDN Description: List of classes, these are the actual
++DN of each class object.  Syntax: DN
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 3]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++Name: dhcpSubnetDN Description: List of subnets, these are the actual DN
++of each subnet object.  Syntax: DN
++
++Name: dhcpPoolDN Description: List of pools, these are the actual DN of
++each Pool object.  Syntax: DN
++
++Name: dhcpOptionsDN Description: List of options, these are the actual
++DN of each Options object.  Syntax: DN
++
++Name: dhcpHostDN Description: List of hosts, these are the actual DN of
++each host object.  Syntax: DN
++
++Name: dhcpSharedNetworkDN Description: List of shared networks, these
++are the actual DN of each shared network object.  Syntax: DN
++
++Name: dhcpGroupDN Description: List of groups, these are the actual DN
++of each Group object.  Syntax: DN
++
++Name: dhcpLeaseDN Description: Single Lease DN. A dhcpHost configuration
++uses this attribute to identify a static IP address assignment.  Syntax:
++DN Flags: SINGLE-VALUE
++
++Name: dhcpLeasesDN Description: List of leases, these are the actual DN
++of each lease object.  Syntax: DN
++
++Name: dhcpServiceDN Description: The DN of dhcpService object(s)which
++contain the configuration information. Each dhcpServer object has this
++attribute identifying the DHCP configuration(s) that the server is
++associated with.  Syntax: DN
++
++Name: dhcpHWAddress Description: The hardware address of the client
++associated with a lease Syntax: OctetString Flags: SINGLE-VALUE
++
++Name: dhcpVersion Description: This is the version identified for the
++object that this attribute is part of. In case of the dhcpServer object,
++this represents the DHCP software version.  Syntax: IA5String Flags:
++SINGLE-VALUE
++
++Name: dhcpImplementation Description: DHCP Server implementation
++description e.g. DHCP Vendor information.  Syntax: IA5String Flags:
++SINGLE-VALUE
++
++Name: dhcpHashBucketAssignment Description: HashBucketAssignment bit map
++for the DHCP Server, as defined in DHC Load Balancing Algorithm [RFC
++3074].  Syntax: Octet String Flags: SINGLE-VALUE
++
++Name: dhcpDelayedServiceParameter Description: Delay in seconds
++corresponding to Delayed Service Parameter configuration, as defined in
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 4]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++DHC Load Balancing Algorithm [RFC 3074].  Syntax: Integer Flags: SINGLE-
++VALUE
++
++Name: dhcpMaxClientLeadTime Description: Maximum Client Lead Time
++configuration in seconds, as defined in DHCP Failover Protocol [FAILOVR]
++Syntax: Integer Flags: SINGLE-VALUE
++
++Name: dhcpFailOverEndpointState Description: Server (Failover Endpoint)
++state, as defined in DHCP Failover Protocol [FAILOVR] Syntax: IA5String
++Flags: SINGLE-VALUE
++
++5. Configurations and Services
++
++The schema definitions below are for readability the LDIF layout for
++this schema will follow in section 8.
++
++The DHC working group is currently considering several proposals for
++fail-over and redundancy of DHCP servers.  These may require sharing of
++configuration information between servers.  This schema provides a
++generalized mechanism for supporting any of these proposals, by
++separating the definition of a server from the definition of
++configuration service provided by the server.
++
++Separating the DHCP Server (dhcpServer) and the DHCP Configuration
++(dhcpService) representations allows a configuration service to be
++provided by one or more servers. Similarly, a server may provide one or
++more configurations. The schema allows a server to be configured as
++either a primary or secondary provider of a DHCP configuration.
++
++Configurations are also defined so that one configuration can include
++some of the objects that are defined in another configuration.  This
++allows for sharing and/or a hierarchy of related configuration items.
++
++Name: dhcpService Description:  Service object that represents the
++actual DHCP Service configuration. This will be a container with the
++following attributes.  Must: cn, dhcpPrimaryDN May: dhcpSecondaryDN,
++dhcpSharedNetworkDN, dhcpSubnetDN, dhcpGroupDN, dhcpHostDN,
++dhcpClassesDN, dhcpOptionsDN, dhcpStatements
++
++The following objects could exist inside the dhcpService container:
++dhcpSharedNetwork, dhcpSubnet, dhcpGroup, dhcpHost, dhcpClass,
++dhcpOptions, dhcpLog
++
++Name: dhcpServer Description:  Server object that the DHCP server will
++login as.  The configuration information is in the dhcpService container
++that the dhcpServiceDN points to.  Must: cn, dhcpServiceDN May:
++dhcpVersion, dhcpImplementation, dhcpHashBucketAssignment,
++dhcpDelayedServiceParameter, dhcpMaxClientLeadTime, 
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 5]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++dhcpFailOverEndpointState, dhcpStatements
++
++5.1. DHCP Declaration related classes:
++
++Name: dhcpSharedNetwork Description: Shared Network class will list what
++pools and subnets are in this network.
++
++This will be a container with the following attributes.  Must: cn May:
++dhcpSubnetDN, dhcpPoolDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpSharedNetwork container:
++dhcpSubnet, dhcpPool, dhcpOptions, dhcpLog
++
++Name: dhcpSubnet Description: Subnet object will include configuration
++information associated with a subnet, including a range and a net mask.
++
++This will be a container with the following attributes.  Must: cn
++(Subnet address), dhcpNetMask May: dhcpRange, dhcpPoolDN, dhcpGroupDN,
++dhcpHostDN, dhcpClassesDN, dhcpLeasesDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpSubnet container: dhcpPool,
++dhcpGroup, dhcpHost, dhcpClass, dhcpOptions, dhcpLease, dhcpLog
++
++Name: dhcpGroup Description: Group object will have configuration
++information associated with a group.
++
++This will be a container with the following attributes.  Must: cn May:
++dhcpHostDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpGroup container: dhcpHost,
++dhcpOptions
++
++Name: dhcpHost Description: The host object includes DHCP host
++declarations to assign a static IP address or declare the client as
++known or specify statements for a specific client.  Must: cn May:
++dhcpLeaseDN, dhcpHWAddress, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpHost container: dhcpLease,
++dhcpOptions
++
++Name: dhcpOptions Description: The options class is for option space
++declarations, it contains a list of options.  Must: cn, dhcpOption
++
++Name: dhcpClass Description: This is a class to group clients together
++based on matching rules.
++
++This will be a container with the following attributes.  Must: cn May:
++dhcpSubClassesDN, dhcpOptionsDN, dhcpStatements
++
++The following object can exist within a dhcpClass container:
++dhcpSubclass, dhcpOptions
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 6]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++Name: dhcpSubClass Description: This includes configuration information
++for a subclass associated with a class. The dhcpSubClass object will
++always be contained within the corresponding class container object.
++Must: cn May:  dhcpClassData, dhcpOptionsDN, dhcpStatements
++
++Name: dhcpPool Description: This contains configuration for a pool that
++will have the range of addresses, permit lists and point to classes and
++leases that are members of this pool.
++
++This will be a container that could be contained by dhcpSubnet or a
++dhcpSharedNetwork.  Must: cn, dhcpRange May: dhcpClassesDN,
++dhcpPermitList, dhcpLeasesDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpPool container: dhcpClass,
++dhcpOptions, dhcpLease, dhcpLog
++
++6. Tracking Address Assignments
++
++The behavior of a DHCP server is influenced by two factors - it's
++configuration and the current state of the addresses that have been
++assigned to clients. This schema defines a set of objects for
++representing the DHCP configuration associated with a server. The
++following object classes provide the ability to record how addresses are
++used including maintaining history (audit log) on individual leases.
++Recording lease information in a directory could result in a significant
++performance impact and is therefore optional. Implementations supporting
++logging of leases need to consider the performance impact.
++
++6.1. dhcpLeases Attribute Definitions
++
++The schema definitions below are for readability the LDIF layout for
++this schema will follow in section 8.
++
++Name: dhcpAddressState Description: This stores information about the
++current binding-status of an address.  For dynamic addresses managed by
++DHCP, the values should be restricted to the states defined in the DHCP
++Failover Protocol draft [FAILOVR]: 'FREE', 'ACTIVE', 'EXPIRED',
++'RELEASED', 'RESET', 'ABANDONED', 'BACKUP'.  For more information on
++these states see [FAILOVR].  For other addresses, it SHOULD be one of
++the following: 'UNKNOWN', 'RESERVED' (an address that is managed by DHCP
++that is reserved for a specific client), 'RESERVED-ACTIVE' (same as
++reserved, but address is currently in use),  'ASSIGNED' (assigned
++manually or by some other mechanism), 'UNASSIGNED', 'NOTASSIGNABLE'.
++Syntax: IA5String Flags: SINGLE-VALUE
++
++Name: dhcpExpirationTime Description: This is the time the current lease
++for an address expires.  Syntax: DateTime Flags: SINGLE-VALUE
++
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 7]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++Name: dhcpStartTimeOfState Description: This is the time of the last
++state change for a leased address.  Syntax: DateTime Flags: SINGLE-VALUE
++
++Name: dhcpLastTransactionTime Description: This is the last time a valid
++DHCP packet was received from the client.  Syntax: DateTime Flags:
++SINGLE-VALUE
++
++Name: dhcpBootpFlag Description: This indicates whether the address was
++assigned via BOOTP Syntax: Boolean Flags: SINGLE-VALUE
++
++Name: dhcpDomainName Description: This is the name of the domain sent to
++the client by the server.  It is essentially the same as the value for
++DHCP option 15 sent to the client, and represents only the domain - not
++the full FQDN.  To obtain the full FQDN assigned to the client you must
++prepend the &quot;dhcpAssignedHostName&quot; to this value with a &quot;.&quot;.  Syntax:
++IA5String Flags: SINGLE-VALUE
++
++Name: dhcpDnsStatus Description: This indicates the status of updating
++DNS resource records on behalf of the client by the DHCP server for this
++address.  The value is a 16-bit bitmask that has the same values as
++specified by the Failover-DDNS option (see [FAILOVR]).  Syntax: Integer
++Flags: SINGLE-VALUE
++
++Name: dhcpRequestedHostName Description: This is the hostname that was
++requested by the client.  Syntax: IA5String Flags: SINGLE-VALUE
++
++Name: dhcpAssignedHostName Description: This is the actual hostname that
++was assigned to a client. It may not be the name that was requested by
++the client.  The fully qualified domain name can be determined by
++appending the value of &quot;dhcpDomainName&quot; (with a dot separator) to this
++name.  Syntax: IA5String Flags: SINGLE-VALUE
++
++Name: dhcpReservedForClient Description: This is the distinguished name
++of the &quot;dhcpHost&quot; that an address is reserved for.  This may not be the
++same as the &quot;dhcpAssignedToClient&quot; attribute if the address is being
++reassigned but the current lease has not yet expired.  Syntax: DN Flags:
++SINGLE-VALUE
++
++Name: dhcpAssignedToClient Description: This is the distinguished name
++of a &quot;dhcpHost&quot; that an address is currently assigned to.  This
++attribute is only present in the class when the address is leased.
++Syntax: DN Flags: SINGLE-VALUE
++
++Name: dhcpRelayAgentInfo Description: If the client request was received
++via a relay agent, this contains information about the relay agent that
++was available from the DHCP request.  This is a hex-encoded option
++value.  Syntax: OctetString Flags: SINGLE-VALUE
++
++Name: dhcpErrorLog Description: Generic error log attribute that allows
++logging error conditions within a dhcpService or a dhcpSubnet, like no IP 
++addresses available for lease. Syntax: IA5String 
++
++M. Meredith et al.        Expires December 2001                 [Page 8]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++6.2.  dhcpLeases Object Class
++
++This class represents an IP address.  It may or may not be leaseable,
++and the object may exist even though a lease is not currently active for
++the associated IP address.
++
++It is recommended that all Lease objects for a single DHCP Service be
++centrally located within a single container. This ensures that the lease
++objects and the corresponding logs do not have to be relocated, when
++address ranges allocated to individual DHCP subnets and/or pools change.
++
++The schema definitions below are for readability the LDIF layout for
++this schema will follow in section 8.
++
++Name: dhcpLeases Description: This is the object that holds state
++information about an IP address. The cn (which is the IP address), and
++the current address-state are mandatory attributes. If the address is
++assigned then, some of the optional attributes will have valid data.
++Must: cn, dhcpAddressState May: dhcpExpirationTime,
++dhcpStartTimeOfState, dhcpLastTransactionTime, dhcpBootpFlag,
++dhcpDomainName, dhcpDnsStatus, dhcpRequestedHostName,
++dhcpAssignedHostName, dhcpReservedForClient, dhcpAssignedToClient,
++dhcpRelayAgentInfo, dhcpHWAddress
++
++6.3 Audit Log Information
++
++A dhcpLog object is created whenever a lease is assigned or released.
++This object is intended to be created under the corresponding dhcpLeases
++container, or dhcpPool, dhcpSubnet, dhcpSharedNetwork or dhcpService
++containers.
++
++The log information under the dhcpLeases container would be for
++addresses matching that lease information. The log information in the
++other containers could be used for errors, i.e. when a pool or subnet is
++out our addresses or if a server is not able to assign any more
++addresses for a particular dhcpService.
++
++Name: dhcpLog Description: This is the object that holds past
++information about an IP address. The cn is the time/date stamp when the
++address was assigned or released, the address state at the time, if the
++address was assigned or released.  Must: cn May: dhcpAddressState,
++dhcpExpirationTime, dhcpStartTimeOfState, dhcpLastTransactionTime,
++dhcpBootpFlag, dhcpDomainName, dhcpDnsStatus, dhcpRequestedHostName,
++dhcpAssignedHostName, dhcpReservedForClient, dhcpAssignedToClient,
++dhcpRelayAgentInfo, dhcpHWAddress, dhcpErrorLog
++
++
++
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 9]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++7. Determining settings
++
++The dhcpStatements attribute is the key to DHC enhancements that may
++come along, and the different key words that a particular server
++implementation may use. This attribute can be used to hold conditional
++DHCP Statements and DHCP server parameters. Having a generic settings
++attribute that is just a string, allows this schema to be extensible and
++easy to configure.
++
++All of the attributes that end with DN are references to the class that
++precedes the DN e.g. the dhcpPrimaryDN and dhcpSecondaryDN attributes
++hold the Distinguished Names of the dhcpServer objects that are
++associated with the dhcpService object.
++
++8. LDIF format for attributes and classes.
++
++# Attributes
++
++( 2.16.840.1.113719.1.203.4.1 NAME 'dhcpPrimaryDN' DESC
++'The DN of the dhcpServer which is the primary server for the
++configuration.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.2 NAME 'dhcpSecondaryDN' DESC 'The DN of
++dhcpServer(s) which provide backup service for the configuration.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.3 NAME 'dhcpStatements' DESC 'Flexible
++storage for specific data depending on what object this exists in. Like
++conditional statements, server parameters, etc. This allows the standard
++to evolve without needing to adjust the schema.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.26 )
++
++( 2.16.840.1.113719.1.203.4.4 NAME 'dhcpRange' DESC 'The starting &amp;
++ending IP Addresses in the range (inclusive), separated by a hyphen; if
++the range only contains one address, then just the address can be
++specified with no hyphen.  Each range is defined as a separate value.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++( 2.16.840.1.113719.1.203.4.5 NAME 'dhcpPermitList' DESC 'This attribute
++contains the permit lists associated with a pool. Each permit list is
++defined as a separate value.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++( 2.16.840.1.113719.1.203.4.6 NAME 'dhcpNetMask' DESC 'The subnet mask
++length for the subnet.  The mask can be easily computed from this
++length.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.7 NAME 'dhcpOption' DESC 'Encoded option
++values to be sent to clients.  Each value represents a single option and
++contains (OptionTag, Length, OptionValue) encoded in the format used by
++DHCP.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )
++
++M. Meredith et al.        Expires December 2001                [Page 10]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++( 2.16.840.1.113719.1.203.4.8 NAME 'dhcpClassData' DESC 'Encoded text
++string or list of bytes expressed in hexadecimal, separated by colons.
++Clients match subclasses based on matching the class data with the
++results of match or spawn with statements in the class name
++declarations.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.9 NAME 'dhcpOptionsDN' DESC 'The
++distinguished name(s) of the dhcpOption objects containing the
++configuration options provided by the server.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.10 NAME 'dhcpHostDN' DESC 'the distinguished
++name(s) of the dhcpHost objects.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.11 NAME 'dhcpPoolDN' DESC 'The distinguished
++name(s) of pools.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.12 NAME 'dhcpGroupDN' DESC 'The
++distinguished name(s)   of the groups.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.13 NAME 'dhcpSubnetDN' DESC 'The
++distinguished name(s) of the subnets.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.14 NAME 'dhcpLeaseDN' DESC 'The
++distinguished name of a client address.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE)
++
++( 2.16.840.1.113719.1.203.4.15 NAME 'dhcpLeasesDN' DESC 'The
++distinguished name(s) client addresses.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.16 NAME 'dhcpClassesDN' DESC 'The
++distinguished name(s) of a class(es) in a subclass.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.17 NAME 'dhcpSubclassesDN' DESC 'The
++distinguished name(s) of subclass(es).' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.18 NAME 'dhcpSharedNetworkDN' DESC 'The
++distinguished name(s) of sharedNetworks.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.19 NAME 'dhcpServiceDN' DESC 'The DN of
++dhcpService object(s)which contain the configuration information. Each
++dhcpServer object has this attribute identifying the DHCP
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 11]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++configuration(s) that the server is associated with.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.20 NAME 'dhcpVersion' DESC 'The version
++attribute of this object.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-
++VALUE )
++
++( 2.16.840.1.113719.1.203.4.21 NAME 'dhcpImplementation' DESC
++'Description of the DHCP Server implementation e.g. DHCP Server's
++vendor.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.22 NAME 'dhcpAddressState' DESC 'This stores
++information about the current binding-status of an address.  For dynamic
++addresses managed by DHCP, the values should be restricted to the
++following: &quot;FREE&quot;, &quot;ACTIVE&quot;, &quot;EXPIRED&quot;, &quot;RELEASED&quot;, &quot;RESET&quot;,
++&quot;ABANDONED&quot;, &quot;BACKUP&quot;.  For other addresses, it SHOULD be one of the
++following: &quot;UNKNOWN&quot;, &quot;RESERVED&quot; (an address that is managed by DHCP
++that is reserved for a specific client), &quot;RESERVED-ACTIVE&quot; (same as
++reserved, but address is currently in use), &quot;ASSIGNED&quot; (assigned
++manually or by some other mechanism), &quot;UNASSIGNED&quot;, &quot;NOTASSIGNABLE&quot;.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.23 NAME 'dhcpExpirationTime' DESC 'This is
++the time the current lease for an address expires.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.24 NAME 'dhcpStartTimeOfState' DESC 'This is
++the time of the last state change for a leased address.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.25 NAME 'dhcpLastTransactionTime' DESC 'This
++is the last time a valid DHCP packet was received from the client.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.26 NAME 'dhcpBootpFlag' DESC 'This indicates
++whether the address was assigned via BOOTP.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.7 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.27 NAME 'dhcpDomainName' DESC 'This is the
++name of the domain sent to the client by the server.  It is essentially
++the same as the value for DHCP option 15 sent to the client, and
++represents only the domain - not the full FQDN.  To obtain the full FQDN
++assigned to the client you must prepend the &quot;dhcpAssignedHostName&quot; to
++this value with a &quot;.&quot;.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-
++VALUE )
++
++( 2.16.840.1.113719.1.203.4.28 NAME 'dhcpDnsStatus' DESC 'This indicates
++the status of updating DNS resource records on behalf of the client by
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 12]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++the DHCP server for this address.  The value is a 16-bit bitmask.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.29 NAME 'dhcpRequestedHostName' DESC 'This
++is the hostname that was requested by the client.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.30 NAME 'dhcpAssignedHostName' DESC 'This is
++the actual hostname that was assigned to a client. It may not be the
++name that was requested by the client.  The fully qualified domain name
++can be determined by appending the value of &quot;dhcpDomainName&quot; (with a dot
++separator) to this name.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-
++VALUE )
++
++( 2.16.840.1.113719.1.203.4.31 NAME 'dhcpReservedForClient' DESC 'The
++distinguished name of a &quot;dhcpClient&quot; that an address is reserved for.
++This may not be the same as the &quot;dhcpAssignedToClient&quot; attribute if the
++address is being reassigned but the current lease has not yet expired.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.32 NAME 'dhcpAssignedToClient' DESC 'This is
++the distinguished name of a &quot;dhcpClient&quot; that an address is currently
++assigned to.  This attribute is only present in the class when the
++address is leased.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.33 NAME 'dhcpRelayAgentInfo' DESC 'If the
++client request was received via a relay agent, this contains information
++about the relay agent that was available from the DHCP request.  This is
++a hex-encoded option value.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40
++SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.34 NAME 'dhcpHWAddress' DESC 'The clients
++hardware address that requested this IP address.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.35 NAME 'dhcpHashBucketAssignment' DESC
++'HashBucketAssignment bit map for the DHCP Server, as defined in DHC
++Load Balancing Algorithm [RFC 3074].' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.36 NAME 'dhcpDelayedServiceParameter' DESC
++'Delay in seconds corresponding to Delayed Service Parameter
++configuration, as defined in  DHC Load Balancing Algorithm [RFC 3074]. '
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.37 NAME 'dhcpMaxClientLeadTime' DESC
++'Maximum Client Lead Time configuration in seconds, as defined in DHCP
++Failover Protocol [FAILOVR]' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 13]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.38 NAME 'dhcpFailOverEndpointState' DESC
++'Server (Failover Endpoint) state, as defined in DHCP Failover Protocol
++[FAILOVR]' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.39 NAME 'dhcpErrorLog' DESC
++Generic error log attribute that allows logging error conditions within a 
++dhcpService or a dhcpSubnet, like no IP addresses available for lease. 
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++#Classes
++
++( 2.16.840.1.113719.1.203.6.1 NAME 'dhcpService' DESC ' Service object
++that represents the actual DHCP Service configuration. This is a
++container object.' SUP top MUST (cn $ dhcpPrimaryDN) MAY
++(dhcpSecondaryDN $ dhcpSharedNetworkDN $ dhcpSubnetDN $ dhcpGroupDN $
++dhcpHostDN $  dhcpClassesDN $ dhcpOptionsDN $ dhcpStatements ) )
++
++( 2.16.840.1.113719.1.203.6.2 NAME 'dhcpSharedNetwork' DESC 'This stores
++configuration information for a shared network.' SUP top MUST  cn MAY
++(dhcpSubnetDN $ dhcpPoolDN $ dhcpOptionsDN $ dhcpStatements) X-
++NDS_CONTAINMENT ('dhcpService' ) )
++
++( 2.16.840.1.113719.1.203.6.3 NAME 'dhcpSubnet' DESC 'This class defines
++a subnet. This is a container object.' SUP top MUST ( cn $ dhcpNetMask )
++MAY (dhcpRange $ dhcpPoolDN $ dhcpGroupDN $ dhcpHostDN $ dhcpClassesDN $
++dhcpLeasesDN $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++('dhcpService' 'dhcpSharedNetwork') )
++
++( 2.16.840.1.113719.1.203.6.4 NAME 'dhcpPool' DESC 'This stores
++configuration information about a pool.' SUP top MUST ( cn $ dhcpRange )
++MAY (dhcpClassesDN $ dhcpPermitList $ dhcpLeasesDN $ dhcpOptionsDN $
++dhcpStatements) X-NDS_CONTAINMENT ('dhcpSubnet' 'dhcpSharedNetwork') )
++
++( 2.16.840.1.113719.1.203.6.5 NAME 'dhcpGroup' DESC 'Group object that
++lists host DNs and parameters. This is a container object.' SUP top MUST
++cn MAY ( dhcpHostDN $ dhcpOptionsDN $ dhcpStatements ) X-NDS_CONTAINMENT
++('dhcpSubnet' 'dhcpService' ) )
++
++( 2.16.840.1.113719.1.203.6.6 NAME 'dhcpHost' DESC 'This represents
++information about a particular client' SUP top MUST cn MAY  (dhcpLeaseDN
++$ dhcpHWAddress $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++('dhcpService' 'dhcpSubnet' 'dhcpGroup') )
++
++( 2.16.840.1.113719.1.203.6.7 NAME 'dhcpClass' DESC 'Represents
++information about a collection of related clients.' SUP top MUST cn MAY
++(dhcpSubClassesDN $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++('dhcpService' 'dhcpSubnet' ) )
++
++( 2.16.840.1.113719.1.203.6.8 NAME 'dhcpSubClass' DESC 'Represents
++information about a collection of related classes.' SUP top MUST cn MAY
++(dhcpClassData $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 14]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++'dhcpClass' )
++
++( 2.16.840.1.113719.1.203.6.9 NAME 'dhcpOptions' DESC 'Represents
++information about a collection of options defined.' SUP top MUST cn MAY
++( dhcpOption ) X-NDS_CONTAINMENT  ('dhcpService' 'dhcpSharedNetwork'
++'dhcpSubnet' 'dhcpPool' 'dhcpGroup' 'dhcpHost' 'dhcpClass' )
++
++( 2.16.840.1.113719.1.203.6.10 NAME 'dhcpLeases' DESC 'This class
++represents an IP Address, which may or may not have been leased.' SUP
++top MUST ( cn $ dhcpAddressState ) MAY ( dhcpExpirationTime $
++dhcpStartTimeOfState $ dhcpLastTransactionTime $ dhcpBootpFlag $
++dhcpDomainName $ dhcpDnsStatus $ dhcpRequestedHostName $
++dhcpAssignedHostName $ dhcpReservedForClient $ dhcpAssignedToClient $
++dhcpRelayAgentInfo $ dhcpHWAddress ) X-NDS_CONTAINMENT ( 'dhcpService'
++'dhcpSubnet' 'dhcpPool') )
++
++( 2.16.840.1.113719.1.203.6.11 NAME 'dhcpLog' DESC 'This is the object
++that holds past information about the IP address. The cn is the
++time/date stamp when the address was assigned or released, the address
++state at the time, if the address was assigned or released.' SUP top
++MUST ( cn ) MAY ( dhcpAddressState $ dhcpExpirationTime $
++dhcpStartTimeOfState $ dhcpLastTransactionTime $ dhcpBootpFlag $
++dhcpDomainName $ dhcpDnsStatus $ dhcpRequestedHostName $
++dhcpAssignedHostName $ dhcpReservedForClient $ dhcpAssignedToClient $
++dhcpRelayAgentInfo $ dhcpHWAddress $ dhcpErrorLog) X-NDS_CONTAINMENT 
++('dhcpLeases' 'dhcpPool' 'dhcpSubnet' 'dhcpSharedNetwork' 'dhcpService' ) )
++
++( 2.16.840.1.113719.1.203.6.12 NAME 'dhcpServer' DESC 'DHCP Server
++Object' SUP top MUST (cn, dhcpServiceDN) MAY (dhcpVersion $
++dhcpImplementation $ dhcpHashBucketAssignment $
++dhcpDelayedServiceParameter $ dhcpMaxClientLeadTime $
++dhcpFailOverEndpointState $ dhcpStatements) X-NDS_CONTAINMENT ('O' 'OU' 
++'dc') )
++
++9. Security Considerations
++
++Since the DHCP Configuration information is stored in a directory, the
++security of the information is limited to the security offered by the
++directory including the security of the objects within that directory.
++
++10.  Intellectual Property Rights Notices
++
++The IETF takes no position regarding the validity or scope of any
++intellectual property or other rights that might be claimed to pertain
++to the implementation or use of the technology described in this
++document or the extent to which any license under such rights might or
++might not be available; neither does it represent that it has made any
++effort to identify any such rights.  Information on the IETF's
++procedures with respect to rights in standards-track and standards-
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 15]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++related documentation can be found in BCP-11.  Copies of claims of
++rights made available for publication and any assurances of licenses to
++be made available, or the result of an attempt made to obtain a general
++license or permission for the use of such proprietary rights by
++implementors or users of this specification can be obtained from the
++IETF Secretariat.
++
++The IETF invites any interested party to bring to its attention any
++copyrights, patents or patent applications, or other proprietary rights
++which may cover technology that may be required to practice this
++standard.  Please address the information to the IETF Executive
++Director.
++
++11.  Full Copyright Statement
++
++Copyright (C) The Internet Society (2001).  All Rights Reserved.
++
++This document and translations of it may be copied and furnished to
++others, and derivative works that comment on or otherwise explain it or
++assist in its implementation may be prepared, copied, published and
++distributed, in whole or in part, without restriction of any kind,
++provided that the above copyright notice and this paragraph are included
++on all such copies and derivative works.  However, this document itself
++may not be modified in any way, such as by removing the copyright notice
++or references to the Internet Society or other Internet organizations,
++except as needed for the purpose of developing Internet standards in
++which case the procedures for copyrights defined in the Internet
++Standards process must be followed, or as required to translate it into
++languages other than English.
++
++The limited permissions granted above are perpetual and will not be
++revoked by the Internet Society or its successors or assigns.
++
++This document and the information contained herein is provided on an &quot;AS
++IS&quot; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK
++FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT
++LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT
++INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR
++FITNESS FOR A PARTICULAR PURPOSE.
++
++12. References
++
++[RFC2131] Droms, R., &quot;Dynamic Host Configuration Protocol&quot;, RFC 2131,
++March 1997.
++
++[RFC2132] Alexander, S., Droms, R., &quot;DHCP Options and BOOTP Vendor
++Extensions&quot;, RFC 2132, March 1997.
++
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 16]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++[MSDHCP]  Gu, Y., Vyaghrapuri, R., &quot;An LDAP Schema for Dynamic Host
++Configuration Protocol Service&quot;, Internet Draft &lt;draft-gu-dhcp-ldap-
++schema-00.txt&gt;, August 1998.
++
++[NOVDHCP] Miller, T., Patel, A., Rao, P., &quot;Lightweight Directory Access
++Protocol (v3): Schema for Dynamic Host Configuration Protocol (DHCP)&quot;,
++Internet Draft &lt;draft-miller-dhcp-ldap-schema-00.txt&gt;, June 1998.
++
++[FAILOVR] Droms, R., Rabil, G., Dooley, M., Kapur, A., Gonczi, S., Volz,
++B., &quot;DHCP Failover Protocol&quot;, Internet Draft &lt;draft-ietf-dhc-
++failover-08.txt&gt;, July 2000.
++
++[RFC 3074] Volz B., Gonczi S., Lemon T., Stevens R., &quot;DHC Load Balancing
++Algorithm&quot;, February 2001
++
++[AGENT]   Patrick, M., &quot;DHCP Relay Agent Information Option&quot;, Internet
++Draft &lt;draft-ietf-dhc-agent-options-09.txt&gt;, March 2000.
++
++[DHCPOPT] Carney, M., &quot;New Option Review Guidelines and Additional
++Option Namespace&quot;, Internet Draft &lt;draft-ietf-dhc-
++option_review_and_namespace-01.txt&gt;, October 1999.
++
++[POLICY]  Strassner, J., Elleson, E., Moore, B., &quot;Policy Framework LDAP
++Core Schema&quot;, Internet Draft &lt;draft-ietf-policy-core-schema-06.txt&gt;,
++November 1999.
++
++[RFC2251] Wahl, M., Howes, T., Kille, S., &quot;Lightweight Directory Access
++Protocol (v3)&quot;, RFC 2251, December 1997.
++
++[RFC2252] Wahl, M., Coulbeck, A., Howes, T., Kille, S., &quot;Lightweight
++Directory Access Protocol (v3) Attribute Syntax Definitions&quot;, RFC 2252,
++December 1997.
++
++[RFC2255] Howes, T., Smith, M., &quot;The LDAP URL Format&quot;, RFC 2255,
++December 1997.
++
++[RFC951]  Croft, B., Gilmore, J., &quot;Bootstrap Protocol (BOOTP)&quot;, RFC 951,
++September 1985.
++
++[RFC2119] Bradner, S. &quot;Key words for use in RFCs to Indicate Requirement
++Levels&quot;, RFC 2119, March 1997.
++
++13. Acknowledgments
++
++This work is partially based on a previous draft draft-ietf-dhc-
++schema-02.doc.
++
++
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 17]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++14. Author's Addresses
++
++Comments regarding this draft may be sent to the authors at the
++following address:
++
++Mark Meredith
++Mark Hinckley
++Novell Inc.
++1800 S. Novell Place
++Provo, Utah 84606
++
++Vijay K. Nanjundaswamy
++Novell Software Development (I) Ltd
++49/1 &amp; 49/3, Garvebhavi Palya,
++7th Mile, Hosur Road
++Bangalore 560068
++
++email: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mark_meredith at novell.com</A>
++email: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">knvijay at novell.com</A>
++email: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mhinckley at novell.com</A>
++
++This Internet Draft expires December 16, 2001.
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 18]
++
++
++
++
+diff -Naur dhcp-3.0.3/includes/dhcpd.h dhcp-3.0.3-ldap/includes/dhcpd.h
+--- dhcp-3.0.3/includes/dhcpd.h	2005-04-29 19:10:57.000000000 -0400
++++ dhcp-3.0.3-ldap/includes/dhcpd.h	2005-07-25 08:14:44.000000000 -0400
+@@ -79,6 +79,11 @@
+ #include &lt;isc-dhcp/result.h&gt;
+ #include &lt;omapip/omapip_p.h&gt;
+ 
++#if defined(LDAP_CONFIGURATION)
++# include &lt;ldap.h&gt;
++# include &lt;sys/utsname.h&gt; /* for uname() */
++#endif
++
+ #if !defined (OPTION_HASH_SIZE)
+ # define OPTION_HASH_SIZE 17
+ # define OPTION_HASH_PTWO 32	/* Next power of two above option hash. */
+@@ -139,6 +144,8 @@
+ 	char *inbuf;
+ 	unsigned bufix, buflen;
+ 	unsigned bufsiz;
++
++	char (*read_function) (struct parse *);
+ };
+ 
+ /* Variable-length array of data. */
+@@ -241,6 +248,26 @@
+ 	u_int8_t hbuf [17];
+ };
+ 
++#if defined(LDAP_CONFIGURATION)
++# define LDAP_BUFFER_SIZE		8192
++# define LDAP_METHOD_STATIC		0
++# define LDAP_METHOD_DYNAMIC		1
++
++/* This is a tree of the current configuration we are building from LDAP */
++
++struct ldap_config_stack {
++	LDAPMessage * res; 	/* Pointer returned from ldap_search */
++	LDAPMessage * ldent; 	/* Current item in LDAP that we're processing 
++				   in res */
++	int close_brace;	/* Put a closing } after we're through with
++				   this item */
++	int processed; 		/* We set this flag if this base item has been
++				   processed. After this base item is processed,
++				   we can start processing the children */
++	struct ldap_config_stack *next;
++};
++#endif
++
+ typedef enum {
+ 	server_startup = 0,
+ 	server_running = 1,
+@@ -416,6 +443,16 @@
+ # define DEFAULT_PING_TIMEOUT 1
+ #endif
+ 
++#if defined(LDAP_CONFIGURATION)
++# define SV_LDAP_SERVER  		47
++# define SV_LDAP_PORT  			48
++# define SV_LDAP_USERNAME  		49
++# define SV_LDAP_PASSWORD  		50
++# define SV_LDAP_BASE_DN 		51
++# define SV_LDAP_METHOD			52
++# define SV_LDAP_DEBUG_FILE		53
++#endif
++
+ #if !defined (DEFAULT_DEFAULT_LEASE_TIME)
+ # define DEFAULT_DEFAULT_LEASE_TIME 43200
+ #endif
+@@ -1519,7 +1556,7 @@
+ char *quotify_string (const char *, const char *, int);
+ char *quotify_buf (const unsigned char *, unsigned, const char *, int);
+ char *print_base64 (const unsigned char *, unsigned, const char *, int);
+-char *print_hw_addr PROTO ((int, int, unsigned char *));
++char *print_hw_addr PROTO ((const int, const int, const unsigned char *));
+ void print_lease PROTO ((struct lease *));
+ void dump_raw PROTO ((const unsigned char *, unsigned));
+ void dump_packet_option (struct option_cache *, struct packet *,
+@@ -2620,3 +2657,14 @@
+ #endif /* FAILOVER_PROTOCOL */
+ 
+ const char *binding_state_print (enum failover_state);
++
++/* ldap.c */
++#if defined(LDAP_CONFIGURATION)
++extern struct enumeration ldap_methods;
++isc_result_t ldap_read_config (void);
++int find_haddr_in_ldap (struct host_decl **, int, unsigned,
++                        const unsigned char *, const char *, int);
++int find_subclass_in_ldap (struct class *, struct class **, 
++			   struct data_string *);
++#endif
++
+diff -Naur dhcp-3.0.3/includes/site.h dhcp-3.0.3-ldap/includes/site.h
+--- dhcp-3.0.3/includes/site.h	2002-03-12 13:33:39.000000000 -0500
++++ dhcp-3.0.3-ldap/includes/site.h	2005-07-25 08:14:44.000000000 -0400
+@@ -177,3 +177,13 @@
+    traces. */
+ 
+ #define TRACING
++
++/* Define this if you want to read your config from LDAP. Read README.ldap
++   about how to set this up */
++
++#define LDAP_CONFIGURATION
++
++/* Define this if you want to enable LDAP over a SSL connection. You will need
++   to add -lcrypto -lssl to the LIBS= line of server/Makefile */
++
++/* #define USE_SSL */
+diff -Naur dhcp-3.0.3/README.ldap dhcp-3.0.3-ldap/README.ldap
+--- dhcp-3.0.3/README.ldap	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/README.ldap	2005-07-25 08:14:44.000000000 -0400
+@@ -0,0 +1,172 @@
++LDAP Support in DHCP
++Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++Last updated 3/23/2003
++
++This document describes setting up the DHCP server to read it's configuration 
++from LDAP. This work is based on the IETF document 
++draft-ietf-dhc-ldap-schema-01.txt included in the doc directory. For the latest
++version of this document, please see <A HREF="http://home.ntelos.net/~masneyb.">http://home.ntelos.net/~masneyb.</A>
++
++First question on most people's mind is &quot;Why do I want to store my 
++configuration in LDAP?&quot; If you run a small DHCP server, and the configuration
++on it rarely changes, then you won't need to store your configuration in LDAP.
++But, if you have several DHCP servers, and you want an easy way to manage your 
++configuration, this can be a solution. 
++
++The first step will be to setup your LDAP server. I am using OpenLDAP from
++www.openldap.org. Building and installing OpenLDAP is beyond the scope of this 
++document. There is plenty of documentation out there about this. Once you have 
++OpenLDAP installed, you will have to edit your slapd.conf file. I added the 
++following 2 lines to my configuration file:
++
++include         /etc/ldap/schema/dhcp.schema
++index           dhcpHWAddress 	eq
++index           dhcpClassData	eq
++
++The first line tells it to include the dhcp schema file. You will find this 
++file under the contrib directory in this distribution. You will need to copy 
++this file to where your other schema files are (maybe
++/usr/local/openldap/etc/openldap/schema/). The second line sets up
++an index for the dhcpHWAddress parameter. The third parameter is for reading 
++subclasses from LDAP every time a DHCP request comes in. Make sure you run the 
++slapindex command and restart slapd to have these changes to into effect.
++
++Now that you have LDAP setup, you should be able to use gq (<A HREF="http://biot.com/gq/">http://biot.com/gq/</A>)
++to verify that the dhcp schema file is loaded into LDAP. Pull up gq, and click
++on the Schema tab. Go under objectClasses, and you should see at least the 
++following object classes listed: dhcpClass, dhcpGroup, dhcpHost, dhcpOptions, 
++dhcpPool, dhcpServer, dhcpService, dhcpSharedNetwork, dhcpSubClass, and 
++dhcpSubnet. If you do not see these, you need to check over your LDAP 
++configuration before you go any further.
++
++You should now be ready to build DHCP. If you would like to enable LDAP over
++SSL, you will need to perform the following steps:
++
++  * Edit the includes/site.h file and uncomment the USE_SSL line
++  * Edit the dst/Makefile.dist file and remove md5_dgst.c and md5_dgst.o
++    from the SRC= and OBJ= lines (around line 24)
++  * Now run configure in the base source directory. If you chose to enable
++    LDAP over SSL, you must append -lcrypto -lssl to the LIBS= line in the file
++    work.os/server/Makefile (replace os with your operating system, linux-2.2 on
++    my machine).  You should now be able to type make to build your DHCP server.
++
++If you choose to not enable LDAP over SSL, then you only need to run configure
++and make in the toplevel source directory.
++
++Once you have DHCP installed, you will need to setup your initial plaintext 
++config file. In my /etc/dhcpd.conf file, I have:
++
++ldap-server &quot;localhost&quot;;
++ldap-port 389;
++ldap-username &quot;cn=DHCP User, dc=ntelos, dc=net&quot;;
++ldap-password &quot;blah&quot;;
++ldap-base-dn &quot;dc=ntelos, dc=net&quot;;
++ldap-method dynamic;
++ldap-debug-file &quot;/var/log/dhcp-ldap-startup.log&quot;;
++
++All of these parameters should be self explanatory except for the ldap-method.
++You can set this to static or dynamic. If you set it to static, the 
++configuration is read once on startup, and LDAP isn't used anymore. But, if you
++set this to dynamic, the configuration is read once on startup, and the 
++hosts that are stored in LDAP are looked up every time a DHCP request comes in.
++
++When the optional statement ldap-debug-file is specified, on startup the DHCP
++server will write out the configuration that it generated from LDAP. If you are
++getting errors about your LDAP configuration, this is a good place to start
++looking.
++
++The next step is to set up your LDAP tree. Here is an example config that will
++give a 10.100.0.x address to machines that have a host entry in LDAP. 
++Otherwise, it will give a 10.200.0.x address to them. (NOTE: replace 
++dc=ntelos, dc=net with your base dn). If you would like to convert your 
++existing dhcpd.conf file to LDIF format, there is a script 
++contrib/dhcpd-conf-to-ldap.pl that will convert it for you. Type
++dhcpd-conf-to-ldap.pl --help to see the usage information for this script.
++
++# You must specify the server's host name in LDAP that you are going to run
++# DHCP on and point it to which config tree you want to use. Whenever DHCP 
++# first starts up, it will do a search for this entry to find out which 
++# config to use
++dn: cn=brian.ntelos.net, dc=ntelos, dc=net
++objectClass: top
++objectClass: dhcpServer
++cn: brian.ntelos.net
++dhcpServiceDN: cn=DHCP Service Config, dc=ntelos, dc=net
++
++# Here is the config tree that brian.ntelos.net points to. 
++dn: cn=DHCP Service Config, dc=ntelos, dc=net
++cn: DHCP Service Config
++objectClass: top
++objectClass: dhcpService
++dhcpPrimaryDN: dc=ntelos, dc=net
++dhcpStatements: ddns-update-style none
++dhcpStatements: default-lease-time 600
++dhcpStatements: max-lease-time 7200
++
++# Set up a shared network segment
++dn: cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: WV
++objectClass: top
++objectClass: dhcpSharedNetwork
++
++# Set up a subnet declaration with a pool statement. Also note that we have
++# a dhcpOptions object with this entry
++dn: cn=10.100.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: 10.100.0.0
++objectClass: top
++objectClass: dhcpSubnet
++objectClass: dhcpOptions
++dhcpOption: domain-name-servers 10.100.0.2
++dhcpOption: routers 10.100.0.1
++dhcpOption: subnet-mask 255.255.255.0
++dhcpOption: broadcast-address 10.100.0.255
++dhcpNetMask: 24
++
++# Set up a pool for this subnet. Only known hosts will get these IPs
++dn: cn=Known Pool, cn=10.100.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: Known Pool
++objectClass: top
++objectClass: dhcpPool
++dhcpRange: 10.100.0.3 10.100.0.254
++dhcpPermitList: deny unknown-clients
++
++# Set up another subnet declaration with a pool statement
++dn: cn=10.200.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: 10.200.0.0
++objectClass: top
++objectClass: dhcpSubnet
++objectClass: dhcpOptions
++dhcpOption: domain-name-servers 10.200.0.2
++dhcpOption: routers 10.200.0.1
++dhcpOption: subnet-mask 255.255.255.0
++dhcpOption: broadcast-address 10.200.0.255
++dhcpNetMask: 24
++
++# Set up a pool for this subnet. Only unknown hosts will get these IPs
++dn: cn=Known Pool, cn=10.200.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: Known Pool
++objectClass: top
++objectClass: dhcpPool
++dhcpRange: 10.200.0.3 10.200.0.254
++dhcpPermitList: deny known clients
++
++# Set aside a group for all of our known MAC addresses
++dn: cn=Customers, cn=DHCP Service Config, dc=ntelos, dc=net
++objectClass: top
++objectClass: dhcpGroup
++cn: Customers
++
++# Host entry for my laptop
++dn: cn=brianlaptop, cn=Customers, cn=DHCP Service Config, dc=ntelos, dc=net
++objectClass: top
++objectClass: dhcpHost
++cn: brianlaptop
++dhcpHWAddress: ethernet 00:00:00:00:00:00
++
++You can use the command slapadd to load all of these entries into your LDAP 
++server. After you load this, you should be able to start up DHCP. If you run
++into problems reading the configuration, try running dhcpd with the -d flag. 
++If you still have problems, edit the site.conf file in the DHCP source and
++add the line: COPTS= -DDEBUG_LDAP and recompile DHCP. (make sure you run make 
++clean and rerun configure before you rebuild).
++
+diff -Naur dhcp-3.0.3/server/class.c dhcp-3.0.3-ldap/server/class.c
+--- dhcp-3.0.3/server/class.c	2004-06-10 13:59:51.000000000 -0400
++++ dhcp-3.0.3-ldap/server/class.c	2005-07-25 08:14:44.000000000 -0400
+@@ -90,6 +90,7 @@
+ 	int matched = 0;
+ 	int status;
+ 	int ignorep;
++	int classfound;
+ 
+ 	for (class = collection -&gt; classes; class; class = class -&gt; nic) {
+ #if defined (DEBUG_CLASS_MATCHING)
+@@ -135,9 +136,19 @@
+ 				   class -&gt; submatch, MDL));
+ 			if (status &amp;&amp; data.len) {
+ 				nc = (struct class *)0;
+-				if (class_hash_lookup (&amp;nc, class -&gt; hash,
+-						       (const char *)data.data,
+-						       data.len, MDL)) {
++                                classfound = class_hash_lookup (&amp;nc, 
++						class -&gt; hash, 
++						(const char *)data.data,
++						data.len, MDL);
++
++#ifdef LDAP_CONFIGURATION
++                                if (!classfound &amp;&amp; 
++						find_subclass_in_ldap (class, 
++								&amp;nc, &amp;data)) 
++					classfound = 1;
++#endif
++
++				if (classfound) {
+ #if defined (DEBUG_CLASS_MATCHING)
+ 					log_info (&quot;matches subclass %s.&quot;,
+ 					      print_hex_1 (data.len,
+diff -Naur dhcp-3.0.3/server/confpars.c dhcp-3.0.3-ldap/server/confpars.c
+--- dhcp-3.0.3/server/confpars.c	2004-11-24 12:39:18.000000000 -0500
++++ dhcp-3.0.3-ldap/server/confpars.c	2005-07-25 08:14:44.000000000 -0400
+@@ -62,7 +62,17 @@
+ 
+ isc_result_t readconf ()
+ {
+-	return read_conf_file (path_dhcpd_conf, root_group, ROOT_GROUP, 0);
++	isc_result_t res;
++
++	res = read_conf_file (path_dhcpd_conf, root_group, ROOT_GROUP, 0);
++#if defined(LDAP_CONFIGURATION)
++	if (res != ISC_R_SUCCESS)
++		return (res);
++
++	return ldap_read_config ();
++#else
++	return (res);
++#endif
+ }
+ 
+ isc_result_t read_conf_file (const char *filename, struct group *group,
+diff -Naur dhcp-3.0.3/server/dhcpd.c dhcp-3.0.3-ldap/server/dhcpd.c
+--- dhcp-3.0.3/server/dhcpd.c	2005-03-03 11:55:24.000000000 -0500
++++ dhcp-3.0.3-ldap/server/dhcpd.c	2005-07-25 08:14:44.000000000 -0400
+@@ -436,6 +436,9 @@
+ 	/* Add the ddns update style enumeration prior to parsing. */
+ 	add_enumeration (&amp;ddns_styles);
+ 	add_enumeration (&amp;syslog_enum);
++#if defined (LDAP_CONFIGURATION)
++	add_enumeration (&amp;ldap_methods);
++#endif
+ 
+ 	if (!group_allocate (&amp;root_group, MDL))
+ 		log_fatal (&quot;Can't allocate root group!&quot;);
+diff -Naur dhcp-3.0.3/server/ldap.c dhcp-3.0.3-ldap/server/ldap.c
+--- dhcp-3.0.3/server/ldap.c	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.3-ldap/server/ldap.c	2005-08-01 07:46:53.000000000 -0400
+@@ -0,0 +1,1548 @@
++/* ldap.c
++
++   Routines for reading the configuration from LDAP */
++
++/*
++ * Copyright (c) 2003-2004 Ntelos, Inc.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of The Internet Software Consortium nor the names
++ *    of its contributors may be used to endorse or promote products derived
++ *    from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
++ * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
++ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
++ * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
++ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
++ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
++ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
++ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
++ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ * This LDAP module was written by Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;. It's
++ * development was sponsored by Ntelos, Inc. (www.ntelos.com).
++ */
++
++#include &quot;dhcpd.h&quot;
++#include &lt;signal.h&gt;
++
++#if defined(LDAP_CONFIGURATION)
++
++static LDAP * ld = NULL;
++static char *ldap_server = NULL, 
++            *ldap_username = NULL, 
++            *ldap_password = NULL,
++            *ldap_base_dn = NULL,
++            *ldap_debug_file = NULL;
++static int ldap_port = LDAP_PORT,
++           ldap_method = LDAP_METHOD_DYNAMIC,
++           ldap_debug_fd = -1;
++static struct ldap_config_stack *ldap_stack = NULL;
++
++typedef struct ldap_dn_node {
++    struct ldap_dn_node *next;
++    size_t refs;
++    char *dn;
++} ldap_dn_node;
++
++static ldap_dn_node *ldap_service_dn_head = NULL;
++static ldap_dn_node *ldap_service_dn_tail = NULL;
++
++
++static void
++ldap_parse_class (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  strncat (cfile-&gt;inbuf, &quot;class \&quot;&quot;, LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, &quot;\&quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++}
++
++
++static void
++ldap_parse_subclass (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr, **classdata;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  if ((classdata = ldap_get_values (ld, item-&gt;ldent, 
++                                  &quot;dhcpClassData&quot;)) == NULL || 
++      classdata[0] == NULL)
++    {
++      if (classdata != NULL)
++        ldap_value_free (classdata);
++      ldap_value_free (tempstr);
++
++      return;
++    }
++
++  strncat (cfile-&gt;inbuf, &quot;subclass &quot;, LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, classdata[0], LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, &quot; &quot;, LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, &quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++  ldap_value_free (classdata);
++}
++
++
++static void
++ldap_parse_host (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr, **hwaddr;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  hwaddr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpHWAddress&quot;);
++
++  strncat (cfile-&gt;inbuf, &quot;host &quot;, LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++
++  if (hwaddr != NULL &amp;&amp; hwaddr[0] != NULL)
++    {
++      strncat (cfile-&gt;inbuf, &quot; {\nhardware &quot;, LDAP_BUFFER_SIZE);
++      strncat (cfile-&gt;inbuf, hwaddr[0], LDAP_BUFFER_SIZE);
++      strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (hwaddr);
++    }
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++}
++
++
++static void
++ldap_parse_shared_network (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr;
++
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  strncat (cfile-&gt;inbuf, &quot;shared-network \&quot;&quot;, LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, &quot;\&quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++}
++
++
++static void
++parse_netmask (int netmask, char *netmaskbuf)
++{
++  unsigned long nm;
++  int i;
++
++  nm = 0;
++  for (i=1; i &lt;= netmask; i++)
++    {
++      nm |= 1 &lt;&lt; (32 - i);
++    }
++
++  sprintf (netmaskbuf, &quot;%d.%d.%d.%d&quot;, (int) (nm &gt;&gt; 24) &amp; 0xff, 
++                                      (int) (nm &gt;&gt; 16) &amp; 0xff, 
++                                      (int) (nm &gt;&gt; 8) &amp; 0xff, 
++                                      (int) nm &amp; 0xff);
++}
++
++static void
++ldap_parse_subnet (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr, **netmaskstr, netmaskbuf[16];
++  int i;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  if ((netmaskstr = ldap_get_values (ld, item-&gt;ldent, 
++                                     &quot;dhcpNetmask&quot;)) == NULL || 
++      netmaskstr[0] == NULL)
++    {
++      if (netmaskstr != NULL)
++        ldap_value_free (netmaskstr);
++      ldap_value_free (tempstr);
++
++      return;
++    }
++
++  strncat (cfile-&gt;inbuf, &quot;subnet &quot;, LDAP_BUFFER_SIZE);
++  strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++
++  strncat (cfile-&gt;inbuf, &quot; netmask &quot;, LDAP_BUFFER_SIZE);
++  parse_netmask (strtol (netmaskstr[0], NULL, 10), netmaskbuf);
++  strncat (cfile-&gt;inbuf, netmaskbuf, LDAP_BUFFER_SIZE);
++
++  strncat (cfile-&gt;inbuf, &quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  ldap_value_free (tempstr);
++  ldap_value_free (netmaskstr);
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpRange&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          strncat (cfile-&gt;inbuf, &quot;range&quot;, LDAP_BUFFER_SIZE);
++          strncat (cfile-&gt;inbuf, &quot; &quot;, LDAP_BUFFER_SIZE);
++          strncat (cfile-&gt;inbuf, tempstr[i], LDAP_BUFFER_SIZE);
++          strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++        }
++      ldap_value_free (tempstr);
++    }
++
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++ldap_parse_pool (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr;
++  int i;
++
++  strncat (cfile-&gt;inbuf, &quot;pool {\n&quot;, LDAP_BUFFER_SIZE);
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpRange&quot;)) != NULL)
++    {
++      strncat (cfile-&gt;inbuf, &quot;range&quot;, LDAP_BUFFER_SIZE);
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          strncat (cfile-&gt;inbuf, &quot; &quot;, LDAP_BUFFER_SIZE);
++          strncat (cfile-&gt;inbuf, tempstr[i], LDAP_BUFFER_SIZE);
++        }
++      strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpPermitList&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          strncat (cfile-&gt;inbuf, tempstr[i], LDAP_BUFFER_SIZE);
++          strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++        }
++      ldap_value_free (tempstr);
++    }
++
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++ldap_parse_group (struct ldap_config_stack *item, struct parse *cfile)
++{
++  strncat (cfile-&gt;inbuf, &quot;group {\n&quot;, LDAP_BUFFER_SIZE);
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++add_to_config_stack (LDAPMessage * res, LDAPMessage * ent)
++{
++  struct ldap_config_stack *ns;
++
++  ns = dmalloc (sizeof (*ns), MDL);
++  ns-&gt;res = res;
++  ns-&gt;ldent = ent;
++  ns-&gt;close_brace = 0;
++  ns-&gt;processed = 0;
++  ns-&gt;next = ldap_stack;
++  ldap_stack = ns;
++}
++
++
++static void
++ldap_stop()
++{
++    struct sigaction new, old;
++
++    new.sa_flags   = 0;
++    new.sa_handler = SIG_IGN;
++    sigemptyset(&amp;new.sa_mask);
++
++    /*
++    ** ldap_unbind after a LDAP_SERVER_DOWN result
++    ** causes a SIGPIPE and dhcpd gets terminated,
++    ** since it doesn't handle it...
++    */
++    sigaction (SIGPIPE, &amp;new, &amp;old);
++    if(ld)
++      ldap_unbind (ld);
++    ld = NULL;
++    sigaction (SIGPIPE, &amp;old, &amp;new);
++}
++
++
++static void
++ldap_start (void)
++{
++  struct option_state *options;
++  struct option_cache *oc;
++  struct data_string db;
++  int ret, version;
++
++  if (ld != NULL)
++    return;
++
++  if (ldap_server == NULL)
++    {
++      options = NULL;
++      option_state_allocate (&amp;options, MDL);
++
++      execute_statements_in_scope ((struct binding_value **) NULL,
++                 (struct packet *) NULL, (struct lease *) NULL,
++                 (struct client_state *) NULL, (struct option_state *) NULL,
++                 options, &amp;global_scope, root_group, (struct group *) NULL);
++
++      memset (&amp;db, 0, sizeof (db));
++      oc = lookup_option (&amp;server_universe, options, SV_LDAP_SERVER);
++      if (oc &amp;&amp;
++          evaluate_option_cache (&amp;db,  (struct packet*) NULL,
++                (struct lease *) NULL, (struct client_state *) NULL,
++                options, (struct option_state *) NULL, &amp;global_scope, oc, MDL))
++        {
++          ldap_server = dmalloc (db.len + 1, MDL);
++          if (!ldap_server)
++            log_fatal (&quot;no memory for ldap server&quot;);
++          memcpy (ldap_server, db.data, db.len);
++          ldap_server[db.len] = 0;
++          data_string_forget (&amp;db, MDL);
++        }
++
++      oc = lookup_option (&amp;server_universe, options, SV_LDAP_USERNAME);
++      if (oc &amp;&amp;
++          evaluate_option_cache (&amp;db,  (struct packet*) NULL,
++                (struct lease *) NULL, (struct client_state *) NULL,
++                options, (struct option_state *) NULL, &amp;global_scope, oc, MDL))
++        {
++          ldap_username = dmalloc (db.len + 1, MDL);
++          if (!ldap_username)
++            log_fatal (&quot;no memory for ldap username&quot;);
++          memcpy (ldap_username, db.data, db.len);
++          ldap_username[db.len] = 0;
++          data_string_forget (&amp;db, MDL);
++        }
++
++      oc = lookup_option (&amp;server_universe, options, SV_LDAP_PASSWORD);
++      if (oc &amp;&amp;
++          evaluate_option_cache (&amp;db,  (struct packet*) NULL,
++                (struct lease *) NULL, (struct client_state *) NULL,
++                options, (struct option_state *) NULL, &amp;global_scope, oc, MDL))
++        {
++          ldap_password = dmalloc (db.len + 1, MDL);
++          if (!ldap_password)
++            log_fatal (&quot;no memory for ldap password&quot;);
++          memcpy (ldap_password, db.data, db.len);
++          ldap_password[db.len] = 0;
++          data_string_forget (&amp;db, MDL);
++        }
++
++      oc = lookup_option (&amp;server_universe, options, SV_LDAP_BASE_DN);
++      if (oc &amp;&amp;
++          evaluate_option_cache (&amp;db,  (struct packet*) NULL,
++                (struct lease *) NULL, (struct client_state *) NULL,
++                options, (struct option_state *) NULL, &amp;global_scope, oc, MDL))
++        {
++          ldap_base_dn = dmalloc (db.len + 1, MDL);
++          if (!ldap_base_dn)
++            log_fatal (&quot;no memory for ldap base dn&quot;);
++          memcpy (ldap_base_dn, db.data, db.len);
++          ldap_base_dn[db.len] = 0;
++          data_string_forget (&amp;db, MDL);
++        }
++
++      oc = lookup_option (&amp;server_universe, options, SV_LDAP_METHOD);
++      if (oc &amp;&amp;
++          evaluate_option_cache (&amp;db,  (struct packet*) NULL,
++                (struct lease *) NULL, (struct client_state *) NULL,
++                options, (struct option_state *) NULL, &amp;global_scope, oc, MDL))
++        {
++
++          if (db.len == 1) 
++            ldap_method = db.data [0];
++          else
++            log_fatal (&quot;invalid ldap method type&quot;);
++          data_string_forget (&amp;db, MDL);
++        }
++
++      oc = lookup_option (&amp;server_universe, options, SV_LDAP_DEBUG_FILE);
++      if (oc &amp;&amp;
++          evaluate_option_cache (&amp;db,  (struct packet*) NULL,
++                (struct lease *) NULL, (struct client_state *) NULL,
++                options, (struct option_state *) NULL, &amp;global_scope, oc, MDL))
++        {
++          ldap_debug_file = dmalloc (db.len + 1, MDL);
++          if (!ldap_debug_file)
++            log_fatal (&quot;no memory for ldap debug file&quot;);
++          memcpy (ldap_debug_file, db.data, db.len);
++          ldap_debug_file[db.len] = 0;
++          data_string_forget (&amp;db, MDL);
++        }
++
++      option_state_dereference (&amp;options, MDL);
++    }
++
++  if (ldap_server == NULL || ldap_base_dn == NULL)
++    {
++      log_info (&quot;Not searching LDAP since ldap-server, ldap-port and ldap-base-dn were not specified in the config file&quot;);
++      ldap_method = LDAP_METHOD_STATIC;
++      return;
++    }
++
++  if (ldap_debug_file != NULL &amp;&amp; ldap_debug_fd == -1)
++    {
++      if ((ldap_debug_fd = open (ldap_debug_file, O_CREAT | O_TRUNC | O_WRONLY,
++                                 S_IRUSR | S_IWUSR)) &lt; 0)
++        log_error (&quot;Error opening debug LDAP log file %s: %s&quot;, ldap_debug_file,
++                   strerror (errno));
++    }
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Connecting to LDAP server %s:%d&quot;, ldap_server, ldap_port);
++#endif
++
++  if ((ld = ldap_init (ldap_server, ldap_port)) == NULL)
++    {
++      log_error (&quot;Cannot init ldap session to %s&quot;, ldap_server);
++      return;
++    }
++
++  version = LDAP_VERSION3;
++  if ((ret = ldap_set_option (ld, LDAP_OPT_PROTOCOL_VERSION, &amp;version)) != LDAP_OPT_SUCCESS)
++    {
++      log_error (&quot;Cannot set LDAP version to %d: %s&quot;, version,
++                 ldap_err2string (ret));
++    }
++
++#if defined (USE_SSL)
++  if ((ret = ldap_start_tls_s (ld, NULL, NULL)) != LDAP_SUCCESS)
++    log_error (&quot;Warning: Cannot start TLS session to %s: %s&quot;,
++               ldap_server, ldap_err2string (ret));
++  else
++    log_info (&quot;TLS session successfully started to %s&quot;, ldap_server);
++#endif
++
++  if (ldap_username != NULL &amp;&amp; *ldap_username != '\0')
++    {
++      if ((ret = ldap_simple_bind_s (ld, ldap_username,
++                                     ldap_password)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error: Cannot login into ldap server %s: %s&quot;, ldap_server,
++                     ldap_err2string (ret));
++          ldap_stop();
++          return;
++        }
++    }
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Successfully logged into LDAP server %s&quot;, ldap_server);
++#endif
++}
++
++
++static void
++parse_external_dns (LDAPMessage * ent)
++{
++  char *search[] = {&quot;dhcpOptionsDN&quot;, &quot;dhcpSharedNetworkDN&quot;, &quot;dhcpSubnetDN&quot;,
++                    &quot;dhcpGroupDN&quot;, &quot;dhcpHostDN&quot;, &quot;dhcpClassesDN&quot;,
++                    &quot;dhcpPoolDN&quot;, NULL};
++  LDAPMessage * newres, * newent;
++  struct ldap_config_stack *ns;
++  char **tempstr;
++  int i, j, ret;
++#if defined (DEBUG_LDAP)
++  char *dn;
++
++  dn = ldap_get_dn (ld, ent);
++  if (dn != NULL)
++    {
++      log_info (&quot;Parsing external DNs for '%s'&quot;, dn);
++      ldap_memfree (dn);
++    }
++#endif
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return;
++
++  for (i=0; search[i] != NULL; i++)
++    {
++      if ((tempstr = ldap_get_values (ld, ent, search[i])) == NULL)
++        continue;
++
++      for (j=0; tempstr[j] != NULL; j++)
++        {
++          if (*tempstr[j] == '\0')
++            continue;
++
++          if ((ret = ldap_search_s (ld, tempstr[j], LDAP_SCOPE_BASE, 
++                                    &quot;objectClass=*&quot;, NULL, 0, 
++                                    &amp;newres)) != LDAP_SUCCESS)
++            {
++              ldap_value_free (tempstr);
++              ldap_stop();
++              return;
++            }
++    
++#if defined (DEBUG_LDAP)
++          log_info (&quot;Adding contents of subtree '%s' to config stack from '%s' reference&quot;, tempstr[j], search[i]);
++#endif
++          for (newent = ldap_first_entry (ld, newres);
++               newent != NULL;
++               newent = ldap_next_entry (ld, newent))
++            {
++#if defined (DEBUG_LDAP)
++              dn = ldap_get_dn (ld, newent);
++              if (dn != NULL)
++                {
++                  log_info (&quot;Adding LDAP result set starting with '%s' to config stack&quot;, dn);
++                  ldap_memfree (dn);
++                }
++#endif
++
++              add_to_config_stack (newres, newent);
++              /* don't free newres here */
++            }
++        }
++
++      ldap_value_free (tempstr);
++    }
++}
++
++
++static void
++free_stack_entry (struct ldap_config_stack *item)
++{
++  struct ldap_config_stack *look_ahead_pointer = item;
++  int may_free_msg = 1;
++
++  while (look_ahead_pointer-&gt;next != NULL)
++    {
++      look_ahead_pointer = look_ahead_pointer-&gt;next;
++      if (look_ahead_pointer-&gt;res == item-&gt;res)
++        {
++          may_free_msg = 0;
++          break;
++        }
++    }
++
++  if (may_free_msg) 
++    ldap_msgfree (item-&gt;res);
++
++  dfree (item, MDL);
++}
++
++
++static void
++next_ldap_entry (struct parse *cfile)
++{
++  struct ldap_config_stack *temp_stack;
++
++  if (ldap_stack != NULL &amp;&amp; ldap_stack-&gt;close_brace)
++    {
++      strncat (cfile-&gt;inbuf, &quot;}\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_stack-&gt;close_brace = 0;
++    }
++
++  while (ldap_stack != NULL &amp;&amp; 
++         (ldap_stack-&gt;ldent == NULL ||
++          (ldap_stack-&gt;ldent = ldap_next_entry (ld, ldap_stack-&gt;ldent)) == NULL))
++    {
++      if (ldap_stack-&gt;close_brace)
++        {
++          strncat (cfile-&gt;inbuf, &quot;}\n&quot;, LDAP_BUFFER_SIZE);
++          ldap_stack-&gt;close_brace = 0;
++        }
++
++      temp_stack = ldap_stack;
++      ldap_stack = ldap_stack-&gt;next;
++      free_stack_entry (temp_stack);
++    }
++
++  if (ldap_stack != NULL &amp;&amp; ldap_stack-&gt;close_brace)
++    {
++      strncat (cfile-&gt;inbuf, &quot;}\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_stack-&gt;close_brace = 0;
++    }
++}
++
++
++static char
++check_statement_end (const char *statement)
++{
++  char *ptr;
++
++  if (statement == NULL || *statement == '\0')
++    return ('\0');
++
++  /*
++  ** check if it ends with &quot;}&quot;, e.g.:
++  **   &quot;zone my.domain. { ... }&quot;
++  ** optionally followed by spaces
++  */
++  ptr = strrchr (statement, '}');
++  if (ptr != NULL)
++    {
++      /* skip following white-spaces */
++      for (++ptr; isspace ((int)*ptr); ptr++);
++
++      /* check if we reached the end */
++      if (*ptr == '\0')
++        return ('}'); /* yes, block end */
++      else
++        return (*ptr);
++    }
++
++  /*
++  ** this should not happen, but...
++  ** check if it ends with &quot;;&quot;, e.g.:
++  **   &quot;authoritative;&quot;
++  ** optionally followed by spaces
++  */
++  ptr = strrchr (statement, ';');
++  if (ptr != NULL)
++    {
++      /* skip following white-spaces */
++      for (++ptr; isspace ((int)*ptr); ptr++);
++
++      /* check if we reached the end */
++      if (*ptr == '\0')
++        return (';'); /* ends with a ; */
++      else
++        return (*ptr);
++    }
++
++  return ('\0');
++}
++
++
++static isc_result_t
++ldap_parse_entry_options (LDAPMessage *ent, char *buffer, size_t size,
++                          int *lease_limit)
++{
++  char **tempstr;
++  int i;
++
++  if (ent == NULL || buffer == NULL || size == 0)
++    return (ISC_R_FAILURE);
++
++  if ((tempstr = ldap_get_values (ld, ent, &quot;dhcpStatements&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          if (lease_limit != NULL &amp;&amp;
++              strncasecmp (&quot;lease limit &quot;, tempstr[i], 12) == 0)
++            {
++              *lease_limit = (int) strtol ((tempstr[i]) + 12, NULL, 10);
++              continue;
++            }
++
++          strncat (buffer, tempstr[i], size);
++
++          switch((int) check_statement_end (tempstr[i]))
++            {
++              case '}':
++              case ';':
++                strncat (buffer, &quot;\n&quot;, size);
++                break;
++              default:
++                strncat (buffer, &quot;;\n&quot;, size);
++                break;
++            }
++        }
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, ent, &quot;dhcpOption&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          strncat (buffer, &quot;option &quot;, size);
++          strncat (buffer, tempstr[i], size);
++          switch ((int) check_statement_end (tempstr[i]))
++            {
++              case ';':
++                strncat (buffer, &quot;\n&quot;, size);
++                break;
++              default:
++                strncat (buffer, &quot;;\n&quot;, size);
++                break;
++            }
++        }
++      ldap_value_free (tempstr);
++    }
++
++  return (ISC_R_SUCCESS);
++}
++
++
++static void
++ldap_generate_config_string (struct parse *cfile)
++{
++  char **objectClass, *dn;
++  struct ldap_config_stack *entry;
++  LDAPMessage * ent, * res;
++  int i, j, ignore, found;
++  int ret;
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return;
++
++  entry = ldap_stack;
++  if ((objectClass = ldap_get_values (ld, entry-&gt;ldent, 
++                                      &quot;objectClass&quot;)) == NULL)
++    return;
++    
++  ignore = 0;
++  found = 1;
++  for (i=0; objectClass[i] != NULL; i++)
++    {
++      if (strcasecmp (objectClass[i], &quot;dhcpSharedNetwork&quot;) == 0)
++        ldap_parse_shared_network (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpClass&quot;) == 0)
++        ldap_parse_class (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpSubnet&quot;) == 0)
++        ldap_parse_subnet (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpPool&quot;) == 0)
++        ldap_parse_pool (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpGroup&quot;) == 0)
++        ldap_parse_group (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpHost&quot;) == 0)
++        {
++          if (ldap_method == LDAP_METHOD_STATIC)
++            ldap_parse_host (entry, cfile);
++          else
++            {
++              ignore = 1;
++              break;
++            }
++        }
++      else if (strcasecmp (objectClass[i], &quot;dhcpSubClass&quot;) == 0)
++        {
++          if (ldap_method == LDAP_METHOD_STATIC)
++            ldap_parse_subclass (entry, cfile);
++          else
++            {
++              ignore = 1;
++              break;
++            }
++        }
++      else
++        found = 0;
++
++      if (found &amp;&amp; cfile-&gt;inbuf[0] == '\0')
++        {
++          ignore = 1;
++          break;
++        }
++    }
++
++  ldap_value_free (objectClass);
++
++  if (ignore)
++    {
++      next_ldap_entry (cfile);
++      return;
++    }
++
++  ldap_parse_entry_options(entry-&gt;ldent, cfile-&gt;inbuf,
++                           LDAP_BUFFER_SIZE-1, NULL);
++
++  dn = ldap_get_dn (ld, entry-&gt;ldent);
++
++#if defined(DEBUG_LDAP)
++  if (dn != NULL)
++    log_info (&quot;Found LDAP entry '%s'&quot;, dn);
++#endif
++
++  if (dn == NULL ||
++      (ret = ldap_search_s (ld, dn, LDAP_SCOPE_ONELEVEL, &quot;objectClass=*&quot;, 
++                            NULL, 0, &amp;res)) != LDAP_SUCCESS)
++    {
++      if (dn)
++        ldap_memfree (dn);
++
++      ldap_stop();
++      return;
++    }
++
++  ldap_memfree (dn);
++
++  if ((ent = ldap_first_entry (ld, res)) != NULL)
++    {
++      add_to_config_stack (res, ent);
++      parse_external_dns (entry-&gt;ldent);
++    }
++  else
++    {
++      ldap_msgfree (res);
++      parse_external_dns (entry-&gt;ldent);
++      next_ldap_entry (cfile);
++    }
++}
++
++
++static void
++ldap_close_debug_fd()
++{
++  if (ldap_debug_fd != -1)
++    {
++      close (ldap_debug_fd);
++      ldap_debug_fd = -1;
++    }
++}
++
++
++static void
++ldap_write_debug (const void *buff, size_t size)
++{
++  if (ldap_debug_fd != -1)
++    {
++      if (write (ldap_debug_fd, buff, size) &lt; 0)
++        {
++          log_error (&quot;Error writing to LDAP debug file %s: %s.&quot;
++                     &quot; Disabling log file.&quot;, ldap_debug_file,
++                     strerror (errno));
++          ldap_close_debug_fd();
++        }
++    }
++}
++
++static char
++ldap_read_function (struct parse *cfile)
++{
++  char eofstring[2] = {EOF, '\0'};
++ 
++  cfile-&gt;inbuf[0] = '\0';
++  cfile-&gt;buflen = 0;
++
++  while (ldap_stack != NULL &amp;&amp; *cfile-&gt;inbuf == '\0')
++    ldap_generate_config_string (cfile);
++
++  cfile-&gt;buflen = strlen (cfile-&gt;inbuf);
++  if (cfile-&gt;buflen &gt; 0)
++    ldap_write_debug (cfile-&gt;inbuf, cfile-&gt;buflen);
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Sending config line '%s'&quot;, cfile-&gt;inbuf);
++#endif
++
++  if (ldap_stack == NULL)
++    strncat (cfile-&gt;inbuf, eofstring, LDAP_BUFFER_SIZE);
++
++  cfile-&gt;buflen = strlen (cfile-&gt;inbuf);
++  cfile-&gt;bufix = 1;
++
++  return (cfile-&gt;inbuf[0]);
++}
++
++
++static char *
++ldap_get_host_name (LDAPMessage * ent)
++{
++  char **name, *ret;
++
++  ret = NULL;
++  if ((name = ldap_get_values (ld, ent, &quot;cn&quot;)) == NULL || name[0] == NULL)
++    {
++      if (name != NULL)
++        ldap_value_free (name);
++
++#if defined (DEBUG_LDAP)
++      ret = ldap_get_dn (ld, ent);
++      if (ret != NULL)
++        {
++          log_info (&quot;Cannot get cn attribute for LDAP entry %s&quot;, ret);
++          ldap_memfree(ret);
++        }
++#endif
++      return (NULL);
++    }
++
++  ret = dmalloc (strlen (name[0]) + 1, MDL);
++  strcpy (ret, name[0]);
++  ldap_value_free (name);
++
++  return (ret);
++}
++
++
++static int
++getfqhostname(char *fqhost, size_t size)
++{
++#if defined(MAXHOSTNAMELEN)
++  char   hname[MAXHOSTNAMELEN];
++#else
++  char   hname[65];
++#endif
++  struct hostent *hp;
++
++  if(NULL == fqhost || 1 &gt;= size)
++    return -1;
++
++  memset(hname, 0, sizeof(hname));
++  if( gethostname(hname, sizeof(hname)-1))
++    return -1;
++
++  if(NULL == (hp = gethostbyname(hname)))
++    return -1;
++
++  strncpy(fqhost, hp-&gt;h_name, size-1);
++  fqhost[size-1] = '\0';
++  return 0;
++}
++
++
++isc_result_t
++ldap_read_config (void)
++{
++  LDAPMessage * ldres, * hostres, * ent, * hostent;
++  char hfilter[1024], sfilter[1024], fqdn[257];
++  char *buffer, **tempstr = NULL, *hostdn;
++  ldap_dn_node *curr = NULL;
++  struct parse *cfile;
++  struct utsname unme;
++  isc_result_t res;
++  size_t length;
++  int ret, cnt;
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return (ldap_server == NULL ? ISC_R_SUCCESS : ISC_R_FAILURE);
++ 
++  buffer = dmalloc (LDAP_BUFFER_SIZE+1, MDL);
++  if (buffer == NULL)
++    return (ISC_R_FAILURE);
++
++  cfile = (struct parse *) NULL;
++  res = new_parse (&amp;cfile, -1, buffer, LDAP_BUFFER_SIZE, &quot;LDAP&quot;, 0);
++  if (res != ISC_R_SUCCESS)
++    return (res);
++ 
++  uname (&amp;unme);
++  if(0 == getfqhostname(fqdn, sizeof(fqdn)))
++    {
++      snprintf (hfilter, sizeof (hfilter),
++                &quot;(&amp;(objectClass=dhcpServer)(|(cn=%s)(cn=%s)))&quot;, 
++                unme.nodename, fqdn);
++    }
++  else
++    {
++      snprintf (hfilter, sizeof (hfilter),
++                &quot;(&amp;(objectClass=dhcpServer)(cn=%s))&quot;, unme.nodename);
++    }
++
++  hostres = NULL;
++  if ((ret = ldap_search_s (ld, ldap_base_dn, LDAP_SCOPE_SUBTREE,
++                            hfilter, NULL, 0, &amp;hostres)) != LDAP_SUCCESS)
++    {
++      log_error (&quot;Cannot find host LDAP entry %s %s&quot;,
++                 unme.nodename, hfilter);
++      if(NULL != hostres)
++        ldap_msgfree (hostres);
++      ldap_stop();
++      return (ISC_R_FAILURE);
++    }
++
++  if ((hostent = ldap_first_entry (ld, hostres)) == NULL)
++    {
++      log_error (&quot;Error: Cannot find LDAP entry matching %s&quot;, hfilter);
++      ldap_msgfree (hostres);
++      ldap_stop();
++      return (ISC_R_FAILURE);
++    }
++
++  hostdn = ldap_get_dn (ld, hostent);
++#if defined(DEBUG_LDAP)
++  if (hostdn != NULL)
++    log_info (&quot;Found dhcpServer LDAP entry '%s'&quot;, hostdn);
++#endif
++
++  if (hostdn == NULL ||
++      (tempstr = ldap_get_values (ld, hostent, &quot;dhcpServiceDN&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      log_error (&quot;Error: Cannot find LDAP entry matching %s&quot;, hfilter);
++
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      if (hostdn)
++        ldap_memfree (hostdn);
++      ldap_msgfree (hostres);
++      ldap_stop();
++      return (ISC_R_FAILURE);
++    }
++
++#if defined(DEBUG_LDAP)
++  log_info (&quot;LDAP: Parsing dhcpServer options '%s' ...&quot;, hostdn);
++#endif
++
++  cfile-&gt;inbuf[0] = '\0';
++  ldap_parse_entry_options(hostent, cfile-&gt;inbuf, LDAP_BUFFER_SIZE, NULL);
++  cfile-&gt;buflen = strlen (cfile-&gt;inbuf);
++  if(cfile-&gt;buflen &gt; 0)
++    {
++      ldap_write_debug (cfile-&gt;inbuf, cfile-&gt;buflen);
++
++      res = conf_file_subparse (cfile, root_group, ROOT_GROUP);
++      if (res != ISC_R_SUCCESS)
++        {
++          log_error (&quot;LDAP: cannot parse dhcpServer entry '%s'&quot;, hostdn);
++          ldap_memfree (hostdn);
++          ldap_stop();
++          return res;
++        }
++      cfile-&gt;inbuf[0] = '\0';
++    }
++  ldap_msgfree (hostres);
++
++  /*
++  ** attach ldap (tree) read function now
++  */
++  cfile-&gt;bufix = cfile-&gt;buflen = 0;
++  cfile-&gt;read_function = ldap_read_function;
++
++  res = ISC_R_SUCCESS;
++  for (cnt=0; tempstr[cnt] != NULL; cnt++)
++    {
++      snprintf(sfilter, sizeof(sfilter), &quot;(&amp;(objectClass=dhcpService)&quot;
++                        &quot;(|(dhcpPrimaryDN=%s)(dhcpSecondaryDN=%s)))&quot;,
++                        hostdn, hostdn);
++      ldres = NULL;
++      if ((ret = ldap_search_s (ld, tempstr[cnt], LDAP_SCOPE_BASE,
++                                sfilter, NULL, 0, &amp;ldres)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error searching for dhcpServiceDN '%s': %s. Please update the LDAP entry '%s'&quot;,
++                     tempstr[cnt], ldap_err2string (ret), hostdn);
++          if(NULL != ldres)
++            ldap_msgfree(ldres);
++          res = ISC_R_FAILURE;
++          break;
++        }
++
++      if ((ent = ldap_first_entry (ld, ldres)) == NULL)
++        {
++          log_error (&quot;Error: Cannot find dhcpService DN '%s' with primary or secondary server reference. Please update the LDAP server entry '%s'&quot;,
++                     tempstr[cnt], hostdn);
++
++          ldap_msgfree(ldres);
++          res = ISC_R_FAILURE;
++          break;
++        }
++
++      /*
++      ** FIXME: how to free the remembered dn's on exit?
++      **        This should be OK if dmalloc registers the
++      **        memory it allocated and frees it on exit..
++      */
++
++      curr = dmalloc (sizeof (*curr), MDL);
++      if (curr != NULL)
++        {
++          length = strlen (tempstr[cnt]);
++          curr-&gt;dn = dmalloc (length + 1, MDL);
++          if (curr-&gt;dn == NULL)
++            {
++              dfree (curr, MDL);
++              curr = NULL;
++            }
++          else
++            strcpy (curr-&gt;dn, tempstr[cnt]);
++        }
++
++      if (curr != NULL)
++        {
++          curr-&gt;refs++;
++
++          /* append to service-dn list */
++          if (ldap_service_dn_tail != NULL)
++            ldap_service_dn_tail-&gt;next = curr;
++          else
++            ldap_service_dn_head = curr;
++
++          ldap_service_dn_tail = curr;
++        }
++      else
++        log_fatal (&quot;no memory to remember ldap service dn&quot;);
++
++#if defined (DEBUG_LDAP)
++      log_info (&quot;LDAP: Parsing dhcpService DN '%s' ...&quot;, tempstr[cnt]);
++#endif
++      add_to_config_stack (ldres, ent);
++      res = conf_file_subparse (cfile, root_group, ROOT_GROUP);
++      if (res != ISC_R_SUCCESS)
++        {
++          log_error (&quot;LDAP: cannot parse dhcpService entry '%s'&quot;, tempstr[cnt]);
++          break;
++        }
++    }
++
++  end_parse (&amp;cfile);
++  ldap_close_debug_fd();
++
++  ldap_memfree (hostdn);
++  ldap_value_free (tempstr);
++
++  if (res != ISC_R_SUCCESS)
++    {
++      struct ldap_config_stack *temp_stack;
++
++      while ((curr = ldap_service_dn_head) != NULL)
++        {
++          ldap_service_dn_head = curr-&gt;next;
++          dfree (curr-&gt;dn, MDL);
++          dfree (curr, MDL);
++        }
++
++      ldap_service_dn_tail = NULL;
++
++      while ((temp_stack = ldap_stack) != NULL)
++        {
++          ldap_stack = temp_stack-&gt;next;
++          free_stack_entry (temp_stack);
++        }
++
++      ldap_stop();
++    }
++
++  return (res);
++}
++
++
++/* This function will parse the dhcpOption and dhcpStatements field in the LDAP
++   entry if it exists. Right now, type will be either HOST_DECL or CLASS_DECL.
++   If we are parsing a HOST_DECL, this always returns 0. If we are parsing a 
++   CLASS_DECL, this will return what the current lease limit is in LDAP. If
++   there is no lease limit specified, we return 0 */
++
++static int
++ldap_parse_options (LDAPMessage * ent, struct group *group,
++                         int type, struct host_decl *host,
++                         struct class **class)
++{
++  int i, declaration, lease_limit;
++  char option_buffer[8192];
++  enum dhcp_token token;
++  struct parse *cfile;
++  isc_result_t res;
++  const char *val;
++
++  lease_limit = 0;
++  *option_buffer = '\0';
++  res = ldap_parse_entry_options (ent, option_buffer, sizeof(option_buffer) - 1,
++                                  &amp;lease_limit);
++  if (res != ISC_R_SUCCESS)
++    return (lease_limit);
++
++  option_buffer[sizeof(option_buffer) - 1] = '\0';
++  if (*option_buffer == '\0')
++    return (lease_limit);
++
++  cfile = (struct parse *) NULL;
++  res = new_parse (&amp;cfile, -1, option_buffer, strlen (option_buffer), 
++                   type == HOST_DECL ? &quot;LDAP-HOST&quot; : &quot;LDAP-SUBCLASS&quot;, 0);
++  if (res != ISC_R_SUCCESS)
++    return (lease_limit);
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Sending the following options: '%s'&quot;, option_buffer);
++#endif
++
++  declaration = 0;
++  do
++    {
++      token = peek_token (&amp;val, NULL, cfile);
++      if (token == END_OF_FILE)
++        break;
++       declaration = parse_statement (cfile, group, type, host, declaration);
++    } while (1);
++
++  end_parse (&amp;cfile);
++
++  return (lease_limit);
++}
++
++
++
++int
++find_haddr_in_ldap (struct host_decl **hp, int htype, unsigned hlen,
++                    const unsigned char *haddr, const char *file, int line)
++{
++  char buf[128], *type_str, **tempstr, *addr_str;
++  LDAPMessage * res, *ent;
++  struct host_decl * host;
++  isc_result_t status;
++  ldap_dn_node *curr;
++  int ret;
++
++  if (ldap_method == LDAP_METHOD_STATIC)
++    return (0);
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return (0);
++
++  switch (htype)
++    {
++      case HTYPE_ETHER:
++        type_str = &quot;ethernet&quot;;
++        break;
++      case HTYPE_IEEE802:
++        type_str = &quot;token-ring&quot;;
++        break;
++      case HTYPE_FDDI:
++        type_str = &quot;fddi&quot;;
++        break;
++      default:
++        log_info (&quot;Ignoring unknown type %d&quot;, htype);
++        return (0);
++    }
++
++  /*
++  ** FIXME: dhcpHWAddress attribute uses octetStringMatch
++  **        (what means exact octet match, case sensitive)!
++  **
++  **        it is not guaranted, that ldap contains _exactly_
++  **        &quot;type addr&quot; with one space between!
++  **        AFAIK print_hw_addr() produces a lower case string.
++  */
++  snprintf (buf, sizeof (buf),
++            &quot;(&amp;(objectClass=dhcpHost)(dhcpHWAddress=%s %s))&quot;,
++           type_str, print_hw_addr (htype, hlen, haddr));
++
++  res = ent = NULL;
++  for (curr = ldap_service_dn_head;
++       curr != NULL &amp;&amp; *curr-&gt;dn != '\0';
++       curr = curr-&gt;next)
++    {
++#if defined (DEBUG_LDAP)
++      log_info (&quot;Searching for %s in LDAP tree %s&quot;, buf, curr-&gt;dn);
++#endif
++      ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                           buf, NULL, 0, &amp;res);
++
++      if(ret == LDAP_SERVER_DOWN)
++        {
++          log_info (&quot;LDAP server was down, trying to reconnect...&quot;);
++
++          ldap_stop();
++          ldap_start();
++          if(ld == NULL)
++            {
++              log_info (&quot;LDAP reconnect failed - try again later...&quot;);
++              return (0);
++            }
++
++          ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                               buf, NULL, 0, &amp;res);
++        }
++
++      if (ret == LDAP_SUCCESS)
++        {
++          if( (ent = ldap_first_entry (ld, res)) != NULL)
++            break; /* search OK and have entry */
++
++#if defined (DEBUG_LDAP)
++          log_info (&quot;No host entry for %s in LDAP tree %s&quot;,
++                    buf, curr-&gt;dn);
++#endif
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++        }
++      else
++        {
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++
++          if (ret != LDAP_NO_SUCH_OBJECT &amp;&amp; ret != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot search for %s in LDAP tree %s: %s&quot;, buf, 
++                         curr-&gt;dn, ldap_err2string (ret));
++              ldap_stop();
++              return (0);
++            }
++#if defined (DEBUG_LDAP)
++          else
++            {
++              log_info (&quot;ldap_search_s returned %s when searching for %s in %s&quot;,
++                        ldap_err2string (ret), buf, curr-&gt;dn);
++            }
++#endif
++        }
++    }
++
++  if (res &amp;&amp; ent)
++    {
++#if defined (DEBUG_LDAP)
++      char *dn = ldap_get_dn (ld, ent);
++      if (dn != NULL)
++        {
++          log_info (&quot;Found dhcpHWAddress LDAP entry %s&quot;, dn);
++          ldap_memfree(dn);
++        }
++#endif
++
++      host = (struct host_decl *)0;
++      status = host_allocate (&amp;host, MDL);
++      if (status != ISC_R_SUCCESS)
++        {
++          log_fatal (&quot;can't allocate host decl struct: %s&quot;, 
++                     isc_result_totext (status)); 
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      host-&gt;name = ldap_get_host_name (ent);
++      if (host-&gt;name == NULL)
++        {
++          host_dereference (&amp;host, MDL);
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      if (!clone_group (&amp;host-&gt;group, root_group, MDL))
++        {
++          log_fatal (&quot;can't clone group for host %s&quot;, host-&gt;name);
++          host_dereference (&amp;host, MDL);
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      /*
++      ** PROBLEM: since dhcpd uses no unique names for groups,
++      **          it seems to be not possible to find the right
++      **          one, our host may belong to.
++      **
++      ** PERHAPS: Check if parent DN is a dhcpGroup or the host-dn
++      **          is referenced via dhcpHostDN in a dhcpGroup.
++      **          If found, we may fetch and apply group options
++      **          and statements to above host-&gt;group ?
++      */
++      ldap_parse_options (ent, host-&gt;group, HOST_DECL, host, NULL);
++
++      *hp = host;
++      ldap_msgfree (res);
++      return (1);
++    }
++
++
++  if(res) ldap_msgfree (res);
++  return (0);
++}
++
++
++int
++find_subclass_in_ldap (struct class *class, struct class **newclass, 
++                       struct data_string *data)
++{
++  LDAPMessage * res, * ent;
++  int i, ret, lease_limit;
++  isc_result_t status;
++  ldap_dn_node *curr;
++  char buf[1024];
++
++  if (ldap_method == LDAP_METHOD_STATIC)
++    return (0);
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return (0);
++
++  snprintf (buf, sizeof (buf), &quot;(&amp;(objectClass=dhcpSubClass)(cn=%s)(dhcpClassData=%s))&quot;, print_hex_1 (data-&gt;len, data-&gt;data, 60), print_hex_2 (strlen (class-&gt;name), class-&gt;name, 60));
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Searching LDAP for %s&quot;, buf);
++#endif
++
++  res = ent = NULL;
++  for (curr = ldap_service_dn_head;
++       curr != NULL &amp;&amp; *curr-&gt;dn != '\0';
++       curr = curr-&gt;next)
++    {
++#if defined (DEBUG_LDAP)
++      log_info (&quot;Searching for %s in LDAP tree %s&quot;, buf, curr-&gt;dn);
++#endif
++      ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                           buf, NULL, 0, &amp;res);
++
++      if(ret == LDAP_SERVER_DOWN)
++        {
++          log_info (&quot;LDAP server was down, trying to reconnect...&quot;);
++
++          ldap_stop();
++          ldap_start();
++
++          if(ld == NULL)
++            {
++              log_info (&quot;LDAP reconnect failed - try again later...&quot;);
++              return (0);
++            }
++
++          ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                               buf, NULL, 0, &amp;res);
++        }
++
++      if (ret == LDAP_SUCCESS)
++        {
++          if( (ent = ldap_first_entry (ld, res)) != NULL)
++            break; /* search OK and have entry */
++
++#if defined (DEBUG_LDAP)
++          log_info (&quot;No subclass entry for %s in LDAP tree %s&quot;,
++                    buf, curr-&gt;dn);
++#endif
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++        }
++      else
++        {
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++
++          if (ret != LDAP_NO_SUCH_OBJECT &amp;&amp; ret != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot search for %s in LDAP tree %s: %s&quot;, buf, 
++                         curr-&gt;dn, ldap_err2string (ret));
++              ldap_stop();
++              return (0);
++            }
++#if defined (DEBUG_LDAP)
++          else
++            {
++              log_info (&quot;ldap_search_s returned %s when searching for %s in %s&quot;,
++                        ldap_err2string (ret), buf, curr-&gt;dn);
++            }
++#endif
++        }
++    }
++
++  if (res &amp;&amp; ent)
++    {
++#if defined (DEBUG_LDAP)
++      char *dn = ldap_get_dn (ld, ent);
++      if (dn != NULL)
++        {
++          log_info (&quot;Found subclass LDAP entry %s&quot;, dn);
++          ldap_memfree(dn);
++        }
++#endif
++
++      status = class_allocate (newclass, MDL);
++      if (status != ISC_R_SUCCESS)
++        {
++          log_error (&quot;Cannot allocate memory for a new class&quot;);
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      group_reference (&amp;(*newclass)-&gt;group, class-&gt;group, MDL);
++      class_reference (&amp;(*newclass)-&gt;superclass, class, MDL);
++      lease_limit = ldap_parse_options (ent, (*newclass)-&gt;group, 
++                                        CLASS_DECL, NULL, newclass);
++      if (lease_limit == 0)
++        (*newclass)-&gt;lease_limit = class-&gt;lease_limit; 
++      else
++        class-&gt;lease_limit = lease_limit;
++
++      if ((*newclass)-&gt;lease_limit) 
++        {
++          (*newclass)-&gt;billed_leases = 
++              dmalloc ((*newclass)-&gt;lease_limit * sizeof (struct lease *), MDL);
++          if (!(*newclass)-&gt;billed_leases) 
++            {
++              log_error (&quot;no memory for billing&quot;);
++              class_dereference (newclass, MDL);
++              ldap_msgfree (res);
++              return (0);
++            }
++          memset ((*newclass)-&gt;billed_leases, 0, 
++                ((*newclass)-&gt;lease_limit * sizeof (*newclass)-&gt;billed_leases));
++        }
++
++      data_string_copy (&amp;(*newclass)-&gt;hash_string, data, MDL);
++
++      ldap_msgfree (res);
++      return (1);
++    }
++
++  if(res) ldap_msgfree (res);
++  return (0);
++}
++
++#endif
++
+diff -Naur dhcp-3.0.3/server/Makefile.dist dhcp-3.0.3-ldap/server/Makefile.dist
+--- dhcp-3.0.3/server/Makefile.dist	2004-06-10 13:59:50.000000000 -0400
++++ dhcp-3.0.3-ldap/server/Makefile.dist	2005-07-25 08:14:44.000000000 -0400
+@@ -25,9 +25,9 @@
+ CATMANPAGES = dhcpd.cat8 dhcpd.conf.cat5 dhcpd.leases.cat5
+ SEDMANPAGES = dhcpd.man8 dhcpd.conf.man5 dhcpd.leases.man5
+ SRCS   = dhcpd.c dhcp.c bootp.c confpars.c db.c class.c failover.c \
+-	 omapi.c mdb.c stables.c salloc.c ddns.c
++	 ldap.c omapi.c mdb.c stables.c salloc.c ddns.c
+ OBJS   = dhcpd.o dhcp.o bootp.o confpars.o db.o class.o failover.o \
+-	 omapi.o mdb.o stables.o salloc.o ddns.o
++	 ldap.o omapi.o mdb.o stables.o salloc.o ddns.o
+ PROG   = dhcpd
+ MAN    = dhcpd.8 dhcpd.conf.5 dhcpd.leases.5
+ 
+diff -Naur dhcp-3.0.3/server/mdb.c dhcp-3.0.3-ldap/server/mdb.c
+--- dhcp-3.0.3/server/mdb.c	2005-03-03 11:55:25.000000000 -0500
++++ dhcp-3.0.3-ldap/server/mdb.c	2005-07-25 08:14:44.000000000 -0400
+@@ -375,6 +375,12 @@
+ {
+ 	struct host_decl *foo;
+ 	struct hardware h;
++	int ret;
++
++#if defined(LDAP_CONFIGURATION)
++	if ((ret = find_haddr_in_ldap (hp, htype, hlen, haddr, file, line)))
++		return ret;
++#endif
+ 
+ 	h.hlen = hlen + 1;
+ 	h.hbuf [0] = htype;
+diff -Naur dhcp-3.0.3/server/stables.c dhcp-3.0.3-ldap/server/stables.c
+--- dhcp-3.0.3/server/stables.c	2004-06-10 13:59:58.000000000 -0400
++++ dhcp-3.0.3-ldap/server/stables.c	2005-07-25 08:14:44.000000000 -0400
+@@ -483,6 +483,15 @@
+ 	{ &quot;log-facility&quot;, &quot;Nsyslog-facilities.&quot;,	&amp;server_universe, 44 },
+ 	{ &quot;do-forward-updates&quot;, &quot;f&quot;,			&amp;server_universe, 45 },
+ 	{ &quot;ping-timeout&quot;, &quot;T&quot;,				&amp;server_universe, 46 },
++#if defined(LDAP_CONFIGURATION)
++	{ &quot;ldap-server&quot;, &quot;t&quot;,				&amp;server_universe, 47 },
++	{ &quot;ldap-port&quot;, &quot;d&quot;,				&amp;server_universe, 48 },
++	{ &quot;ldap-username&quot;, &quot;t&quot;,				&amp;server_universe, 49 },
++	{ &quot;ldap-password&quot;, &quot;t&quot;,				&amp;server_universe, 50 },
++	{ &quot;ldap-base-dn&quot;, &quot;t&quot;,				&amp;server_universe, 51 },
++	{ &quot;ldap-method&quot;, &quot;Nldap-methods.&quot;,		&amp;server_universe, 52 },
++	{ &quot;ldap-debug-file&quot;, &quot;t&quot;,			&amp;server_universe, 53 },
++#else
+ 	{ &quot;unknown-47&quot;, &quot;X&quot;,				&amp;server_universe, 47 },
+ 	{ &quot;unknown-48&quot;, &quot;X&quot;,				&amp;server_universe, 48 },
+ 	{ &quot;unknown-49&quot;, &quot;X&quot;,				&amp;server_universe, 49 },
+@@ -490,6 +499,7 @@
+ 	{ &quot;unknown-51&quot;, &quot;X&quot;,				&amp;server_universe, 51 },
+ 	{ &quot;unknown-52&quot;, &quot;X&quot;,				&amp;server_universe, 52 },
+ 	{ &quot;unknown-53&quot;, &quot;X&quot;,				&amp;server_universe, 53 },
++#endif
+ 	{ &quot;unknown-54&quot;, &quot;X&quot;,				&amp;server_universe, 54 },
+ 	{ &quot;unknown-55&quot;, &quot;X&quot;,				&amp;server_universe, 55 },
+ 	{ &quot;unknown-56&quot;, &quot;X&quot;,				&amp;server_universe, 56 },
+@@ -694,6 +704,20 @@
+ 	{ &quot;option-end&quot;, &quot;e&quot;,				&amp;server_universe, 255 },
+ };
+ 
++#if defined(LDAP_CONFIGURATION)
++struct enumeration_value ldap_values [] = {
++	{ &quot;static&quot;, LDAP_METHOD_STATIC },
++	{ &quot;dynamic&quot;, LDAP_METHOD_DYNAMIC },
++	{ (char *) 0, 0 }
++};
++
++struct enumeration ldap_methods = {
++	(struct enumeration *)0,
++	&quot;ldap-methods&quot;,
++	ldap_values
++};
++#endif
++
+ struct enumeration_value ddns_styles_values [] = {
+ 	{ &quot;none&quot;, 0 },
+ 	{ &quot;ad-hoc&quot;, 1 },
+diff -Naur dhcp-3.0.3/site.conf dhcp-3.0.3-ldap/site.conf
+--- dhcp-3.0.3/site.conf	1999-07-07 11:20:10.000000000 -0400
++++ dhcp-3.0.3-ldap/site.conf	2005-07-25 08:14:44.000000000 -0400
+@@ -1,2 +1,3 @@
+ # Put local site configuration stuff here to override the default
+ # settings in Makefile.conf
++#COPTS = -DDEBUG_LDAP -DDEBUG_CLASS_MATCHING -Wall -O -Wno-unused

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.3-mis_host.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.3-mis_host.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.3-mis_host.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,21 @@
+--- server/dhcp.c.orig	2005-08-10 00:11:04.832158056 +0200
++++ server/dhcp.c	2005-08-10 00:13:22.857175064 +0200
+@@ -1736,11 +1736,17 @@
+ 	}
+ 
+ 	/* Try to find a matching host declaration for this lease.
++	 * If this is an offer, then verify our host for the lease is the
++	 * right one for the host we're offering to...by dereffing and
++	 * re-finding.
+ 	 */
+-	if (!host) {
++	if ((offer == DHCPOFFER) ||(!lease -&gt; host)) {
+ 		struct host_decl *hp = (struct host_decl *)0;
+ 		struct host_decl *h;
+ 
++		if (lease -&gt; host)
++			host_dereference (&amp;lease -&gt; host, MDL);
++
+ 		/* Try to find a host_decl that matches the client
+ 		   identifier or hardware address on the packet, and
+ 		   has no fixed IP address.   If there is one, hang

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-Makefile.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-Makefile.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-Makefile.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,148 @@
+--- dhcp-3.0.5/client/Makefile.dist.Makefile	2004-06-10 13:59:11.000000000 -0400
++++ dhcp-3.0.5/client/Makefile.dist	2006-11-10 11:10:13.000000000 -0500
+@@ -128,6 +128,6 @@
+ 
+ 
+ dhclient:	$(OBJS) $(DHCPLIB)
+-	$(CC) $(LFLAGS) -o $(PROG) $(OBJS) $(DHCPLIB) $(LIBS)
++	$(CC) $(LFLAGS) -pie $(RPM_OPT_FLAGS) -Wl,-z,relro,-z,now,-z,noexecstack,-z,nodlopen -o $(PROG) $(OBJS) $(DHCPLIB) $(LIBS)
+ 
+ # Dependencies (semi-automatically-generated)
+--- dhcp-3.0.5/dhcpctl/Makefile.dist.Makefile	2005-03-03 11:55:23.000000000 -0500
++++ dhcp-3.0.5/dhcpctl/Makefile.dist	2006-11-10 11:11:16.000000000 -0500
+@@ -37,10 +37,10 @@
+ all:	libdhcpctl.a omshell cltest $(CATMANPAGES)
+ 
+ omshell:	omshell.o $(DHCPCTLLIBS)
+-	$(CC) $(DEBUG) $(LFLAGS) -o omshell omshell.o $(DHCPCTLLIBS) $(LIBS)
++	$(CC) $(DEBUG) $(LFLAGS) -pie $(RPM_OPT_FLAGS) -Wl,-z,relro,-z,now,-z,noexecstack,-z,nodlopen -o omshell omshell.o $(DHCPCTLLIBS) $(LIBS)
+ 
+ cltest:	cltest.o $(DHCPCTLLIBS)
+-	$(CC) $(DEBUG) $(LFLAGS) -o cltest cltest.o $(DHCPCTLLIBS) $(LIBS)
++	$(CC) $(DEBUG) $(LFLAGS) -pie $(RPM_OPT_FLAGS) -Wl,-z,relro,-z,now,-z,noexecstack,-z,nodlopen -o cltest cltest.o $(DHCPCTLLIBS) $(LIBS)
+ 
+ libdhcpctl.a:	$(OBJ)
+ 	rm -f libdhcpctl.a
+--- dhcp-3.0.5/dst/Makefile.dist.Makefile	2004-06-10 13:59:28.000000000 -0400
++++ dhcp-3.0.5/dst/Makefile.dist	2006-11-10 11:11:42.000000000 -0500
+@@ -30,7 +30,12 @@
+ 
+ all:	libdst.a
+ 
+-install:
++install: all
++	if [ ! -d $(DESTDIR)$(LIBDIR) ]; then \
++		mkdir $(DESTDIR)$(LIBDIR); chmod 755 $(DESTDIR)$(LIBDIR); \
++	fi
++	$(INSTALL) libdst.a $(DESTDIR)$(LIBDIR)
++	$(CHMOD) 644 $(DESTDIR)$(LIBDIR)/libdst.a
+ 
+ libdst.a:	$(OBJ)
+ 	rm -f dst.a
+--- dhcp-3.0.5/minires/Makefile.dist.Makefile	2004-06-10 13:59:40.000000000 -0400
++++ dhcp-3.0.5/minires/Makefile.dist	2006-11-10 11:14:00.000000000 -0500
+@@ -21,9 +21,6 @@
+ #   &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">info at isc.org</A>&gt;
+ #   <A HREF="http://www.isc.org/">http://www.isc.org/</A>
+ 
+-CATMANPAGES = dhcpctl.cat3
+-SEDMANPAGES = dhcpctl.man3
+-MAN    = dhcpctl.3
+ SRC    = res_mkupdate.c res_init.c res_update.c res_send.c res_comp.c \
+ 	 res_sendsigned.c res_findzonecut.c res_query.c res_mkquery.c \
+ 	 ns_date.c ns_parse.c ns_sign.c ns_name.c ns_samedomain.c ns_verify.c
+@@ -50,24 +47,17 @@
+ 	-rm -f $(OBJ) libres.a
+ 
+ realclean: clean
+-	-rm -f *~ $(CATMANPAGES) $(SEDMANPAGES)
++	-rm -f *~
+ 
+ distclean: realclean
+ 	-rm -f Makefile
+ 
+ links:
+-	@for foo in $(SRC) $(MAN) $(HDRS); do \
++	@for foo in $(SRC) $(HDRS); do \
+ 	  if [ ! -b $$foo ]; then \
+ 	    rm -f $$foo; \
+ 	  fi; \
+ 	  ln -s $(TOP)/minires/$$foo $$foo; \
+ 	done
+ 
+-dhcpctl.cat3:	dhcpctl.man3
+-	nroff -man dhcpctl.man3 &gt;dhcpctl.cat3
+-
+-dhcpctl.man3:	dhcpctl.3
+-	sed -e &quot;s#ETCDIR#$(ETC)#g&quot; -e &quot;s#DBDIR#$(VARDB)#g&quot; \
+-		-e &quot;s#RUNDIR#$(VARRUN)#g&quot; &lt; dhcpctl.3 &gt;dhcpctl.man3
+-
+ # Dependencies (semi-automatically-generated)
+--- dhcp-3.0.5/relay/Makefile.dist.Makefile	2004-06-10 13:59:50.000000000 -0400
++++ dhcp-3.0.5/relay/Makefile.dist	2006-11-10 11:13:30.000000000 -0500
+@@ -83,6 +83,6 @@
+ 		-e &quot;s#RUNDIR#$(VARRUN)#&quot; &lt; dhcrelay.8 &gt;dhcrelay.man8
+ 
+ dhcrelay:	dhcrelay.o $(DHCPLIB)
+-	$(CC) $(LFLAGS) -o $(PROG) dhcrelay.o $(DHCPLIB) $(LIBS)
++	$(CC) $(LFLAGS) -pie $(RPM_OPT_FLAGS) -Wl,-z,relro,-z,now,-z,nodlopen,-z,noexecstack -o $(PROG) dhcrelay.o $(DHCPLIB) $(LIBS)
+ 
+ # Dependencies (semi-automatically-generated)
+--- dhcp-3.0.5/server/Makefile.dist.Makefile	2004-06-10 13:59:50.000000000 -0400
++++ dhcp-3.0.5/server/Makefile.dist	2006-11-10 11:14:27.000000000 -0500
+@@ -103,6 +103,6 @@
+ 		-e &quot;s#RUNDIR#$(VARRUN)#g&quot; &lt; dhcpd.leases.5 &gt;dhcpd.leases.man5
+ 
+ dhcpd:	$(OBJS) $(COBJ) $(DHCPLIB)
+-	$(CC) $(LFLAGS) -o dhcpd $(OBJS) $(DHCPLIB) $(LIBS)
++	$(CC) $(LFLAGS) -pie $(RPM_OPT_FLAGS) -Wl,-z,relro,-z,now,-z,noexecstack,-z,nodlopen -o dhcpd $(OBJS) $(DHCPLIB) $(LIBS)
+ 
+ # Dependencies (semi-automatically-generated)
+--- dhcp-3.0.5/Makefile.Makefile	2004-06-10 13:59:10.000000000 -0400
++++ dhcp-3.0.5/Makefile	2006-11-10 11:09:32.000000000 -0500
+@@ -33,7 +33,7 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make all); \
++	   (cd work.$$sysname; $(MAKE) all); \
+ 	fi
+ 
+ install:
+@@ -41,7 +41,7 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make install); \
++	   (cd work.$$sysname; $(MAKE) install); \
+ 	fi
+ 
+ depend:
+@@ -49,7 +49,7 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make depend); \
++	   (cd work.$$sysname; $(MAKE) depend); \
+ 	fi
+ 
+ clean:
+@@ -81,6 +81,6 @@
+ 	 if [ ! -d work.$$sysname ]; then \
+ 	   echo No build directory for $$sysname - please run ./configure.; \
+ 	else \
+-	   (cd work.$$sysname; make links); \
++	   (cd work.$$sysname; $(MAKE) links); \
+ 	fi
+ 
+--- dhcp-3.0.5/Makefile.conf.Makefile	2005-06-16 15:39:35.000000000 -0400
++++ dhcp-3.0.5/Makefile.conf	2006-11-10 11:12:43.000000000 -0500
+@@ -49,7 +49,7 @@
+ DEBUG = -g
+ #WARNERR = -Werror
+ RANLIB = ranlib
+-MKDEP = mkdep
++MKDEP = $(CC)
+ CLIENT_PATH = '&quot;PATH=/usr/ucb:/usr/bin:/usr/sbin:/bin:/sbin&quot;'
+ 
+ BINDLIB = ../minires/libres.a

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-client.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-client.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-client.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,1587 @@
+--- dhcp-3.0.5/client/scripts/linux.client	2002-11-14 20:09:09.000000000 -0500
++++ dhcp-3.0.5/client/scripts/linux	2006-11-29 10:52:47.000000000 -0500
+@@ -19,16 +19,54 @@
+ # address if it is not supplied. This might be much more easily done
+ # by the dhclient C code, and passed on.
+ 
+-# 4. TIMEOUT not tested. ping has a flag I don't know, and I'm suspicious
+-# of the $1 in its args.
++if [ -n &quot;${dhc_dbus}&quot; ]; then
++   /bin/dbus-send \
++       --system \
++       --dest=com.redhat.dhcp \
++       --type=method_call \
++       /com/redhat/dhcp/$interface \
++       com.redhat.dhcp.set \
++       'string:'&quot;`env | /bin/egrep -v '^(PATH|SHLVL|_|PWD|dhc_dbus)\='`&quot;;
++       if (( ( dhc_dbus &amp; 31 ) == 31 )); then
++	   exit 0;
++       fi;
++fi;
++
++function save_previous() {
++  if [ -e $1 ]; then
++    /bin/mv $1 $1.predhclient
++  else
++    echo ''&gt; $1.predhclient 
++  fi
++}
+ 
+ make_resolv_conf() {
+-  if [ &quot;x$new_domain_name&quot; != x ] &amp;&amp; [ x&quot;$new_domain_name_servers&quot; != x ]; then
+-    echo search $new_domain_name &gt;/etc/resolv.conf
+-    chmod 644 /etc/resolv.conf
++  if [ &quot;${PEERDNS}&quot; == &quot;no&quot; ]; then  
++      return 
++  fi
++
++  if [ x$reason == xRENEW ] &amp;&amp;
++     [ &quot;$new_domain_name&quot; == &quot;$old_domain_name&quot; ] &amp;&amp; 
++     [ &quot;$new_domain_name_servers&quot; == &quot;$old_domain_name_servers&quot; ]; then
++      return;
++  fi
++
++  if [ -n &quot;$new_domain_name&quot; ] || [ -n &quot;$new_domain_name_servers&quot; ]; then
++    cp -fp /etc/resolv.conf /etc/resolv.conf.predhclient
++    rscf=`mktemp /tmp/XXXXXX`;
++    echo '; generated by /sbin/dhclient-script' &gt; $rscf
++    if [ -n &quot;$SEARCH&quot; ]; then
++ 	echo search $SEARCH &gt;&gt; $rscf
++    else
++	if [ -n &quot;$new_domain_name&quot; ]; then
++ 	    echo search $new_domain_name &gt;&gt; $rscf
++        fi
++    fi
+     for nameserver in $new_domain_name_servers; do
+-      echo nameserver $nameserver &gt;&gt;/etc/resolv.conf
++      echo nameserver $nameserver &gt;&gt; $rscf
+     done
++    change_resolv_conf $rscf
++    rm -f $rscf
+   fi
+ }
+ 
+@@ -53,12 +91,344 @@
+   fi
+ fi
+ 
++# Import Red Hat Linux configuration
++cd /etc/sysconfig/network-scripts;
++. /etc/sysconfig/network-scripts/network-functions
++. /etc/rc.d/init.d/functions
++
++[ -f ../network ] &amp;&amp; . ../network
++[ -f ../networking/network ] &amp;&amp; . ../networking/network
++
++CONFIG=$interface
++
++need_config ${CONFIG}
++
++if [ -f &quot;${CONFIG}&quot; ]; then 
++    source_config
++else
++    echo $&quot;$0: configuration for $interface not found. Continuing with defaults.&quot; &gt;&amp;2
++fi
++
++source_config
++
+ release=`uname -r`
+-release=`expr $release : '\(.*\)\..*'`
+-relminor=`echo $release |sed -e 's/[0-9]*\.\([0-9][0-9]*\)\(\..*\)*$/\1/'`
+-relmajor=`echo $release |sed -e 's/\([0-9][0-9]*\)\..*$/\1/'`
++relmajor=`echo $release |/bin/cut -f1 -d'.'`
++relminor=`echo $release |/bin/cut -f2 -d'.'`
++
++# simple IP arithmetic functions:
++
++function quad2num()
++{
++    if [ $# -eq 4 ]; then
++       let n=&quot;$1&lt;&lt;24|$2&lt;&lt;16|$3&lt;&lt;8|$4&quot;
++       echo $n;
++       return 0;
++    fi
++    echo '0';
++    return 1;
++}
++
++function ip2num()
++{
++    IFS='.' quad2num $1;
++}
++
++function num2ip()
++{
++    let n=&quot;$1&quot;;
++    let o1='(n&gt;&gt;24)&amp;0xff';
++    let o2='(n&gt;&gt;16)&amp;0xff';
++    let o3='(n&gt;&gt;8)&amp;0xff';
++    let o4='n &amp; 0xff';
++    echo $o1.$o2.$o3.$o4;
++}
++
++function mask()
++{   
++    ip=$1
++    m=$2
++    let ip=`IFS='.' ip2num $ip`;
++    let m=`IFS='.' ip2num $m`;
++    let n='ip&amp;m';
++    num2ip $n;
++}
++
++function mask_bits()
++{
++    ip=$1
++    let ip=`IFS='.' ip2num $ip`;
++    let bits=0
++    for ((bit=1; '((ip&amp;bit)==0) &amp;&amp; (bits &lt; 32)'; 'bit&lt;&lt;=1')) do
++        let bits+=1
++    done
++    let n_bits=32-bits
++    echo $n_bits
++}
++
++function class_bits()
++{
++    let ip=`IFS='.' ip2num $1`;
++    let bits=32
++    let mask='255';
++    for ((i=0; i &lt;= 3; i++, 'mask&lt;&lt;=8')); do
++	let v='ip&amp;mask';
++	if [ &quot;$v&quot; -eq 0 ] ; then
++	    let bits-=8;
++        else
++            break;
++	fi;
++    done;
++    echo $bits;
++}
++
++function routerReachable()
++{ # Handle silly DHCP servers that give us a router not on our subnet:    
++    router=$1
++    routerSubnet=`mask $router $new_subnet_mask`
++    mySubnet=`mask $new_ip_address $new_subnet_mask`
++    unreachable=0
++    if [ &quot;$routerSubnet&quot; != &quot;$mySubnet&quot; ]; then
++	unreachable=1
++	if /sbin/arping -f -q -I $interface -w2 $router; then
++	    /sbin/ip route add ${router}/32 dev $interface
++	    if [ $? -eq 0 ]; then
++		unreachable=0
++	    else
++		/usr/bin/logger -p local7.notice -t &quot;NET&quot;  &quot;dhclient: failed to create host route for unreachable router $router not on subnet $mySubnet&quot;;
++	    fi
++	else
++	    unreachable=1
++	    if [ -x /usr/bin/logger ]; then
++		/usr/bin/logger -p local7.notice -t &quot;NET&quot;  &quot;dhclient: DHCP router $router is unreachable on DHCP subnet $mySubnet router subnet $routerSubnet&quot;;
++	    fi;
++	fi;
++    fi;
++    return $unreachable;
++}
++
++function add_default_gateway()
++{
++    router=$1
++    metric=''
++    if [ $# -gt 1 ] &amp;&amp; [ &quot;$2&quot; -gt 0 ]; then 
++	metric=&quot;metric $2&quot;;
++    fi;    
++    if routerReachable $router ; then
++	/sbin/ip route replace default via $router dev $interface $metric;
++	if [ $? -ne 0 ]; then 
++	    /usr/bin/logger -p local7.notice -t &quot;NET&quot;  'dhclient: failed to create default route: '$router dev $interface $metric;
++	    return 1;
++	else
++	    return 0;
++	fi;
++    fi;
++    return 1;
++}
++
++function dhconfig()
++{
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++	if [ x$old_ip_address != x ] &amp;&amp; [ x$alias_ip_address != x ] &amp;&amp; \
++		[ x$alias_ip_address != x$old_ip_address ]; then
++         # Possible new alias. Remove old alias.
++	    ifconfig $interface:0- inet 0
++	fi
++
++	if [ x$old_ip_address != x ] &amp;&amp; [ x$old_ip_address != x$new_ip_address ]; then
++        # IP address changed. Bringing down the interface will delete all routes,
++        # and clear the ARP cache.
++	    ifconfig $interface inet 0 down
++	fi
++    fi
++    if [ x$reason = xBOUND ] || [ x$reason = xREBOOT ] ||
++       [ x$old_ip_address  != x$new_ip_address ] ||
++       [ x$old_subnet_mask != x$new_subnet_mask ] ||
++       [ x$new_network_number != x$new_network_number ] ||
++       [ x$old_broadcast_address != x$new_broadcast_address ] ||
++       [ &quot;x$old_routers&quot; != &quot;x$new_routers&quot; ] ||
++       [ x$old_interface_mtu != x$new_interface_mtu ] ; then
++	if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++	    ifconfig $interface inet $new_ip_address $new_subnet_arg \
++		$new_broadcast_arg
++	    if [ -n &quot;$new_interface_mtu&quot; ]; then
++		/sbin/ip link set $interface mtu $new_interface_mtu;
++	    fi;
++	    if [ -x /etc/dhclient-${interface}-up-hooks ]; then
++		. /etc/dhclient-${interface}-up-hooks;
++	    elif [ -x /etc/dhclient-up-hooks ]; then
++		. /etc/dhclient-up-hooks;
++	    fi;
++	fi;
++	
++	if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 4 ) != 4 )); then
++	    prefix_bits=`mask_bits $new_subnet_mask`
++            # Add a network route to the computed network address.
++	    if [ $relmajor -lt 2 ] || \
++		( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] ); then
++		/sbin/ip route replace ${new_network_number}/${prefix_bits} dev $interface
++		if [ $added_old_broadcast_route -eq 1 ]; then
++		   /sbin/ip route del default;
++		fi;
++	    fi;
++	    if [[  ( ( -z &quot;$GATEWAYDEV&quot; )  || ( &quot;$GATEWAYDEV&quot; = &quot;$interface&quot; ) ) &amp;&amp; ( ( -z &quot;$GATEWAY&quot; )  || ( ( -n &quot;$DHCLIENT_IGNORE_GATEWAY&quot; ) &amp;&amp; ( &quot;$DHCLIENT_IGNORE_GATEWAY&quot; = [Yy]* ) ) ) ]]; then
++		metric=${METRIC:-''};
++		let i=${METRIC:-0};
++		default_routers=()
++		for router in $new_routers; do
++		    added_router=0
++		    for r in ${default_routers[@]}; do
++			if [ &quot;$r&quot; == &quot;$router&quot; ]; then
++			    added_router=1;
++                        fi;
++		    done
++		    if [ -z &quot;$router&quot; ] || [ &quot;$added_router&quot; -eq 1 ] || [ `IFS=. ip2num $router` -le 0 ] || [[ ( &quot;$router&quot; = &quot;$new_broadcast_address&quot; ) &amp;&amp; ( &quot;$new_subnet_mask&quot; != &quot;255.255.255.255&quot; ) ]]; then
++			continue;
++		    fi;
++		    default_routers=(${default_routers[@]} $router)
++		    add_default_gateway $router $metric;		    
++		    let i=i+1;
++		    metric=$i; 
++		done
++	    elif [[ ( ( -z &quot;$GATEWAYDEV&quot; ) || ( &quot;$GATEWAYDEV&quot; = &quot;$interface&quot; ) ) &amp;&amp; ( -n &quot;$GATEWAY&quot; ) ]]; then
++		routerSubnet=`mask $GATEWAY $new_subnet_mask`
++		mySubnet=`mask $new_ip_address $new_subnet_mask`
++		if [ &quot;$routerSubnet&quot; = &quot;$mySubnet&quot; ]; then
++		    /sbin/ip route replace default via $GATEWAY dev $interface 
++		fi;
++	    fi;
++            # static routes
++	    if [ &quot;x$new_static_routes&quot; != x ]; then
++		IFS=', 	' static_routes=($new_static_routes)
++		route_targets=()
++		for((i=0; i&lt;${#static_routes[@]}; i+=2)); do
++		    target=${static_routes[$i]}
++		    gateway=${static_routes[$i+1]}
++		    metric=''
++		    for t in ${route_targets[@]}; do
++			if [ $t == $target ]; then
++			    if [ -z &quot;$metric&quot; ]; then
++				metric=1;
++			    else
++				((metric=metric+1));
++			    fi;
++			fi;
++		    done;
++		    if [ -n &quot;$metric&quot; ]; then
++			metric=&quot;metric $metric&quot;;
++		    fi;		    
++		    if routerReachable $gateway; then
++			/sbin/ip route replace ${target}/`class_bits $target` via ${gateway} dev $interface ${metric}
++			if [ $? -ne 0 ]; then
++			   /usr/bin/logger -p local7.notice -t 'NET' 'dhclient: failed to create static route:' ${target}/`class_bits $target` via ${gateway} dev $interface ${metric};			
++			else			    
++ 			   route_targets=(${route_targets[@]} $target);
++			fi;
++		    fi;
++		done
++	    fi
++	fi
++    fi
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++	if [ x$new_ip_address != x$alias_ip_address ] &amp;&amp; [ x$alias_ip_address != x ];
++	    then
++	    ifconfig $interface:0- inet 0
++	    ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
++	    /sbin/ip route replace ${alias_ip_address}/32 dev $interface:0
++	fi
++    fi
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 1 ) != 1 )); then
++	make_resolv_conf
+ 
+-if [ x$new_broadcast_address != x ]; then
++	if [ -n &quot;$new_host_name&quot; ] &amp;&amp; need_hostname; then
++	    hostname $new_host_name
++	fi
++    fi;
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 8 ) != 8 )); then
++	if [ &quot;${PEERNIS}&quot; = no ]; then
++	    :
++	elif [ -n &quot;$new_nis_domain&quot; ]; then
++	    domainname &quot;$new_nis_domain&quot;
++	    save_previous /etc/yp.conf
++	    let contents=0
++	    echo '# generated by /sbin/dhclient-script' &gt; /etc/yp.conf
++	    if [ -n &quot;$new_nis_servers&quot; ]; then
++		for I in $new_nis_servers; do
++		    echo &quot;domain $new_nis_domain server $I&quot; &gt;&gt; /etc/yp.conf
++		    let contents=contents+1
++		done
++	    else
++		echo &quot;domain $new_nis_domain broadcast&quot; &gt;&gt; /etc/yp.conf
++		let contents=contents+1
++	    fi
++	    level=`/sbin/runlevel`
++	    level=${level##*\ }
++	    if [ &quot;$level&quot; = &quot;unknown&quot; ]; then
++		level=1;
++	    fi
++	    if [ $contents -gt 0 ] &amp;&amp; [[ &quot;$level&quot; = [0-6] ]] &amp;&amp; /sbin/chkconfig --level=$level ypbind &gt;/dev/null 2&gt;&amp;1 &amp;&amp; [ -r /var/run/ypbind.pid ] &amp;&amp; yppid=`cat /var/run/ypbind.pid` &amp;&amp; [ -d /proc/${yppid} ] &amp;&amp; [ &quot;`if [ -x /sbin/busybox ]; then /sbin/busybox readlink /proc/${yppid}/exe; else echo /sbin/ypbind; fi`&quot; = &quot;/sbin/ypbind&quot; ]; then
++	       kill -HUP $yppid;
++	    fi
++	elif [ -n &quot;$new_nis_servers&quot; ]; then
++	    save_previous /etc/yp.conf
++	    echo '# generated by /sbin/dhclient-script' &gt; /etc/yp.conf
++	    let contents=0
++	    for I in $new_nis_servers; do
++		echo &quot;ypserver $I&quot; &gt;&gt; /etc/yp.conf
++		let contents=contents+1
++	    done
++	    level=`/sbin/runlevel`
++	    level=${level##*\ }
++	    if [ &quot;$level&quot; = &quot;unknown&quot; ]; then
++		level=1;
++	    fi
++	    if [ $contents -gt 0 ] &amp;&amp; [[ &quot;$level&quot; = [0-6] ]] &amp;&amp; /sbin/chkconfig --level=$level ypbind &gt;/dev/null 2&gt;&amp;1 &amp;&amp; [ -r /var/run/ypbind.pid ] &amp;&amp; yppid=`cat /var/run/ypbind.pid` &amp;&amp; [ -d /proc/${yppid} ] &amp;&amp; [ &quot;`if [ -x /sbin/busybox ]; then /sbin/busybox readlink /proc/${yppid}/exe; else echo /sbin/ypbind; fi`&quot; = &quot;/sbin/ypbind&quot; ] ; then
++	       kill -HUP $yppid;
++	    fi
++	fi
++    fi
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 16 ) != 16 )); then
++	if [ -n &quot;$DHCP_TIME_OFFSET_SETS_TIMEZONE&quot; ] &amp;&amp; [[ &quot;$DHCP_TIME_OFFSET_SETS_TIMEZONE&quot; = [yY1]* ]]; then
++	    if [ -n &quot;$new_time_offset&quot; ]; then
++	    #   DHCP option &quot;time-offset&quot; is requested by default and should be handled.
++	    #   The geographical zone abbreviation cannot be determined from the GMT offset,
++	    #   but the $ZONEINFO/Etc/GMT$offset file can be used - note: this disables DST.
++		((z=new_time_offset/3600));
++		((hoursWest=`printf '%+d' $z`))
++		if (( $hoursWest &lt; 0 )); then
++		   # tzdata treats negative 'hours west' as positive 'gmtoff' !
++		   ((hoursWest*=-1));
++		fi
++		tzfile=/usr/share/zoneinfo/Etc/GMT`printf '%+d' $hoursWest`;
++		if [ -e $tzfile ]; then
++		    /bin/mv -f /etc/localtime /etc/localtime.predhclient;
++		    /bin/cp -fp $tzfile /etc/localtime;
++		    /bin/touch /etc/localtime;
++		fi;
++	    fi;
++	fi;
++	if [ &quot;${PEERNTP}&quot; = no ]; then
++	    :
++	elif [ -n &quot;$new_ntp_servers&quot; ] &amp;&amp; [ -e /etc/ntp.conf ]; then
++	    save_previous /etc/ntp.conf
++	    /bin/egrep -v '(^[\ \	]*(server|fudge))|(generated by /sbin/dhclient-script)'&lt; /etc/ntp.conf.predhclient &gt; /etc/ntp.conf
++	    echo '# servers generated by /sbin/dhclient-script' &gt;&gt; /etc/ntp.conf
++	    localClocks=(`/bin/egrep '^[\ \	]*server[\ \	]+127\.127' /etc/ntp.conf.predhclient | while read s addr rest; do echo $addr; done`)      
++	    localClockFudge=&quot;`/bin/egrep '^[\ \	]*fudge[\ \	]+127\.127' /etc/ntp.conf.predhclient`&quot;;
++	    for s in $new_ntp_servers ${localClocks[@]};
++	      do
++	      echo 'server '$s &gt;&gt; /etc/ntp.conf;
++	    done
++	    echo &quot;$localClockFudge&quot; &gt;&gt; /etc/ntp.conf;
++	    if [ -x /usr/bin/diff ] &amp;&amp; /usr/bin/diff -q /etc/ntp.conf /etc/ntp.conf.predhclient &gt;/dev/null 2&gt;&amp;1; then
++		: ;
++	    else
++		/sbin/service ntpd condrestart &gt;/dev/null 2&gt;&amp;1
++	    fi;
++	fi
++    fi;
++}
++
++if [ x$new_broadcast_address != x ] &amp;&amp; [ x$new_subnet_mask != x ] &amp;&amp; [ &quot;$new_subnet_mask&quot; != &quot;255.255.255.255&quot; ]; then
+   new_broadcast_arg=&quot;broadcast $new_broadcast_address&quot;
+ fi
+ if [ x$old_broadcast_address != x ]; then
+@@ -79,79 +449,85 @@
+   exit_with_hooks 0
+ fi
+ 
++added_old_broadcast_route=0;
+ if [ x$reason = xPREINIT ]; then
+-  if [ x$alias_ip_address != x ]; then
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++	if [ x$alias_ip_address != x ]; then
+     # Bring down alias interface. Its routes will disappear too.
+-    ifconfig $interface:0- inet 0
+-  fi
+-  if [ $relmajor -lt 2 ] || ( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] )
+-   then
+-    ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
++	    ifconfig $interface:0- inet 0
++	fi
++	if [ x$keep_old_ip = xyes ]; then
++	    ifconfig $interface up
++	elif [ $relmajor -lt 2 ] || ( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] )   then
++	    ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
+ 		broadcast 255.255.255.255 up
+     # Add route to make broadcast work. Do not omit netmask.
+-    route add default dev $interface netmask 0.0.0.0
+-  else
+-    ifconfig $interface 0 up
+-  fi
++	    /sbin/ip route replace default dev $interface &amp;&amp; added_old_broadcast_route=1;
++	else
++	    ifconfig $interface 0 up
++	fi     
+ 
+   # We need to give the kernel some time to get the interface up.
+-  sleep 1
+-
+-  exit_with_hooks 0
++  #	sleep 1
++  # I don't think this is necessary with modern kernels - no problems found during testing -
++  # JVD, 2005-06-17
++	# but just in case:
++	if [ -n &quot;$DHCLIENT_DELAY&quot; ] &amp;&amp; [ &quot;$DHCLIENT_DELAY&quot; -gt 0 ] ; then
++	    sleep $DHCLIENT_DELAY;
++	fi;
++	exit_with_hooks 0
++    fi;
+ fi
+ 
+ if [ x$reason = xARPCHECK ] || [ x$reason = xARPSEND ]; then
+-  exit_with_hooks 0
++    if [ -z &quot;$new_ip_address&quot; ] || [ -z &quot;$interface&quot; ] ||  /sbin/arping -q -f -c 2 -w 3 -D -I ${interface} ${new_ip_address}; then
++	exit_with_hooks 0
++    else
++	exit_with_hooks 1
++    fi;
+ fi
+   
+ if [ x$reason = xBOUND ] || [ x$reason = xRENEW ] || \
+-   [ x$reason = xREBIND ] || [ x$reason = xREBOOT ]; then
+-  current_hostname=`hostname`
+-  if [ x$current_hostname = x ] || \
+-     [ x$current_hostname = x$old_host_name ]; then
+-    if [ x$current_hostname = x ] || \
+-       [ x$new_host_name != x$old_host_name ]; then
+-      hostname $new_host_name
+-    fi
+-  fi
+-    
+-  if [ x$old_ip_address != x ] &amp;&amp; [ x$alias_ip_address != x ] &amp;&amp; \
+-		[ x$alias_ip_address != x$old_ip_address ]; then
+-    # Possible new alias. Remove old alias.
+-    ifconfig $interface:0- inet 0
+-  fi
+-  if [ x$old_ip_address != x ] &amp;&amp; [ x$old_ip_address != x$new_ip_address ]; then
+-    # IP address changed. Bringing down the interface will delete all routes,
+-    # and clear the ARP cache.
+-    ifconfig $interface inet 0 down
+-
+-  fi
+-  if [ x$old_ip_address = x ] || [ x$old_ip_address != x$new_ip_address ] || \
+-     [ x$reason = xBOUND ] || [ x$reason = xREBOOT ]; then
+-
+-    ifconfig $interface inet $new_ip_address $new_subnet_arg \
+-							$new_broadcast_arg
+-    # Add a network route to the computed network address.
+-    if [ $relmajor -lt 2 ] || \
+-		( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] ); then
+-      route add -net $new_network_number $new_subnet_arg dev $interface
+-    fi
+-    for router in $new_routers; do
+-      route add default gw $router
+-    done
+-  fi
+-  if [ x$new_ip_address != x$alias_ip_address ] &amp;&amp; [ x$alias_ip_address != x ];
+-   then
+-    ifconfig $interface:0- inet 0
+-    ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
+-    route add -host $alias_ip_address $interface:0
+-  fi
+-  make_resolv_conf
+-  exit_with_hooks 0
++   [ x$reason = xREBIND ] || [ x$reason = xREBOOT ]; then    
++    dhconfig ;
++    exit_with_hooks 0
+ fi
+ 
+ if [ x$reason = xEXPIRE ] || [ x$reason = xFAIL ] || [ x$reason = xRELEASE ] \
+    || [ x$reason = xSTOP ]; then
++  if [ -f /etc/resolv.conf.predhclient ]; then
++     change_resolv_conf /etc/resolv.conf.predhclient
++     rm -f /etc/resolv.conf.predhclient
++  fi
++  if [ -n &quot;$DHCP_TIME_OFFSET_SETS_TIMEZONE&quot; ] &amp;&amp; [[ &quot;$DHCP_TIME_OFFSET_SETS_TIMEZONE&quot; = [yY1]* ]]; then
++      if [ -e /etc/localtime.predhclient ]; then
++	  /bin/rm -f /etc/localtime
++	  /bin/mv -f /etc/localtime.predhclient /etc/localtime;
++	  /bin/touch /etc/localtime;
++      fi;
++  fi;
++  if [ -f /etc/ntp.conf.predhclient ]; then
++     /bin/rm -f /etc/ntp.conf
++     /bin/mv -f /etc/ntp.conf.predhclient /etc/ntp.conf
++     service ntpd condrestart &gt;/dev/null 2&gt;&amp;1 
++  fi
++  if [ -f /etc/yp.conf.predhclient ]; then
++     /bin/rm -f /etc/yp.conf
++     /bin/mv -f /etc/yp.conf.predhclient /etc/yp.conf
++     level=`/sbin/runlevel`
++     level=${level##*\ }
++     if [ &quot;$level&quot; = &quot;unknown&quot; ]; then
++	 level=1;
++     fi
++     if [[ &quot;$level&quot; = [0-6] ]] &amp;&amp; /sbin/chkconfig --level=$level ypbind &gt;/dev/null 2&gt;&amp;1 &amp;&amp; [ -r /var/run/ypbind.pid ] &amp;&amp; yppid=`cat /var/run/ypbind.pid` &amp;&amp; [ -d /proc/${yppid} ] &amp;&amp; [ &quot;`if [ -x /sbin/busybox ]; then /sbin/busybox readlink /proc/${yppid}/exe; else echo /sbin/ypbind; fi`&quot; = &quot;/sbin/ypbind&quot; ] ; then
++	 kill -HUP $yppid;
++     fi
++  fi 
++  if [ -x /etc/dhclient-${interface}-down-hooks ]; then
++      . /etc/dhclient-${interface}-down-hooks;
++  elif [ -x /etc/dhclient-down-hooks ]; then
++      . /etc/dhclient-down-hooks;
++  fi;
+   if [ x$alias_ip_address != x ]; then
+     # Turn off alias interface.
+     ifconfig $interface:0- inet 0
+@@ -162,37 +538,29 @@
+   fi
+   if [ x$alias_ip_address != x ]; then
+     ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
+-    route add -host $alias_ip_address $interface:0
++    /sbin/ip route replace ${alias_ip_address}/32 $interface:0
+   fi
+   exit_with_hooks 0
+ fi
+ 
+-if [ x$reason = xTIMEOUT ]; then
+-  if [ x$alias_ip_address != x ]; then
+-    ifconfig $interface:0- inet 0
+-  fi
+-  ifconfig $interface inet $new_ip_address $new_subnet_arg \
++if [ x$reason = xTIMEOUT ] &amp;&amp; [ &quot;x$new_routers&quot; != 'x' ]; then
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++	if [ x$alias_ip_address != x ]; then
++	    ifconfig $interface:0- inet 0
++	fi
++	ifconfig $interface inet $new_ip_address $new_subnet_arg \
+ 					$new_broadcast_arg
+-  set $new_routers
+-  ############## what is -w in ping?
+-  if ping -q -c 1 $1; then
+-    if [ x$new_ip_address != x$alias_ip_address ] &amp;&amp; \
+-			[ x$alias_ip_address != x ]; then
+-      ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
+-      route add -host $alias_ip_address dev $interface:0
+-    fi
+-    if [ $relmajor -lt 2 ] || \
+-		( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] ); then
+-      route add -net $new_network_number
++    fi;
++    set $new_routers
++    if ping -q -c 1 -w 10 -I $interface $1; then
++	dhconfig ;
++	exit_with_hooks 0
+     fi
+-    for router in $new_routers; do
+-      route add default gw $router
+-    done
+-    make_resolv_conf
+-    exit_with_hooks 0
+-  fi
+-  ifconfig $interface inet 0 down
++    if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++	ifconfig $interface inet 0 down
++    fi;
++    exit_with_hooks 1
++elif [ x$reason = xTIMEOUT ]; then
+   exit_with_hooks 1
+ fi
+-
+ exit_with_hooks 0
+--- dhcp-3.0.5/client/clparse.c.client	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/client/clparse.c	2006-11-29 10:52:26.000000000 -0500
+@@ -51,6 +51,9 @@
+ 	DHO_DOMAIN_NAME,
+ 	DHO_DOMAIN_NAME_SERVERS,
+ 	DHO_HOST_NAME,
++	DHO_NIS_DOMAIN,
++	DHO_NIS_SERVERS,
++	DHO_NTP_SERVERS,
+ 	0
+ };
+ 
+@@ -84,6 +87,7 @@
+ 	top_level_config.requested_options = default_requested_options;
+ 	top_level_config.omapi_port = -1;
+ 	top_level_config.do_forward_update = 1;
++	top_level_config.bootp_broadcast_always = 0;
+ 
+ 	group_allocate (&amp;top_level_config.on_receipt, MDL);
+ 	if (!top_level_config.on_receipt)
+@@ -230,7 +234,9 @@
+ 	interface-declaration |
+ 	LEASE client-lease-statement |
+ 	ALIAS client-lease-statement |
+-	KEY key-definition */
++	KEY key-definition 
++	BOOTP_BROADCAST_ALWAYS
++*/
+ 
+ void parse_client_statement (cfile, ip, config)
+ 	struct parse *cfile;
+@@ -554,6 +560,12 @@
+ 		parse_reject_statement (cfile, config);
+ 		return;
+ 
++	      case BOOTP_BROADCAST_ALWAYS:
++		token = next_token(&amp;val, (unsigned*)0, cfile);
++		config -&gt; bootp_broadcast_always = 1;
++		parse_semi (cfile);
++		return;
++		
+ 	      default:
+ 		lose = 0;
+ 		stmt = (struct executable_statement *)0;
+--- dhcp-3.0.5/client/dhclient-script.8.client	2005-09-28 15:17:08.000000000 -0400
++++ dhcp-3.0.5/client/dhclient-script.8	2006-11-29 10:52:26.000000000 -0500
+@@ -47,7 +47,7 @@
+ exit hooks provided (see HOOKS for details).   These hooks will allow the
+ user to override the default behaviour of the client in creating a
+ .B /etc/resolv.conf
+-file.
++file, and to handle DHCP options not handled by default. 
+ .PP
+ No standard client script exists for some operating systems, even though
+ the actual client may work, so a pioneering user may well need to create
+@@ -91,6 +91,27 @@
+ .B ETCDIR/dhclient-exit-hooks
+ script can modify the valid of exit_status to change the exit status
+ of dhclient-script.
++.PP
++Immediately after dhclient brings an interface UP with a new IP address,
++subnet mask, and routes, in the REBOOT/BOUND states, it will check for the
++existence of an executable
++.B ETCDIR/dhclient-up-hooks
++script, and source it if found. This script can handle DHCP options in
++the environment that are not handled by default. A per-interface 
++.B ETCDIR/dhclient-up-${IF}-hooks
++script will override the generic script and be sourced when interface
++$IF has been brought up.
++.PP
++Immediately before dhclient brings an interface DOWN, removing its IP 
++address, subnet mask, and routes, in the STOP/RELEASE  states, it will 
++check for the existence of an executable
++.B ETCDIR/dhclient-down-hooks
++script, and source it if found. This script can handle DHCP options in
++the environment that are not handled by default. A per-interface 
++.B ETCDIR/dhclient-down-${IF}-hooks
++script will override the generic script and be sourced when interface
++$IF is about to be brought down.
++
+ .SH OPERATION
+ When dhclient needs to invoke the client configuration script, it
+ defines a set of variables in the environment, and then invokes
+--- dhcp-3.0.5/client/dhclient.conf.5.client	2005-06-16 15:40:13.000000000 -0400
++++ dhcp-3.0.5/client/dhclient.conf.5	2006-11-29 10:52:26.000000000 -0500
+@@ -185,7 +185,8 @@
+ options.   Only the option names should be specified in the request
+ statement - not option parameters.   By default, the DHCP server
+ requests the subnet-mask, broadcast-address, time-offset, routers,
+-domain-name, domain-name-servers and host-name options. 
++domain-name, domain-name-servers, host-name, nis-domain, nis-servers,
++and ntp-servers options.
+ .PP
+ In some cases, it may be desirable to send no parameter request list
+ at all.   To do this, simply write the request statement but specify
+@@ -581,6 +582,18 @@
+ Whenever the client tries to renew the lease, it will use that same
+ media type.   The lease must expire before the client will go back to
+ cycling through media types.
++.PP
++ \fBbootp-broadcast-always;\fR
++.PP
++The 
++.B bootp-broadcast-always
++statement instructs dhclient to always set the bootp broadcast flag in
++request packets, so that servers will always broadcast replies.
++This is equivalent to supplying the dhclient -B argument, and has
++the same effect as specifying 'always-broadcast' in the server's dhcpd.conf.
++This option is provided as a Red Hat extension to enable dhclient to work
++on IBM zSeries z/OS Linux guests .
++.PP
+ .SH SAMPLE
+ The following configuration file is used on a laptop running NetBSD
+ 1.3.   The laptop has an IP alias of 192.5.5.213, and has one
+--- dhcp-3.0.5/client/dhclient.8.client	2006-11-29 10:52:26.000000000 -0500
++++ dhcp-3.0.5/client/dhclient.8	2006-11-29 10:52:26.000000000 -0500
+@@ -85,6 +85,28 @@
+ .B -x
+ ]
+ [
++.B -I
++.I dhcp-client-identifier
++]
++[
++.B -H
++.I host-name
++.R |
++.B -F fqdn.fqdn
++]
++[
++.B -V
++.I vendor-class-identifier
++]
++[
++.B -R
++.I request option list
++]
++[
++.B -T 
++.I timeout
++]
++[
+ .I if0
+ [
+ .I ...ifN
+@@ -273,6 +295,107 @@
+ -s dhclient-script environment, which would allow applications running
+ in that environment to handle options they do not know about in advance -
+ this is a Red Hat extension to support dhcdbd and NetworkManager.
++.PP
++The -I &lt;id&gt; argument allows you to specify the dhcp-client-identifier string, &lt;id&gt;,
++to be sent to the dhcp server on the command line. It is equivalent to the
++top level dhclient.conf statement:
++.br
++ \fBsend dhcp-client-identifier &quot;&lt;id&gt;&quot;;\fR
++.br
++The -I &lt;id&gt; command line option will override any top level dhclient.conf 
++ 'send dhcp-client-identifier' statement, but more specific per-interface
++ 'interface &quot;X&quot; { send dhcp-client-identifier...; }' statements in dhclient.conf
++will override the -I &lt;id&gt; command line option for interface &quot;X&quot;.
++This option is provided as a Red Hat extension to enable dhclient to work
++on IBM zSeries z/OS Linux guests .
++.PP
++The -B option instructs dhclient to set the bootp broadcast flag in request
++packets, so that servers will always broadcast replies . This is equivalent
++to specifying the 'bootp-broadcast-always' option in dhclient.conf, and has
++the same effect as specifying 'always-broadcast' in the server's dhcpd.conf.
++This option is provided as a Red Hat extension to enable dhclient to work
++on IBM zSeries z/OS Linux guests .
++.PP 
++The -H &lt;host-name&gt; option allows you to specify the DHCP host-name option
++to send to the server on the dhclient command line. It is equivalent to the
++top level dhclient.conf statement:
++.br
++\f send host-name &quot;&lt;host-name&gt;&quot;;\fR
++.br
++The -H &lt;host-name&gt; option  will override any top level dhclient.conf 
++ 'send host-name' statement, but more specific per-interface 
++ 'interface &quot;X&quot; { send host-name...;' statements in dhclient.conf
++will override the -H &lt;host-name&gt; command line option for interface &quot;X&quot;.
++The host-name option only specifies the client's host name prefix, to which
++the server will append the 'ddns-domainname' or 'domain-name' options, if any,
++to derive the fully qualified domain name of the client host.
++The -H &lt;host-name&gt; option cannot be used with the -F &lt;fqdn.fqdn&gt; option.
++Only one -H &lt;host-name&gt; option may be specified.
++The -H &lt;host-name&gt; option is provided as a Red Hat extension to simplify
++configuration of clients of DHCP servers that require the host-name option
++to be sent (eg. some modern cable modems), and for dynamic DNS updates (DDNS). 
++.PP
++The -F &lt;fqdn.fqdn&gt; option allows you to specify the DHCP fqdn.fqdn option
++to send to the server on the dhclient command line. It is equivalent to the
++top level dhclient.conf statement:
++.br
++\f send fqdn.fqdn &quot;&lt;domain-name&gt;&quot;;\fR
++.br
++The -F &lt;fqdn.fqdn&gt; option  will override any top level dhclient.conf 
++ 'send fqdn.fqdn' statement, but more specific per-interface 
++ 'interface &quot;X&quot; { send fqdn.fqdn...;' statements in dhclient.conf
++will override the -F &lt;fqdn.fqdn&gt; command line option for interface &quot;X&quot;.
++This option cannot be used with the -H &lt;host-name&gt; option.
++The DHCP fqdn.fqdn option must specify the complete domain name of the client
++host, which the server may use for dynamic DNS updates.
++Only one -F &lt;fqdn.fqdn&gt; option may be specified.
++The -F &lt;fqdn.fqdn&gt; option is provided as a Red Hat extension to simplify
++configuration of DDNS. 
++.PP
++The -T &lt;timeout&gt; option allows you to specify the time after which 
++the dhclient will decide that no DHCP servers can be contacted when
++no responses have been received. It is equivalent to the 
++.br
++\f timeout &lt;integer&gt;;\fR
++.br
++dhclient.conf statement, and will override any such statements in dhclient.conf.
++.br
++This option is provided as a Red Hat extension.
++.PP
++The -V &lt;vendor-class-identifier&gt; option allows you to specify the DHCP 
++vendor-class-identifier option to send to the server on the dhclient command line. 
++It is equivalent to the top level dhclient.conf statement:
++.br
++\f send vendor-class-identifier &quot;&lt;vendor-class-identifier&gt;&quot;;\fR
++.br
++The -V &lt;vendor-class-identifier&gt; option  will override any top level dhclient.conf 
++ 'send vendor-class-identifier' statement, but more specific per-interface 
++ 'interface &quot;X&quot; { send vendor-class-identifier...;' statements in dhclient.conf
++will override the -V &lt;vendor-class-identifier&gt; command line option for interface &quot;X&quot;.
++The -V &lt;vendor-class-identifier&gt; option is provided as a Red Hat extension to simplify
++configuration of clients of DHCP servers that require the vendor-class-identifier option
++to be sent.
++.PP
++The -R &lt;request option list&gt; option allows you to specify the list of options the
++client is to request from the server on the dhclient command line.
++The option list must be a single string, consisting of option names separated
++by at least one comma and optional space characters. The default option list
++is :
++.br
++    subnet-mask, broadcast-address, time-offset, routers, 
++.br
++    domain-name, domain-name-servers, host-name, nis-domain, 
++.br
++    nis-servers, ntp-servers
++.br
++You can specify a different list of options to request with the -R &lt;option list&gt; argument.
++This is equivalent to the dhclient.conf statement:
++.br
++\f    request &lt;option list&gt; ;\fR
++.br
++The -R argument is provided as a Red Hat extension to ISC dhclient to facilitate requesting
++a list of options from the server different to the default.
++.PP
+ .SH CONFIGURATION
+ The syntax of the dhclient.conf(5) file is discussed separately.
+ .SH OMAPI
+--- dhcp-3.0.5/client/dhclient.c.client	2006-11-29 10:52:26.000000000 -0500
++++ dhcp-3.0.5/client/dhclient.c	2006-11-29 10:52:26.000000000 -0500
+@@ -77,11 +77,18 @@
+ #ifdef EXTENDED_NEW_OPTION_INFO
+ int extended_option_environment = 0;
+ #endif
++int bootp_broadcast_always = 0;
+ 
+ static void usage PROTO ((void));
+ 
+ void do_release(struct client_state *);
+ 
++extern int log_isc_blurb;
++
++extern int asprintf(char **strp, const char *fmt, ...);
++
++extern u_int32_t default_requested_options[];
++
+ int main (argc, argv, envp)
+ 	int argc;
+ 	char **argv, **envp;
+@@ -104,6 +111,14 @@
+ 	int no_dhclient_pid = 0;
+ 	int no_dhclient_script = 0;
+ 	char *s;
++	char *dhcp_client_identifier_arg = 0L;
++	char *dhcp_host_name_arg = 0L;
++	char *dhcp_fqdn_arg = 0L;
++	char *dhcp_vendor_class_identifier_arg = 0L;
++	char *dhclient_request_options = 0L;
++	int timeout_arg = 0;
++	char *arg_conf = 0L;
++	int arg_conf_len=0;
+ 
+ 	/* Make sure we have stdin, stdout and stderr. */
+ 	i = open (&quot;/dev/null&quot;, O_RDWR);
+@@ -145,45 +160,60 @@
+ 			release_mode = 1;
+ 			no_daemon = 1;
+ 		} else if (!strcmp (argv [i], &quot;-p&quot;)) {
+-			if (++i == argc)
++			if (++i == argc) {
+ 				usage ();
++				return EXIT_FAILURE;
++			}
+ 			local_port = htons (atoi (argv [i]));
+ 			log_debug (&quot;binding to user-specified port %d&quot;,
+ 			       ntohs (local_port));
+ 		} else if (!strcmp (argv [i], &quot;-d&quot;)) {
+ 			no_daemon = 1;
+                 } else if (!strcmp (argv [i], &quot;-pf&quot;)) {
+-                        if (++i == argc)
++                        if (++i == argc) {
+                                 usage ();
++                                return EXIT_FAILURE;
++                        }
+                         path_dhclient_pid = argv [i];
+ 			no_dhclient_pid = 1;
+                 } else if (!strcmp (argv [i], &quot;-cf&quot;)) {
+-                        if (++i == argc)
++                        if (++i == argc) {
+                                 usage ();
++                                return EXIT_FAILURE;
++                        }
+                         path_dhclient_conf = argv [i];
+ 			no_dhclient_conf = 1;
+                 } else if (!strcmp (argv [i], &quot;-lf&quot;)) {
+-                        if (++i == argc)
++                        if (++i == argc) {
+                                 usage ();
++                                return EXIT_FAILURE;
++                        }
+                         path_dhclient_db = argv [i];
+ 			no_dhclient_db = 1;
+ 		} else if (!strcmp (argv [i], &quot;-sf&quot;)) {
+-			if (++i == argc)
++			if (++i == argc) {
+ 				usage ();
+-                        path_dhclient_script = argv [i];
++				return EXIT_FAILURE;
++			}
++            path_dhclient_script = argv [i];
+ 			no_dhclient_script = 1;
+ 		} else if (!strcmp (argv [i], &quot;-1&quot;)) {
+ 			onetry = 1;
+ 		} else if (!strcmp (argv [i], &quot;-q&quot;)) {
+ 			quiet = 1;
+ 			quiet_interface_discovery = 1;
++			log_isc_blurb = 0;      
+ 		} else if (!strcmp (argv [i], &quot;-s&quot;)) {
+-			if (++i == argc)
++			if (++i == argc) {
+ 				usage ();
++				return EXIT_FAILURE;
++			}
+ 			server = argv [i];
+ 		} else if (!strcmp (argv [i], &quot;-g&quot;)) {
+-			if (++i == argc)
++			if (++i == argc) {
+ 				usage ();
++				return EXIT_FAILURE;
++			}
+ 			relay = argv [i];
+ 		} else if (!strcmp (argv [i], &quot;-nw&quot;)) {
+ 			nowait = 1;
+@@ -195,8 +225,10 @@
+ 			persist = 1;
+ 		} else if (!strcmp (argv [i], &quot;-e&quot;)) {
+ 			struct string_list *tmp;
+-			if (++i == argc)
++			if (++i == argc) {
+ 				usage ();
++				return EXIT_FAILURE;
++			}
+ 			tmp = dmalloc (strlen (argv [i]) + sizeof *tmp, MDL);
+ 			if (!tmp)
+ 				log_fatal (&quot;No memory for %s&quot;, argv [i]);
+@@ -212,8 +244,91 @@
+ 			extended_option_environment = 1;
+ 			new_option_info_tree = GENERATE_NEW_OPTION_INFO;
+ #endif
++		} else if (!strcmp (argv [i], &quot;-I&quot;)) {
++			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
++				usage ();
++				return EXIT_FAILURE;
++			}
++
++			if (strlen(argv[i]) &gt;= DHCP_OPTION_LEN) {
++				log_error(&quot;-I option dhcp-client-identifier string \&quot;%s\&quot; is too long - maximum length is: %d&quot;,  argv[i], DHCP_OPTION_LEN-1);
++				exit(1);
++			}
++
++			dhcp_client_identifier_arg = argv[i];
++		} else if (!strcmp (argv [i], &quot;-B&quot;)) {
++			bootp_broadcast_always = 1;
++		} else if (!strcmp (argv [i], &quot;-H&quot;)) {
++			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
++				usage ();
++				return EXIT_FAILURE;
++			}
++
++			if (strlen(argv[i]) &gt;= DHCP_OPTION_LEN) {
++				log_error(&quot;-H option host-name string \&quot;%s\&quot; is too long - maximum length is: %d&quot;,  argv[i], DHCP_OPTION_LEN-1);
++				exit(1);
++			}
++
++			if (dhcp_host_name_arg != NULL) {
++				log_error(&quot;The -H &lt;host-name&gt; and -F &lt;fqdn&gt; arguments are mutually exclusive&quot;);
++				exit(1);
++			}
++
++			dhcp_host_name_arg = argv[i];
++		} else if (!strcmp (argv [i], &quot;-F&quot;)) {
++			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
++				usage ();
++				return EXIT_FAILURE;
++			}
++
++			if (strlen(argv[i]) &gt;= DHCP_OPTION_LEN) {
++				log_error(&quot;-F option fqdn.fqdn string \&quot;%s\&quot; is too long - maximum length is: %d&quot;,  argv[i], DHCP_OPTION_LEN-1);
++				exit(1);
++			}
++
++			if (dhcp_fqdn_arg != NULL) {
++				log_error(&quot;Only one -F &lt;fqdn&gt; argument can be specified&quot;);
++				exit(1);
++			}
++
++			if (dhcp_host_name_arg != NULL) {
++				log_error(&quot;The -F &lt;fqdn&gt; and -H &lt;host-name&gt; arguments are mutually exclusive&quot;);
++				exit(1);
++			}
++
++			dhcp_fqdn_arg = argv[i];
++		} else if (!strcmp (argv [i], &quot;-T&quot;)) {
++			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
++				usage ();
++				return EXIT_FAILURE;
++			}
++
++			if ((timeout_arg = atoi(argv[i])) &lt;= 0) {
++				log_error(&quot;-T timeout option must be &gt; 0 - bad value: %s&quot;,argv[i]);
++				exit(1);
++			}
++		} else if (!strcmp (argv [i], &quot;-V&quot;)) {
++			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
++				usage ();
++				return EXIT_FAILURE;
++			}
++
++			if (strlen(argv[i]) &gt;= DHCP_OPTION_LEN) {
++				log_error(&quot;-V option vendor-class-identifier string \&quot;%s\&quot; is too long - maximum length is: %d&quot;,  argv[i], DHCP_OPTION_LEN-1);
++				exit(1);
++			}
++
++			dhcp_vendor_class_identifier_arg = argv[i];
++		} else if (!strcmp (argv [i], &quot;-R&quot;)) {
++			if ((++i == argc) || (argv[i] == 0L) || (*(argv[i])=='\0')) {
++				usage ();
++				return EXIT_FAILURE;
++			}
++
++			dhclient_request_options=argv[i];
+  		} else if (argv [i][0] == '-') {
+  		    usage ();
++ 		    return EXIT_FAILURE;
+ 		} else {
+  		    struct interface_info *tmp = (struct interface_info *)0;
+ 		    status = interface_allocate (&amp;tmp, MDL);
+@@ -248,6 +363,7 @@
+ 		path_dhclient_script = s;
+ 	}
+ 
++	
+ 	/* first kill of any currently running client */
+ 	if (release_mode) {
+ 		FILE *pidfd;
+@@ -267,8 +383,94 @@
+ 				}
+ 			}
+ 			fclose(pidfd);
+-		}
+-	}
++		}else
++		{  /* handle release for interfaces requested with Red Hat /sbin/ifup  -
++                    * pidfile will be /var/run/dhclient-$interface.pid 
++		    */
++
++		    if ( (path_dhclient_pid == NULL) || (*path_dhclient_pid == '\0'))
++			path_dhclient_pid = &quot;/var/run/dhclient.pid&quot;;
++		    
++		    char *new_path_dhclient_pid;
++		    struct interface_info *ip;
++		    int pdp_len = strlen(path_dhclient_pid), pfx, dpfx;
++		    /* find append point: beginning of any trailing '.pid'
++		     * or '-$IF.pid' 
++		     */
++		    for (  pfx=pdp_len; 
++			   (pfx &gt;= 0) 
++			 &amp;&amp;(path_dhclient_pid[pfx] != '.')
++			 &amp;&amp;(path_dhclient_pid[pfx] != '/'); 
++			   pfx--
++			);
++		    if( pfx == -1 )
++			pfx = pdp_len;
++		    if (path_dhclient_pid[pfx] == '/')
++			pfx += 1;
++		    for (  dpfx=pfx; 
++			   (dpfx &gt;= 0)
++			&amp;&amp; (path_dhclient_pid[dpfx] != '-')
++			&amp;&amp; (path_dhclient_pid[dpfx] != '/');
++			   dpfx--
++                       );
++		    if ( ( dpfx &gt; -1 ) &amp;&amp; (path_dhclient_pid[dpfx] != '/') )
++			pfx = dpfx;					    
++		    for (ip = interfaces; ip; ip = ip -&gt; next) 
++		    {
++			if ( interfaces_requested 
++			   &amp;&amp;(ip -&gt; flags &amp; (INTERFACE_REQUESTED))
++			   &amp;&amp;(ip -&gt; name != 0L)  
++			   )
++			{
++			    int n_len = strlen(ip-&gt;name);
++
++			    new_path_dhclient_pid = (char*) malloc( pfx + n_len + 6 );
++			    strncpy( new_path_dhclient_pid, path_dhclient_pid, pfx );
++			    sprintf( new_path_dhclient_pid + pfx, &quot;-%s.pid&quot;, ip -&gt; name );
++
++			    if ((pidfd = fopen(new_path_dhclient_pid, &quot;r&quot;)) != NULL) {
++				e = fscanf(pidfd, &quot;%ld\n&quot;, &amp;temp);
++				oldpid = (pid_t)temp;
++
++				if (e != 0 &amp;&amp; e != EOF) {
++				    if (oldpid) {
++					if (kill(oldpid, SIGTERM) == 0)
++					    unlink(path_dhclient_pid);
++				    }
++				}
++				fclose(pidfd);
++			    }
++			    free(new_path_dhclient_pid);
++			
++			}
++		    }
++		}	          
++	}else
++	{
++	    FILE *pidfp=0L;
++	    long temp=0;
++	    pid_t dhcpid=0;
++	    int   dhc_running=0;
++	    char  procfn[256]=&quot;&quot;;
++	    
++	    if ((pidfp = fopen(path_dhclient_pid, &quot;r&quot;)) != NULL ) 	   
++	    {
++		 if( (fscanf(pidfp, &quot;%ld&quot;, &amp;temp)==1)
++		   &amp;&amp;( (dhcpid=(pid_t)temp) &gt; 0)
++		    )
++		 {
++		     snprintf(procfn,256,&quot;/proc/%u&quot;,dhcpid);
++		     dhc_running = ( access(procfn, F_OK) == 0 );		     
++		 }
++		 fclose(pidfp);
++	    }
++	    if( dhc_running )
++	    {
++		log_fatal(&quot;dhclient(%u) is already running - exiting. &quot;, dhcpid);
++		return(1);
++	    }	    
++	}	
++	write_client_pid_file();
+ 
+ 	if (!quiet) {
+ 		log_info (&quot;%s %s&quot;, message, DHCP_VERSION);
+@@ -348,6 +550,223 @@
+ 	/* Parse the dhclient.conf file. */
+ 	read_client_conf ();
+ 
++	/* Parse any extra -I / -H / -F / -T command line configuration arguments: */
++
++	if ( (dhcp_client_identifier_arg != 0L) &amp;&amp; (*dhcp_client_identifier_arg != '\0') )
++	{ 
++		arg_conf_len = asprintf(&amp;arg_conf,  &quot;send dhcp-client-identifier \&quot;%s\&quot;;&quot;,
++					dhcp_client_identifier_arg
++		                       );
++		if (( arg_conf == 0 ) || (arg_conf_len &lt;= 0))
++			log_fatal(&quot;Unable to send -I option dhcp-client-identifier&quot;);
++	}
++	
++	if ( ( dhcp_host_name_arg != 0L ) &amp;&amp; (*dhcp_host_name_arg != '\0') )
++	{
++		if( arg_conf == 0 )
++		{
++			arg_conf_len = asprintf(&amp;arg_conf,  &quot;send host-name \&quot;%s\&quot;;&quot;,
++						dhcp_host_name_arg
++				               );
++			if( ( arg_conf == 0 ) || (arg_conf_len &lt;= 0) )
++				log_fatal(&quot;Unable to send -H option host-name&quot;);
++		}else
++		{
++			char *last_arg_conf = arg_conf;
++			arg_conf = 0L;
++			arg_conf_len = asprintf( &amp;arg_conf, &quot;%s\nsend host-name \&quot;%s\&quot;;&quot;, 
++					         last_arg_conf,
++						 dhcp_host_name_arg
++				               );
++			if ((arg_conf == 0) || (arg_conf_len &lt;= 0))
++				log_fatal(&quot;Unable to send -H option host-name&quot;);				
++			free(last_arg_conf);
++		}
++	}
++
++	if ( ( dhcp_fqdn_arg != 0L ) &amp;&amp; (*dhcp_fqdn_arg != '\0') )
++	{
++		if( arg_conf == 0 )
++		{
++			arg_conf_len = asprintf(&amp;arg_conf,  &quot;send fqdn.fqdn \&quot;%s\&quot;;&quot;,
++					dhcp_fqdn_arg
++		                       );
++			if( ( arg_conf == 0 ) || (arg_conf_len &lt;= 0) )
++				log_fatal(&quot;Unable to send -F option fqdn.fqdn&quot;);
++		}else
++		{
++			char *last_arg_conf = arg_conf;
++			arg_conf = 0L;
++			arg_conf_len = asprintf( &amp;arg_conf, &quot;%s\nsend fqdn.fqdn \&quot;%s\&quot;;&quot;, 
++						 last_arg_conf,
++						 dhcp_fqdn_arg
++				               );
++			if ((arg_conf == 0)  || (arg_conf_len &lt;= 0))
++				log_fatal(&quot;Unable to send -F option fqdn.fqdn&quot;);				
++			free(last_arg_conf);
++		}
++	}
++
++	if( timeout_arg )
++	{
++		if( arg_conf == 0 )
++		{
++			arg_conf_len = asprintf(&amp;arg_conf,  &quot;timeout %d;&quot;,
++						timeout_arg
++		                               );
++			if( ( arg_conf == 0 ) || (arg_conf_len &lt;= 0) )
++				log_fatal(&quot;Unable to process -T timeout argument&quot;);
++		}else
++		{
++			char *last_arg_conf = arg_conf;
++			arg_conf = 0L;
++			arg_conf_len = asprintf( &amp;arg_conf, &quot;%s\ntimeout %d;&quot;, 
++						 last_arg_conf,
++						 timeout_arg
++				               );
++			if ((arg_conf == 0) || (arg_conf_len == 0))
++				log_fatal(&quot;Unable to process -T timeout argument&quot;);
++			free(last_arg_conf);
++		}
++	}
++
++	if (   ( dhcp_vendor_class_identifier_arg != 0L ) 
++	    &amp;&amp; (*dhcp_vendor_class_identifier_arg != '\0') 
++           )
++	{
++		if( arg_conf == 0 )
++		{
++			arg_conf_len = asprintf(&amp;arg_conf,  &quot;send vendor-class-identifier \&quot;%s\&quot;;&quot;,
++						dhcp_vendor_class_identifier_arg
++		                               );
++			if( ( arg_conf == 0 ) || (arg_conf_len &lt;= 0) )
++				log_fatal(&quot;Unable to send -V option vendor-class-identifier&quot;);
++		}else
++		{
++			char *last_arg_conf = arg_conf;
++			arg_conf = 0L;
++			arg_conf_len = asprintf( &amp;arg_conf, &quot;%s\nsend vendor-class-identifier \&quot;%s\&quot;;&quot;, 
++						 last_arg_conf,
++						 dhcp_vendor_class_identifier_arg
++				               );
++			if ((arg_conf == 0)  || (arg_conf_len &lt;= 0))
++				log_fatal(&quot;Unable to send -V option vendor-class-identifier&quot;);
++			free(last_arg_conf);
++		}
++	}
++
++	if ( dhclient_request_options != 0L )
++	{
++		if( arg_conf == 0 )
++		{
++			arg_conf_len = asprintf(&amp;arg_conf,  &quot;request %s;&quot;, dhclient_request_options);
++			if( ( arg_conf == 0 ) || (arg_conf_len &lt;= 0) )
++				log_fatal(&quot;Unable to parse -R &lt;request options list&gt; argument&quot;);
++		}else
++		{
++			char *last_arg_conf = arg_conf;
++			arg_conf = 0L;
++			arg_conf_len = asprintf( &amp;arg_conf, &quot;%s\nrequest %s;&quot;, 
++						 last_arg_conf,
++						 dhclient_request_options
++				               );
++			if ((arg_conf == 0)  || (arg_conf_len &lt;= 0))
++				log_fatal(&quot;Unable to parse -R &lt;request options list&gt; argument&quot;);
++			free(last_arg_conf);
++		}
++	}
++
++	if ( arg_conf )
++	{
++		if( arg_conf_len == 0 )
++			if( (arg_conf_len = strlen(arg_conf)) == 0 )
++                             /* huh ? cannot happen ! */
++				log_fatal(&quot;Unable to process -I/-H/-F/-T/-V/-R configuration arguments&quot;);
++		
++		/* parse the extra dhclient.conf configuration arguments
++		 * into top level config:
++		 */
++	      	struct parse *cfile = (struct parse *)0;
++		const char *val=0L;
++		int  token;
++		
++		status = new_parse (&amp;cfile, -1, arg_conf, arg_conf_len,
++				    &quot;extra dhclient -I/-H/-F/-T/-V/-R configuration arguments&quot;, 0
++				   );
++
++		if ((status != ISC_R_SUCCESS) || ( cfile -&gt; warnings_occurred ))
++			log_fatal (&quot;Cannot parse -I/-H/-F/-T/-V/-R configuration arguments !&quot;);
++		        /* more detailed parse failures will be logged */
++
++		do {
++			token = peek_token (&amp;val, (unsigned *)0, cfile);
++			if (token == END_OF_FILE)
++				break;
++
++			parse_client_statement (cfile,
++						(struct interface_info *)0,
++						&amp;top_level_config);
++			
++
++		} while (1);
++
++		if( cfile -&gt; warnings_occurred )
++			log_fatal (&quot;Cannot parse -I/-H/-F/-T/-V/-R configuration arguments !&quot;);
++		end_parse (&amp;cfile);
++
++		if ( timeout_arg )
++		{
++			/* we just set the toplevel timeout, but per-client timeouts may
++			   still be at defaults. Also, it makes no sense having the 
++                           reboot_timeout or backoff_cutoff greater than the timeout:
++                         */
++			if ( ( top_level_config.backoff_cutoff == 15 )
++			   &amp;&amp;( top_level_config.backoff_cutoff &gt; ( timeout_arg / 2 ) )
++			     )  top_level_config.backoff_cutoff
++				= (((unsigned long)( timeout_arg / 2 ))==0)
++				  ? timeout_arg
++				  : (unsigned long)( timeout_arg / 2 );
++
++			for (ip = interfaces; ip; ip = ip -&gt; next) 
++			{
++				if ( ip -&gt; client -&gt; config -&gt; timeout == 60 )
++					ip -&gt; client -&gt; config -&gt; timeout = timeout_arg;
++
++				if ( (ip -&gt; client -&gt; config -&gt; reboot_timeout == 10 )
++				   &amp;&amp;(ip -&gt; client -&gt; config -&gt; reboot_timeout 
++				     &gt;ip -&gt; client -&gt; config -&gt; timeout
++				     )
++				   )    ip -&gt; client -&gt; config -&gt; reboot_timeout 
++				      = ip -&gt; client -&gt; config -&gt; timeout;
++
++				if ( (ip -&gt; client -&gt; config -&gt; backoff_cutoff == 15 )
++				   &amp;&amp;(ip -&gt; client -&gt; config -&gt; backoff_cutoff
++				     &gt; top_level_config.backoff_cutoff
++				     )
++				  )     ip -&gt; client -&gt; config -&gt; backoff_cutoff
++				      = top_level_config.backoff_cutoff;
++			}
++		}
++
++		if (  ( dhclient_request_options != 0 )
++		    &amp;&amp;( top_level_config.requested_options !=  default_requested_options )
++		   )
++		{
++			for (ip = interfaces; ip; ip = ip -&gt; next) 
++			{
++				if (    ip -&gt; client -&gt; config -&gt; requested_options 
++				     == default_requested_options
++				   )
++					ip -&gt; client -&gt; config -&gt; requested_options =
++						top_level_config.requested_options;
++			}
++		}
++
++		free(arg_conf);
++		arg_conf = 0L;
++		arg_conf_len = 0L;
++	}
++		
+ 	/* Parse the lease database. */
+ 	read_client_leases ();
+ 
+@@ -385,6 +804,16 @@
+ 				continue;
+ 			script_init (ip -&gt; client,
+ 				     &quot;PREINIT&quot;, (struct string_list *)0);
++			if (/* Has an active lease */
++			    ip -&gt; client -&gt; active &amp;&amp;
++			    !ip -&gt; client -&gt; active -&gt; is_bootp &amp;&amp;
++			    ip -&gt; client -&gt; active -&gt; expiry &gt; cur_time &amp;&amp;
++			    /* Which is same as current ip */
++			    ip -&gt; primary_address.s_addr != 0 &amp;&amp;
++			    ip -&gt; client -&gt; active -&gt; address.len == 4 &amp;&amp;
++			    memcmp (ip -&gt; client -&gt; active -&gt; address.iabuf,
++				    &amp;ip-&gt;primary_address, 4) == 0)
++				client_envadd (ip -&gt; client, &quot;&quot;, &quot;keep_old_ip&quot;, &quot;%s&quot;, &quot;yes&quot;);
+ 			if (ip -&gt; client -&gt; alias)
+ 				script_write_params (ip -&gt; client, &quot;alias_&quot;,
+ 						     ip -&gt; client -&gt; alias);
+@@ -423,10 +852,7 @@
+ 				do_release (client);
+ 			else {
+ 				client -&gt; state = S_INIT;
+-				/* Set up a timeout to start the initialization
+-				   process. */
+-				add_timeout (cur_time + random () % 5,
+-					     state_reboot, client, 0, 0);
++				add_timeout (cur_time, state_reboot, client, 0, 0);
+ 			}
+ 		}
+ 	}
+@@ -479,20 +905,27 @@
+ 
+ static void usage ()
+ {
+-	log_info (&quot;%s %s&quot;, message, DHCP_VERSION);
+-	log_info (copyright);
+-	log_info (arr);
+-	log_info (url);
++	printf (&quot;%s %s\n&quot;, message, DHCP_VERSION);
++	printf (copyright);
++	printf (&quot;\n&quot;);
++	printf (arr);
++	printf (&quot;\n&quot;);
++	printf (url);
++	printf (&quot;\n&quot;);
+ 
+ #ifdef EXTENDED_NEW_OPTION_INFO
+-	log_error (&quot;Usage: dhclient [-1dqr] [-nwx] [-p &lt;port&gt;] %s&quot;,
++	printf (&quot;Usage: dhclient [-1dqr] [-nwx] [-p &lt;port&gt;] %s&quot;,
+ #else
+-	log_error (&quot;Usage: dhclient [-1dqr] [-nw] [-p &lt;port&gt;] %s&quot;,
++	printf (&quot;Usage: dhclient [-1dqr] [-nw] [-p &lt;port&gt;] %s&quot;,
+ #endif
+-		   &quot;[-s server]&quot;);
+-	log_error (&quot;                [-cf config-file] [-lf lease-file]%s&quot;,
+-		   &quot;[-pf pid-file] [-e VAR=val]&quot;);
+-	log_fatal (&quot;                [-sf script-file] [interface]&quot;);
++		&quot;[-s server]&quot;);
++	printf (&quot;                [-cf config-file] [-lf lease-file]%s&quot;,
++		&quot;[-pf pid-file] [-e VAR=val]&quot;);
++	printf (&quot;                [ -I &lt;dhcp-client-identifier&gt; ] [-B]\n&quot;);
++	printf (&quot;                [ -H &lt;host-name&gt; | -F &lt;fqdn.fqdn&gt; ] [ -T &lt;timeout&gt; ]\n&quot;);
++	printf (&quot;                [ -V &lt;vendor-class-identifier&gt; ]\n&quot;);
++	printf (&quot;                [ -R &lt;request option list&gt; ]\n&quot;);
++	printf (&quot;                [-sf script-file] [interface]&quot;);
+ }
+ 
+ isc_result_t find_class (struct class **c,
+@@ -599,6 +1032,7 @@
+ 	void *cpp;
+ {
+ 	struct client_state *client = cpp;
++	enum dhcp_state init_state = client -&gt; state;
+ 
+ 	ASSERT_STATE(state, S_INIT);
+ 
+@@ -611,9 +1045,20 @@
+ 	client -&gt; first_sending = cur_time;
+ 	client -&gt; interval = client -&gt; config -&gt; initial_interval;
+ 
+-	/* Add an immediate timeout to cause the first DHCPDISCOVER packet
+-	   to go out. */
+-	send_discover (client);
++	if ( init_state != S_DECLINED )
++	{
++		/* Add an immediate timeout to cause the first DHCPDISCOVER packet
++		   to go out. */	
++		send_discover (client);
++	}else
++	{
++		/* We've received an OFFER and it has been DECLINEd by dhclient-script.
++		 * wait for a random time between 1 and backoff_cutoff seconds before trying again. 
++		 */
++		add_timeout( cur_time + (( 1 + (random () &gt;&gt; 2) ) %  client -&gt; config -&gt; backoff_cutoff),
++			     send_discover, client, 0, 0
++			   ); 
++	}
+ }
+ 
+ /* state_selecting is called when one or more DHCPOFFER packets have been
+@@ -693,7 +1138,6 @@
+ 	/* Add an immediate timeout to send the first DHCPREQUEST packet. */
+ 	send_request (client);
+ }  
+-
+ /* state_requesting is called when we receive a DHCPACK message after
+    having sent out one or more DHCPREQUEST packets. */
+ 
+@@ -884,6 +1328,7 @@
+ 		send_decline (client);
+ 		destroy_client_lease (client -&gt; new);
+ 		client -&gt; new = (struct client_lease *)0;
++		client -&gt; state = S_DECLINED;
+ 		state_init (client);
+ 		return;
+ 	}
+@@ -1395,6 +1840,7 @@
+ 
+ 	/* If we're past the panic timeout, call the script and tell it
+ 	   we haven't found anything for this interface yet. */
++
+ 	if (interval &gt; client -&gt; config -&gt; timeout) {
+ 		state_panic (client);
+ 		return;
+@@ -1934,8 +2380,9 @@
+ 	client -&gt; packet.xid = random ();
+ 	client -&gt; packet.secs = 0; /* filled in by send_discover. */
+ 
+-	if (can_receive_unicast_unconfigured (client -&gt; interface))
+-		client -&gt; packet.flags = 0;
++	if (  (!(bootp_broadcast_always || client -&gt; config -&gt; bootp_broadcast_always))
++	   &amp;&amp; can_receive_unicast_unconfigured (client -&gt; interface)
++	   )	client -&gt; packet.flags = 0;
+ 	else
+ 		client -&gt; packet.flags = htons (BOOTP_BROADCAST);
+ 
+@@ -2021,8 +2468,9 @@
+ 	} else {
+ 		memset (&amp;client -&gt; packet.ciaddr, 0,
+ 			sizeof client -&gt; packet.ciaddr);
+-		if (can_receive_unicast_unconfigured (client -&gt; interface))
+-			client -&gt; packet.flags = 0;
++		if (  (!(bootp_broadcast_always || client -&gt; config -&gt; bootp_broadcast_always))
++		   &amp;&amp; can_receive_unicast_unconfigured (client -&gt; interface)
++		   )	client -&gt; packet.flags = 0;
+ 		else
+ 			client -&gt; packet.flags = htons (BOOTP_BROADCAST);
+ 	}
+@@ -2081,8 +2529,9 @@
+ 	client -&gt; packet.hops = 0;
+ 	client -&gt; packet.xid = client -&gt; xid;
+ 	client -&gt; packet.secs = 0; /* Filled in by send_request. */
+-	if (can_receive_unicast_unconfigured (client -&gt; interface))
+-		client -&gt; packet.flags = 0;
++	if (  (!(bootp_broadcast_always || client -&gt; config -&gt; bootp_broadcast_always))
++	   &amp;&amp; can_receive_unicast_unconfigured (client -&gt; interface)
++	   )    client -&gt; packet.flags = 0;
+ 	else
+ 		client -&gt; packet.flags = htons (BOOTP_BROADCAST);
+ 
+@@ -2549,6 +2998,7 @@
+ 
+ 	es.client = client;
+ 	es.prefix = prefix;
++	es.universe = 0L;
+ 
+ 	client_envadd (client,
+ 		       prefix, &quot;ip_address&quot;, &quot;%s&quot;, piaddr (lease -&gt; address));
+@@ -2677,6 +3127,8 @@
+ 			wstatus = 0;
+ 		}
+ 	} else {
++	        if (leaseFile)
++		  fclose (leaseFile);
+ 		execve (scriptName, argv, envp);
+ 		log_error (&quot;execve (%s, ...): %m&quot;, scriptName);
+ 		exit (0);
+@@ -2868,7 +3320,9 @@
+ 			      case S_INIT:
+ 			      case S_REBINDING:
+ 			      case S_STOPPED:
++			      case S_DECLINED:
+ 				break;
++				
+ 			}
+ 			client -&gt; state = S_INIT;
+ 			state_reboot (client);

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-common.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-common.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-common.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,198 @@
+--- dhcp-3.0.5/common/parse.c.common	2006-11-13 19:07:33.000000000 -0500
++++ dhcp-3.0.5/common/parse.c	2006-11-13 19:07:33.000000000 -0500
+@@ -4842,14 +4842,15 @@
+ #endif
+ 
+ 	if (log_perror) {
+-		write (STDERR_FILENO, mbuf, strlen (mbuf));
+-		write (STDERR_FILENO, &quot;\n&quot;, 1);
+-		write (STDERR_FILENO, cfile -&gt; token_line,
++		int r;
++		r = write (STDERR_FILENO, mbuf, strlen (mbuf));
++		r = write (STDERR_FILENO, &quot;\n&quot;, 1);
++		r = write (STDERR_FILENO, cfile -&gt; token_line,
+ 		       strlen (cfile -&gt; token_line));
+-		write (STDERR_FILENO, &quot;\n&quot;, 1);
++		r = write (STDERR_FILENO, &quot;\n&quot;, 1);
+ 		if (cfile -&gt; lexchar &lt; 81)
+-			write (STDERR_FILENO, lexbuf, lix);
+-		write (STDERR_FILENO, &quot;^\n&quot;, 2);
++			r = write (STDERR_FILENO, lexbuf, lix);
++		r = write (STDERR_FILENO, &quot;^\n&quot;, 2);
+ 	}
+ 
+ 	cfile -&gt; warnings_occurred = 1;
+--- dhcp-3.0.5/common/alloc.c.common	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/alloc.c	2006-11-13 19:07:33.000000000 -0500
+@@ -146,7 +146,7 @@
+ 	for (car = option_chain_head -&gt; first; car; car = cdr) {
+ 		cdr = car -&gt; cdr;
+ 		if (car -&gt; car)
+-			option_cache_dereference ((struct option_cache **)
++			option_cache_dereference ((void*)
+ 						  (&amp;car -&gt; car), MDL);
+ 		dfree (car, MDL);
+ 		car = cdr;
+--- dhcp-3.0.5/common/conflex.c.common	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/conflex.c	2006-11-13 19:07:33.000000000 -0500
+@@ -605,6 +605,8 @@
+ 			return BALANCE;
+ 		if (!strcasecmp (atom + 1, &quot;ound&quot;))
+ 			return BOUND;
++		if (!strcasecmp (atom + 1, &quot;ootp-broadcast-always&quot;))
++			return BOOTP_BROADCAST_ALWAYS;
+ 		break;
+ 	      case 'c':
+ 		if (!strcasecmp (atom + 1, &quot;ase&quot;))
+--- dhcp-3.0.5/common/dhcp-options.5.common	2006-04-26 11:12:43.000000000 -0400
++++ dhcp-3.0.5/common/dhcp-options.5	2006-11-13 19:07:33.000000000 -0500
+@@ -834,6 +834,24 @@
+ classless IP routing is now the most widely deployed routing standard,
+ this option is virtually useless, and is not implemented by any of the
+ popular DHCP clients, for example the Microsoft DHCP client.
++.PP
++NOTE to Red Hat dhclient users:
++.br
++The RedHat dhclient-script interprets trailing 0 octets of the  target
++as  indicating  the  subnet  class  of  the route - so for this
++static-routes value:
++.br
++        option static-routes 172.0.0.0 172.16.2.254,
++.br
++                             192.168.0.0 192.168.2.254;
++.br
++the Red Hat dhclient-script will create routes:
++.br
++        172/8 via 172.16.2.254 dev $interface
++.br
++        192.168/16 via 192.168.2.254 dev $interface
++.br
++which slightly increases the usefulness of the static-routes option.
+ .RE
+ .PP
+ .nf
+--- dhcp-3.0.5/common/discover.c.common	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/discover.c	2006-11-13 19:07:33.000000000 -0500
+@@ -878,7 +878,7 @@
+ 		interface -&gt; client = (struct client_state *)0;
+ 
+ 	if (interface -&gt; shared_network)
+-		omapi_object_dereference ((omapi_object_t **)
++		omapi_object_dereference ((void*)
+ 					  &amp;interface -&gt; shared_network, MDL);
+ 
+ 	return ISC_R_SUCCESS;
+--- dhcp-3.0.5/common/options.c.common	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/options.c	2006-11-13 19:07:33.000000000 -0500
+@@ -1733,9 +1733,9 @@
+ 		   in its place. */
+ 		if (bptr) {
+ 			option_cache_dereference
+-				((struct option_cache **)&amp;bptr -&gt; car, MDL);
++			        ((void*)&amp;bptr -&gt; car, MDL);
+ 			option_cache_reference
+-				((struct option_cache **)&amp;bptr -&gt; car,
++			        ((void*)&amp;bptr -&gt; car,
+ 				 oc, MDL);
+ 			return;
+ 		}
+@@ -1749,7 +1749,7 @@
+ 	}
+ 	bptr -&gt; cdr = hash [hashix];
+ 	bptr -&gt; car = 0;
+-	option_cache_reference ((struct option_cache **)&amp;bptr -&gt; car, oc, MDL);
++	option_cache_reference ((void*)&amp;bptr -&gt; car, oc, MDL);
+ 	hash [hashix] = bptr;
+ }
+ 
+@@ -1793,7 +1793,7 @@
+ 		else
+ 			hash [hashix] = bptr -&gt; cdr;
+ 		option_cache_dereference
+-			((struct option_cache **)(&amp;bptr -&gt; car), MDL);
++			((void*)(&amp;bptr -&gt; car), MDL);
+ 		free_pair (bptr, MDL);
+ 	}
+ }
+@@ -1869,7 +1869,7 @@
+ 		for (cp = heads [i]; cp; cp = next) {
+ 			next = cp -&gt; cdr;
+ 			option_cache_dereference
+-				((struct option_cache **)&amp;cp -&gt; car,
++			    ((void*)&amp;cp -&gt; car,
+ 				 file, line);
+ 			free_pair (cp, file, line);
+ 		}
+@@ -2276,9 +2276,9 @@
+ 	for (tail = &amp;head -&gt; first; *tail; tail = &amp;((*tail) -&gt; cdr)) {
+ 		if (oc -&gt; option ==
+ 		    ((struct option_cache *)((*tail) -&gt; car)) -&gt; option) {
+-			option_cache_dereference ((struct option_cache **)
++			option_cache_dereference ((void*)
+ 						  (&amp;(*tail) -&gt; car), MDL);
+-			option_cache_reference ((struct option_cache **)
++			option_cache_reference ((void*)
+ 						(&amp;(*tail) -&gt; car), oc, MDL);
+ 			return;
+ 		}
+@@ -2286,7 +2286,7 @@
+ 
+ 	*tail = cons (0, 0);
+ 	if (*tail) {
+-		option_cache_reference ((struct option_cache **)
++		option_cache_reference ((void*)
+ 					(&amp;(*tail) -&gt; car), oc, MDL);
+ 	}
+ }
+@@ -2344,7 +2344,7 @@
+ 		    ((struct option_cache *)(*tail) -&gt; car) -&gt; option -&gt; code)
+ 		{
+ 			tmp = (*tail) -&gt; cdr;
+-			option_cache_dereference ((struct option_cache **)
++			option_cache_dereference ((void*)
+ 						  (&amp;(*tail) -&gt; car), MDL);
+ 			dfree (*tail, MDL);
+ 			(*tail) = tmp;
+--- dhcp-3.0.5/common/packet.c.common	2005-03-03 11:55:23.000000000 -0500
++++ dhcp-3.0.5/common/packet.c	2006-11-13 19:07:33.000000000 -0500
+@@ -140,6 +140,7 @@
+ 	struct ip ip;
+ 	struct udphdr udp;
+ 
++	memset( &amp;ip, '\0', sizeof ip);
+ 	/* Fill out the IP header */
+ 	IP_V_SET (&amp;ip, 4);
+ 	IP_HL_SET (&amp;ip, 20);
+@@ -219,7 +220,7 @@
+ {
+   unsigned char *data;
+   struct ip ip;
+-  struct udphdr *udp;
++  struct udphdr udph, *udp=&amp;udph;
+   u_int32_t ip_len = (buf [bufix] &amp; 0xf) &lt;&lt; 2;
+   u_int32_t sum, usum;
+   static int ip_packets_seen;
+@@ -233,7 +234,7 @@
+   int ignore = 0;
+ 
+   memcpy(&amp;ip, buf + bufix, sizeof (struct ip));
+-  udp = (struct udphdr *)(buf + bufix + ip_len);
++  memcpy(udp, buf + bufix + ip_len, sizeof(struct udphdr));
+ 
+ #ifdef USERLAND_FILTER
+   /* Is it a UDP packet? */
+--- dhcp-3.0.5/common/dispatch.c.common	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/dispatch.c	2006-11-13 19:08:00.000000000 -0500
+@@ -195,7 +195,6 @@
+ 	}
+ }
+ 
+-#if defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
+ void cancel_all_timeouts ()
+ {
+ 	struct timeout *t, *n;
+@@ -216,4 +215,3 @@
+ 		dfree (t, MDL);
+ 	}
+ }
+-#endif

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-dhcpctl.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-dhcpctl.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-dhcpctl.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,86 @@
+--- dhcp-3.0.5/dhcpctl/callback.c.dhcpctl	2004-06-10 13:59:23.000000000 -0400
++++ dhcp-3.0.5/dhcpctl/callback.c	2006-11-10 11:50:05.000000000 -0500
+@@ -150,7 +150,7 @@
+ 		return ISC_R_INVALIDARG;
+ 	p = (dhcpctl_callback_object_t *)h;
+ 	if (p -&gt; handle)
+-		omapi_object_dereference ((omapi_object_t **)&amp;p -&gt; handle,
++		omapi_object_dereference ((void*)&amp;p -&gt; handle,
+ 					  file, line);
+ 	return ISC_R_SUCCESS;
+ }
+--- dhcp-3.0.5/dhcpctl/dhcpctl.3.dhcpctl	2004-09-24 17:08:38.000000000 -0400
++++ dhcp-3.0.5/dhcpctl/dhcpctl.3	2006-11-10 11:50:08.000000000 -0500
+@@ -43,7 +43,8 @@
+ .\&quot;
+ .\&quot;
+ .Sh SYNOPSIS
+-.Fd #include &lt;dhcpctl/dhcpctl.h&gt;
++.Fd #include &lt;dhcpctl.h&gt;
++.sp
+ .Ft dhcpctl_status
+ .Fo dhcpctl_initialize
+ .Fa void
+@@ -426,7 +427,7 @@
+ #include &lt;netinet/in.h&gt;
+ 
+ #include &lt;isc/result.h&gt;
+-#include &lt;dhcpctl/dhcpctl.h&gt;
++#include &lt;dhcpctl.h&gt;
+ 
+ int main (int argc, char **argv) {
+ 	dhcpctl_data_string ipaddrstring = NULL;
+--- dhcp-3.0.5/dhcpctl/remote.c.dhcpctl	2004-06-10 13:59:24.000000000 -0400
++++ dhcp-3.0.5/dhcpctl/remote.c	2006-11-10 11:50:10.000000000 -0500
+@@ -122,7 +122,7 @@
+ 	isc_result_t status;
+ 
+ 	m = (dhcpctl_remote_object_t *)0;
+-	status = omapi_object_allocate ((omapi_object_t **)&amp;m,
++	status = omapi_object_allocate ((void*)&amp;m,
+ 					dhcpctl_remote_type, 0, MDL);
+ 	if (status != ISC_R_SUCCESS)
+ 		return status;
+@@ -135,7 +135,7 @@
+ 	}
+ 	status = omapi_object_reference (&amp;m -&gt; inner, g, MDL);
+ 	if (status != ISC_R_SUCCESS) {
+-		omapi_object_dereference ((omapi_object_t **)&amp;m, MDL);
++		omapi_object_dereference ((void*)&amp;m, MDL);
+ 		omapi_object_dereference (&amp;g, MDL);
+ 		return status;
+ 	}
+@@ -143,7 +143,7 @@
+ 					 (omapi_object_t *)m, MDL);
+ 
+ 	if (status != ISC_R_SUCCESS) {
+-		omapi_object_dereference ((omapi_object_t **)&amp;m, MDL);
++		omapi_object_dereference ((void*)&amp;m, MDL);
+ 		omapi_object_dereference (&amp;g, MDL);
+ 		return status;
+ 	}
+@@ -152,13 +152,13 @@
+ 				       omapi_datatype_string,
+ 				       object_type);
+ 	if (status != ISC_R_SUCCESS) {
+-		omapi_object_dereference ((omapi_object_t **)&amp;m, MDL);
++		omapi_object_dereference ((void*)&amp;m, MDL);
+ 		omapi_object_dereference (&amp;g, MDL);
+ 		return status;
+ 	}
+ 
+ 	status = omapi_object_reference (h, (omapi_object_t *)m, MDL);
+-	omapi_object_dereference ((omapi_object_t **)&amp;m, MDL);
++	omapi_object_dereference ((void*)&amp;m, MDL);
+ 	omapi_object_dereference (&amp;g, MDL);
+ 	if (status != ISC_R_SUCCESS)
+ 		return status;
+@@ -339,7 +339,7 @@
+ 		return ISC_R_INVALIDARG;
+ 	p = (dhcpctl_remote_object_t *)h;
+ 	if (p -&gt; handle)
+-		omapi_object_dereference ((omapi_object_t **)&amp;p -&gt; handle,
++		omapi_object_dereference ((void*)&amp;p -&gt; handle,
+ 					  file, line);
+ 	if (p -&gt; rtype)
+ 		omapi_typed_data_dereference ((omapi_typed_data_t **)&amp;p-&gt;rtype,

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-dst.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-dst.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-dst.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,60 @@
+--- dhcp-3.0.5/dst/dst_api.c.dst	2001-02-22 02:22:08.000000000 -0500
++++ dhcp-3.0.5/dst/dst_api.c	2006-11-13 17:31:45.000000000 -0500
+@@ -58,6 +58,10 @@
+ 
+ #include &quot;dst_internal.h&quot;
+ 
++/* prototypes */
++extern int b64_pton(char const *src, u_char *target, size_t targsize);
++extern int b64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize);
++
+ /* static variables */
+ static int done_init = 0;
+ dst_func *dst_t_func[DST_MAX_ALGS];
+@@ -542,8 +546,14 @@
+ 			 ,name));
+ 		return (NULL);
+ 	}
++
+ 	/* read in the key string */
+-	fgets(enckey, sizeof(enckey), fp);
++	if( fgets(enckey, sizeof(enckey), fp) == NULL )
++	{
++	        EREPORT((&quot;dst_read_public_key(): Can not read enckey field from %s\n&quot;
++			 ,name));
++		return (NULL);
++	}
+ 
+ 	/* If we aren't at end-of-file, something is wrong.  */
+ 	while ((c = getc(fp)) != EOF)
+@@ -866,7 +876,7 @@
+ 	len = cnt;
+ 	p = in_buff;
+ 
+-	if (!dst_s_verify_str((const char **) &amp;p, &quot;Private-key-format: v&quot;)) {
++	if (!dst_s_verify_str((void*) &amp;p, &quot;Private-key-format: v&quot;)) {
+ 		EREPORT((&quot;dst_s_read_private_key_file(): Not a Key file/Decrypt failed %s\n&quot;, name));
+ 		goto fail;
+ 	}
+@@ -884,7 +894,7 @@
+ 
+ 	while (*p++ != '\n') ;	/* skip to end of line */
+ 
+-	if (!dst_s_verify_str((const char **) &amp;p, &quot;Algorithm: &quot;))
++	if (!dst_s_verify_str((void*) &amp;p, &quot;Algorithm: &quot;))
+ 		goto fail;
+ 
+ 	if (sscanf((char *)p, &quot;%d&quot;, &amp;alg) != 1)
+--- dhcp-3.0.5/dst/dst_support.c.dst	2001-02-22 02:22:08.000000000 -0500
++++ dhcp-3.0.5/dst/dst_support.c	2006-11-13 17:32:00.000000000 -0500
+@@ -32,6 +32,10 @@
+ 
+ #include &quot;dst_internal.h&quot;
+ 
++/* prototypes */
++extern int b64_pton(char const *src, u_char *target, size_t targsize);
++extern int b64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize);
++
+ /*
+  * dst_s_conv_bignum_u8_to_b64
+  *	This function converts binary data stored as a u_char[] to a

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-extended-new-option-info.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-extended-new-option-info.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-extended-new-option-info.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,428 @@
+--- dhcp-3.0.5/client/scripts/linux.dbus-example.enoi	2006-11-13 12:59:34.000000000 -0500
++++ dhcp-3.0.5/client/scripts/linux.dbus-example	2006-11-13 12:59:26.000000000 -0500
+@@ -0,0 +1,223 @@
++#!/bin/bash
++# dhclient-script for Linux. Dan Halbert, March, 1997.
++# Updated for Linux 2.[12] by Brian J. Murrell, January 1999.
++# No guarantees about this. I'm a novice at the details of Linux
++# networking.
++
++# Notes:
++
++# 0. This script is based on the netbsd script supplied with dhcp-970306.
++
++# 1. ifconfig down apparently deletes all relevant routes and flushes
++# the arp cache, so this doesn't need to be done explicitly.
++
++# 2. The alias address handling here has not been tested AT ALL.
++# I'm just going by the doc of modern Linux ip aliasing, which uses
++# notations like eth0:0, eth0:1, for each alias.
++
++# 3. I have to calculate the network address, and calculate the broadcast
++# address if it is not supplied. This might be much more easily done
++# by the dhclient C code, and passed on.
++
++# 4. TIMEOUT not tested. ping has a flag I don't know, and I'm suspicious
++# of the $1 in its args.
++
++if [ -n &quot;${dhc_dbus}&quot; ]; then
++  /bin/dbus-send \
++    --system --dest=com.redhat.dhcp --type=method_call \
++    /com/redhat/dhcp/$interface com.redhat.dhcp.set \
++    'string:'&quot;`env | /bin/egrep -v '^(PATH|SHLVL|_|PWD|dhc_dbus)\='`&quot;;
++    if (( ( dhc_dbus &amp; 31 ) == 31 )); then
++    exit 0;
++    fi;
++fi;
++
++make_resolv_conf() {
++  if [ &quot;x$new_domain_name&quot; != x ] &amp;&amp; [ x&quot;$new_domain_name_servers&quot; != x ]; then
++    echo search $new_domain_name &gt;/etc/resolv.conf
++    chmod 644 /etc/resolv.conf
++    for nameserver in $new_domain_name_servers; do
++      echo nameserver $nameserver &gt;&gt;/etc/resolv.conf
++    done
++  fi
++}
++
++# Must be used on exit.   Invokes the local dhcp client exit hooks, if any.
++exit_with_hooks() {
++  exit_status=$1
++  if [ -f /etc/dhclient-exit-hooks ]; then
++    . /etc/dhclient-exit-hooks
++  fi
++# probably should do something with exit status of the local script
++  exit $exit_status
++}
++
++# Invoke the local dhcp client enter hooks, if they exist.
++if [ -f /etc/dhclient-enter-hooks ]; then
++  exit_status=0
++  . /etc/dhclient-enter-hooks
++  # allow the local script to abort processing of this state
++  # local script must set exit_status variable to nonzero.
++  if [ $exit_status -ne 0 ]; then
++    exit $exit_status
++  fi
++fi
++
++release=`uname -r`
++release=`expr $release : '\(.*\)\..*'`
++relminor=`echo $release |sed -e 's/[0-9]*\.\([0-9][0-9]*\)\(\..*\)*$/\1/'`
++relmajor=`echo $release |sed -e 's/\([0-9][0-9]*\)\..*$/\1/'`
++
++if [ x$new_broadcast_address != x ]; then
++  new_broadcast_arg=&quot;broadcast $new_broadcast_address&quot;
++fi
++if [ x$old_broadcast_address != x ]; then
++  old_broadcast_arg=&quot;broadcast $old_broadcast_address&quot;
++fi
++if [ x$new_subnet_mask != x ]; then
++  new_subnet_arg=&quot;netmask $new_subnet_mask&quot;
++fi
++if [ x$old_subnet_mask != x ]; then
++  old_subnet_arg=&quot;netmask $old_subnet_mask&quot;
++fi
++if [ x$alias_subnet_mask != x ]; then
++  alias_subnet_arg=&quot;netmask $alias_subnet_mask&quot;
++fi
++
++if [ x$reason = xMEDIUM ]; then
++  # Linux doesn't do mediums (ok, ok, media).
++  exit_with_hooks 0
++fi
++
++if [ x$reason = xPREINIT ]; then
++  if [ x$alias_ip_address != x ]; then
++    # Bring down alias interface. Its routes will disappear too.
++    ifconfig $interface:0- inet 0
++  fi
++  if [ $relmajor -lt 2 ] || ( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] )
++   then
++    ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
++		broadcast 255.255.255.255 up
++    # Add route to make broadcast work. Do not omit netmask.
++    route add default dev $interface netmask 0.0.0.0
++  else
++    ifconfig $interface 0 up
++  fi
++
++  # We need to give the kernel some time to get the interface up.
++  sleep 1
++
++  exit_with_hooks 0
++fi
++
++if [ x$reason = xARPCHECK ] || [ x$reason = xARPSEND ]; then
++  exit_with_hooks 0
++fi
++  
++if [ x$reason = xBOUND ] || [ x$reason = xRENEW ] || \
++   [ x$reason = xREBIND ] || [ x$reason = xREBOOT ]; then
++  current_hostname=`hostname`
++  if [ x$current_hostname = x ] || \
++     [ x$current_hostname = x$old_host_name ]; then
++    if [ x$current_hostname = x ] || \
++       [ x$new_host_name != x$old_host_name ]; then
++      hostname $new_host_name
++    fi
++  fi
++
++  if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++  if [ x$old_ip_address != x ] &amp;&amp; [ x$alias_ip_address != x ] &amp;&amp; \
++		[ x$alias_ip_address != x$old_ip_address ]; then
++    # Possible new alias. Remove old alias.
++    ifconfig $interface:0- inet 0
++  fi
++  if [ x$old_ip_address != x ] &amp;&amp; [ x$old_ip_address != x$new_ip_address ]; then
++    # IP address changed. Bringing down the interface will delete all routes,
++    # and clear the ARP cache.
++    ifconfig $interface inet 0 down
++
++  fi
++  fi
++  if [ x$old_ip_address = x ] || [ x$old_ip_address != x$new_ip_address ] || \
++     [ x$reason = xBOUND ] || [ x$reason = xREBOOT ]; then
++  if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++    ifconfig $interface inet $new_ip_address $new_subnet_arg \
++							$new_broadcast_arg
++  fi
++  if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 4 ) != 4 )); then
++    # Add a network route to the computed network address.
++    if [ $relmajor -lt 2 ] || \
++		( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] ); then
++      route add -net $new_network_number $new_subnet_arg dev $interface
++    fi
++    for router in $new_routers; do
++      route add default gw $router
++    done
++  fi
++  fi
++  if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++  if [ x$new_ip_address != x$alias_ip_address ] &amp;&amp; [ x$alias_ip_address != x ];
++   then
++    ifconfig $interface:0- inet 0
++    ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
++    route add -host $alias_ip_address $interface:0
++  fi
++  fi
++  if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 1 ) != 1 )); then
++  make_resolv_conf
++  fi
++  exit_with_hooks 0
++fi
++
++if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++if [ x$reason = xEXPIRE ] || [ x$reason = xFAIL ] || [ x$reason = xRELEASE ] \
++   || [ x$reason = xSTOP ]; then
++  if [ x$alias_ip_address != x ]; then
++    # Turn off alias interface.
++    ifconfig $interface:0- inet 0
++  fi
++  if [ x$old_ip_address != x ]; then
++    # Shut down interface, which will delete routes and clear arp cache.
++    ifconfig $interface inet 0 down
++  fi
++  if [ x$alias_ip_address != x ]; then
++    ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
++    route add -host $alias_ip_address $interface:0
++  fi
++  exit_with_hooks 0
++fi
++fi
++
++if [ x$reason = xTIMEOUT ]; then
++  if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++  if [ x$alias_ip_address != x ]; then
++    ifconfig $interface:0- inet 0
++  fi
++  ifconfig $interface inet $new_ip_address $new_subnet_arg \
++					$new_broadcast_arg
++  fi
++  set $new_routers
++  ############## what is -w in ping?
++  if ping -q -c 1 $1; then
++    if [ x$new_ip_address != x$alias_ip_address ] &amp;&amp; \
++			[ x$alias_ip_address != x ]; then
++      ifconfig $interface:0 inet $alias_ip_address $alias_subnet_arg
++      route add -host $alias_ip_address dev $interface:0
++    fi
++    if [ $relmajor -lt 2 ] || \
++		( [ $relmajor -eq 2 ] &amp;&amp; [ $relminor -eq 0 ] ); then
++      route add -net $new_network_number
++    fi
++    for router in $new_routers; do
++      route add default gw $router
++    done
++    make_resolv_conf
++    exit_with_hooks 0
++  fi
++  if [ -z &quot;${dhc_dbus}&quot; ] || (( ( dhc_dbus &amp; 2 ) != 2 )); then
++  ifconfig $interface inet 0 down
++  fi
++  exit_with_hooks 1
++fi
++
++exit_with_hooks 0
+--- dhcp-3.0.5/client/dhclient.c.enoi	2006-08-22 11:13:57.000000000 -0400
++++ dhcp-3.0.5/client/dhclient.c	2006-11-13 12:44:11.000000000 -0500
+@@ -74,6 +74,9 @@
+ int onetry=0;
+ int quiet=0;
+ int nowait=0;
++#ifdef EXTENDED_NEW_OPTION_INFO
++int extended_option_environment = 0;
++#endif
+ 
+ static void usage PROTO ((void));
+ 
+@@ -204,6 +207,11 @@
+ 		} else if (!strcmp (argv [i], &quot;--version&quot;)) {
+ 			log_info (&quot;isc-dhclient-%s&quot;, DHCP_VERSION);
+ 			exit (0);
++#ifdef EXTENDED_NEW_OPTION_INFO
++		} else if (!strcmp (argv [i], &quot;-x&quot;)) {
++			extended_option_environment = 1;
++			new_option_info_tree = GENERATE_NEW_OPTION_INFO;
++#endif
+  		} else if (argv [i][0] == '-') {
+  		    usage ();
+ 		} else {
+@@ -476,7 +484,11 @@
+ 	log_info (arr);
+ 	log_info (url);
+ 
++#ifdef EXTENDED_NEW_OPTION_INFO
++	log_error (&quot;Usage: dhclient [-1dqr] [-nwx] [-p &lt;port&gt;] %s&quot;,
++#else
+ 	log_error (&quot;Usage: dhclient [-1dqr] [-nw] [-p &lt;port&gt;] %s&quot;,
++#endif
+ 		   &quot;[-s server]&quot;);
+ 	log_error (&quot;                [-cf config-file] [-lf lease-file]%s&quot;,
+ 		   &quot;[-pf pid-file] [-e VAR=val]&quot;);
+@@ -2447,8 +2459,30 @@
+ struct envadd_state {
+ 	struct client_state *client;
+ 	const char *prefix;
++#ifdef EXTENDED_NEW_OPTION_INFO
++	struct universe *universe;
++#endif
+ };
+ 
++#ifdef EXTENDED_NEW_OPTION_INFO
++static
++void build_universe_info_envvar
++(	struct option_cache *oc,
++	struct packet *p, struct lease *l,
++	struct client_state *client,
++	struct option_state *in_o,
++	struct option_state *cf_o,
++	struct binding_scope **scope,
++	struct universe *u, void *es
++)
++{
++	char info_name[512], info_data[512];
++	snprintf(info_name, 512, &quot;%s._universe_.&quot;, oc-&gt;option-&gt;universe-&gt;name);
++	snprintf(info_data, 512, &quot;%u:%s&quot;, oc-&gt;option-&gt;code,oc-&gt;option-&gt;format);
++	client_envadd( client, info_name, oc-&gt;option-&gt;name, info_data );
++}
++#endif
++
+ void client_option_envadd (struct option_cache *oc,
+ 			   struct packet *packet, struct lease *lease,
+ 			   struct client_state *client_state,
+@@ -2465,6 +2499,28 @@
+ 				   in_options, cfg_options, scope, oc, MDL)) {
+ 		if (data.len) {
+ 			char name [256];
++#ifdef EXTENDED_NEW_OPTION_INFO
++			if (extended_option_environment) {
++				if ((oc-&gt;option-&gt;universe != &amp;dhcp_universe)
++					&amp;&amp; (oc-&gt;option-&gt;universe-&gt;index &gt; fqdn_universe.index)
++					&amp;&amp; (es-&gt;universe !=  oc-&gt;option-&gt;universe)) {
++					es-&gt;universe = oc-&gt;option-&gt;universe;
++					(*(es-&gt;universe-&gt;foreach)) ((struct packet *)0,
++											    (struct lease *)0, 
++					                            client_state, 
++					                            in_options, cfg_options,
++					                            scope, es-&gt;universe, es,  
++					                            build_universe_info_envvar);
++				} else {
++					if (lookup_new_option_info(oc-&gt;option) != NULL) {
++						build_universe_info_envvar(oc, packet, lease,
++						                           client_state, in_options,
++						                           cfg_options, scope,
++						                           oc-&gt;option-&gt;universe, es);
++					}
++				}
++			}
++#endif
+ 			if (dhcp_option_ev_name (name, sizeof name,
+ 						 oc -&gt; option)) {
+ 				client_envadd (es -&gt; client, es -&gt; prefix,
+@@ -2704,7 +2760,14 @@
+ 			s = option -&gt; name;
+ 			if (j + 1 == buflen)
+ 				return 0;
++#ifdef EXTENDED_NEW_OPTION_INFO
++			if (!extended_option_environment)
++				buf[j++] = '_';
++			else
++				buf[j++] = '.';
++#else
+ 			buf [j++] = '_';
++#endif
+ 		}
+ 		++i;
+ 	} while (i != 2);
+--- dhcp-3.0.5/client/dhclient.8.enoi	2005-09-14 12:03:33.000000000 -0400
++++ dhcp-3.0.5/client/dhclient.8	2006-11-13 12:42:28.000000000 -0500
+@@ -82,6 +82,9 @@
+ .B -w
+ ]
+ [
++.B -x
++]
++[
+ .I if0
+ [
+ .I ...ifN
+@@ -265,6 +268,11 @@
+ supplying the
+ .B -nw
+ flag.
++.PP
++The -x argument enables extended option information to be created in the
++-s dhclient-script environment, which would allow applications running
++in that environment to handle options they do not know about in advance -
++this is a Red Hat extension to support dhcdbd and NetworkManager.
+ .SH CONFIGURATION
+ The syntax of the dhclient.conf(5) file is discussed separately.
+ .SH OMAPI
+--- dhcp-3.0.5/common/parse.c.enoi	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/parse.c	2006-11-13 12:42:28.000000000 -0500
+@@ -1271,6 +1271,10 @@
+ 	option_hash_add (option -&gt; universe -&gt; hash,
+ 			 (const char *)option -&gt; name,
+ 			 0, option, MDL);
++#ifdef EXTENDED_NEW_OPTION_INFO
++	if (new_option_info_tree != NULL)
++		add_new_option_info(option);
++#endif
+ 	return 1;
+ }
+ 
+--- dhcp-3.0.5/common/tables.c.enoi	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/tables.c	2006-11-13 12:42:28.000000000 -0500
+@@ -1250,3 +1250,35 @@
+ 			   fqdn_universe.name, 0,
+ 			   &amp;fqdn_universe, MDL);
+ }
++
++#ifdef EXTENDED_NEW_OPTION_INFO
++#include &lt;search.h&gt;
++
++void *new_option_info_tree = NULL;
++
++static int new_option_info_comparator(const void * p1, const void * p2) {
++	uint32_t ocode1 = (((const struct option*)p1)-&gt;universe-&gt;index &lt;&lt; 8)
++	                   | (((const struct option*)p1)-&gt;code),
++	         ocode2 = (((const struct option*)p2)-&gt;universe-&gt;index &lt;&lt; 8)
++	                   | (((const struct option*)p2)-&gt;code);
++
++	return((ocode1 == ocode2) ? 0 : ((ocode1 &gt; ocode2) ? 1 : -1));
++}
++
++void *add_new_option_info(struct option * option) {
++	if (option-&gt;universe-&gt;index &gt;= fqdn_universe.index)
++		return NULL;
++
++	if (new_option_info_tree == GENERATE_NEW_OPTION_INFO)
++		new_option_info_tree = NULL;
++
++    return tsearch(option, &amp;(new_option_info_tree), new_option_info_comparator);
++}
++
++void *lookup_new_option_info(struct option * option) {
++	if (new_option_info_tree == GENERATE_NEW_OPTION_INFO)
++		return NULL;
++
++	return tfind(option, &amp;(new_option_info_tree), new_option_info_comparator);
++}
++#endif
+--- dhcp-3.0.5/includes/dhcpd.h.enoi	2006-05-17 16:16:59.000000000 -0400
++++ dhcp-3.0.5/includes/dhcpd.h	2006-11-13 12:42:28.000000000 -0500
+@@ -1811,6 +1811,13 @@
+ void initialize_common_option_spaces PROTO ((void));
+ struct universe *config_universe;
+ 
++#ifdef EXTENDED_NEW_OPTION_INFO
++#define GENERATE_NEW_OPTION_INFO ((void*)1)
++extern void *new_option_info_tree;
++extern void *add_new_option_info(struct option *);
++extern void *lookup_new_option_info(struct option *);
++#endif
++
+ /* stables.c */
+ #if defined (FAILOVER_PROTOCOL)
+ extern failover_option_t null_failover_option;

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-fix-warnings.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-fix-warnings.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-fix-warnings.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,1741 @@
+--- dhcp-3.0.5/client/clparse.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/client/clparse.c	2006-11-13 18:29:17.000000000 -0500
+@@ -39,8 +39,6 @@
+ 
+ #include &quot;dhcpd.h&quot;
+ 
+-static TIME parsed_time;
+-
+ struct client_config top_level_config;
+ 
+ u_int32_t default_requested_options [] = {
+@@ -65,7 +63,6 @@
+ isc_result_t read_client_conf ()
+ {
+ 	struct client_config *config;
+-	struct client_state *state;
+ 	struct interface_info *ip;
+ 	isc_result_t status;
+ 
+@@ -246,11 +243,9 @@
+ 	int token;
+ 	const char *val;
+ 	struct option *option;
+-	struct executable_statement *stmt, **p;
+-	enum statement_op op;
++	struct executable_statement *stmt;
+ 	int lose;
+ 	char *name;
+-	struct data_string key_id;
+ 	enum policy policy;
+ 	int known;
+ 	int tmp, i;
+@@ -979,11 +974,9 @@
+ {
+ 	int token;
+ 	const char *val;
+-	char *t, *n;
+ 	struct interface_info *ip;
+ 	struct option_cache *oc;
+ 	struct client_state *client = (struct client_state *)0;
+-	struct data_string key_id;
+ 
+ 	switch (next_token (&amp;val, (unsigned *)0, cfile)) {
+ 	      case KEY:
+@@ -1174,12 +1167,6 @@
+ 	struct parse *cfile;
+ 	int flag;
+ {
+-	enum dhcp_token token;
+-	const char *val;
+-	unsigned char rf = flag;
+-	struct expression *data = (struct expression *)0;
+-	int status;
+-
+ 	parse_warn (cfile, &quot;allow/deny/ignore not permitted here.&quot;);
+ 	skip_to_semi (cfile);
+ 	return 0;
+--- dhcp-3.0.5/common/icmp.c.warnings	2004-06-10 13:59:18.000000000 -0400
++++ dhcp-3.0.5/common/icmp.c	2006-11-13 18:29:17.000000000 -0500
+@@ -61,11 +61,7 @@
+ {
+ 	struct protoent *proto;
+ 	int protocol = 1;
+-	struct sockaddr_in from;
+-	int fd;
+ 	int state;
+-	struct icmp_state *new;
+-	omapi_object_t *h;
+ 	isc_result_t result;
+ 
+ 	/* Only initialize icmp once. */
+@@ -284,7 +280,6 @@
+ void trace_icmp_input_input (trace_type_t *ttype, unsigned length, char *buf)
+ {
+ 	struct iaddr *ia;
+-	unsigned len;
+ 	u_int8_t *icbuf;
+ 	ia = (struct iaddr *)buf;
+ 	ia-&gt;len = ntohl(ia-&gt;len);
+--- dhcp-3.0.5/common/parse.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/common/parse.c	2006-11-13 18:29:17.000000000 -0500
+@@ -311,9 +311,6 @@
+ 	struct parse *cfile;
+ 	struct iaddr *addr;
+ {
+-	const char *val;
+-	enum dhcp_token token;
+-
+ 	addr -&gt; len = 4;
+ 	if (parse_numeric_aggregate (cfile, addr -&gt; iabuf,
+ 				     &amp;addr -&gt; len, DOT, 10, 8))
+@@ -650,7 +647,6 @@
+ TIME parse_date (cfile)
+ 	struct parse *cfile;
+ {
+-	struct tm tm;
+ 	int guess;
+ 	int tzoff, wday, year, mon, mday, hour, min, sec;
+ 	const char *val;
+@@ -1022,7 +1018,6 @@
+ 	char tokbuf [128];
+ 	unsigned tokix = 0;
+ 	char type;
+-	int code;
+ 	int is_signed;
+ 	char *s;
+ 	int has_encapsulation = 0;
+@@ -1515,7 +1510,6 @@
+ {
+ 	enum dhcp_token token;
+ 	const char *val;
+-	struct executable_statement base;
+ 	struct class *cta;
+ 	struct option *option;
+ 	struct option_cache *cache;
+@@ -1818,7 +1812,6 @@
+ 		if (token != NAME &amp;&amp; token != NUMBER_OR_NAME) {
+ 			parse_warn (cfile,
+ 				    &quot;%s can't be a variable name&quot;, val);
+-		      badunset:
+ 			skip_to_semi (cfile);
+ 			*lose = 1;
+ 			return 0;
+@@ -2793,16 +2786,12 @@
+ 	enum dhcp_token token;
+ 	const char *val;
+ 	struct collection *col;
+-	struct option *option;
+ 	struct expression *nexp, **ep;
+ 	int known;
+ 	enum expr_op opcode;
+ 	const char *s;
+ 	char *cptr;
+-	struct executable_statement *stmt;
+-	int i;
+ 	unsigned long u;
+-	isc_result_t status, code;
+ 	unsigned len;
+ 
+ 	token = peek_token (&amp;val, (unsigned *)0, cfile);
+@@ -3290,7 +3279,6 @@
+ 					parse_warn
+ 						(cfile,
+ 						 &quot;expecting dns expression.&quot;);
+-			      badnstrans:
+ 				expression_dereference (expr, MDL);
+ 				*lose = 1;
+ 				return 0;
+@@ -4198,8 +4186,6 @@
+ 	struct expression *expr = (struct expression *)0;
+ 	struct expression *tmp;
+ 	int lose;
+-	struct executable_statement *stmt;
+-	int ftt = 1;
+ 
+ 	token = peek_token (&amp;val, (unsigned *)0, cfile);
+ 	if (token == SEMI) {
+@@ -4317,9 +4303,7 @@
+ 	struct expression *t = (struct expression *)0;
+ 	unsigned char buf [4];
+ 	unsigned len;
+-	unsigned char *ob;
+ 	struct iaddr addr;
+-	int num;
+ 	const char *f, *g;
+ 	struct enumeration_value *e;
+ 
+@@ -4557,11 +4541,6 @@
+ 
+ 	/* Parse the option data... */
+ 	do {
+-		/* Set a flag if this is an array of a simple type (i.e.,
+-		   not an array of pairs of IP addresses, or something
+-		   like that. */
+-		int uniform = option -&gt; format [1] == 'A';
+-
+ 		for (fmt = option -&gt; format; *fmt; fmt++) {
+ 			if (*fmt == 'A')
+ 				break;
+@@ -4760,7 +4739,6 @@
+ 	int token;
+ 	const char *val;
+ 	unsigned len;
+-	u_int8_t *s;
+ 
+ 	token = peek_token (&amp;val, (unsigned *)0, cfile);
+ 	if (token == NUMBER_OR_NAME || token == NUMBER) {
+@@ -4827,9 +4805,10 @@
+ 		if (lix &lt; (sizeof lexbuf) - 1)
+ 			lexbuf [lix++] = ' ';
+ 		if (cfile -&gt; token_line [i] == '\t') {
+-			for (lix;
+-			     lix &lt; (sizeof lexbuf) - 1 &amp;&amp; (lix &amp; 7); lix++)
++			while ((lix &lt; (sizeof lexbuf) - 1) &amp;&amp; (lix &amp; 7)) {
+ 				lexbuf [lix] = ' ';
++				lix++;
++			}
+ 		}
+ 	}
+ 	lexbuf [lix] = 0;
+--- dhcp-3.0.5/common/socket.c.warnings	2004-06-10 13:59:21.000000000 -0400
++++ dhcp-3.0.5/common/socket.c	2006-11-13 18:29:17.000000000 -0500
+@@ -55,8 +55,6 @@
+ # endif
+ #endif
+ 
+-static int once = 0;
+-
+ /* Reinitializes the specified interface after an address change.   This
+    is not required for packet-filter APIs. */
+ 
+--- dhcp-3.0.5/common/memory.c.warnings	2004-06-10 13:59:19.000000000 -0400
++++ dhcp-3.0.5/common/memory.c	2006-11-13 18:29:18.000000000 -0500
+@@ -84,8 +84,7 @@
+ 
+ isc_result_t supersede_group (struct group_object *group, int writep)
+ {
+-	struct group_object *t, *u;
+-	isc_result_t status;
++	struct group_object *t;
+ 
+ 	/* Register the group in the group name hash table,
+ 	   so we can look it up later. */
+@@ -142,7 +141,6 @@
+ int clone_group (struct group **gp, struct group *group,
+ 		 const char *file, int line)
+ {
+-	isc_result_t status;
+ 	struct group *g = (struct group *)0;
+ 
+ 	/* Normally gp should contain the null pointer, but for convenience
+--- dhcp-3.0.5/common/print.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/print.c	2006-11-13 18:29:18.000000000 -0500
+@@ -1043,7 +1043,6 @@
+ 			       const char *suffix, ...)
+ {
+ 	va_list list;
+-	char *buf;
+ 	unsigned len;
+ 	char *s, *t, *u;
+ 
+@@ -1081,7 +1080,6 @@
+ 			      struct data_string *data)
+ {
+ 	int i;
+-	char *buf;
+ 	char obuf [3];
+ 
+ 	/* See if this is just ASCII. */
+--- dhcp-3.0.5/common/options.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/common/options.c	2006-11-13 18:29:18.000000000 -0500
+@@ -43,16 +43,11 @@
+ 
+ struct option *vendor_cfg_option;
+ 
+-static void do_option_set PROTO ((pair *,
+-				  struct option_cache *,
+-				  enum statement_op));
+-
+ /* Parse all available options out of the specified packet. */
+ 
+ int parse_options (packet)
+ 	struct packet *packet;
+ {
+-	int i;
+ 	struct option_cache *op = (struct option_cache *)0;
+ 
+ 	/* Allocate a new option state. */
+@@ -112,8 +107,6 @@
+ 	unsigned length;
+ 	struct universe *universe;
+ {
+-	unsigned char *t;
+-	const unsigned char *end = buffer + length;
+ 	unsigned len, offset;
+ 	int code;
+ 	struct option_cache *op = (struct option_cache *)0;
+@@ -277,7 +270,6 @@
+ 			  const unsigned char *buffer,
+ 			  unsigned length, struct universe *u)
+ {
+-	char *name;
+ 	struct buffer *bp = (struct buffer *)0;
+ 
+ 	/* FQDN options have to be at least four bytes long. */
+@@ -466,9 +458,7 @@
+ 	int priority_len;
+ 	unsigned char buffer [4096];	/* Really big buffer... */
+ 	unsigned main_buffer_size, mb_max;
+-	unsigned mainbufix, bufix, agentix;
+-	int fileix;
+-	int snameix;
++	unsigned mainbufix, agentix;
+ 	unsigned option_size;
+ 	unsigned length;
+ 	int i;
+@@ -476,7 +466,6 @@
+ 	struct data_string ds;
+ 	pair pp, *hash;
+ 	int need_endopt = 0;
+-	int have_sso = 0;
+ 	int ocount = 0;
+ 	int ofbuf1=0, ofbuf2=0;
+ 
+@@ -814,7 +803,6 @@
+ 	    if (u -&gt; options [code] &amp;&amp;
+ 		((u -&gt; options [code] -&gt; format [0] == 'E' &amp;&amp; !oc) ||
+ 		 u -&gt; options [code] -&gt; format [0] == 'e')) {
+-		int uix;
+ 		static char *s, *t;
+ 		struct option_cache *tmp;
+ 		struct data_string name;
+@@ -940,7 +928,6 @@
+ 	    toptstart = tix;
+ 	    while (length) {
+ 		    unsigned incr = length;
+-		    int consumed = 0;
+ 		    int *pix;
+ 		    unsigned char *base;
+ 
+@@ -1053,7 +1040,6 @@
+ 	const char *format;
+ {
+ 	const char *p;
+-	int retval = 0;
+ 
+ 	p = format;
+ 	while (*p != '\0') {
+@@ -2006,7 +1992,6 @@
+ {
+ 	pair ocp;
+ 	int status;
+-	int i;
+ 	static struct option_cache *no_nwip;
+ 	struct data_string ds;
+ 	struct option_chain_head *head;
+@@ -2020,7 +2005,6 @@
+ 
+ 	status = 0;
+ 	for (ocp = head -&gt; first; ocp; ocp = ocp -&gt; cdr) {
+-		struct option_cache *oc = (struct option_cache *)(ocp -&gt; car);
+ 		if (store_option (result, universe, packet,
+ 				  lease, client_state, in_options,
+ 				  cfg_options, scope,
+@@ -2206,7 +2190,6 @@
+ {
+ 	struct universe *universe = find_option_universe (oc -&gt; option,
+ 							  vsname);
+-	int i;
+ 
+ 	if (universe -&gt; foreach)
+ 		(*universe -&gt; foreach) (packet, lease, client_state,
+@@ -2256,7 +2239,6 @@
+ 	struct option_cache *oc;
+ {
+ 	pair *tail;
+-	pair np = (pair )0;
+ 	struct option_chain_head *head;
+ 
+ 	if (universe -&gt; index &gt;= options -&gt; universe_count)
+@@ -2428,7 +2410,6 @@
+ 	struct iaddr from;
+ 	struct hardware *hfrom;
+ {
+-	int i;
+ 	struct option_cache *op;
+ 	struct packet *decoded_packet;
+ #if defined (DEBUG_MEMORY_LEAKAGE)
+--- dhcp-3.0.5/common/inet.c.warnings	2005-03-03 11:55:22.000000000 -0500
++++ dhcp-3.0.5/common/inet.c	2006-11-13 18:29:18.000000000 -0500
+@@ -124,7 +124,7 @@
+ 	struct iaddr subnet;
+ 	struct iaddr mask;
+ {
+-	int i, j, k;
++	int i;
+ 	struct iaddr rv;
+ 
+ 	if (subnet.len &gt; sizeof(subnet.iabuf))
+--- dhcp-3.0.5/common/tree.c.warnings	2006-07-17 11:34:44.000000000 -0400
++++ dhcp-3.0.5/common/tree.c	2006-11-13 18:29:18.000000000 -0500
+@@ -249,8 +249,6 @@
+ 	struct expression *expr;
+ 	int limit;
+ {
+-	struct expression *rv;
+-
+ 	/* Allocate a node to enforce a limit on evaluation. */
+ 	if (!expression_allocate (new, MDL))
+ 		log_error (&quot;no memory for limit expression&quot;);
+@@ -644,11 +642,10 @@
+ 	struct binding_scope **scope;
+ 	struct expression *expr;
+ {
+-	ns_updrec *foo;
+ 	unsigned long ttl = 0;
+ 	char *tname;
+ 	struct data_string name, data;
+-	int r0, r1, r2, r3;
++	int r0, r1, r2;
+ 
+ 	if (!result || *result) {
+ 		log_error (&quot;evaluate_dns_expression called with non-null %s&quot;,
+@@ -903,10 +900,7 @@
+ 	struct binding_scope **scope;
+ 	struct expression *expr;
+ {
+-	struct data_string left, right;
+-	struct data_string rrtype, rrname, rrdata;
+-	unsigned long ttl;
+-	int srrtype, srrname, srrdata, sttl;
++	struct data_string left;
+ 	int bleft, bright;
+ 	int sleft, sright;
+ 	struct binding *binding;
+@@ -1275,11 +1269,10 @@
+ 	int line;
+ {
+ 	struct data_string data, other;
+-	unsigned long offset, len, i;
++	unsigned long offset, len;
+ 	int s0, s1, s2, s3;
+ 	int status;
+ 	struct binding *binding;
+-	char *s;
+ 	struct binding_value *bv;
+ 
+ 	switch (expr -&gt; op) {
+@@ -1826,7 +1819,6 @@
+ 					       MDL);
+ 
+ 		if (s0 &amp;&amp; s1) {
+-			char *upper;
+ 			int i;
+ 
+ 			/* The buffer must be a multiple of the number's
+@@ -3127,8 +3119,6 @@
+ int op_precedence (op1, op2)
+ 	enum expr_op op1, op2;
+ {
+-	int ov1, ov2;
+-
+ 	return op_val (op1) - op_val (op2);
+ }
+ 
+@@ -3742,7 +3732,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int i;
+ 	struct binding_scope *binding_scope;
+ 
+ 	if (!ptr || !*ptr) {
+--- dhcp-3.0.5/common/dns.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/dns.c	2006-11-13 18:29:19.000000000 -0500
+@@ -127,7 +127,6 @@
+ isc_result_t find_tsig_key (ns_tsig_key **key, const char *zname,
+ 			    struct dns_zone *zone)
+ {
+-	isc_result_t status;
+ 	ns_tsig_key *tkey;
+ 
+ 	if (!zone)
+@@ -201,7 +200,6 @@
+ 
+ isc_result_t dns_zone_lookup (struct dns_zone **zone, const char *name)
+ {
+-	struct dns_zone *tz = (struct dns_zone *)0;
+ 	int len;
+ 	char *tname = (char *)0;
+ 	isc_result_t status;
+@@ -234,7 +232,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int i;
+ 	struct dns_zone *dns_zone;
+ 
+ 	if (!ptr || !*ptr) {
+@@ -397,9 +394,7 @@
+ void cache_found_zone (ns_class class,
+ 		       char *zname, struct in_addr *addrs, int naddrs)
+ {
+-	isc_result_t status = ISC_R_NOTFOUND;
+ 	struct dns_zone *zone = (struct dns_zone *)0;
+-	struct data_string nsaddrs;
+ 	int ix = strlen (zname);
+ 
+ 	if (zname [ix - 1] == '.')
+--- dhcp-3.0.5/common/resolv.c.warnings	2005-10-27 11:56:26.000000000 -0400
++++ dhcp-3.0.5/common/resolv.c	2006-11-13 18:29:19.000000000 -0500
+@@ -50,10 +50,8 @@
+ 	struct parse *cfile;
+ 	const char *val;
+ 	int token;
+-	int declaration = 0;
+ 	struct name_server *sp, *sl, *ns;
+ 	struct domain_search_list *dp, *dl, *nd;
+-	struct iaddr *iaddr;
+ 
+ 	if ((file = open (path_resolv_conf, O_RDONLY)) &lt; 0) {
+ 		log_error (&quot;Can't open %s: %m&quot;, path_resolv_conf);
+@@ -179,7 +177,6 @@
+ 
+ struct name_server *first_name_server ()
+ {
+-	FILE *rc;
+ 	static TIME rcdate;
+ 	struct stat st;
+ 
+@@ -190,8 +187,6 @@
+ 			return (struct name_server *)0;
+ 		}
+ 		if (st.st_mtime &gt; rcdate) {
+-			char rcbuf [512];
+-			char *s, *t, *u;
+ 			rcdate = cur_time + 1;
+ 			
+ 			read_resolv_conf (rcdate);
+--- dhcp-3.0.5/common/execute.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/execute.c	2006-11-13 18:29:19.000000000 -0500
+@@ -54,8 +54,6 @@
+ 	struct executable_statement *r, *e, *next;
+ 	int rc;
+ 	int status;
+-	unsigned long num;
+-	struct binding_scope *outer;
+ 	struct binding *binding;
+ 	struct data_string ds;
+ 	struct binding_scope *ns;
+@@ -283,7 +281,6 @@
+ 					binding -&gt; next = (*scope) -&gt; bindings;
+ 					(*scope) -&gt; bindings = binding;
+ 				    } else {
+-				       badalloc:
+ 					dfree (binding, MDL);
+ 					binding = (struct binding *)0;
+ 				    }
+@@ -526,8 +523,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	struct executable_statement *bp;
+-
+ 	if (!ptr || !*ptr) {
+ 		log_error (&quot;%s(%d): null pointer&quot;, file, line);
+ #if defined (POINTER_DEBUG)
+@@ -650,8 +645,6 @@
+ 	int indent;
+ {
+ 	struct executable_statement *r, *x;
+-	int result;
+-	int status;
+ 	const char *s, *t, *dot;
+ 	int col;
+ 
+@@ -906,10 +899,8 @@
+ {
+ 	int status, sub;
+ 	struct executable_statement *s;
+-	unsigned long foo;
+ 
+ 	if (is_data_expression (expr)) {
+-		struct executable_statement *e;
+ 		struct data_string cd, ds;
+ 		memset (&amp;ds, 0, sizeof ds);
+ 		memset (&amp;cd, 0, sizeof cd);
+@@ -983,7 +974,6 @@
+ {
+ 	struct executable_statement *foo;
+ 	int ok = 0;
+-	int result;
+ 
+ 	for (foo = stmt; foo; foo = foo -&gt; next) {
+ 	    if ((*callback) (foo, vp, condp) != 0)
+--- dhcp-3.0.5/common/comapi.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/common/comapi.c	2006-11-13 18:29:20.000000000 -0500
+@@ -143,7 +143,6 @@
+ {
+ 	struct group_object *group;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_group)
+ 		return ISC_R_INVALIDARG;
+@@ -217,7 +216,6 @@
+ {
+ 	struct group_object *group;
+ 	isc_result_t status;
+-	struct data_string ip_addrs;
+ 
+ 	if (h -&gt; type != dhcp_type_group)
+ 		return ISC_R_INVALIDARG;
+@@ -240,7 +238,6 @@
+ isc_result_t dhcp_group_destroy (omapi_object_t *h, const char *file, int line)
+ {
+ 	struct group_object *group, *t;
+-	isc_result_t status;
+ 
+ 	if (h -&gt; type != dhcp_type_group)
+ 		return ISC_R_INVALIDARG;
+@@ -271,7 +268,7 @@
+ isc_result_t dhcp_group_signal_handler (omapi_object_t *h,
+ 					const char *name, va_list ap)
+ {
+-	struct group_object *group, *t;
++	struct group_object *group;
+ 	isc_result_t status;
+ 	int updatep = 0;
+ 
+@@ -453,7 +450,6 @@
+ {
+ 	dhcp_control_object_t *control;
+ 	isc_result_t status;
+-	int foo;
+ 	unsigned long newstate;
+ 
+ 	if (h -&gt; type != dhcp_type_control)
+@@ -488,7 +484,6 @@
+ {
+ 	dhcp_control_object_t *control;
+ 	isc_result_t status;
+-	struct data_string ip_addrs;
+ 
+ 	if (h -&gt; type != dhcp_type_control)
+ 		return ISC_R_INVALIDARG;
+@@ -511,9 +506,6 @@
+ isc_result_t dhcp_control_destroy (omapi_object_t *h,
+ 				   const char *file, int line)
+ {
+-	dhcp_control_object_t *control, *t;
+-	isc_result_t status;
+-
+ 	if (h -&gt; type != dhcp_type_control)
+ 		return ISC_R_INVALIDARG;
+ 
+@@ -524,9 +516,8 @@
+ isc_result_t dhcp_control_signal_handler (omapi_object_t *h,
+ 					const char *name, va_list ap)
+ {
+-	dhcp_control_object_t *control, *t;
++	dhcp_control_object_t *control;
+ 	isc_result_t status;
+-	int updatep = 0;
+ 
+ 	if (h -&gt; type != dhcp_type_control)
+ 		return ISC_R_INVALIDARG;
+@@ -580,7 +571,6 @@
+ {
+ 	omapi_value_t *tv = (omapi_value_t *)0;
+ 	isc_result_t status;
+-	dhcp_control_object_t *control;
+ 
+ 	/* First see if we were sent a handle. */
+ 	if (ref) {
+@@ -629,7 +619,6 @@
+ {
+ 	struct subnet *subnet;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_subnet)
+ 		return ISC_R_INVALIDARG;
+@@ -675,7 +664,6 @@
+ isc_result_t dhcp_subnet_destroy (omapi_object_t *h, const char *file, int line)
+ {
+ 	struct subnet *subnet;
+-	isc_result_t status;
+ 
+ 	if (h -&gt; type != dhcp_type_subnet)
+ 		return ISC_R_INVALIDARG;
+@@ -752,10 +740,6 @@
+ 				 omapi_object_t *id,
+ 				 omapi_object_t *ref)
+ {
+-	omapi_value_t *tv = (omapi_value_t *)0;
+-	isc_result_t status;
+-	struct subnet *subnet;
+-
+ 	/* Can't look up subnets yet. */
+ 
+ 	/* If we get to here without finding a subnet, no valid key was
+@@ -784,7 +768,6 @@
+ {
+ 	struct shared_network *shared_network;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_shared_network)
+ 		return ISC_R_INVALIDARG;
+@@ -832,7 +815,6 @@
+ 					  const char *file, int line)
+ {
+ 	struct shared_network *shared_network;
+-	isc_result_t status;
+ 
+ 	if (h -&gt; type != dhcp_type_shared_network)
+ 		return ISC_R_INVALIDARG;
+@@ -922,10 +904,6 @@
+ 					 omapi_object_t *id,
+ 					 omapi_object_t *ref)
+ {
+-	omapi_value_t *tv = (omapi_value_t *)0;
+-	isc_result_t status;
+-	struct shared_network *shared_network;
+-
+ 	/* Can't look up shared_networks yet. */
+ 
+ 	/* If we get to here without finding a shared_network, no valid key was
+--- dhcp-3.0.5/dhcpctl/dhcpctl.c.warnings	2004-06-10 13:59:24.000000000 -0400
++++ dhcp-3.0.5/dhcpctl/dhcpctl.c	2006-11-13 18:29:20.000000000 -0500
+@@ -101,7 +101,6 @@
+ 				dhcpctl_handle authinfo)
+ {
+ 	isc_result_t status;
+-	dhcpctl_status waitstatus;
+ 
+ 	status = omapi_generic_new (connection, MDL);
+ 	if (status != ISC_R_SUCCESS) {
+@@ -171,7 +170,6 @@
+ {
+ 	isc_result_t status;
+ 	omapi_value_t *tv = (omapi_value_t *)0;
+-	omapi_data_string_t *value = (omapi_data_string_t *)0;
+ 	unsigned len;
+ 	int ip;
+ 
+@@ -263,7 +261,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *name = (omapi_data_string_t *)0;
+-	int len;
+ 
+ 	status = omapi_data_string_new (&amp;name, strlen (value_name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+@@ -297,7 +294,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *name = (omapi_data_string_t *)0;
+-	int len;
+ 
+ 	status = omapi_data_string_new (&amp;name, strlen (value_name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+@@ -386,7 +382,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *name = (omapi_data_string_t *)0;
+-	int len;
+ 
+ 	status = omapi_data_string_new (&amp;name, strlen (value_name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+@@ -416,7 +411,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *name = (omapi_data_string_t *)0;
+-	int len;
+ 
+ 	status = omapi_data_string_new (&amp;name, strlen (value_name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+--- dhcp-3.0.5/dhcpctl/callback.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/dhcpctl/callback.c	2006-11-13 18:29:20.000000000 -0500
+@@ -59,7 +59,6 @@
+ {
+ 	dhcpctl_callback_object_t *callback;
+ 	omapi_object_t *inner;
+-	isc_result_t status;
+ 
+ 	callback = dmalloc (sizeof *callback, MDL);
+ 	if (!callback)
+@@ -162,8 +161,6 @@
+ 					    omapi_object_t *id,
+ 					    omapi_object_t *p)
+ {
+-	int i;
+-
+ 	if (p -&gt; type != dhcpctl_callback_type)
+ 		return ISC_R_INVALIDARG;
+ 
+--- dhcp-3.0.5/dhcpctl/remote.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/dhcpctl/remote.c	2006-11-13 18:29:20.000000000 -0500
+@@ -354,8 +354,6 @@
+ 					  omapi_object_t *id,
+ 					  omapi_object_t *p)
+ {
+-	int i;
+-
+ 	if (p -&gt; type != dhcpctl_remote_type)
+ 		return ISC_R_INVALIDARG;
+ 
+--- dhcp-3.0.5/dhcpctl/omshell.c.warnings	2005-10-27 11:56:26.000000000 -0400
++++ dhcp-3.0.5/dhcpctl/omshell.c	2006-11-13 18:29:20.000000000 -0500
+@@ -82,11 +82,9 @@
+ 	dhcpctl_handle connection;
+ 	dhcpctl_handle authenticator;
+ 	dhcpctl_handle oh;
+-	dhcpctl_data_string cid, ip_addr;
+-	dhcpctl_data_string result, groupname, identifier;
+ 	struct data_string secret;
+ 	const char *name = 0, *algorithm = &quot;hmac-md5&quot;;
+-	int i, j;
++	int i;
+ 	int port = 7911;
+ 	const char *server = &quot;127.0.0.1&quot;;
+ 	struct parse *cfile;
+@@ -481,7 +479,6 @@
+ 				val = buf;
+ 				do {
+ 				    int intval = atoi (val);
+-				dotiszero:
+ 				    if (intval &gt; 255) {
+ 					parse_warn (cfile,
+ 						    &quot;dotted octet &gt; 255: %s&quot;,
+--- dhcp-3.0.5/dhcpctl/cltest.c.warnings	2004-06-10 13:59:23.000000000 -0400
++++ dhcp-3.0.5/dhcpctl/cltest.c	2006-11-13 18:29:20.000000000 -0500
+@@ -60,9 +60,8 @@
+ 	isc_result_t status, waitstatus;
+ 	dhcpctl_handle authenticator;
+ 	dhcpctl_handle connection;
+-	dhcpctl_handle host_handle, group_handle, interface_handle;
+-	dhcpctl_data_string cid;
+-	dhcpctl_data_string result, groupname, identifier;
++	dhcpctl_handle interface_handle;
++	dhcpctl_data_string result;
+ 	int i;
+ 	int mode = undefined;
+ 	const char *interface = 0;
+--- dhcp-3.0.5/dst/prandom.c.warnings	2001-02-22 02:22:09.000000000 -0500
++++ dhcp-3.0.5/dst/prandom.c	2006-11-13 18:29:20.000000000 -0500
+@@ -335,7 +335,7 @@
+ 		cnt += do_time(work);
+ 	}
+ 	while ((n = fread(buffer, sizeof(char), sizeof(buffer), pipe)) &gt; 0)
+-		NULL; /* drain the pipe */
++		continue; /* drain the pipe */
+ 	pclose(pipe);
+ 	return (cnt);		/* read how many bytes where read in */
+ }
+--- dhcp-3.0.5/minires/res_mkupdate.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/minires/res_mkupdate.c	2006-11-13 18:29:20.000000000 -0500
+@@ -112,7 +112,7 @@
+ 	u_int16_t rtype, rclass;
+ 	u_int32_t n1, rttl;
+ 	u_char *dnptrs[20], **dpp, **lastdnptr;
+-	unsigned siglen, certlen;
++	unsigned certlen;
+ 	int keylen;
+ 	unsigned buflen = *blp;
+ 	u_char *buf = (unsigned char *)bp;
+--- dhcp-3.0.5/minires/res_update.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/minires/res_update.c	2006-11-13 18:29:20.000000000 -0500
+@@ -106,7 +106,7 @@
+ 	double answer[PACKETSZ / sizeof (double)];
+ 	double packet[2*PACKETSZ / sizeof (double)];
+ 	struct zonegrp *zptr, tgrp;
+-	int nzones = 0, nscount = 0;
++	int nscount = 0;
+ 	unsigned n;
+ 	unsigned rval;
+ 	struct sockaddr_in nsaddrs[MAXNS];
+--- dhcp-3.0.5/omapip/protocol.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/omapip/protocol.c	2006-11-13 18:29:20.000000000 -0500
+@@ -161,7 +161,6 @@
+ 	omapi_remote_auth_t *ra;
+ 	omapi_value_t *signature;
+ 	isc_result_t status;
+-	u_int32_t foo;
+ 	unsigned auth_len;
+ 
+ 	if (po -&gt; type != omapi_type_protocol ||
+@@ -940,8 +939,6 @@
+ 					  omapi_object_t *id,
+ 					  omapi_object_t *p)
+ {
+-	int i;
+-
+ 	if (p -&gt; type != omapi_type_protocol)
+ 		return ISC_R_INVALIDARG;
+ 
+@@ -1128,8 +1125,6 @@
+ 					    omapi_object_t *id,
+ 					    omapi_object_t *p)
+ {
+-	int i;
+-
+ 	if (p -&gt; type != omapi_type_protocol_listener)
+ 		return ISC_R_INVALIDARG;
+ 
+--- dhcp-3.0.5/omapip/buffer.c.warnings	2005-10-06 15:05:46.000000000 -0400
++++ dhcp-3.0.5/omapip/buffer.c	2006-11-13 18:29:20.000000000 -0500
+@@ -438,7 +438,6 @@
+ 	int bytes_written;
+ 	unsigned first_byte;
+ 	omapi_buffer_t *buffer;
+-	unsigned char *bufp;
+ 	omapi_connection_object_t *c;
+ 	isc_result_t status;
+ 
+@@ -575,7 +574,6 @@
+ 					  u_int32_t value)
+ {
+ 	u_int32_t inbuf;
+-	isc_result_t status;
+ 
+ 	inbuf = htonl (value);
+ 	
+@@ -602,7 +600,6 @@
+ 					  u_int32_t value)
+ {
+ 	u_int16_t inbuf;
+-	isc_result_t status;
+ 
+ 	inbuf = htons (value);
+ 	
+--- dhcp-3.0.5/omapip/connection.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/omapip/connection.c	2006-11-13 18:29:21.000000000 -0500
+@@ -111,10 +111,6 @@
+ 	omapi_connection_object_t *obj;
+ 	int flag;
+ 	struct sockaddr_in local_sin;
+-#if defined (TRACING)
+-	trace_addr_t *addrs;
+-	u_int16_t naddrs;
+-#endif
+ 
+ 	obj = (omapi_connection_object_t *)0;
+ 	status = omapi_connection_allocate (&amp;obj, MDL);
+@@ -1005,8 +1001,6 @@
+ 					    omapi_object_t *id,
+ 					    omapi_object_t *m)
+ {
+-	int i;
+-
+ 	if (m -&gt; type != omapi_type_connection)
+ 		return ISC_R_INVALIDARG;
+ 
+--- dhcp-3.0.5/omapip/listener.c.warnings	2004-06-10 13:59:48.000000000 -0400
++++ dhcp-3.0.5/omapip/listener.c	2006-11-13 18:29:21.000000000 -0500
+@@ -68,12 +68,9 @@
+ 				omapi_addr_t *addr,
+ 				int max)
+ {
+-	struct hostent *he;
+-	int hix;
+ 	isc_result_t status;
+ 	omapi_listener_object_t *obj;
+ 	int i;
+-	struct in_addr ia;
+ 
+ 	/* Get the handle. */
+ 	obj = (omapi_listener_object_t *)0;
+@@ -200,8 +197,6 @@
+ 	SOCKLEN_T len;
+ 	omapi_connection_object_t *obj;
+ 	omapi_listener_object_t *listener;
+-	omapi_addr_t remote_addr;
+-	int i;
+ 	struct sockaddr_in addr;
+ 	int socket;
+ 
+@@ -223,7 +218,6 @@
+ 	/* If we're recording a trace, remember the connection. */
+ 	if (trace_record ()) {
+ 		trace_iov_t iov [3];
+-		u_int32_t lsock;
+ 		iov [0].buf = (char *)&amp;addr.sin_port;
+ 		iov [0].len = sizeof addr.sin_port;
+ 		iov [1].buf = (char *)&amp;addr.sin_addr;
+@@ -455,8 +449,6 @@
+ 					  omapi_object_t *id,
+ 					  omapi_object_t *l)
+ {
+-	int i;
+-
+ 	if (l -&gt; type != omapi_type_listener)
+ 		return ISC_R_INVALIDARG;
+ 
+--- dhcp-3.0.5/omapip/generic.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/generic.c	2006-11-13 18:29:21.000000000 -0500
+@@ -292,7 +292,6 @@
+ isc_result_t omapi_generic_clear_flags (omapi_object_t *o)
+ {
+ 	int i;
+-	isc_result_t status;
+ 	omapi_generic_object_t *g;
+ 
+ 	if (o -&gt; type != omapi_type_generic)
+--- dhcp-3.0.5/omapip/support.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/support.c	2006-11-13 18:29:21.000000000 -0500
+@@ -53,7 +53,6 @@
+ 
+ omapi_object_type_t *omapi_object_types;
+ int omapi_object_type_count;
+-static int ot_max;
+ 
+ #if defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
+ void omapi_type_relinquish ()
+@@ -298,7 +297,6 @@
+ isc_result_t omapi_signal_in (omapi_object_t *handle, const char *name, ...)
+ {
+ 	va_list ap;
+-	omapi_object_t *outer;
+ 	isc_result_t status;
+ 
+ 	if (!handle)
+@@ -368,7 +366,6 @@
+ 				  const char *name,
+ 				  omapi_typed_data_t *value)
+ {
+-	omapi_object_t *outer;
+ 	omapi_data_string_t *nds;
+ 	isc_result_t status;
+ 
+@@ -389,8 +386,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *n = (omapi_data_string_t *)0;
+-	int len;
+-	int ip;
+ 
+ 	status = omapi_data_string_new (&amp;n, strlen (name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+@@ -415,8 +410,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *n = (omapi_data_string_t *)0;
+-	int len;
+-	int ip;
+ 
+ 	status = omapi_data_string_new (&amp;n, strlen (name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+@@ -441,8 +434,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *n = (omapi_data_string_t *)0;
+-	int len;
+-	int ip;
+ 
+ 	status = omapi_data_string_new (&amp;n, strlen (name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+@@ -467,8 +458,6 @@
+ 	isc_result_t status;
+ 	omapi_typed_data_t *tv = (omapi_typed_data_t *)0;
+ 	omapi_data_string_t *n = (omapi_data_string_t *)0;
+-	int len;
+-	int ip;
+ 
+ 	status = omapi_data_string_new (&amp;n, strlen (name), MDL);
+ 	if (status != ISC_R_SUCCESS)
+--- dhcp-3.0.5/omapip/handle.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/handle.c	2006-11-13 18:29:21.000000000 -0500
+@@ -76,7 +76,6 @@
+ 
+ isc_result_t omapi_object_handle (omapi_handle_t *h, omapi_object_t *o)
+ {
+-	int tabix;
+ 	isc_result_t status;
+ 
+ 	if (o -&gt; handle) {
+@@ -285,7 +284,6 @@
+ isc_result_t omapi_handle_td_lookup (omapi_object_t **obj,
+ 				     omapi_typed_data_t *handle)
+ {
+-	isc_result_t status;
+ 	omapi_handle_t h;
+ 
+ 	if (handle -&gt; type == omapi_datatype_int)
+--- dhcp-3.0.5/omapip/message.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/omapip/message.c	2006-11-13 18:29:21.000000000 -0500
+@@ -209,8 +209,6 @@
+ isc_result_t omapi_message_destroy (omapi_object_t *h,
+ 				    const char *file, int line)
+ {
+-	int i;
+-
+ 	omapi_message_object_t *m;
+ 	if (h -&gt; type != omapi_type_message)
+ 		return ISC_R_INVALIDARG;
+@@ -261,8 +259,6 @@
+ 					 omapi_object_t *id,
+ 					 omapi_object_t *m)
+ {
+-	int i;
+-
+ 	if (m -&gt; type != omapi_type_message)
+ 		return ISC_R_INVALIDARG;
+ 
+--- dhcp-3.0.5/omapip/convert.c.warnings	2004-11-24 12:39:17.000000000 -0500
++++ dhcp-3.0.5/omapip/convert.c	2006-11-13 18:29:21.000000000 -0500
+@@ -165,7 +165,7 @@
+ 	u_int32_t number;
+ 	static char h2a [] = &quot;0123456789abcdef&quot;;
+ 	int power = converted_length (inbuf, base, width);
+-	int i, j;
++	int i;
+ 
+ 	if (base &gt; 16)
+ 		return 0;
+--- dhcp-3.0.5/omapip/hash.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/hash.c	2006-11-13 18:29:21.000000000 -0500
+@@ -81,8 +81,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int i;
+-	struct hash_bucket *hbc, *hbn = (struct hash_bucket *)0;
+ 	struct hash_table *ptr = *tp;
+ 
+ #if defined (DEBUG_MEMORY_LEAKAGE) || \
+@@ -175,7 +173,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	struct hash_bucket *hp;
+ #if defined (DEBUG_MALLOC_POOL)
+ 	for (hp = free_hash_buckets; hp; hp = hp -&gt; next) {
+ 		if (hp == ptr) {
+--- dhcp-3.0.5/omapip/array.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/array.c	2006-11-13 18:29:21.000000000 -0500
+@@ -46,7 +46,6 @@
+ 				   omapi_array_deref_t deref,
+ 				   const char *file, int line)
+ {
+-	isc_result_t status;
+ 	omapi_array_t *aptr;
+ 
+ 	if (!array || *array)
+@@ -63,7 +62,6 @@
+ isc_result_t omapi_array_free (omapi_array_t **array,
+ 			       const char *file, int line)
+ {
+-	isc_result_t status;
+ 	omapi_array_t *aptr;
+ 	int i;
+ 
+--- dhcp-3.0.5/omapip/trace.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/trace.c	2006-11-13 18:29:21.000000000 -0500
+@@ -312,7 +312,7 @@
+ 				   void (*stop_tracing) (trace_type_t *),
+ 				   const char *file, int line)
+ {
+-	trace_type_t *ttmp, *tptr;
++	trace_type_t *ttmp;
+ 	unsigned slen = strlen (name);
+ 	isc_result_t status;
+ 
+@@ -511,7 +511,6 @@
+ 	trace_type_t *ttype;
+ 	unsigned paylen;
+ 	int status;
+-	int len;
+ 	fpos_t curpos;
+ 
+ 	status = fgetpos (traceinfile, &amp;curpos);
+@@ -637,7 +636,6 @@
+ 	unsigned bufmax = 0;
+ 	unsigned buflen = 0;
+ 	char *buf = (char *)0;
+-	isc_result_t status;
+ 	time_t result;
+ 	trace_type_t *ttp;
+ 	
+--- dhcp-3.0.5/omapip/mrtrace.c.warnings	2004-09-30 16:23:07.000000000 -0400
++++ dhcp-3.0.5/omapip/mrtrace.c	2006-11-13 18:29:21.000000000 -0500
+@@ -85,7 +85,6 @@
+ 	unsigned buflen = 0;
+ 	char *buf = (char *)0;
+ 	isc_result_t status;
+-	u_int32_t id;
+ 	int i;
+ 
+ 	if (trace_playback ()) {
+@@ -412,7 +411,6 @@
+ 	isc_result_t status;
+ 
+ 	if (trace_playback ()) {
+-		int nscount;
+ 		status = trace_get_packet (&amp;trace_mr_randomid, &amp;buflen, &amp;buf);
+ 		if (status != ISC_R_SUCCESS) {
+ 			log_error (&quot;trace_mr_statp: no statp packet found.&quot;);
+--- dhcp-3.0.5/relay/dhcrelay.c.warnings	2006-04-27 17:38:30.000000000 -0400
++++ dhcp-3.0.5/relay/dhcrelay.c	2006-11-13 18:29:21.000000000 -0500
+@@ -734,7 +734,7 @@
+ 	unsigned length;
+ 	struct in_addr giaddr;
+ {
+-	int is_dhcp = 0, agent_options_present = 0;
++	int is_dhcp = 0;
+ 	unsigned optlen;
+ 	u_int8_t *op, *nextop, *sp, *max, *end_pad = NULL;
+ 
+--- dhcp-3.0.5/server/dhcpd.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/server/dhcpd.c	2006-11-13 18:29:21.000000000 -0500
+@@ -215,9 +215,6 @@
+ 	struct interface_info *ip;
+ 	struct parse *parse;
+ 	int lose;
+-	omapi_object_t *auth;
+-	struct tsig_key *key;
+-	omapi_typed_data_t *td;
+ 	int no_dhcpd_conf = 0;
+ 	int no_dhcpd_db = 0;
+ 	int no_dhcpd_pid = 0;
+@@ -976,7 +973,6 @@
+ 	   necessary. */
+ 	if (!ia) {
+ 		const char *fnn = &quot;fallback-net&quot;;
+-		char *s;
+ 		status = shared_network_allocate (&amp;ip -&gt; shared_network, MDL);
+ 		if (status != ISC_R_SUCCESS)
+ 			log_fatal (&quot;No memory for shared subnet: %s&quot;,
+--- dhcp-3.0.5/server/dhcp.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/server/dhcp.c	2006-11-13 18:29:21.000000000 -0500
+@@ -388,7 +388,6 @@
+ 	int ours = 0;
+ 	struct option_cache *oc;
+ 	struct data_string data;
+-	int status;
+ 	char msgbuf [1024]; /* XXX */
+ 	const char *s;
+ 	char smbuf [19];
+@@ -927,14 +926,13 @@
+ 	char msgbuf [1024];
+ 	struct data_string d1, prl;
+ 	struct option_cache *oc;
+-	struct expression *expr;
+ 	struct option_state *options = (struct option_state *)0;
+ 	struct dhcp_packet raw;
+ 	struct packet outgoing;
+ 	unsigned char dhcpack = DHCPACK;
+ 	struct subnet *subnet = (struct subnet *)0;
+ 	struct iaddr cip, gip;
+-	unsigned i, j;
++	unsigned i;
+ 	int nulltp;
+ 	struct sockaddr_in to;
+ 	struct in_addr from;
+@@ -1308,7 +1306,6 @@
+ 	unsigned i;
+ 	struct data_string data;
+ 	struct option_state *options = (struct option_state *)0;
+-	struct expression *expr;
+ 	struct option_cache *oc = (struct option_cache *)0;
+ 	struct iaddr myfrom;
+ 
+@@ -1514,15 +1511,11 @@
+ 	TIME max_lease_time;
+ 	TIME default_lease_time;
+ 	struct option_cache *oc;
+-	struct expression *expr;
+-	int status;
+ 	isc_result_t result;
+-	int did_ping = 0;
+ 	TIME ping_timeout;
+ 
+ 	unsigned i, j;
+-	int s1, s2;
+-	int val;
++	int s1;
+ 	int ignorep;
+ 
+ 	/* If we're already acking this lease, don't do it again. */
+@@ -2742,12 +2735,9 @@
+ 	struct in_addr from;
+ 	struct hardware hto;
+ 	int result;
+-	int i;
+ 	struct lease_state *state = lease -&gt; state;
+ 	int nulltp, bootpp, unicastp = 1;
+-	struct option_tag *ot, *not;
+ 	struct data_string d1;
+-	struct option_cache *oc;
+ 	const char *s;
+ 
+ 	if (!state)
+@@ -2968,7 +2958,6 @@
+ 	struct data_string d1;
+ 	int have_client_identifier = 0;
+ 	struct data_string client_identifier;
+-	int status;
+ 	struct hardware h;
+ 
+ 	/* Quick check to see if the peer has leases. */
+--- dhcp-3.0.5/server/confpars.c.warnings	2006-11-13 18:29:06.000000000 -0500
++++ dhcp-3.0.5/server/confpars.c	2006-11-13 18:29:21.000000000 -0500
+@@ -329,15 +329,12 @@
+ 	enum dhcp_token token;
+ 	const char *val;
+ 	struct shared_network *share;
+-	char *t, *n;
+-	struct expression *expr;
+-	struct data_string data;
++	char *n;
+ 	struct hardware hardware;
+ 	struct executable_statement *et, *ep;
+ 	struct option *option;
+ 	struct option_cache *cache;
+ 	int lose;
+-	struct data_string key_id;
+ 	int known;
+ 	isc_result_t status;
+ 
+@@ -927,7 +924,6 @@
+ 					    &quot;load balance settings.&quot;);
+ 			if (token != NUMBER) {
+ 				parse_warn (cfile, &quot;expecting number&quot;);
+-			      badsplit:
+ 				skip_to_rbrace (cfile, 1);
+ 				dhcp_failover_state_dereference (&amp;peer, MDL);
+ 				return;
+@@ -1538,8 +1534,6 @@
+ 
+ 	/* See if there's already a pool into which we can merge this one. */
+ 	for (pp = pool -&gt; shared_network -&gt; pools; pp; pp = pp -&gt; next) {
+-		struct lease *l;
+-
+ 		if (pp -&gt; group -&gt; statements != pool -&gt; group -&gt; statements)
+ 			continue;
+ #if defined (FAILOVER_PROTOCOL)
+@@ -1850,7 +1844,6 @@
+ 	char *name;
+ 	const char *tname;
+ 	struct executable_statement *stmt = (struct executable_statement *)0;
+-	struct expression *expr;
+ 	int new = 1;
+ 	isc_result_t status = ISC_R_FAILURE;
+ 
+@@ -2259,7 +2252,6 @@
+ 	unsigned char addr [4];
+ 	unsigned len = sizeof addr;
+ 	int declaration = 0;
+-	struct interface_info *ip;
+ 	isc_result_t status;
+ 
+ 	subnet = (struct subnet *)0;
+@@ -2553,8 +2545,6 @@
+ 	char tbuf [32];
+ 	struct lease *lease;
+ 	struct executable_statement *on;
+-	struct expression *exp;
+-	struct data_string ds;
+ 	int lose;
+ 	TIME t;
+ 	char *s;
+@@ -2980,7 +2970,6 @@
+ 
+ 			token = peek_token (&amp;val, (unsigned *)0, cfile);
+ 			if (token == STRING) {
+-			    unsigned char *tuid;
+ 			    token = next_token (&amp;val, &amp;buflen, cfile);
+ 			    binding -&gt; value -&gt; type = binding_data;
+ 			    binding -&gt; value -&gt; value.data.len = buflen;
+@@ -3137,7 +3126,6 @@
+ 	int dynamic = 0;
+ 	struct subnet *subnet;
+ 	struct shared_network *share;
+-	struct pool *p;
+ 	struct pool *pool;
+ 	isc_result_t status;
+ 
+--- dhcp-3.0.5/server/db.c.warnings	2006-07-19 12:45:30.000000000 -0400
++++ dhcp-3.0.5/server/db.c	2006-11-13 18:29:21.000000000 -0500
+@@ -56,7 +56,6 @@
+ 	struct tm *t;
+ 	char tbuf [64];
+ 	int errors = 0;
+-	int i;
+ 	struct binding *b;
+ 	char *s;
+ 
+@@ -199,7 +198,6 @@
+ 		}
+ 	}
+ 	if (lease -&gt; uid_len) {
+-		int i;
+ 		s = quotify_buf (lease -&gt; uid, lease -&gt; uid_len, MDL);
+ 		if (s) {
+ 			fprintf (db_file, &quot;\n  uid \&quot;%s\&quot;;&quot;, s);
+@@ -467,7 +465,6 @@
+ 	struct group_object *group;
+ {
+ 	int errors = 0;
+-	int i;
+ 
+ 	/* If the lease file is corrupt, don't try to write any more leases
+ 	   until we've written a good lease file. */
+@@ -625,8 +622,6 @@
+ {
+ 	struct collection *lp;
+ 	struct class *cp;
+-	struct hash_bucket *bp;
+-	int i;
+ 
+ 	for (lp = collections; lp; lp = lp -&gt; next) {
+ 	    for (cp = lp -&gt; classes; cp; cp = cp -&gt; nic) {
+--- dhcp-3.0.5/server/failover.c.warnings	2006-09-22 12:29:44.000000000 -0400
++++ dhcp-3.0.5/server/failover.c	2006-11-13 18:29:21.000000000 -0500
+@@ -57,7 +57,6 @@
+ {
+ 	dhcp_failover_state_t *state;
+ 	isc_result_t status;
+-	dhcp_failover_listener_t *l;
+ 
+ 	for (state = failover_states; state; state = state -&gt; next) {
+ 		dhcp_failover_state_transition (state, &quot;startup&quot;);
+@@ -174,7 +173,6 @@
+ {
+ 	isc_result_t status;
+ 	dhcp_failover_link_t *obj;
+-	omapi_value_t *value = (omapi_value_t *)0;
+ 	dhcp_failover_state_t *state;
+ 	omapi_object_t *o;
+ 	int i;
+@@ -276,8 +274,6 @@
+ 	isc_result_t status;
+ 	dhcp_failover_link_t *link;
+ 	omapi_object_t *c;
+-	u_int16_t nlen;
+-	u_int32_t vlen;
+ 	dhcp_failover_state_t *s, *state = (dhcp_failover_state_t *)0;
+ 
+ 	if (h -&gt; type != dhcp_type_failover_link) {
+@@ -591,7 +587,6 @@
+ 	unsigned op_size;
+ 	unsigned op_count;
+ 	int i;
+-	isc_result_t status;
+ 	
+ 	if (link -&gt; imsg_count + 2 &gt; link -&gt; imsg_len) {
+ 		log_error (&quot;FAILOVER: message overflow at option code.&quot;);
+@@ -1121,8 +1116,6 @@
+ 					   omapi_object_t *id,
+ 					   omapi_object_t *p)
+ {
+-	int i;
+-
+ 	if (p -&gt; type != dhcp_type_failover_listener)
+ 		return ISC_R_INVALIDARG;
+ 
+@@ -1182,11 +1175,8 @@
+ 					 const char *name, va_list ap)
+ {
+ 	isc_result_t status;
+-	omapi_connection_object_t *c;
+-	omapi_protocol_object_t *obj;
+ 	dhcp_failover_state_t *state;
+ 	dhcp_failover_link_t *link;
+-	char *peer_name;
+ 
+ 	if (!o || o -&gt; type != dhcp_type_failover_state)
+ 		return ISC_R_INVALIDARG;
+@@ -1831,7 +1821,6 @@
+ 	enum failover_state previous_state = state -&gt; partner.state;
+ 	enum failover_state new_state;
+ 	int startupp;
+-	isc_result_t status;
+ 
+ 	new_state = msg -&gt; server_state;
+ 	startupp = (msg -&gt; server_flags &amp; FTF_STARTUP) ? 1 : 0;
+@@ -2185,7 +2174,6 @@
+ 	struct lease *next = (struct lease *)0;
+ 	struct shared_network *s;
+ 	struct pool *p;
+-	int polarity;
+ 	binding_state_t peer_lease_state;
+ 	binding_state_t my_lease_state;
+ 	struct lease **lq;
+@@ -2328,7 +2316,6 @@
+ 
+ int dhcp_failover_state_pool_check (dhcp_failover_state_t *state)
+ {
+-	struct lease *lp;
+ 	struct shared_network *s;
+ 	struct pool *p;
+ 
+@@ -2647,7 +2634,7 @@
+ 
+ void dhcp_failover_keepalive (void *vs)
+ {
+-	dhcp_failover_state_t *state = vs;
++	return;
+ }
+ 
+ void dhcp_failover_reconnect (void *vs)
+@@ -2681,7 +2668,6 @@
+ void dhcp_failover_startup_timeout (void *vs)
+ {
+ 	dhcp_failover_state_t *state = vs;
+-	isc_result_t status;
+ 
+ #if defined (DEBUG_FAILOVER_TIMING)
+ 	log_info (&quot;dhcp_failover_startup_timeout&quot;);
+@@ -2693,7 +2679,6 @@
+ void dhcp_failover_link_startup_timeout (void *vl)
+ {
+ 	dhcp_failover_link_t *link = vl;
+-	isc_result_t status;
+ 	omapi_object_t *p;
+ 
+ 	for (p = (omapi_object_t *)link; p -&gt; inner; p = p -&gt; inner)
+@@ -3172,7 +3157,6 @@
+ int dhcp_failover_state_match (dhcp_failover_state_t *state,
+ 			       u_int8_t *addr, unsigned addrlen)
+ {
+-	struct option_cache *oc;
+ 	struct data_string ds;
+ 	int i;
+ 	
+@@ -3709,7 +3693,6 @@
+ 					omapi_object_t *connection,
+ 					int msg_type, ...)
+ {
+-	unsigned count = 0;
+ 	unsigned size = 0;
+ 	int bad_option = 0;
+ 	int opix = 0;
+@@ -3822,7 +3805,6 @@
+ {
+ 	dhcp_failover_state_t *state = vstate;
+ 	dhcp_failover_link_t *link;
+-	isc_result_t status;
+ 
+ #if defined (DEBUG_FAILOVER_TIMING)
+ 	log_info (&quot;dhcp_failover_timeout&quot;);
+@@ -3942,7 +3924,6 @@
+ 	dhcp_failover_link_t *link;
+ 	dhcp_failover_state_t *state;
+ 	isc_result_t status;
+-	char hba [32];
+ #if defined (DEBUG_FAILOVER_MESSAGES)	
+ 	char obuf [64];
+ 	unsigned obufix = 0;
+--- dhcp-3.0.5/server/omapi.c.warnings	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/server/omapi.c	2006-11-13 18:29:21.000000000 -0500
+@@ -208,7 +208,6 @@
+ {
+ 	struct lease *lease;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_lease)
+ 		return ISC_R_INVALIDARG;
+@@ -378,7 +377,6 @@
+ isc_result_t dhcp_lease_destroy (omapi_object_t *h, const char *file, int line)
+ {
+ 	struct lease *lease;
+-	isc_result_t status;
+ 
+ 	if (h -&gt; type != dhcp_type_lease)
+ 		return ISC_R_INVALIDARG;
+@@ -455,7 +453,6 @@
+ {
+ 	struct lease *lease;
+ 	isc_result_t status;
+-	int updatep = 0;
+ 
+ 	if (h -&gt; type != dhcp_type_lease)
+ 		return ISC_R_INVALIDARG;
+@@ -876,9 +873,8 @@
+ 				   omapi_data_string_t *name,
+ 				   omapi_typed_data_t *value)
+ {
+-	struct host_decl *host, *hp;
++	struct host_decl *host;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_host)
+ 		return ISC_R_INVALIDARG;
+@@ -1137,7 +1133,6 @@
+ isc_result_t dhcp_host_destroy (omapi_object_t *h, const char *file, int line)
+ {
+ 	struct host_decl *host;
+-	isc_result_t status;
+ 
+ 	if (h -&gt; type != dhcp_type_host)
+ 		return ISC_R_INVALIDARG;
+@@ -1558,7 +1553,6 @@
+ {
+ 	struct pool *pool;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_pool)
+ 		return ISC_R_INVALIDARG;
+@@ -1604,8 +1598,6 @@
+ isc_result_t dhcp_pool_destroy (omapi_object_t *h, const char *file, int line)
+ {
+ 	struct pool *pool;
+-	isc_result_t status;
+-	struct permit *pc, *pn;
+ 
+ 	if (h -&gt; type != dhcp_type_pool)
+ 		return ISC_R_INVALIDARG;
+@@ -1702,10 +1694,6 @@
+ isc_result_t dhcp_pool_lookup (omapi_object_t **lp,
+ 			       omapi_object_t *id, omapi_object_t *ref)
+ {
+-	omapi_value_t *tv = (omapi_value_t *)0;
+-	isc_result_t status;
+-	struct pool *pool;
+-
+ 	/* Can't look up pools yet. */
+ 
+ 	/* If we get to here without finding a pool, no valid key was
+@@ -1734,7 +1722,6 @@
+ {
+ 	struct class *class;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_class)
+ 		return ISC_R_INVALIDARG;
+@@ -1780,8 +1767,6 @@
+ isc_result_t dhcp_class_destroy (omapi_object_t *h, const char *file, int line)
+ {
+ 	struct class *class;
+-	isc_result_t status;
+-	int i;
+ 
+ 	if (h -&gt; type != dhcp_type_class &amp;&amp; h -&gt; type != dhcp_type_subclass)
+ 		return ISC_R_INVALIDARG;
+@@ -1881,10 +1866,6 @@
+ isc_result_t dhcp_class_lookup (omapi_object_t **lp,
+ 				omapi_object_t *id, omapi_object_t *ref)
+ {
+-	omapi_value_t *tv = (omapi_value_t *)0;
+-	isc_result_t status;
+-	struct class *class;
+-
+ 	/* Can't look up classs yet. */
+ 
+ 	/* If we get to here without finding a class, no valid key was
+@@ -1913,7 +1894,6 @@
+ {
+ 	struct subclass *subclass;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_subclass)
+ 		return ISC_R_INVALIDARG;
+@@ -2008,10 +1988,6 @@
+ isc_result_t dhcp_subclass_lookup (omapi_object_t **lp,
+ 				   omapi_object_t *id, omapi_object_t *ref)
+ {
+-	omapi_value_t *tv = (omapi_value_t *)0;
+-	isc_result_t status;
+-	struct subclass *subclass;
+-
+ 	/* Can't look up subclasss yet. */
+ 
+ 	/* If we get to here without finding a subclass, no valid key was
+--- dhcp-3.0.5/server/mdb.c.warnings	2006-07-18 14:16:25.000000000 -0400
++++ dhcp-3.0.5/server/mdb.c	2006-11-13 18:29:21.000000000 -0500
+@@ -238,7 +238,6 @@
+ 	struct host_decl *hp = (struct host_decl *)0;
+ 	struct host_decl *np = (struct host_decl *)0;
+ 	struct host_decl *foo;
+-	struct executable_statement *esp;
+ 	int hw_head = 0, uid_head = 1;
+ 
+ 	/* Don't need to do it twice. */
+@@ -373,7 +372,6 @@
+ 			 const unsigned char *haddr, unsigned hlen,
+ 			 const char *file, int line)
+ {
+-	struct host_decl *foo;
+ 	struct hardware h;
+ 
+ 	h.hlen = hlen + 1;
+@@ -403,7 +401,6 @@
+ 			   struct iaddr *addr, struct shared_network *share)
+ {
+ 	int i;
+-	struct subnet *subnet;
+ 	struct iaddr ip_address;
+ 	struct host_decl *hp;
+ 	struct data_string fixed_addr;
+@@ -453,12 +450,11 @@
+ 	struct pool *pool;
+ 	struct lease **lpchain;
+ {
+-	struct lease *address_range, *lp, *plp;
++	struct lease *address_range;
+ 	struct iaddr net;
+ 	unsigned min, max, i;
+ 	char lowbuf [16], highbuf [16], netbuf [16];
+ 	struct shared_network *share = subnet -&gt; shared_network;
+-	isc_result_t status;
+ 	struct lease *lt = (struct lease *)0;
+ 
+ 	/* All subnets should have attached shared network structures. */
+@@ -745,7 +741,6 @@
+ 	struct lease *lease;
+ {
+ 	struct lease *comp = (struct lease *)0;
+-	isc_result_t status;
+ 
+ 	if (find_lease_by_ip_addr (&amp;comp, lease -&gt; ip_addr, MDL)) {
+ 		if (!comp -&gt; pool) {
+@@ -795,7 +790,6 @@
+ 	int enter_uid = 0;
+ 	int enter_hwaddr = 0;
+ 	struct lease *lp, **lq, *prev;
+-	TIME lp_next_state;
+ 
+ #if defined (FAILOVER_PROTOCOL)
+ 	/* We must commit leases before sending updates regarding them
+@@ -1475,7 +1469,6 @@
+ 	void *vpool;
+ {
+ 	struct pool *pool;
+-	struct lease *lt = (struct lease *)0;
+ 	struct lease *next = (struct lease *)0;
+ 	struct lease *lease = (struct lease *)0;
+ 	struct lease **lptr [5];
+@@ -2013,7 +2006,6 @@
+ {
+ 	struct shared_network *s;
+ 	struct pool *p;
+-	struct hash_bucket *hb;
+ 	int i;
+ 	struct lease *l;
+ 	struct lease **lptr [5];
+--- dhcp-3.0.5/server/ddns.c.warnings	2005-03-03 11:55:24.000000000 -0500
++++ dhcp-3.0.5/server/ddns.c	2006-11-13 18:29:21.000000000 -0500
+@@ -224,7 +224,6 @@
+ 	struct data_string ddns_fwd_name;
+ 	struct data_string ddns_rev_name;
+ 	struct data_string ddns_dhcid;
+-	unsigned len;
+ 	struct data_string d1;
+ 	struct option_cache *oc;
+ 	int s1, s2;
+@@ -659,7 +658,6 @@
+ 	struct data_string ddns_rev_name;
+ 	struct data_string ddns_dhcid;
+ 	isc_result_t rcode;
+-	struct binding *binding;
+ 	int result = 0;
+ 	int client_updated = 0;
+ 

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-includes.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-includes.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-includes.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,64 @@
+--- dhcp-3.0.5/includes/omapip/omapip.h.includes	2004-06-10 13:59:39.000000000 -0400
++++ dhcp-3.0.5/includes/omapip/omapip.h	2006-11-10 11:52:28.000000000 -0500
+@@ -251,12 +251,12 @@
+ 		     omapi_array_foreach_index++) {			      \
+ 			if ((array) -&gt; data [omapi_array_foreach_index]) {    \
+ 				((*(array) -&gt; ref)			      \
+-				 ((char **)&amp;var,			      \
++				 ((void*)&amp;var,			              \
+ 				  (array) -&gt; data [omapi_array_foreach_index],\
+ 				  MDL));
+ 
+ #define	omapi_array_foreach_end(array, stype, var)			      \
+-				(*(array) -&gt; deref) ((char **)&amp;var, MDL);     \
++				(*(array) -&gt; deref) ((void*)&amp;var, MDL);       \
+ 			}						      \
+ 		}							      \
+ 	}
+--- dhcp-3.0.5/includes/dhcpd.h.includes	2006-11-10 11:52:08.000000000 -0500
++++ dhcp-3.0.5/includes/dhcpd.h	2006-11-10 11:52:21.000000000 -0500
+@@ -667,7 +667,8 @@
+ 	S_BOUND = 5,
+ 	S_RENEWING = 6,
+ 	S_REBINDING = 7,
+-	S_STOPPED = 8
++	S_STOPPED = 8,
++	S_DECLINED = 9
+ };
+ 
+ /* Authentication and BOOTP policy possibilities (not all values work
+@@ -730,6 +731,8 @@
+ 	int do_forward_update;		/* If nonzero, and if we have the
+ 					   information we need, update the
+ 					   A record for the address we get. */
++	int bootp_broadcast_always;	/* If nonzero, always set the BOOTP_BROADCAST
++								flag in requests */
+ };
+ 
+ /* Per-interface state used in the dhcp client... */
+@@ -1818,6 +1821,13 @@
+ extern void *lookup_new_option_info(struct option *);
+ #endif
+ 
++#ifdef EXTENDED_NEW_OPTION_INFO
++#define GENERATE_NEW_OPTION_INFO ((void*)1)
++extern void *new_option_info_tree;
++extern void *add_new_option_info(struct option*);
++extern void *lookup_new_option_info(struct option *);
++#endif 
++
+ /* stables.c */
+ #if defined (FAILOVER_PROTOCOL)
+ extern failover_option_t null_failover_option;
+--- dhcp-3.0.5/includes/dhctoken.h.includes	2005-09-22 12:19:57.000000000 -0400
++++ dhcp-3.0.5/includes/dhctoken.h	2006-11-10 11:52:25.000000000 -0500
+@@ -309,7 +309,8 @@
+ 	DOMAIN_NAME = 613,
+ 	DO_FORWARD_UPDATE = 614,
+ 	KNOWN_CLIENTS = 615,
+-	ATSFP = 616
++	ATSFP = 616,
++	BOOTP_BROADCAST_ALWAYS=617
+ };
+ 
+ #define is_identifier(x)	((x) &gt;= FIRST_TOKEN &amp;&amp;	\

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-ldap-patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-ldap-patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-ldap-patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,5699 @@
+diff -Naur dhcp-3.0.5/Changelog-LDAP dhcp-3.0.5-ldap/Changelog-LDAP
+--- dhcp-3.0.5/Changelog-LDAP	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/Changelog-LDAP	2007-02-23 14:06:33.000000000 -0500
+@@ -0,0 +1,251 @@
++2007-2-23 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* contrib/dhcpd-conf-to-ldap.pl - fixed a parsing bug in which
++	didn't handle correctly quoted string containing spaces.
++	(Rapha?l Luta &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">raphael.luta at aptiwan.com</A>&gt;)
++
++	* dst/Makefile.dist server/Makefile.dist site.conf - updated build
++	method when using -lssl.
++	(from Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;)
++
++	* server/ldap.c - fix for ldap_read_function to avoid returning
++	empty strings (skipped host declaration from ldap) that are causing
++	parsing errors in ldap-dynamic mode.
++	(from Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;)
++
++	* includes/dhcpd.h README.ldap server/dhcpd.c server/ldap.c
++	server/stables.c - added ldap-ssl &lt;off|start_tls|ldaps|on&gt; option and
++        several ldap-tls* options, that are described in the &quot;man ldap.conf&quot;.
++	(from Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;)
++
++	* includes/dhcpd.h server/ldap.c server/stables.c - added ldap-referrals
++	&lt;on|off&gt; option. Also implemented a LDAP rebuind function
++	(from Kalyan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">skalyanasundaram at novell.com</A>&gt;)
++
++	* includes/dhcpd.h server/ldap.c server/stables.c - renamed dhcpd.conf
++	option ldap-server-cn to ldap-dhcp-server-cn
++	(from Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;)
++
++	* contrib/dhcp.schema - schema updates 
++	(from Kalyan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">skalyanasundaram at novell.com</A>&gt;)
++
++	* server/ldap.c server/ldap_casa.c - CASA support fixes
++	(from Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;)
++
++	* server/ldap.c - added strncat() fix
++	(from Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;)
++
++2006-12-15 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_read_config) - unbind from the LDAP server after
++	the config file has been ran if the server is being ran in static mode
++	(from Tomas Hoger &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">thoger at pobox.sk</A>&gt;)
++
++	* server/ldap.c (ldap_read_function) - fixed bug where the entire
++	configuration was not being processed in the LDAP directory.
++
++	* server/ldap.c - added the following functions for reading values
++	from the config file: _do_lookup_dhcp_string_option(),
++	_do_lookup_dhcp_int_option() and _do_lookup_dhcp_enum_option(). This
++	helped to clean up ldap_start() start a bit. Also, various small
++	formatting changes to the code.
++
++2006-12-15 Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;
++	* Changelog-LDAP - Added / changed some of entries in
++	Changelog-LDAP, e.g.  changes to the dhcpServer and
++	dhcpService objectclasses in schema file was not mentioned.
++
++        * server/ldap.c Some a little bit paranoid checks to strchr results
++	in the group patch, avoided allocation of groupname using snprintf
++	with a &quot;%.*s&quot; format.
++
++        * server/ldap.c - Readded FIXME comment about one space in
++	dhcpHWAddress.
++
++        * server/ldap.c Changed &quot;dhcpdnsZone&quot; and &quot;dhcpdnszoneServer&quot; into
++	&quot;dhcpDnsZone&quot; and &quot;dhcpDnsZoneServer&quot;.
++
++        * Fixed memory leak in ldap_parse_zone (dfree of keyCn), added checks
++	for dmalloc and strchr results.
++
++	* ldap_casa.c, ldap_casa.h - surrounded content of ldap_casa.h and
++	ldap_casa.c with if defined(LDAP_CASA_AUTH).
++
++	* contrib/dhcp.schema  - Reverted the equality change for dhcpOption.
++	The dhcp options are case-insensitive in dhcpd.conf.
++
++	* Changed &quot;dhcpdnsZone&quot; and &quot;dhcpdnszoneServer&quot; into &quot;dhcpDnsZone&quot;
++	and &quot;dhcpDnsZoneServer&quot;.
++
++	* Changed &quot;FQDNs&quot; into &quot;DNs&quot; in dhcpLocatorDN description (DN is already
++	absolute, RDN is relative DN, FQDN means a full qualified domain name).
++
++2006-12-15 Kalyan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">skalyanasundaram at novell.com</A>&gt;
++	* includes/ldap_casa.h server/ldap_casa.c - updated to support CASA
++	1.7
++
++2006-8-15 Kalyan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">skalyanasundaram at novell.com</A>&gt;
++	* server/ldap.c (ldap_parse_options) - fetch option from the group
++	if the host belongs to that group in the dynamic method.
++
++	* contrib/dhcp.schema - modified dhcpServiceDN attribute in dhcpServer
++	objectclasses to be optional instead of mandatory
++
++	* contrib/dhcp.schema - modified dhcpPrimaryDN attribute in dhcpService
++	objectclasses to be optional instead of mandatory
++
++	* contrib/dhcp.schema - schema has been updated with
++	new objectclasses dhcpLocator,dhcpTsigKey,dhcpdnsZone,dhcpFailOver and
++	many attributes.
++
++	* contrib/dhcp.schema - dhcpHWAddress's equality has been modified to
++	caseIgnoreIA5Match.
++
++	* server/ldap.c - added support for reading the dhcpTsigKey and
++	dhcpdnsZone objects. 
++
++	* server/ldap.c (ldap_parse_options) Fetch option from the group if
++	the host belongs to that group in the dynamic method.
++
++	* server/ldap.c - CASA authentication is enabled.
++
++	* server/ldap.c - introduced new attribute ldap-server-cn to mention
++	the dhcpServer object name in configuration.
++
++2006-7-17 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_read_function) - fixes for reading the data
++	from the LDAP tree in some cases (patch from
++	Darrin Smith &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">beldin at beldin.org</A>&gt;)
++
++2006-3-17 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_read_function) - added patch from 
++	Dmitriy Bogun &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">kabanyura at gmail.com</A>&gt;. This patch fixes a bug when
++	EOF wasn't returned in some cases.
++
++2005-9-26 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_start) - added support for reading the
++	ldap-port option. This option was not being used.
++
++2005-5-24 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_parse_host) - allow dhcpHost entries that do
++	not have a hardware address associated with them
++
++2005-4-11 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* README.ldap - updated directions on how to use LDAP over SSL on
++	non-Linux machines
++
++2005-2-23 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_generate_config_string) - do a case insensitive
++	string comparsion when comparing the object classes
++
++2004-11-8 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* debian/control - updated the depends and build-depends line
++	(from Andrew Pollock &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">me at andrew.net.au</A>&gt;)
++
++2004-10-13 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c (ldap_start) - allow doing an anonymous bind to the
++	LDAP server
++
++2004-9-27 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* contrib/dhcpd-conf-to-ldap.pl - make sure the DHCP hardware address
++	is always lowercased
++
++2004-7-30 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c - added more debbuging statements. Fixed possible crash
++	that could occur whenever more than 1 external DN is added to an LDAP
++	entry. Fixed possible infinite loop when reading the external DNs.
++	(from Sebastian Hetze &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">s.hetze at linux-ag.de</A>&gt;)
++
++2004-7-1 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* README.ldap - updated build instructions paragraph
++	(from Mason Schmitt &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sysadmin at sunwave.net</A>&gt;)
++
++2004-6-29 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* debian/control - set the minimum required version of the DHCP server
++	to be 3.0.1rc9
++
++	* configure - fix for sed when configure was run from an older shell
++
++2004-6-22 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* Updated patch to use ISC DHCP 3.0.1rc14
++
++2004-5-24 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c - don't append a ; to the end of a dhcpStatement if it
++	ends in }
++
++	* server/ldap.c contrib/dhcpd-conf-to-ldap.pl - support having multiple
++	dhcpRange statements (from Marco D'Ettorre &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">marco.dettorre at sys-net.it</A>&gt;)
++
++2004-5-5 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* server/ldap.c - added more debugging statements when
++	it is compiled in to help troubleshoot parsing errors. Don't free
++	a LDAP connection prematurely when there is a reference to another
++	LDAP tree. If the config entry ends in }, make sure a ; gets tacked
++	on
++
++	* debian/* - Updated version number. Renamed package from
++	dhcp3-ldap-ntelos to dhcp3-server-ldap.
++
++	* server/ldap.c - enclose the shared-network name in quotes so
++	that there can be shared network statements in LDAP that have spaces
++	in them
++
++	* configure - after the work directory is setup, add -lldap -llber
++	to the server Makefile
++
++Wed Apr 21 15:09:08 CEST 2004 - <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>
++	* contrib/dhcpd-conf-to-ldap.pl:
++	  - added &quot;--conf=file&quot; option usable instead of stdin
++	  - added &quot;--ldif=file&quot; option usable instead of stdout
++	  - added &quot;--second=host|dn&quot; option usefull for failover
++	  - added &quot;--use=feature&quot; option to enable extended features;
++	    currently used to enable failover (default is disabled).
++	  - extended remaining_line() to support block statements
++	  - fixed / improved failover support, added notes about
++
++	* server/ldap.c:
++	  - moved code checking statement ends to check_statement_end()
++	  - moved parsing of entry options/statements to
++	    ldap_parse_entry_options()
++	  - moved code closing debug fd into ldap_close_debug_fd()
++	  - moved code writing to debug fd into ldap_write_debug()
++	  - added support for full hostname in dhcpServer search filter
++	  - added support for multiple dhcpService entries in dhcpServer object
++	  - added parsing of options and statements for dhcpServer object
++	  - added verify if dhcpService contains server dn as primary or
++	    secondary
++	  - changed to search for dhcpHost,dhcpSubClass bellow of all
++	    dhcpService trees instead of base-dn (avoids finding of hosts in
++	    foreign configs)
++	  - fixes to free all dn's fetched by ldap_get_dn (e.g. debug output)
++	  - fixes to free ldap results, mainly in cases where no LDAP_SUCCESS
++	    returned or other error conditions happened
++	  - fixed/improved some log messages
++
++2004-3-30 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* contrib/dhcpd-conf-to-ldap.pl - added option to control the
++	DHCP Config DN. Wrap the DHCP Statements in { }
++	This patch was contributed by Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;
++
++	* server/ldap.c - changed ldap_username and ldap_password to
++	be optional (anonymous bind is used then). Added {} block support
++	to dhcpStatements. (no &quot;;&quot; at end if statement ends with a &quot;}&quot;).
++	Fixed writing to ldap-debug-file. Changed find_haddr_in_ldap() to
++	use dhcpHost objectClass in its filter
++	This patch was contributed by Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;
++
++2004-3-23 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* contrib/dhcpd-conf-to-ldap.pl - added options for server, basedn
++	options and usage message (Net::Domain instead of SYS::Hostname).
++	Added handling of zone, authoritative and failover (config and
++	pool-refs) statements. Added numbering of groups and pools per
++	subnet. This patch was contributed by Marius Tomaschewski &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mt at suse.de</A>&gt;
++
++2004-2-26 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* fixed an instance where the LDAP server would restart, but the DHCP
++	server would not reconnect
++
++2004-2-18 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* allow multiple dhcp*DN entries in the LDAP entry.
++
++2003-9-11 Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++	* updated patch to work with 3.0.1rc12
++
+diff -Naur dhcp-3.0.5/README.ldap dhcp-3.0.5-ldap/README.ldap
+--- dhcp-3.0.5/README.ldap	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/README.ldap	2007-02-23 13:13:36.000000000 -0500
+@@ -0,0 +1,190 @@
++LDAP Support in DHCP
++Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++Last updated 3/23/2003
++
++This document describes setting up the DHCP server to read it's configuration 
++from LDAP. This work is based on the IETF document 
++draft-ietf-dhc-ldap-schema-01.txt included in the doc directory. For the latest
++version of this document, please see <A HREF="http://home.ntelos.net/~masneyb.">http://home.ntelos.net/~masneyb.</A>
++
++First question on most people's mind is &quot;Why do I want to store my 
++configuration in LDAP?&quot; If you run a small DHCP server, and the configuration
++on it rarely changes, then you won't need to store your configuration in LDAP.
++But, if you have several DHCP servers, and you want an easy way to manage your 
++configuration, this can be a solution. 
++
++The first step will be to setup your LDAP server. I am using OpenLDAP from
++www.openldap.org. Building and installing OpenLDAP is beyond the scope of this 
++document. There is plenty of documentation out there about this. Once you have 
++OpenLDAP installed, you will have to edit your slapd.conf file. I added the 
++following 2 lines to my configuration file:
++
++include         /etc/ldap/schema/dhcp.schema
++index           dhcpHWAddress 	eq
++index           dhcpClassData	eq
++
++The first line tells it to include the dhcp schema file. You will find this 
++file under the contrib directory in this distribution. You will need to copy 
++this file to where your other schema files are (maybe
++/usr/local/openldap/etc/openldap/schema/). The second line sets up
++an index for the dhcpHWAddress parameter. The third parameter is for reading 
++subclasses from LDAP every time a DHCP request comes in. Make sure you run the 
++slapindex command and restart slapd to have these changes to into effect.
++
++Now that you have LDAP setup, you should be able to use gq (<A HREF="http://biot.com/gq/">http://biot.com/gq/</A>)
++to verify that the dhcp schema file is loaded into LDAP. Pull up gq, and click
++on the Schema tab. Go under objectClasses, and you should see at least the 
++following object classes listed: dhcpClass, dhcpGroup, dhcpHost, dhcpOptions, 
++dhcpPool, dhcpServer, dhcpService, dhcpSharedNetwork, dhcpSubClass, and 
++dhcpSubnet. If you do not see these, you need to check over your LDAP 
++configuration before you go any further.
++
++You should now be ready to build DHCP. If you would like to enable LDAP over
++SSL, you will need to perform the following steps:
++
++  * Edit the includes/site.h file and uncomment the USE_SSL line
++    or specify &quot;-DUSE_SSL&quot; via CFLAGS.
++  * Edit the dst/Makefile.dist file and remove md5_dgst.c and md5_dgst.o
++    from the SRC= and OBJ= lines (around line 24)
++  * Now run configure in the base source directory. If you chose to enable
++    LDAP over SSL, you must append -lcrypto -lssl to the LIBS= line in the file
++    work.os/server/Makefile (replace os with your operating system, linux-2.2 on
++    my machine).  You should now be able to type make to build your DHCP server.
++
++If you choose to not enable LDAP over SSL, then you only need to run configure
++and make in the toplevel source directory.
++
++Once you have DHCP installed, you will need to setup your initial plaintext 
++config file. In my /etc/dhcpd.conf file, I have:
++
++ldap-server &quot;localhost&quot;;
++ldap-port 389;
++ldap-username &quot;cn=DHCP User, dc=ntelos, dc=net&quot;;
++ldap-password &quot;blah&quot;;
++ldap-base-dn &quot;dc=ntelos, dc=net&quot;;
++ldap-method dynamic;
++ldap-debug-file &quot;/var/log/dhcp-ldap-startup.log&quot;;
++
++If SSL has been enabled at compile time using the USE_SSL flag, the dhcp
++server trys to use TLS if possible, but continues without TLS if not.
++
++You can modify this behaviour using following option in /etc/dhcpd.conf:
++
++ldap-ssl &lt;off | ldaps | start_tls | on&gt;
++   off:       disables TLS/LDAPS.
++   ldaps:     enables LDAPS -- don't forget to set ldap-port to 636.
++   start_tls: enables TLS using START_TLS command
++   on:        enables LDAPS if ldap-port is set to 636 or TLS in 
++              other cases.
++
++See also &quot;man 5 ldap.conf&quot; for description the following TLS related 
++options:
++   ldap-tls-reqcert, ldap-tls-ca-file, ldap-tls-ca-dir, ldap-tls-cert
++   ldap-tls-key, ldap-tls-crlcheck, ldap-tls-ciphers, ldap-tls-randfile
++
++All of these parameters should be self explanatory except for the ldap-method.
++You can set this to static or dynamic. If you set it to static, the 
++configuration is read once on startup, and LDAP isn't used anymore. But, if you
++set this to dynamic, the configuration is read once on startup, and the 
++hosts that are stored in LDAP are looked up every time a DHCP request comes in.
++
++When the optional statement ldap-debug-file is specified, on startup the DHCP
++server will write out the configuration that it generated from LDAP. If you are
++getting errors about your LDAP configuration, this is a good place to start
++looking.
++
++The next step is to set up your LDAP tree. Here is an example config that will
++give a 10.100.0.x address to machines that have a host entry in LDAP. 
++Otherwise, it will give a 10.200.0.x address to them. (NOTE: replace 
++dc=ntelos, dc=net with your base dn). If you would like to convert your 
++existing dhcpd.conf file to LDIF format, there is a script 
++contrib/dhcpd-conf-to-ldap.pl that will convert it for you. Type
++dhcpd-conf-to-ldap.pl --help to see the usage information for this script.
++
++# You must specify the server's host name in LDAP that you are going to run
++# DHCP on and point it to which config tree you want to use. Whenever DHCP 
++# first starts up, it will do a search for this entry to find out which 
++# config to use
++dn: cn=brian.ntelos.net, dc=ntelos, dc=net
++objectClass: top
++objectClass: dhcpServer
++cn: brian.ntelos.net
++dhcpServiceDN: cn=DHCP Service Config, dc=ntelos, dc=net
++
++# Here is the config tree that brian.ntelos.net points to. 
++dn: cn=DHCP Service Config, dc=ntelos, dc=net
++cn: DHCP Service Config
++objectClass: top
++objectClass: dhcpService
++dhcpPrimaryDN: dc=ntelos, dc=net
++dhcpStatements: ddns-update-style none
++dhcpStatements: default-lease-time 600
++dhcpStatements: max-lease-time 7200
++
++# Set up a shared network segment
++dn: cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: WV
++objectClass: top
++objectClass: dhcpSharedNetwork
++
++# Set up a subnet declaration with a pool statement. Also note that we have
++# a dhcpOptions object with this entry
++dn: cn=10.100.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: 10.100.0.0
++objectClass: top
++objectClass: dhcpSubnet
++objectClass: dhcpOptions
++dhcpOption: domain-name-servers 10.100.0.2
++dhcpOption: routers 10.100.0.1
++dhcpOption: subnet-mask 255.255.255.0
++dhcpOption: broadcast-address 10.100.0.255
++dhcpNetMask: 24
++
++# Set up a pool for this subnet. Only known hosts will get these IPs
++dn: cn=Known Pool, cn=10.100.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: Known Pool
++objectClass: top
++objectClass: dhcpPool
++dhcpRange: 10.100.0.3 10.100.0.254
++dhcpPermitList: deny unknown-clients
++
++# Set up another subnet declaration with a pool statement
++dn: cn=10.200.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: 10.200.0.0
++objectClass: top
++objectClass: dhcpSubnet
++objectClass: dhcpOptions
++dhcpOption: domain-name-servers 10.200.0.2
++dhcpOption: routers 10.200.0.1
++dhcpOption: subnet-mask 255.255.255.0
++dhcpOption: broadcast-address 10.200.0.255
++dhcpNetMask: 24
++
++# Set up a pool for this subnet. Only unknown hosts will get these IPs
++dn: cn=Known Pool, cn=10.200.0.0, cn=WV Test, cn=DHCP Service Config, dc=ntelos, dc=net
++cn: Known Pool
++objectClass: top
++objectClass: dhcpPool
++dhcpRange: 10.200.0.3 10.200.0.254
++dhcpPermitList: deny known clients
++
++# Set aside a group for all of our known MAC addresses
++dn: cn=Customers, cn=DHCP Service Config, dc=ntelos, dc=net
++objectClass: top
++objectClass: dhcpGroup
++cn: Customers
++
++# Host entry for my laptop
++dn: cn=brianlaptop, cn=Customers, cn=DHCP Service Config, dc=ntelos, dc=net
++objectClass: top
++objectClass: dhcpHost
++cn: brianlaptop
++dhcpHWAddress: ethernet 00:00:00:00:00:00
++
++You can use the command slapadd to load all of these entries into your LDAP 
++server. After you load this, you should be able to start up DHCP. If you run
++into problems reading the configuration, try running dhcpd with the -d flag. 
++If you still have problems, edit the site.conf file in the DHCP source and
++add the line: COPTS= -DDEBUG_LDAP and recompile DHCP. (make sure you run make 
++clean and rerun configure before you rebuild).
++
+diff -Naur dhcp-3.0.5/common/conflex.c dhcp-3.0.5-ldap/common/conflex.c
+--- dhcp-3.0.5/common/conflex.c	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5-ldap/common/conflex.c	2006-12-14 10:03:41.000000000 -0500
+@@ -47,6 +47,7 @@
+ static enum dhcp_token read_number PROTO ((int, struct parse *));
+ static enum dhcp_token read_num_or_name PROTO ((int, struct parse *));
+ static enum dhcp_token intern PROTO ((char *, enum dhcp_token));
++static int read_function PROTO ((struct parse *));
+ 
+ isc_result_t new_parse (cfile, file, inbuf, buflen, name, eolp)
+ 	struct parse **cfile;
+@@ -74,6 +75,10 @@
+ 	tmp -&gt; file = file;
+ 	tmp -&gt; eol_token = eolp;
+ 
++	if (file != -1) {
++		tmp -&gt; read_function = read_function;;
++	}
++
+ 	tmp -&gt; bufix = 0;
+ 	tmp -&gt; buflen = buflen;
+ 	if (inbuf) {
+@@ -113,22 +118,11 @@
+ 	int c;
+ 
+ 	if (cfile -&gt; bufix == cfile -&gt; buflen) {
+-		if (cfile -&gt; file != -1) {
+-			cfile -&gt; buflen =
+-				read (cfile -&gt; file,
+-				      cfile -&gt; inbuf, cfile -&gt; bufsiz);
+-			if (cfile -&gt; buflen == 0) {
+-				c = EOF;
+-				cfile -&gt; bufix = 0;
+-			} else if (cfile -&gt; buflen &lt; 0) {
+-				c = EOF;
+-				cfile -&gt; bufix = cfile -&gt; buflen = 0;
+-			} else {
+-				c = cfile -&gt; inbuf [0];
+-				cfile -&gt; bufix = 1;
+-			}
+-		} else
++		if (cfile -&gt; read_function) {
++			c = cfile -&gt; read_function (cfile);
++		} else {
+ 			c = EOF;
++		}
+ 	} else {
+ 		c = cfile -&gt; inbuf [cfile -&gt; bufix];
+ 		cfile -&gt; bufix++;
+@@ -1128,3 +1122,25 @@
+ 	}
+ 	return dfv;
+ }
++
++
++static int
++read_function (struct parse * cfile)
++{
++  int c;
++
++	cfile -&gt; buflen = read (cfile -&gt; file, cfile -&gt; inbuf, cfile -&gt; bufsiz);
++	if (cfile -&gt; buflen == 0) {
++		c = EOF;
++		cfile -&gt; bufix = 0;
++	} else if (cfile -&gt; buflen &lt; 0) {
++		c = EOF;
++		cfile -&gt; bufix = cfile -&gt; buflen = 0;
++	} else {
++		c = cfile -&gt; inbuf [0];
++		cfile -&gt; bufix = 1;
++	}
++
++	return c;
++}
++
+diff -Naur dhcp-3.0.5/common/print.c dhcp-3.0.5-ldap/common/print.c
+--- dhcp-3.0.5/common/print.c	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5-ldap/common/print.c	2006-12-14 10:03:41.000000000 -0500
+@@ -166,9 +166,9 @@
+ }
+ 
+ char *print_hw_addr (htype, hlen, data)
+-	int htype;
+-	int hlen;
+-	unsigned char *data;
++	const int htype;
++	const int hlen;
++	const unsigned char *data;
+ {
+ 	static char habuf [49];
+ 	char *s;
+diff -Naur dhcp-3.0.5/contrib/dhcp.schema dhcp-3.0.5-ldap/contrib/dhcp.schema
+--- dhcp-3.0.5/contrib/dhcp.schema	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/contrib/dhcp.schema	2007-02-23 12:53:22.000000000 -0500
+@@ -0,0 +1,462 @@
++attributetype ( 2.16.840.1.113719.1.203.4.1 
++	NAME 'dhcpPrimaryDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The DN of the dhcpServer which is the primary server for the configuration.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.2 
++	NAME 'dhcpSecondaryDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The DN of dhcpServer(s) which provide backup service for the configuration.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.3 
++	NAME 'dhcpStatements' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Flexible storage for specific data depending on what object this exists in. Like conditional statements, server parameters, etc. This allows the standard to evolve without needing to adjust the schema.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.4 
++	NAME 'dhcpRange' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'The starting &amp; ending IP Addresses in the range (inclusive), separated by a hyphen; if the range only contains one address, then just the address can be specified with no hyphen.  Each range is defined as a separate value.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.5 
++	NAME 'dhcpPermitList' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This attribute contains the permit lists associated with a pool. Each permit list is defined as a separate value.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.6 
++	NAME 'dhcpNetMask' 
++	EQUALITY integerMatch
++	DESC 'The subnet mask length for the subnet.  The mask can be easily computed from this length.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.7 
++	NAME 'dhcpOption' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Encoded option values to be sent to clients.  Each value represents a single option and contains (OptionTag, Length, OptionValue) encoded in the format used by DHCP.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.8 
++	NAME 'dhcpClassData' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Encoded text string or list of bytes expressed in hexadecimal, separated by colons.  Clients match subclasses based on matching the class data with the results of match or spawn with statements in the class name declarations.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.9 
++	NAME 'dhcpOptionsDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of the dhcpOption objects containing the configuration options provided by the server.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.10 
++	NAME 'dhcpHostDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'the distinguished name(s) of the dhcpHost objects.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 ) 
++
++attributetype ( 2.16.840.1.113719.1.203.4.11 
++	NAME 'dhcpPoolDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of pools.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.12 
++	NAME 'dhcpGroupDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s)   of the groups.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.13 
++	NAME 'dhcpSubnetDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of the subnets.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.14 
++	NAME 'dhcpLeaseDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name of a client address.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE)
++
++attributetype ( 2.16.840.1.113719.1.203.4.15 
++	NAME 'dhcpLeasesDN' 
++	DESC 'The distinguished name(s) client addresses.' 
++	EQUALITY distinguishedNameMatch
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.16 
++	NAME 'dhcpClassesDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of a class(es) in a subclass.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.17 
++	NAME 'dhcpSubclassesDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of subclass(es).' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.18 
++	NAME 'dhcpSharedNetworkDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name(s) of sharedNetworks.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.19 
++	NAME 'dhcpServiceDN' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The DN of dhcpService object(s)which contain the configuration information. Each dhcpServer object has this attribute identifying the DHCP configuration(s) that the server is associated with.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.20 
++	NAME 'dhcpVersion'
++	DESC 'The version attribute of this object.'
++	EQUALITY caseIgnoreIA5Match
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.21 
++	NAME 'dhcpImplementation' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Description of the DHCP Server implementation e.g. DHCP Servers vendor.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.22 
++	NAME 'dhcpAddressState' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This stores information about the current binding-status of an address.  For dynamic addresses managed by DHCP, the values should be restricted to the following: &quot;FREE&quot;, &quot;ACTIVE&quot;, &quot;EXPIRED&quot;, &quot;RELEASED&quot;, &quot;RESET&quot;, &quot;ABANDONED&quot;, &quot;BACKUP&quot;.  For other addresses, it SHOULD be one of the following: &quot;UNKNOWN&quot;, &quot;RESERVED&quot; (an address that is managed by DHCP that is reserved for a specific client), &quot;RESERVED-ACTIVE&quot; (same as reserved, but address is currently in use), &quot;ASSIGNED&quot; (assigned manually or by some other mechanism), &quot;UNASSIGNED&quot;, &quot;NOTASSIGNABLE&quot;.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.23 
++	NAME 'dhcpExpirationTime' 
++	EQUALITY generalizedTimeMatch 
++	DESC 'This is the time the current lease for an address expires.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.24 
++	NAME 'dhcpStartTimeOfState' 
++	EQUALITY generalizedTimeMatch 
++	DESC 'This is the time of the last state change for a leased address.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.25 
++	NAME 'dhcpLastTransactionTime' 
++	EQUALITY generalizedTimeMatch 
++	DESC 'This is the last time a valid DHCP packet was received from the client.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.26 
++	NAME 'dhcpBootpFlag' 
++	EQUALITY booleanMatch 
++	DESC 'This indicates whether the address was assigned via BOOTP.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.7 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.27 
++	NAME 'dhcpDomainName' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This is the name of the domain sent to the client by the server.  It is essentially the same as the value for DHCP option 15 sent to the client, and represents only the domain - not the full FQDN.  To obtain the full FQDN assigned to the client you must prepend the &quot;dhcpAssignedHostName&quot; to this value with a &quot;.&quot;.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.28 
++	NAME 'dhcpDnsStatus' 
++	EQUALITY integerMatch
++	DESC 'This indicates the status of updating DNS resource records on behalf of the client by the DHCP server for this address.  The value is a 16-bit bitmask.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.29 
++	NAME 'dhcpRequestedHostName' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This is the hostname that was requested by the client.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.30 
++	NAME 'dhcpAssignedHostName' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'This is the actual hostname that was assigned to a client. It may not be the name that was requested by the client.  The fully qualified domain name can be determined by appending the value of &quot;dhcpDomainName&quot; (with a dot separator) to this name.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.31 
++	NAME 'dhcpReservedForClient' 
++	EQUALITY distinguishedNameMatch
++	DESC 'The distinguished name of a &quot;dhcpClient&quot; that an address is reserved for.  This may not be the same as the &quot;dhcpAssignedToClient&quot; attribute if the address is being reassigned but the current lease has not yet expired.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.32 
++	NAME 'dhcpAssignedToClient' 
++	EQUALITY distinguishedNameMatch
++	DESC 'This is the distinguished name of a &quot;dhcpClient&quot; that an address is currently assigned to.  This attribute is only present in the class when the address is leased.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.33 
++	NAME 'dhcpRelayAgentInfo' 
++	EQUALITY octetStringMatch
++	DESC 'If the client request was received via a relay agent, this contains information about the relay agent that was available from the DHCP request.  This is a hex-encoded option value.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.34 
++	NAME 'dhcpHWAddress' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'The clients hardware address that requested this IP address.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.35 
++	NAME 'dhcpHashBucketAssignment' 
++	EQUALITY octetStringMatch
++	DESC 'HashBucketAssignment bit map for the DHCP Server, as defined in DHC Load Balancing Algorithm [RFC 3074].' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.36 
++	NAME 'dhcpDelayedServiceParameter' 
++	EQUALITY integerMatch
++	DESC 'Delay in seconds corresponding to Delayed Service Parameter configuration, as defined in  DHC Load Balancing Algorithm [RFC 3074]. '
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.37 
++	NAME 'dhcpMaxClientLeadTime' 
++	EQUALITY integerMatch
++	DESC 'Maximum Client Lead Time configuration in seconds, as defined in DHCP Failover Protocol [FAILOVR]' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.38 
++	NAME 'dhcpFailOverEndpointState' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Server (Failover Endpoint) state, as defined in DHCP Failover Protocol [FAILOVR]' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.39 
++	NAME 'dhcpErrorLog' 
++	EQUALITY caseIgnoreIA5Match
++	DESC 'Generic error log attribute that allows logging error conditions within a dhcpService or a dhcpSubnet, like no IP addresses available for lease.'
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.40 
++	NAME 'dhcpLocatorDN' 
++	EQUALITY distinguishedNameMatch 
++	DESC 'The DN of dhcpLocator object which contain the DNs of all DHCP configuration objects. There will be a single dhcpLocator object in the tree with links to all the DHCP objects in the tree' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype  ( 2.16.840.1.113719.1.203.4.41 
++	NAME 'dhcpKeyAlgorithm' 
++	EQUALITY caseIgnoreIA5Match 
++	DESC 'Algorithm to generate TSIG Key' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype  ( 2.16.840.1.113719.1.203.4.42 
++	NAME 'dhcpKeySecret' 
++	EQUALITY octetStringMatch 
++	DESC 'Secret to generate TSIG Key' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.43 
++	NAME 'dhcpDnsZoneServer' 
++	EQUALITY caseIgnoreIA5Match 
++	DESC 'Master server of the DNS Zone' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++attributetype ( 2.16.840.1.113719.1.203.4.44 
++	NAME 'dhcpKeyDN' 
++	EQUALITY distinguishedNameMatch 
++	DESC 'The DNs of TSIG Key to use in secure dynamic updates. In case of locator object, this will be list of TSIG keys.  In case of DHCP Service, Shared Network, Subnet and DNS Zone, it will be a single key.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12)
++
++attributetype ( 2.16.840.1.113719.1.203.4.45 
++	NAME 'dhcpZoneDN' 
++	EQUALITY distinguishedNameMatch 
++	DESC 'The DNs of DNS Zone. In case of locator object, this will be list of DNS Zones in the tree. In case of DHCP Service, Shared Network and Subnet, it will be a single DNS Zone.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12)
++
++attributetype ( 2.16.840.1.113719.1.203.4.46 
++	NAME 'dhcpFailOverPrimaryServer' 
++	EQUALITY caseIgnoreIA5Match 
++	DESC 'IP address or DNS name of the server playing primary role in DHC Load Balancing and Fail over.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26  )
++
++attributetype ( 2.16.840.1.113719.1.203.4.47 
++	NAME 'dhcpFailOverSecondaryServer' 
++	EQUALITY caseIgnoreIA5Match 
++	DESC 'IP address or DNS name of the server playing secondary role in DHC Load Balancing and Fail over.' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26  )
++
++attributetype ( 2.16.840.1.113719.1.203.4.48
++	NAME 'dhcpFailOverPrimaryPort' 
++	EQUALITY integerMatch 
++	DESC 'Port on which primary server listens for connections from its fail over peer (secondary server)' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27  )
++	
++attributetype ( 2.16.840.1.113719.1.203.4.49
++	NAME 'dhcpFailOverSecondaryPort' 
++	EQUALITY integerMatch 
++	DESC 'Port on which secondary server listens for connections from its fail over peer (primary server)' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27  )
++
++attributetype ( 2.16.840.1.113719.1.203.4.50
++	NAME 'dhcpFailOverResponseDelay' 
++	EQUALITY integerMatch 
++	DESC 'Maximum response time in seconds, before Server assumes that connection to fail over peer has failed' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27  )
++
++attributetype ( 2.16.840.1.113719.1.203.4.51
++	NAME 'dhcpFailOverUnackedUpdates' 
++	EQUALITY integerMatch 
++	DESC 'Number of BNDUPD messages that server can send before it receives BNDACK from its fail over peer' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27  )
++
++attributetype ( 2.16.840.1.113719.1.203.4.52
++	NAME 'dhcpFailOverSplit' 
++	EQUALITY integerMatch 
++	DESC 'Split between the primary and secondary servers for fail over purpose' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27  )
++
++attributetype ( 2.16.840.1.113719.1.203.4.53
++	NAME 'dhcpFailOverLoadBalanceTime' 
++	EQUALITY integerMatch 
++	DESC 'Cutoff time in seconds, after which load balance is disabled' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.27  )
++
++attributetype ( 2.16.840.1.113719.1.203.4.54
++	NAME 'dhcpFailOverPeerDN' 
++	EQUALITY distinguishedNameMatch 
++	DESC 'The DNs of Fail over peers. In case of locator object, this will be list of fail over peers in the tree. In case of Subnet and pool, it will be a single Fail Over Peer' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 ) 
++
++#List of all servers in the tree
++attributetype ( 2.16.840.1.113719.1.203.4.55
++	NAME 'dhcpServerDN' 
++	EQUALITY distinguishedNameMatch 
++	DESC 'List of all  DHCP Servers in the tree. Used by dhcpLocatorObject' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++attributetype ( 2.16.840.1.113719.1.203.4.56
++	NAME 'dhcpComments' 
++	EQUALITY caseIgnoreIA5Match 
++	DESC 'Generic attribute that allows coments  within any DHCP object' 
++	SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++# Classes
++
++objectclass ( 2.16.840.1.113719.1.203.6.1 
++	NAME 'dhcpService' 
++	DESC 'Service object that represents the actual DHCP Service configuration. This is a container object.' 
++	SUP top 
++	MUST (cn) 
++	MAY ( dhcpPrimaryDN $ dhcpSecondaryDN $ dhcpServerDN $ dhcpSharedNetworkDN $ dhcpSubnetDN $ dhcpGroupDN $ dhcpHostDN $  dhcpClassesDN $ dhcpOptionsDN $ dhcpZoneDN $ dhcpKeyDN $ dhcpFailOverPeerDN $ dhcpStatements $dhcpComments $ dhcpOption) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.2 
++	NAME 'dhcpSharedNetwork' 
++	DESC 'This stores configuration information for a shared network.' 
++	SUP top 
++	MUST cn 
++	MAY ( dhcpSubnetDN $ dhcpPoolDN $ dhcpOptionsDN $ dhcpZoneDN $ dhcpStatements $dhcpComments $ dhcpOption) X-NDS_CONTAINMENT ('dhcpService' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.3 
++	NAME 'dhcpSubnet' 
++	DESC 'This class defines a subnet. This is a container object.' 
++	SUP top 
++	MUST ( cn $ dhcpNetMask ) 
++	MAY ( dhcpRange $ dhcpPoolDN $ dhcpGroupDN $ dhcpHostDN $ dhcpClassesDN $ dhcpLeasesDN $ dhcpOptionsDN $ dhcpZoneDN $ dhcpKeyDN $ dhcpFailOverPeerDN $ dhcpStatements $ dhcpComments $ dhcpOption ) X-NDS_CONTAINMENT ('dhcpService' 'dhcpSharedNetwork') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.4 
++	NAME 'dhcpPool' 
++	DESC 'This stores configuration information about a pool.' 
++	SUP top 
++	MUST ( cn $ dhcpRange ) 
++	MAY ( dhcpClassesDN $ dhcpPermitList $ dhcpLeasesDN $ dhcpOptionsDN $ dhcpZoneDN $dhcpKeyDN $ dhcpStatements $ dhcpComments $ dhcpOption ) 
++	X-NDS_CONTAINMENT ('dhcpSubnet' 'dhcpSharedNetwork') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.5 
++	NAME 'dhcpGroup' 
++	DESC 'Group object that lists host DNs and parameters. This is a container object.' 
++	SUP top 
++	MUST cn 
++	MAY ( dhcpHostDN $ dhcpOptionsDN $ dhcpStatements $ dhcpComments $ dhcpOption )
++	X-NDS_CONTAINMENT ('dhcpSubnet' 'dhcpService' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.6 
++	NAME 'dhcpHost' 
++	DESC 'This represents information about a particular client' 
++	SUP top 
++	MUST cn 
++	MAY  (dhcpLeaseDN $ dhcpHWAddress $ dhcpOptionsDN $ dhcpStatements $ dhcpComments $ dhcpOption) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSubnet' 'dhcpGroup') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.7 
++	NAME 'dhcpClass' 
++	DESC 'Represents information about a collection of related clients.' 
++	SUP top 
++	MUST cn 
++	MAY (dhcpSubClassesDN $ dhcpOptionsDN $ dhcpStatements $ dhcpComments $ dhcpOption) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSubnet' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.8 
++	NAME 'dhcpSubClass' 
++	DESC 'Represents information about a collection of related classes.' 
++	SUP top 
++	MUST cn 
++	MAY (dhcpClassData $ dhcpOptionsDN $ dhcpStatements $ dhcpComments $ dhcpOption) X-NDS_CONTAINMENT 'dhcpClass' )
++
++objectclass ( 2.16.840.1.113719.1.203.6.9 
++	NAME 'dhcpOptions' 
++	DESC 'Represents information about a collection of options defined.' 
++	SUP top AUXILIARY
++	MUST cn 
++	MAY ( dhcpOption $ dhcpComments ) 
++	X-NDS_CONTAINMENT  ('dhcpService' 'dhcpSharedNetwork' 'dhcpSubnet' 'dhcpPool' 'dhcpGroup' 'dhcpHost' 'dhcpClass' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.10 
++	NAME 'dhcpLeases' 
++	DESC 'This class represents an IP Address, which may or may not have been leased.' 
++	SUP top 
++	MUST ( cn $ dhcpAddressState ) 
++	MAY ( dhcpExpirationTime $ dhcpStartTimeOfState $ dhcpLastTransactionTime $ dhcpBootpFlag $ dhcpDomainName $ dhcpDnsStatus $ dhcpRequestedHostName $ dhcpAssignedHostName $ dhcpReservedForClient $ dhcpAssignedToClient $ dhcpRelayAgentInfo $ dhcpHWAddress ) 
++	X-NDS_CONTAINMENT ( 'dhcpService' 'dhcpSubnet' 'dhcpPool') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.11 
++	NAME 'dhcpLog' 
++	DESC 'This is the object that holds past information about the IP address. The cn is the time/date stamp when the address was assigned or released, the address state at the time, if the address was assigned or released.' 
++	SUP top 
++	MUST ( cn ) 
++	MAY ( dhcpAddressState $ dhcpExpirationTime $ dhcpStartTimeOfState $ dhcpLastTransactionTime $ dhcpBootpFlag $ dhcpDomainName $ dhcpDnsStatus $ dhcpRequestedHostName $ dhcpAssignedHostName $ dhcpReservedForClient $ dhcpAssignedToClient $ dhcpRelayAgentInfo $ dhcpHWAddress $ dhcpErrorLog) 
++	X-NDS_CONTAINMENT ('dhcpLeases' 'dhcpPool' 'dhcpSubnet' 'dhcpSharedNetwork' 'dhcpService' ) )
++
++objectclass ( 2.16.840.1.113719.1.203.6.12 
++	NAME 'dhcpServer' 
++	DESC 'DHCP Server Object' 
++	SUP top 
++	MUST ( cn ) 
++	MAY (dhcpServiceDN  $ dhcpLocatorDN $ dhcpVersion $ dhcpImplementation $ dhcpHashBucketAssignment $ dhcpDelayedServiceParameter $ dhcpMaxClientLeadTime $ dhcpFailOverEndpointState $ dhcpStatements $ dhcpComments $ dhcpOption) 
++	X-NDS_CONTAINMENT ('organization' 'organizationalunit' 'domain') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.13 
++	NAME 'dhcpTSigKey' 
++	DESC 'TSIG key for secure dynamic updates' 
++	SUP top 
++	MUST (cn $ dhcpKeyAlgorithm $ dhcpKeySecret ) 
++	MAY ( dhcpComments ) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSharedNetwork' 'dhcpSubnet') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.14 
++	NAME 'dhcpDnsZone' 
++	DESC 'DNS Zone for updating leases' 
++	SUP top 
++	MUST (cn $ dhcpDnsZoneServer ) 
++	MAY (dhcpKeyDN $ dhcpComments) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSharedNetwork' 'dhcpSubnet') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.15 
++	NAME 'dhcpFailOverPeer' 
++	DESC 'This class defines the Fail over peer' 
++	SUP top 
++  MUST ( cn $ dhcpFailOverPrimaryServer $ dhcpFailOverSecondaryServer $ dhcpFailoverPrimaryPort $ dhcpFailOverSecondaryPort) MAY (dhcpFailOverResponseDelay  $ dhcpFailOverUnackedUpdates $ dhcpMaxClientLeadTime $ dhcpFailOverSplit $ dhcpHashBucketAssignment $ dhcpFailOverLoadBalanceTime $ dhcpComments ) 
++	X-NDS_CONTAINMENT ('dhcpService' 'dhcpSharedNetwork' 'dhcpSubnet') )
++
++objectclass ( 2.16.840.1.113719.1.203.6.16 
++	NAME 'dhcpLocator' 
++	DESC 'Locator object for DHCP configuration in the tree. There will be a single dhcpLocator object in the tree with links to all the DHCP objects in the tree' 
++	SUP top 
++	MUST ( cn ) 
++	MAY ( dhcpServiceDN $dhcpServerDN $ dhcpSharedNetworkDN $ dhcpSubnetDN $ dhcpPoolDN $ dhcpGroupDN $ dhcpHostDN $  dhcpClassesDN $ dhcpKeyDN $ dhcpZoneDN $ dhcpFailOverPeerDN $ dhcpOption $ dhcpComments) 
++	X-NDS_CONTAINMENT ('organization' 'organizationalunit' 'domain') )
++
++
+diff -Naur dhcp-3.0.5/contrib/dhcpd-conf-to-ldap.pl dhcp-3.0.5-ldap/contrib/dhcpd-conf-to-ldap.pl
+--- dhcp-3.0.5/contrib/dhcpd-conf-to-ldap.pl	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/contrib/dhcpd-conf-to-ldap.pl	2007-02-23 14:01:43.000000000 -0500
+@@ -0,0 +1,760 @@
++#!/usr/bin/perl -w
++
++# Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;
++# To use this script, set your base DN below. Then run 
++# ./dhcpd-conf-to-ldap.pl &lt; /path-to-dhcpd-conf/dhcpd.conf &gt; output-file
++# The output of this script will generate entries in LDIF format. You can use
++# the slapadd command to add these entries into your LDAP server. You will
++# definately want to double check that your LDAP entries are correct before
++# you load them into LDAP.
++
++# This script does not do much error checking. Make sure before you run this
++# that the DHCP server doesn't give any errors about your config file
++
++# FailOver notes:
++#   Failover is disabled by default, since it may need manually intervention.
++#   You can try the '--use=failover' option to see what happens :-)
++#
++#   If enabled, the failover pool references will be written to LDIF output.
++#   The failover configs itself will be added to the dhcpServer statements
++#   and not to the dhcpService object (since this script uses only one and
++#   it may be usefull to have multiple service containers in failover mode).
++#   Further, this script does not check if primary or secondary makes sense,
++#   it simply converts what it gets...
++
++use Net::Domain qw(hostname hostfqdn hostdomain);
++use Getopt::Long;
++
++my $domain = hostdomain();           # your.domain
++my $basedn = &quot;dc=&quot;.$domain;
++   $basedn =~ s/\./,dc=/g;           # dc=your,dc=domain
++my $server = hostname();             # hostname (nodename)
++my $dhcpcn = 'DHCP Config';          # CN of DHCP config tree
++my $dhcpdn = &quot;cn=$dhcpcn, $basedn&quot;;  # DHCP config tree DN
++my $second = '';                     # secondary server DN / hostname
++my $i_conf = '';                     # dhcp.conf file to read or stdin
++my $o_ldif = '';                     # output ldif file name or stdout
++my @use    = ();                     # extended flags (failover)
++
++sub usage($;$)
++{
++  my $rc = shift;
++  my $err= shift;
++
++  print STDERR &quot;Error: $err\n\n&quot; if(defined $err);
++  print STDERR &lt;&lt;__EOF_USAGE__;
++usage: 
++  $0 [options] &lt; dhcpd.conf &gt; dhcpd.ldif
++
++options:
++
++  --basedn  &quot;dc=your,dc=domain&quot;        (&quot;$basedn&quot;)
++
++  --dhcpdn  &quot;dhcp config DN&quot;           (&quot;$dhcpdn&quot;)
++
++  --server  &quot;dhcp server name&quot;         (&quot;$server&quot;)
++
++  --second  &quot;secondary server or DN&quot;   (&quot;$second&quot;)
++
++  --conf    &quot;/path/to/dhcpd.conf&quot;      (default is stdin)
++  --ldif    &quot;/path/to/output.ldif&quot;     (default is stdout)
++
++  --use     &quot;extended features&quot;        (see source comments)
++__EOF_USAGE__
++  exit($rc);
++}
++
++
++sub next_token
++{
++  local ($lowercase) = @_;
++  local ($token, $newline);
++
++  do 
++    {
++      if (!defined ($line) || length ($line) == 0)
++        {
++          $line = &lt;&gt;;
++          return undef if !defined ($line);
++          chop $line;
++          $line_number++;
++          $token_number = 0;
++        }
++
++      $line =~ s/#.*//;
++      $line =~ s/^\s+//;
++      $line =~ s/\s+$//;
++    }
++  while (length ($line) == 0);
++
++  if (($token, $newline) = $line =~ /^(.*?)\s+(.*)/)
++    {
++      if ($token =~ /^&quot;/) {
++       #handle quoted token
++       if ($token !~ /&quot;\s*$/)
++       {
++         ($tok, $newline)  = $newline =~ /([^&quot;]+&quot;)(.*)/;
++         $token .= &quot; $tok&quot;;
++        }
++      }
++      $line = $newline;
++    }
++  else
++    {
++      $token = $line;
++      $line = '';
++    }
++  $token_number++;
++
++  $token =~ y/[A-Z]/[a-z]/ if $lowercase;
++
++  return ($token);
++}
++
++
++sub remaining_line
++{
++  local ($block) = shift || 0;
++  local ($tmp, $str);
++
++  $str = &quot;&quot;;
++  while (defined($tmp = next_token (0)))
++    {
++      $str .= ' ' if !($str eq &quot;&quot;);
++      $str .= $tmp;
++      last if $tmp =~ /;\s*$/;
++      last if($block and $tmp =~ /\s*[}{]\s*$/);
++    }
++
++  $str =~ s/;$//;
++  return ($str);
++}
++
++
++sub
++add_dn_to_stack
++{
++  local ($dn) = @_;
++
++  $current_dn = &quot;$dn, $current_dn&quot;;
++}
++
++
++sub
++remove_dn_from_stack
++{
++  $current_dn =~ s/^.*?,\s*//;
++}
++
++
++sub
++parse_error
++{
++  print &quot;Parse error on line number $line_number at token number $token_number\n&quot;;
++  exit (1);
++}
++
++
++sub
++print_entry
++{
++  return if (scalar keys %curentry == 0);
++
++  if (!defined ($curentry{'type'}))
++    {
++      $hostdn = &quot;cn=$server, $basedn&quot;;
++      print &quot;dn: $hostdn\n&quot;;
++      print &quot;cn: $server\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpServer\n&quot;;
++      print &quot;dhcpServiceDN: $current_dn\n&quot;;
++      if(grep(/FaIlOvEr/i, @use))
++        {
++          foreach my $fo_peer (keys %failover)
++            {
++              next if(scalar(@{$failover{$fo_peer}}) &lt;= 1);
++              print &quot;dhcpStatements: failover peer $fo_peer { &quot;,
++                    join('; ', @{$failover{$fo_peer}}), &quot;; }\n&quot;;
++            }
++        }
++      print &quot;\n&quot;;
++
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: $dhcpcn\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpService\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++      print &quot;dhcpPrimaryDN: $hostdn\n&quot;;
++      if(grep(/FaIlOvEr/i, @use) and ($second ne ''))
++        {
++          print &quot;dhcpSecondaryDN: $second\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'subnet')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'ip'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpSubnet\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++      
++      print &quot;dhcpNetMask: &quot; . $curentry{'netmask'} . &quot;\n&quot;;
++      if (defined ($curentry{'ranges'}))
++        {
++          foreach $statement (@{$curentry{'ranges'}})
++            {
++              print &quot;dhcpRange: $statement\n&quot;;
++            }
++        }
++    }
++  elsif ($curentry{'type'} eq 'shared-network')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'descr'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpSharedNetwork\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'group')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: group&quot;, $curentry{'idx'}, &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpGroup\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'host')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'host'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpHost\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++
++      if (defined ($curentry{'hwaddress'}))
++        {
++          $curentry{'hwaddress'} =~ y/[A-Z]/[a-z]/;
++          print &quot;dhcpHWAddress: &quot; . $curentry{'hwaddress'} . &quot;\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'pool')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: pool&quot;, $curentry{'idx'}, &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpPool\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++
++      if (defined ($curentry{'ranges'}))
++        {
++          foreach $statement (@{$curentry{'ranges'}})
++            {
++              print &quot;dhcpRange: $statement\n&quot;;
++            }
++        }
++    }
++  elsif ($curentry{'type'} eq 'class')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'class'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpClass\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++    }
++  elsif ($curentry{'type'} eq 'subclass')
++    {
++      print &quot;dn: $current_dn\n&quot;;
++      print &quot;cn: &quot; . $curentry{'subclass'} . &quot;\n&quot;;
++      print &quot;objectClass: top\n&quot;;
++      print &quot;objectClass: dhcpSubClass\n&quot;;
++      if (defined ($curentry{'options'}))
++        {
++          print &quot;objectClass: dhcpOptions\n&quot;;
++        }
++      print &quot;dhcpClassData: &quot; . $curentry{'class'} . &quot;\n&quot;;
++    }
++
++  if (defined ($curentry{'statements'}))
++    {
++      foreach $statement (@{$curentry{'statements'}})
++        {
++          print &quot;dhcpStatements: $statement\n&quot;;
++        }
++    }
++
++  if (defined ($curentry{'options'}))
++    {
++      foreach $statement (@{$curentry{'options'}})
++        {
++          print &quot;dhcpOption: $statement\n&quot;;
++        }
++    }
++
++  print &quot;\n&quot;;
++  undef (%curentry);
++}
++
++
++sub parse_netmask
++{
++  local ($netmask) = @_;
++  local ($i);
++
++  if ((($a, $b, $c, $d) = $netmask =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) != 4)
++    {
++      parse_error ();
++    }
++
++  $num = (($a &amp; 0xff) &lt;&lt; 24) |
++         (($b &amp; 0xff) &lt;&lt; 16) |
++         (($c &amp; 0xff) &lt;&lt; 8) |
++          ($d &amp; 0xff);
++
++  for ($i=1; $i&lt;=32 &amp;&amp; $num &amp; (1 &lt;&lt; (32 - $i)); $i++)
++    {
++    }
++  $i--;
++
++  return ($i);
++}
++
++
++sub parse_subnet
++{
++  local ($ip, $tmp, $netmask);
++
++  print_entry () if %curentry;
++    
++  $ip = next_token (0);
++  parse_error () if !defined ($ip);
++
++  $tmp = next_token (1);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq 'netmask');
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  $netmask = parse_netmask ($tmp);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$ip&quot;);
++  $curentry{'type'} = 'subnet';
++  $curentry{'ip'} = $ip;
++  $curentry{'netmask'} = $netmask;
++  $cursubnet = $ip;
++  $curcounter{$ip} = { pool  =&gt; 0, group =&gt; 0 };
++}
++
++
++sub parse_shared_network
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $descr = next_token (0);
++  parse_error () if !defined ($descr);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$descr&quot;);
++  $curentry{'type'} = 'shared-network';
++  $curentry{'descr'} = $descr;
++}
++
++
++sub parse_host
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $host = next_token (0);
++  parse_error () if !defined ($host);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$host&quot;);
++  $curentry{'type'} = 'host';
++  $curentry{'host'} = $host;
++}
++
++
++sub parse_group
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  my $idx;
++  if(exists($curcounter{$cursubnet})) {
++    $idx = ++$curcounter{$cursubnet}-&gt;{'group'};
++  } else {
++    $idx = ++$curcounter{''}-&gt;{'group'};
++  }
++
++  add_dn_to_stack (&quot;cn=group&quot;.$idx);
++  $curentry{'type'} = 'group';
++  $curentry{'idx'} = $idx;
++}
++
++
++sub parse_pool
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  my $idx;
++  if(exists($curcounter{$cursubnet})) {
++    $idx = ++$curcounter{$cursubnet}-&gt;{'pool'};
++  } else {
++    $idx = ++$curcounter{''}-&gt;{'pool'};
++  }
++
++  add_dn_to_stack (&quot;cn=pool&quot;.$idx);
++  $curentry{'type'} = 'pool';
++  $curentry{'idx'} = $idx;
++}
++
++
++sub parse_class
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $class = next_token (0);
++  parse_error () if !defined ($class);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  $class =~ s/\&quot;//g;
++  add_dn_to_stack (&quot;cn=$class&quot;);
++  $curentry{'type'} = 'class';
++  $curentry{'class'} = $class;
++}
++
++
++sub parse_subclass
++{
++  local ($descr, $tmp);
++
++  print_entry () if %curentry;
++
++  $class = next_token (0);
++  parse_error () if !defined ($class);
++
++  $subclass = next_token (0);
++  parse_error () if !defined ($subclass);
++
++  $tmp = next_token (0);
++  parse_error () if !defined ($tmp);
++  parse_error () if !($tmp eq '{');
++
++  add_dn_to_stack (&quot;cn=$subclass&quot;);
++  $curentry{'type'} = 'subclass';
++  $curentry{'class'} = $class;
++  $curentry{'subclass'} = $subclass;
++}
++
++
++sub parse_hwaddress
++{
++  local ($type, $hw, $tmp);
++
++  $type = next_token (1);
++  parse_error () if !defined ($type);
++
++  $hw = next_token (1);
++  parse_error () if !defined ($hw);
++  $hw =~ s/;$//;
++
++  $curentry{'hwaddress'} = &quot;$type $hw&quot;;
++}
++
++    
++sub parse_range
++{
++  local ($tmp, $str);
++
++  $str = remaining_line ();
++
++  if (!($str eq ''))
++    {
++      $str =~ s/;$//;
++      push (@{$curentry{'ranges'}}, $str);
++    }
++}
++
++
++sub parse_statement
++{
++  local ($token) = shift;
++  local ($str);
++
++  if ($token eq 'option')
++    {
++      $str = remaining_line ();
++      push (@{$curentry{'options'}}, $str);
++    }
++  elsif($token eq 'failover')
++    {
++      $str = remaining_line (1); # take care on block
++      if($str =~ /[{]/)
++        {
++          my ($peername, @statements);
++
++          parse_error() if($str !~ /^\s*peer\s+(.+?)\s+[{]\s*$/);
++          parse_error() if(($peername = $1) !~ /^\&quot;?[^\&quot;]+\&quot;?$/);
++
++          #
++          # failover config block found:
++          # e.g. 'failover peer &quot;some-name&quot; {'
++          #
++          if(not grep(/FaIlOvEr/i, @use))
++            {
++              print STDERR &quot;Warning: Failover config 'peer $peername' found!\n&quot;;
++              print STDERR &quot;         Skipping it, since failover disabled!\n&quot;;
++              print STDERR &quot;         You may try out --use=failover option.\n&quot;;
++            }
++
++          until($str =~ /[}]/ or $str eq &quot;&quot;)
++            {
++                $str = remaining_line (1);
++                # collect all statements, except ending '}'
++                push(@statements, $str) if($str !~ /[}]/);
++            }
++          $failover{$peername} = [@statements];
++        }
++      else
++        {
++          #
++          # pool reference to failover config is fine
++          # e.g. 'failover peer &quot;some-name&quot;;'
++          #
++          if(not grep(/FaIlOvEr/i, @use))
++            {
++              print STDERR &quot;Warning: Failover reference '$str' found!\n&quot;;
++              print STDERR &quot;         Skipping it, since failover disabled!\n&quot;;
++              print STDERR &quot;         You may try out --use=failover option.\n&quot;;
++            }
++          else
++            {
++              push (@{$curentry{'statements'}}, $token. &quot; &quot; . $str);
++            }
++        }
++    }
++  elsif($token eq 'zone')
++    {
++      $str = $token;
++      while($str !~ /}$/) {
++        $str .= ' ' . next_token (0);
++      }
++      push (@{$curentry{'statements'}}, $str);
++    }
++  elsif($token =~ /^(authoritative)[;]*$/)
++    {
++      push (@{$curentry{'statements'}}, $1);
++    }
++  else
++    {
++      $str = $token . &quot; &quot; . remaining_line ();
++      push (@{$curentry{'statements'}}, $str);
++    }
++}
++
++
++my $ok = GetOptions(
++    'basedn=s'      =&gt; \$basedn,
++    'dhcpdn=s'      =&gt; \$dhcpdn,
++    'server=s'      =&gt; \$server,
++    'second=s'      =&gt; \$second,
++    'conf=s'        =&gt; \$i_conf,
++    'ldif=s'        =&gt; \$o_ldif,
++    'use=s'         =&gt; \@use,
++    'h|help|usage'  =&gt; sub { usage(0); },
++);
++
++unless($server =~ /^\w+/)
++  {
++    usage(1, &quot;invalid server name '$server'&quot;);
++  }
++unless($basedn =~ /^\w+=[^,]+/)
++  {
++    usage(1, &quot;invalid base dn '$basedn'&quot;);
++  }
++
++if($dhcpdn =~ /^cn=([^,]+)/i)
++  {
++    $dhcpcn = &quot;$1&quot;;
++  }
++$second = '' if not defined $second;
++unless($second eq '' or $second =~ /^cn=[^,]+\s*,\s*\w+=[^,]+/i)
++  {
++    if($second =~ /^cn=[^,]+$/i)
++      {
++        # relative DN 'cn=name'
++        $second = &quot;$second, $basedn&quot;;
++      }
++    elsif($second =~ /^\w+/)
++      {
++        # assume hostname only
++        $second = &quot;cn=$second, $basedn&quot;;
++      }
++    else
++      {
++        usage(1, &quot;invalid secondary '$second'&quot;)
++      }
++  }
++
++usage(1) unless($ok);
++
++if($i_conf ne &quot;&quot; and -f $i_conf)
++  {
++    if(not open(STDIN, '&lt;', $i_conf))
++      {
++        print STDERR &quot;Error: can't open conf file '$i_conf': $!\n&quot;;
++        exit(1);
++      }
++  }
++if($o_ldif ne &quot;&quot;)
++  {
++    if(-e $o_ldif)
++      {
++        print STDERR &quot;Error: output ldif name '$o_ldif' already exists!\n&quot;;
++        exit(1);
++      }
++    if(not open(STDOUT, '&gt;', $o_ldif))
++      {
++        print STDERR &quot;Error: can't open ldif file '$o_ldif': $!\n&quot;;
++        exit(1);
++      }
++  }
++
++
++print STDERR &quot;Creating LDAP Configuration with the following options:\n&quot;;
++print STDERR &quot;\tBase DN: $basedn\n&quot;;
++print STDERR &quot;\tDHCP DN: $dhcpdn\n&quot;;
++print STDERR &quot;\tServer DN: cn=$server, $basedn\n&quot;;
++print STDERR &quot;\tSecondary DN: $second\n&quot;
++             if(grep(/FaIlOvEr/i, @use) and $second ne '');
++print STDERR &quot;\n&quot;;
++
++my $token;
++my $token_number = 0;
++my $line_number = 0;
++my %curentry;
++my $cursubnet = '';
++my %curcounter = ( '' =&gt; { pool =&gt; 0, group =&gt; 0 } );
++
++$current_dn = &quot;$dhcpdn&quot;;
++$curentry{'descr'} = $dhcpcn;
++$line = '';
++%failover = ();
++
++while (($token = next_token (1)))
++  {
++    if ($token eq '}')
++      {
++        print_entry () if %curentry;
++        if($current_dn =~ /.+?,\s*${dhcpdn}$/) {
++          # don't go below dhcpdn ...
++          remove_dn_from_stack ();
++        }
++      }
++    elsif ($token eq 'subnet')
++      {
++        parse_subnet ();
++        next;
++      }
++    elsif ($token eq 'shared-network')
++      {
++        parse_shared_network ();
++        next;
++      }
++    elsif ($token eq 'class')
++      {
++        parse_class ();
++        next;
++      }
++    elsif ($token eq 'subclass')
++      {
++        parse_subclass ();
++        next;
++      }
++    elsif ($token eq 'pool')
++      {
++        parse_pool ();
++        next;
++      }
++    elsif ($token eq 'group')
++      {
++        parse_group ();
++        next;
++      }
++    elsif ($token eq 'host')
++      {
++        parse_host ();
++        next;
++      }
++    elsif ($token eq 'hardware')
++      {
++        parse_hwaddress ();
++        next;
++      }
++    elsif ($token eq 'range')
++      {
++        parse_range ();
++        next;
++      }
++    else
++      {
++        parse_statement ($token);
++        next;
++      }
++  }
++
++close(STDIN)  if($i_conf);
++close(STDOUT) if($o_ldif);
++
++print STDERR &quot;Done.\n&quot;;
++
+diff -Naur dhcp-3.0.5/debian/changelog dhcp-3.0.5-ldap/debian/changelog
+--- dhcp-3.0.5/debian/changelog	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/changelog	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,25 @@
++dhcp3-server-ldap (3.0.4-1) unstable; urgency=low
++
++  * See ChangeLog-LDAP for changes in this release
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Mon, 08 May 2006 08:31:46 -0400
++
++dhcp3-server-ldap (3.0.1rc13-1) unstable; urgency=low
++
++  * See ChangeLog-LDAP for changes in this release
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Wed, 05 May 2004 07:20:13 -0400
++
++dhcp3-server-ldap (3.0.1rc12-1) unstable; urgency=low
++
++  * Updated patch to work against ISC DHCPD 3.0.1rc12
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Mon, 08 Sep 2003 16:34:00 -0400
++
++dhcp3-server-ldap (3.0.1rc11-2) unstable; urgency=low
++
++  * Added these Debian files. They are mostly from the existing dhcp3-server
++    package in Debian.
++
++ -- Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;  Mon, 04 Aug 2003 13:34:00 -0400
++
+diff -Naur dhcp-3.0.5/debian/control dhcp-3.0.5-ldap/debian/control
+--- dhcp-3.0.5/debian/control	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/control	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,12 @@
++Source: dhcp3-server-ldap
++Section: net
++Priority: optional
++Maintainer: Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at gftp.org</A>&gt;
++Build-Depends: debhelper (&gt;= 2.1.18), dpkg-dev (&gt;= 1.7.0), groff, libldap2-dev
++Standards-Version: 2.4.0.0
++
++Package: dhcp3-server-ldap
++Architecture: any
++Depends: ${shlibs:Depends}, debconf, debianutils (&gt;= 1.7), dhcp3-server (&gt;= 3.0+3.0.1rc9)
++Conflicts: dhcp, dhcp3-ldap-ntelos
++Description: This is the DHCP server with LDAP patches applied to it
+diff -Naur dhcp-3.0.5/debian/copyright dhcp-3.0.5-ldap/debian/copyright
+--- dhcp-3.0.5/debian/copyright	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/copyright	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,30 @@
++/*
++ * Copyright (c) 1996, 1997 The Internet Software Consortium.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of The Internet Software Consortium nor the names of its
++ *    contributors may be used to endorse or promote products derived
++ *    from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
++ * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
++ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
++ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
++ * THE INTERNET SOFTWARE CONSORTIUM OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
++ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
++ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
++ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
++ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
++ * OF THE POSSIBILITY OF SUCH DAMAGE.
++ */
+diff -Naur dhcp-3.0.5/debian/dhcp3-server-ldap.files dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.files
+--- dhcp-3.0.5/debian/dhcp3-server-ldap.files	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.files	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1 @@
++usr/sbin/dhcpd3
+diff -Naur dhcp-3.0.5/debian/dhcp3-server-ldap.postinst dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.postinst
+--- dhcp-3.0.5/debian/dhcp3-server-ldap.postinst	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.postinst	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,13 @@
++#!/bin/sh
++
++set -e 
++
++# Removes the left over diversions of the old package
++
++if [ &quot;$1&quot; = remove -o &quot;$1&quot; = upgrade ]; then
++	for v in `list_versions`; do
++	        dpkg-divert --package dhcp3-server-ldap --remove \
++			--rename --divert /usr/sbin/dhcpd3-noldap \
++			/usr/sbin/dhcpd3
++	done
++fi
+diff -Naur dhcp-3.0.5/debian/dhcp3-server-ldap.postrm dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.postrm
+--- dhcp-3.0.5/debian/dhcp3-server-ldap.postrm	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.postrm	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,8 @@
++#!/bin/sh
++
++set -e 
++
++if [ &quot;$1&quot; = remove ]; then
++	dpkg-divert --package dhcp3-server-ldap --remove --rename \
++		--divert /usr/sbin/dhcpd3-noldap /usr/sbin/dhcpd3
++fi
+diff -Naur dhcp-3.0.5/debian/dhcp3-server-ldap.preinst dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.preinst
+--- dhcp-3.0.5/debian/dhcp3-server-ldap.preinst	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/dhcp3-server-ldap.preinst	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,14 @@
++#!/bin/sh
++
++set -e 
++
++if [ &quot;$1&quot; = install -o &quot;$1&quot; = upgrade ]; then
++	if dpkg-divert --list /usr/sbin/dhcpd3 \
++		| grep -q &quot;by dhcp3-server-ldap&quot;;
++	then
++		exit 0
++	fi
++		
++	dpkg-divert --package dhcp3-server-ldap --add --rename \
++		--divert /usr/sbin/dhcpd3-noldap /usr/sbin/dhcpd3
++fi
+diff -Naur dhcp-3.0.5/debian/dirs dhcp-3.0.5-ldap/debian/dirs
+--- dhcp-3.0.5/debian/dirs	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/dirs	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1 @@
++usr/sbin
+diff -Naur dhcp-3.0.5/debian/rules dhcp-3.0.5-ldap/debian/rules
+--- dhcp-3.0.5/debian/rules	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/debian/rules	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,87 @@
++#!/usr/bin/make -f
++# Made with the iad of dh_make, by Craig Small
++# Sample debian/rules that uses debhelper. GNU copyright 1997 by Joey Hess.
++# Also some stuff taken from debmake scripts, by Cristopt Lameter.
++
++# Uncomment this to turn on verbose mode.
++#export DH_VERBOSE=1
++
++export DH_COMPAT=3
++
++DESTDIR = `pwd`/debian/tmp
++
++IVARS = DESTDIR=$(DESTDIR)
++
++BVARS = PREDEFINES='-D_PATH_DHCPD_DB=\&quot;/var/lib/dhcp3/dhcpd.leases\&quot; \
++	-D_PATH_DHCLIENT_DB=\&quot;/var/lib/dhcp3/dhclient.leases\&quot; \
++	-D_PATH_DHCLIENT_SCRIPT=\&quot;/etc/dhcp3/dhclient-script\&quot; \
++	-D_PATH_DHCPD_CONF=\&quot;/etc/dhcp3/dhcpd.conf\&quot; \
++        -D_PATH_DHCLIENT_CONF=\&quot;/etc/dhcp3/dhclient.conf\&quot;'
++
++build: build-stamp
++build-stamp:
++	dh_testdir
++
++	./configure
++	$(MAKE) $(BVARS)
++
++	touch build-stamp
++
++clean: 
++	dh_testdir
++	rm -f build-stamp install-stamp
++
++	# Add here commands to clean up after the build process.
++	-$(MAKE) distclean
++
++	# Remove leftover junk...
++	rm -Rf work.linux-2.2/
++
++	dh_clean
++
++install: install-stamp
++install-stamp: build-stamp
++	dh_testdir
++	dh_testroot
++	dh_clean -k
++	dh_installdirs
++
++	# Add here commands to install the package into debian/tmp.
++	$(MAKE) install $(IVARS)
++
++	mv $(DESTDIR)/usr/sbin/dhcpd $(DESTDIR)/usr/sbin/dhcpd3
++
++	dh_movefiles
++
++	# Remove unwanted directories that dh_movefiles leaves around
++	rmdir $(DESTDIR)/etc
++	rm -Rf $(DESTDIR)/sbin/
++	rm -Rf $(DESTDIR)/usr/bin/
++	rm -Rf $(DESTDIR)/usr/include/
++	rm -Rf $(DESTDIR)/usr/lib/
++	rm -Rf $(DESTDIR)/usr/local/
++	rm -Rf $(DESTDIR)/usr/man/
++	rm -Rf $(DESTDIR)/var/
++	rm -f $(DESTDIR)/usr/sbin/dhcrelay
++
++	touch install-stamp
++
++# Build architecture-dependent files here (this package does not contain
++#	architecture-independent files).
++binary-arch: build install
++	dh_testdir -a
++	dh_testroot -a
++	dh_strip -a
++	dh_compress -a
++	dh_fixperms -a
++	dh_installdeb -a
++	dh_shlibdeps -a
++	dh_gencontrol -a
++	dh_md5sums -a
++	dh_builddeb -a
++
++source diff:                                                                  
++	@echo &gt;&amp;2 'source and diff are obsolete - use dpkg-source -b'; false
++
++binary: binary-arch
++.PHONY: build clean binary-indep binary-arch binary
+diff -Naur dhcp-3.0.5/doc/draft-ietf-dhc-ldap-schema-01.txt dhcp-3.0.5-ldap/doc/draft-ietf-dhc-ldap-schema-01.txt
+--- dhcp-3.0.5/doc/draft-ietf-dhc-ldap-schema-01.txt	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/doc/draft-ietf-dhc-ldap-schema-01.txt	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,1089 @@
++
++
++
++
++
++Network Working Group                                  M. Meredith,
++Internet Draft                                         V. Nanjundaswamy,
++Document: &lt;draft-ietf-dhc-ldap-schema-00.txt&gt;          M. Hinckley
++Category: Proposed Standard                            Novell Inc.
++Expires: 15th December 2001                            16th June 2001
++
++
++                          LDAP Schema for DHCP
++
++Status of this Memo
++
++This document is an Internet-Draft and is in full conformance with all
++provisions of Section 10 of RFC2026 [ ].
++
++Internet-Drafts are working documents of the Internet Engineering Task
++Force (IETF), its areas, and its working groups.  Note that other groups
++may also distribute working documents as Internet-Drafts. Internet-
++Drafts are draft documents valid for a maximum of six months and may be
++updated, replaced, or obsolete by other documents at any time.  It is
++inappropriate to use Internet-Drafts as reference material or to cite
++them other than as &quot;work in progress.&quot;  The list of current Internet-
++Drafts can be accessed at <A HREF="http://www.ietf.org/ietf/1id-abstracts.txt">http://www.ietf.org/ietf/1id-abstracts.txt</A> The
++list of Internet-Draft Shadow Directories can be accessed at
++<A HREF="http://www.ietf.org/shadow.html.">http://www.ietf.org/shadow.html.</A>
++
++1. Abstract
++
++This document defines a schema for representing DHCP configuration in an
++LDAP directory. It can be used to represent the DHCP Service
++configuration(s) for an entire enterprise network, a subset of the
++network, or even a single server. Representing DHCP configuration in an
++LDAP directory enables centralized management of DHCP services offered
++by one or more DHCP Servers within the enterprise.
++
++2. Conventions used in this document
++
++The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
++&quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
++document are to be interpreted as described in RFC-2119 [ ].
++
++In places where different sets of terminology are commonly used to
++represent similar DHCP concepts, this schema uses the terminology of the
++Internet Software Consortium's DHCP server reference implementation.
++For more information see www.isc.org.
++
++3. Design Considerations
++
++The DHCP LDAP schema is designed to be a simple multi-server schema. The
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 1]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++intent of this schema is to provide a basic framework for representing
++the most common elements used in the configuration of DHCP Server.  This
++should allow other network services to obtain and use basic DHCP
++configuration information in a server-independent but knowledgeable way.
++
++It is expected that some implementations may need to extend the schema
++objects, in order to implement all of their features or needs. It is
++recommended that you use the schema defined in this draft to represent
++DHCP configuration information in an LDAP directory.  Conforming to a
++standard schema improves interoperability between DHCP implementations
++from different vendors.
++
++Some implementations may choose not to support all of the objects
++defined here.
++
++Two decisions are explicitly left up to each implementation:
++
++First, implementations may choose not to store the lease information in
++the directory, so those objects would not be used.
++
++Second, implementations may choose not to implement the auditing
++information.
++
++It is up to the implementation to determine if the data in the directory
++is considered &quot;authoritative&quot;, or if it is simply a copy of data from an
++authoritative source. Validity of the information if used as a copy is
++to be ensured by the implementation.
++
++Primarily two types of applications will use the information in this
++schema: 1. DHCP servers (for loading their configuration) 2. Management
++Interfaces (for defining/editing configurations).
++
++The schema should be efficient for the needs of both types of
++applications.  The schema is designed to allow objects managed by DHCP
++(such as computers, subnets, etc) to be present anywhere in a directory
++hierarchy (to allow those objects to be placed in the directory for
++managing administrative control and access to the objects).
++
++The schema uses a few naming conventions - all object classes and
++attributes are prefixed with &quot;dhcp&quot; to decrease the chance that object
++classes and attributes will have the same name.  The schema also uses
++standard naming attributes (&quot;cn&quot;, &quot;ou&quot;, etc) for all objects.
++
++4. Common DHCP Configuration Attributes
++
++Although DHCP manages several different types of objects, the
++configuration of those objects is often similar.  Consequently, most of
++these objects have a common set of attributes, which are defined below.
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 2]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++4.1. Attributes Definitions
++
++The schema definitions listed below are for readability.  The LDIF
++layout for this schema will follow in section 8.
++
++Name: dhcpPrimaryDN Description: The Distinguished Name of the
++dhcpServer object, which is the primary server for the configuration.
++Syntax: DN Flags: SINGLE-VALUE
++
++Named: dhcpSecondaryDN Description: The Distinguished Name(s) of the
++dhcpServer object(s), which are secondary servers for the configuration.
++Syntax: DN
++
++Name: dhcpStatements Description: Flexible storage for representing any
++specific data depending on the object to which it is attached. Examples
++include conditional statements, Server parameters, etc.  This also
++serves as a 'catch-all' attribute that allows the standard to evolve
++without needing to update the schema.  Syntax: IA5String
++
++Name: dhcpRange Description: The starting and ending IP Addresses in the
++range (inclusive), separated by a hyphen; if the range only contains one
++address, then just the address can be specified with no hyphen.  Each
++range is defined as a separate value.  Syntax: IA5String
++
++Name: dhcpPermitList Description: This attribute contains the permit
++lists associated with a pool. Each permit list is defined as a separate
++value.  Syntax: IA5String
++
++Name: dhcpNetMask Description: The subnet mask length for the subnet.
++The mask can be easily computed from this length.  Syntax: Integer
++Flags: SINGLE-VALUE
++
++Name: dhcpOption Description: Encoded option values to be sent to
++clients.  Each value represents a single option and contains (OptionTag,
++Length, OptionData) encoded in the format used by DHCP.  For more
++information see [DHCPOPT].  Syntax: OctetString
++
++Name: dhcpClassData Description: Encoded text string or list of bytes
++expressed in hexadecimal, separated by colons. Clients match subclasses
++based on matching the class data with the results of a 'match' or 'spawn
++with' statement in the class name declarations.  Syntax: IA5String
++Flags: SINGLE-VALUE
++
++Name: dhcpSubclassesDN Description: List of subclasses, these are the
++actual DN of each subclass object.  Syntax: DN
++
++Name: dhcpClassesDN Description: List of classes, these are the actual
++DN of each class object.  Syntax: DN
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 3]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++Name: dhcpSubnetDN Description: List of subnets, these are the actual DN
++of each subnet object.  Syntax: DN
++
++Name: dhcpPoolDN Description: List of pools, these are the actual DN of
++each Pool object.  Syntax: DN
++
++Name: dhcpOptionsDN Description: List of options, these are the actual
++DN of each Options object.  Syntax: DN
++
++Name: dhcpHostDN Description: List of hosts, these are the actual DN of
++each host object.  Syntax: DN
++
++Name: dhcpSharedNetworkDN Description: List of shared networks, these
++are the actual DN of each shared network object.  Syntax: DN
++
++Name: dhcpGroupDN Description: List of groups, these are the actual DN
++of each Group object.  Syntax: DN
++
++Name: dhcpLeaseDN Description: Single Lease DN. A dhcpHost configuration
++uses this attribute to identify a static IP address assignment.  Syntax:
++DN Flags: SINGLE-VALUE
++
++Name: dhcpLeasesDN Description: List of leases, these are the actual DN
++of each lease object.  Syntax: DN
++
++Name: dhcpServiceDN Description: The DN of dhcpService object(s)which
++contain the configuration information. Each dhcpServer object has this
++attribute identifying the DHCP configuration(s) that the server is
++associated with.  Syntax: DN
++
++Name: dhcpHWAddress Description: The hardware address of the client
++associated with a lease Syntax: OctetString Flags: SINGLE-VALUE
++
++Name: dhcpVersion Description: This is the version identified for the
++object that this attribute is part of. In case of the dhcpServer object,
++this represents the DHCP software version.  Syntax: IA5String Flags:
++SINGLE-VALUE
++
++Name: dhcpImplementation Description: DHCP Server implementation
++description e.g. DHCP Vendor information.  Syntax: IA5String Flags:
++SINGLE-VALUE
++
++Name: dhcpHashBucketAssignment Description: HashBucketAssignment bit map
++for the DHCP Server, as defined in DHC Load Balancing Algorithm [RFC
++3074].  Syntax: Octet String Flags: SINGLE-VALUE
++
++Name: dhcpDelayedServiceParameter Description: Delay in seconds
++corresponding to Delayed Service Parameter configuration, as defined in
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 4]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++DHC Load Balancing Algorithm [RFC 3074].  Syntax: Integer Flags: SINGLE-
++VALUE
++
++Name: dhcpMaxClientLeadTime Description: Maximum Client Lead Time
++configuration in seconds, as defined in DHCP Failover Protocol [FAILOVR]
++Syntax: Integer Flags: SINGLE-VALUE
++
++Name: dhcpFailOverEndpointState Description: Server (Failover Endpoint)
++state, as defined in DHCP Failover Protocol [FAILOVR] Syntax: IA5String
++Flags: SINGLE-VALUE
++
++5. Configurations and Services
++
++The schema definitions below are for readability the LDIF layout for
++this schema will follow in section 8.
++
++The DHC working group is currently considering several proposals for
++fail-over and redundancy of DHCP servers.  These may require sharing of
++configuration information between servers.  This schema provides a
++generalized mechanism for supporting any of these proposals, by
++separating the definition of a server from the definition of
++configuration service provided by the server.
++
++Separating the DHCP Server (dhcpServer) and the DHCP Configuration
++(dhcpService) representations allows a configuration service to be
++provided by one or more servers. Similarly, a server may provide one or
++more configurations. The schema allows a server to be configured as
++either a primary or secondary provider of a DHCP configuration.
++
++Configurations are also defined so that one configuration can include
++some of the objects that are defined in another configuration.  This
++allows for sharing and/or a hierarchy of related configuration items.
++
++Name: dhcpService Description:  Service object that represents the
++actual DHCP Service configuration. This will be a container with the
++following attributes.  Must: cn, dhcpPrimaryDN May: dhcpSecondaryDN,
++dhcpSharedNetworkDN, dhcpSubnetDN, dhcpGroupDN, dhcpHostDN,
++dhcpClassesDN, dhcpOptionsDN, dhcpStatements
++
++The following objects could exist inside the dhcpService container:
++dhcpSharedNetwork, dhcpSubnet, dhcpGroup, dhcpHost, dhcpClass,
++dhcpOptions, dhcpLog
++
++Name: dhcpServer Description:  Server object that the DHCP server will
++login as.  The configuration information is in the dhcpService container
++that the dhcpServiceDN points to.  Must: cn, dhcpServiceDN May:
++dhcpVersion, dhcpImplementation, dhcpHashBucketAssignment,
++dhcpDelayedServiceParameter, dhcpMaxClientLeadTime, 
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 5]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++dhcpFailOverEndpointState, dhcpStatements
++
++5.1. DHCP Declaration related classes:
++
++Name: dhcpSharedNetwork Description: Shared Network class will list what
++pools and subnets are in this network.
++
++This will be a container with the following attributes.  Must: cn May:
++dhcpSubnetDN, dhcpPoolDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpSharedNetwork container:
++dhcpSubnet, dhcpPool, dhcpOptions, dhcpLog
++
++Name: dhcpSubnet Description: Subnet object will include configuration
++information associated with a subnet, including a range and a net mask.
++
++This will be a container with the following attributes.  Must: cn
++(Subnet address), dhcpNetMask May: dhcpRange, dhcpPoolDN, dhcpGroupDN,
++dhcpHostDN, dhcpClassesDN, dhcpLeasesDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpSubnet container: dhcpPool,
++dhcpGroup, dhcpHost, dhcpClass, dhcpOptions, dhcpLease, dhcpLog
++
++Name: dhcpGroup Description: Group object will have configuration
++information associated with a group.
++
++This will be a container with the following attributes.  Must: cn May:
++dhcpHostDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpGroup container: dhcpHost,
++dhcpOptions
++
++Name: dhcpHost Description: The host object includes DHCP host
++declarations to assign a static IP address or declare the client as
++known or specify statements for a specific client.  Must: cn May:
++dhcpLeaseDN, dhcpHWAddress, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpHost container: dhcpLease,
++dhcpOptions
++
++Name: dhcpOptions Description: The options class is for option space
++declarations, it contains a list of options.  Must: cn, dhcpOption
++
++Name: dhcpClass Description: This is a class to group clients together
++based on matching rules.
++
++This will be a container with the following attributes.  Must: cn May:
++dhcpSubClassesDN, dhcpOptionsDN, dhcpStatements
++
++The following object can exist within a dhcpClass container:
++dhcpSubclass, dhcpOptions
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 6]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++Name: dhcpSubClass Description: This includes configuration information
++for a subclass associated with a class. The dhcpSubClass object will
++always be contained within the corresponding class container object.
++Must: cn May:  dhcpClassData, dhcpOptionsDN, dhcpStatements
++
++Name: dhcpPool Description: This contains configuration for a pool that
++will have the range of addresses, permit lists and point to classes and
++leases that are members of this pool.
++
++This will be a container that could be contained by dhcpSubnet or a
++dhcpSharedNetwork.  Must: cn, dhcpRange May: dhcpClassesDN,
++dhcpPermitList, dhcpLeasesDN, dhcpOptionsDN, dhcpStatements
++
++The following objects can exist within a dhcpPool container: dhcpClass,
++dhcpOptions, dhcpLease, dhcpLog
++
++6. Tracking Address Assignments
++
++The behavior of a DHCP server is influenced by two factors - it's
++configuration and the current state of the addresses that have been
++assigned to clients. This schema defines a set of objects for
++representing the DHCP configuration associated with a server. The
++following object classes provide the ability to record how addresses are
++used including maintaining history (audit log) on individual leases.
++Recording lease information in a directory could result in a significant
++performance impact and is therefore optional. Implementations supporting
++logging of leases need to consider the performance impact.
++
++6.1. dhcpLeases Attribute Definitions
++
++The schema definitions below are for readability the LDIF layout for
++this schema will follow in section 8.
++
++Name: dhcpAddressState Description: This stores information about the
++current binding-status of an address.  For dynamic addresses managed by
++DHCP, the values should be restricted to the states defined in the DHCP
++Failover Protocol draft [FAILOVR]: 'FREE', 'ACTIVE', 'EXPIRED',
++'RELEASED', 'RESET', 'ABANDONED', 'BACKUP'.  For more information on
++these states see [FAILOVR].  For other addresses, it SHOULD be one of
++the following: 'UNKNOWN', 'RESERVED' (an address that is managed by DHCP
++that is reserved for a specific client), 'RESERVED-ACTIVE' (same as
++reserved, but address is currently in use),  'ASSIGNED' (assigned
++manually or by some other mechanism), 'UNASSIGNED', 'NOTASSIGNABLE'.
++Syntax: IA5String Flags: SINGLE-VALUE
++
++Name: dhcpExpirationTime Description: This is the time the current lease
++for an address expires.  Syntax: DateTime Flags: SINGLE-VALUE
++
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 7]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++Name: dhcpStartTimeOfState Description: This is the time of the last
++state change for a leased address.  Syntax: DateTime Flags: SINGLE-VALUE
++
++Name: dhcpLastTransactionTime Description: This is the last time a valid
++DHCP packet was received from the client.  Syntax: DateTime Flags:
++SINGLE-VALUE
++
++Name: dhcpBootpFlag Description: This indicates whether the address was
++assigned via BOOTP Syntax: Boolean Flags: SINGLE-VALUE
++
++Name: dhcpDomainName Description: This is the name of the domain sent to
++the client by the server.  It is essentially the same as the value for
++DHCP option 15 sent to the client, and represents only the domain - not
++the full FQDN.  To obtain the full FQDN assigned to the client you must
++prepend the &quot;dhcpAssignedHostName&quot; to this value with a &quot;.&quot;.  Syntax:
++IA5String Flags: SINGLE-VALUE
++
++Name: dhcpDnsStatus Description: This indicates the status of updating
++DNS resource records on behalf of the client by the DHCP server for this
++address.  The value is a 16-bit bitmask that has the same values as
++specified by the Failover-DDNS option (see [FAILOVR]).  Syntax: Integer
++Flags: SINGLE-VALUE
++
++Name: dhcpRequestedHostName Description: This is the hostname that was
++requested by the client.  Syntax: IA5String Flags: SINGLE-VALUE
++
++Name: dhcpAssignedHostName Description: This is the actual hostname that
++was assigned to a client. It may not be the name that was requested by
++the client.  The fully qualified domain name can be determined by
++appending the value of &quot;dhcpDomainName&quot; (with a dot separator) to this
++name.  Syntax: IA5String Flags: SINGLE-VALUE
++
++Name: dhcpReservedForClient Description: This is the distinguished name
++of the &quot;dhcpHost&quot; that an address is reserved for.  This may not be the
++same as the &quot;dhcpAssignedToClient&quot; attribute if the address is being
++reassigned but the current lease has not yet expired.  Syntax: DN Flags:
++SINGLE-VALUE
++
++Name: dhcpAssignedToClient Description: This is the distinguished name
++of a &quot;dhcpHost&quot; that an address is currently assigned to.  This
++attribute is only present in the class when the address is leased.
++Syntax: DN Flags: SINGLE-VALUE
++
++Name: dhcpRelayAgentInfo Description: If the client request was received
++via a relay agent, this contains information about the relay agent that
++was available from the DHCP request.  This is a hex-encoded option
++value.  Syntax: OctetString Flags: SINGLE-VALUE
++
++Name: dhcpErrorLog Description: Generic error log attribute that allows
++logging error conditions within a dhcpService or a dhcpSubnet, like no IP 
++addresses available for lease. Syntax: IA5String 
++
++M. Meredith et al.        Expires December 2001                 [Page 8]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++6.2.  dhcpLeases Object Class
++
++This class represents an IP address.  It may or may not be leaseable,
++and the object may exist even though a lease is not currently active for
++the associated IP address.
++
++It is recommended that all Lease objects for a single DHCP Service be
++centrally located within a single container. This ensures that the lease
++objects and the corresponding logs do not have to be relocated, when
++address ranges allocated to individual DHCP subnets and/or pools change.
++
++The schema definitions below are for readability the LDIF layout for
++this schema will follow in section 8.
++
++Name: dhcpLeases Description: This is the object that holds state
++information about an IP address. The cn (which is the IP address), and
++the current address-state are mandatory attributes. If the address is
++assigned then, some of the optional attributes will have valid data.
++Must: cn, dhcpAddressState May: dhcpExpirationTime,
++dhcpStartTimeOfState, dhcpLastTransactionTime, dhcpBootpFlag,
++dhcpDomainName, dhcpDnsStatus, dhcpRequestedHostName,
++dhcpAssignedHostName, dhcpReservedForClient, dhcpAssignedToClient,
++dhcpRelayAgentInfo, dhcpHWAddress
++
++6.3 Audit Log Information
++
++A dhcpLog object is created whenever a lease is assigned or released.
++This object is intended to be created under the corresponding dhcpLeases
++container, or dhcpPool, dhcpSubnet, dhcpSharedNetwork or dhcpService
++containers.
++
++The log information under the dhcpLeases container would be for
++addresses matching that lease information. The log information in the
++other containers could be used for errors, i.e. when a pool or subnet is
++out our addresses or if a server is not able to assign any more
++addresses for a particular dhcpService.
++
++Name: dhcpLog Description: This is the object that holds past
++information about an IP address. The cn is the time/date stamp when the
++address was assigned or released, the address state at the time, if the
++address was assigned or released.  Must: cn May: dhcpAddressState,
++dhcpExpirationTime, dhcpStartTimeOfState, dhcpLastTransactionTime,
++dhcpBootpFlag, dhcpDomainName, dhcpDnsStatus, dhcpRequestedHostName,
++dhcpAssignedHostName, dhcpReservedForClient, dhcpAssignedToClient,
++dhcpRelayAgentInfo, dhcpHWAddress, dhcpErrorLog
++
++
++
++
++
++
++M. Meredith et al.        Expires December 2001                 [Page 9]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++7. Determining settings
++
++The dhcpStatements attribute is the key to DHC enhancements that may
++come along, and the different key words that a particular server
++implementation may use. This attribute can be used to hold conditional
++DHCP Statements and DHCP server parameters. Having a generic settings
++attribute that is just a string, allows this schema to be extensible and
++easy to configure.
++
++All of the attributes that end with DN are references to the class that
++precedes the DN e.g. the dhcpPrimaryDN and dhcpSecondaryDN attributes
++hold the Distinguished Names of the dhcpServer objects that are
++associated with the dhcpService object.
++
++8. LDIF format for attributes and classes.
++
++# Attributes
++
++( 2.16.840.1.113719.1.203.4.1 NAME 'dhcpPrimaryDN' DESC
++'The DN of the dhcpServer which is the primary server for the
++configuration.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.2 NAME 'dhcpSecondaryDN' DESC 'The DN of
++dhcpServer(s) which provide backup service for the configuration.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.3 NAME 'dhcpStatements' DESC 'Flexible
++storage for specific data depending on what object this exists in. Like
++conditional statements, server parameters, etc. This allows the standard
++to evolve without needing to adjust the schema.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.26 )
++
++( 2.16.840.1.113719.1.203.4.4 NAME 'dhcpRange' DESC 'The starting &amp;
++ending IP Addresses in the range (inclusive), separated by a hyphen; if
++the range only contains one address, then just the address can be
++specified with no hyphen.  Each range is defined as a separate value.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++( 2.16.840.1.113719.1.203.4.5 NAME 'dhcpPermitList' DESC 'This attribute
++contains the permit lists associated with a pool. Each permit list is
++defined as a separate value.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )
++
++( 2.16.840.1.113719.1.203.4.6 NAME 'dhcpNetMask' DESC 'The subnet mask
++length for the subnet.  The mask can be easily computed from this
++length.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.7 NAME 'dhcpOption' DESC 'Encoded option
++values to be sent to clients.  Each value represents a single option and
++contains (OptionTag, Length, OptionValue) encoded in the format used by
++DHCP.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 )
++
++M. Meredith et al.        Expires December 2001                [Page 10]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++( 2.16.840.1.113719.1.203.4.8 NAME 'dhcpClassData' DESC 'Encoded text
++string or list of bytes expressed in hexadecimal, separated by colons.
++Clients match subclasses based on matching the class data with the
++results of match or spawn with statements in the class name
++declarations.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.9 NAME 'dhcpOptionsDN' DESC 'The
++distinguished name(s) of the dhcpOption objects containing the
++configuration options provided by the server.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.10 NAME 'dhcpHostDN' DESC 'the distinguished
++name(s) of the dhcpHost objects.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.11 NAME 'dhcpPoolDN' DESC 'The distinguished
++name(s) of pools.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.12 NAME 'dhcpGroupDN' DESC 'The
++distinguished name(s)   of the groups.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.13 NAME 'dhcpSubnetDN' DESC 'The
++distinguished name(s) of the subnets.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.14 NAME 'dhcpLeaseDN' DESC 'The
++distinguished name of a client address.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE)
++
++( 2.16.840.1.113719.1.203.4.15 NAME 'dhcpLeasesDN' DESC 'The
++distinguished name(s) client addresses.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.16 NAME 'dhcpClassesDN' DESC 'The
++distinguished name(s) of a class(es) in a subclass.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.17 NAME 'dhcpSubclassesDN' DESC 'The
++distinguished name(s) of subclass(es).' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.18 NAME 'dhcpSharedNetworkDN' DESC 'The
++distinguished name(s) of sharedNetworks.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.19 NAME 'dhcpServiceDN' DESC 'The DN of
++dhcpService object(s)which contain the configuration information. Each
++dhcpServer object has this attribute identifying the DHCP
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 11]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++configuration(s) that the server is associated with.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.12 )
++
++( 2.16.840.1.113719.1.203.4.20 NAME 'dhcpVersion' DESC 'The version
++attribute of this object.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-
++VALUE )
++
++( 2.16.840.1.113719.1.203.4.21 NAME 'dhcpImplementation' DESC
++'Description of the DHCP Server implementation e.g. DHCP Server's
++vendor.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.22 NAME 'dhcpAddressState' DESC 'This stores
++information about the current binding-status of an address.  For dynamic
++addresses managed by DHCP, the values should be restricted to the
++following: &quot;FREE&quot;, &quot;ACTIVE&quot;, &quot;EXPIRED&quot;, &quot;RELEASED&quot;, &quot;RESET&quot;,
++&quot;ABANDONED&quot;, &quot;BACKUP&quot;.  For other addresses, it SHOULD be one of the
++following: &quot;UNKNOWN&quot;, &quot;RESERVED&quot; (an address that is managed by DHCP
++that is reserved for a specific client), &quot;RESERVED-ACTIVE&quot; (same as
++reserved, but address is currently in use), &quot;ASSIGNED&quot; (assigned
++manually or by some other mechanism), &quot;UNASSIGNED&quot;, &quot;NOTASSIGNABLE&quot;.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.23 NAME 'dhcpExpirationTime' DESC 'This is
++the time the current lease for an address expires.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.24 NAME 'dhcpStartTimeOfState' DESC 'This is
++the time of the last state change for a leased address.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.25 NAME 'dhcpLastTransactionTime' DESC 'This
++is the last time a valid DHCP packet was received from the client.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.24 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.26 NAME 'dhcpBootpFlag' DESC 'This indicates
++whether the address was assigned via BOOTP.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.7 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.27 NAME 'dhcpDomainName' DESC 'This is the
++name of the domain sent to the client by the server.  It is essentially
++the same as the value for DHCP option 15 sent to the client, and
++represents only the domain - not the full FQDN.  To obtain the full FQDN
++assigned to the client you must prepend the &quot;dhcpAssignedHostName&quot; to
++this value with a &quot;.&quot;.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-
++VALUE )
++
++( 2.16.840.1.113719.1.203.4.28 NAME 'dhcpDnsStatus' DESC 'This indicates
++the status of updating DNS resource records on behalf of the client by
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 12]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++the DHCP server for this address.  The value is a 16-bit bitmask.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.29 NAME 'dhcpRequestedHostName' DESC 'This
++is the hostname that was requested by the client.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.30 NAME 'dhcpAssignedHostName' DESC 'This is
++the actual hostname that was assigned to a client. It may not be the
++name that was requested by the client.  The fully qualified domain name
++can be determined by appending the value of &quot;dhcpDomainName&quot; (with a dot
++separator) to this name.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-
++VALUE )
++
++( 2.16.840.1.113719.1.203.4.31 NAME 'dhcpReservedForClient' DESC 'The
++distinguished name of a &quot;dhcpClient&quot; that an address is reserved for.
++This may not be the same as the &quot;dhcpAssignedToClient&quot; attribute if the
++address is being reassigned but the current lease has not yet expired.'
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.32 NAME 'dhcpAssignedToClient' DESC 'This is
++the distinguished name of a &quot;dhcpClient&quot; that an address is currently
++assigned to.  This attribute is only present in the class when the
++address is leased.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.33 NAME 'dhcpRelayAgentInfo' DESC 'If the
++client request was received via a relay agent, this contains information
++about the relay agent that was available from the DHCP request.  This is
++a hex-encoded option value.' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40
++SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.34 NAME 'dhcpHWAddress' DESC 'The clients
++hardware address that requested this IP address.' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.35 NAME 'dhcpHashBucketAssignment' DESC
++'HashBucketAssignment bit map for the DHCP Server, as defined in DHC
++Load Balancing Algorithm [RFC 3074].' SYNTAX
++1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.36 NAME 'dhcpDelayedServiceParameter' DESC
++'Delay in seconds corresponding to Delayed Service Parameter
++configuration, as defined in  DHC Load Balancing Algorithm [RFC 3074]. '
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.37 NAME 'dhcpMaxClientLeadTime' DESC
++'Maximum Client Lead Time configuration in seconds, as defined in DHCP
++Failover Protocol [FAILOVR]' SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 13]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.38 NAME 'dhcpFailOverEndpointState' DESC
++'Server (Failover Endpoint) state, as defined in DHCP Failover Protocol
++[FAILOVR]' SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++( 2.16.840.1.113719.1.203.4.39 NAME 'dhcpErrorLog' DESC
++Generic error log attribute that allows logging error conditions within a 
++dhcpService or a dhcpSubnet, like no IP addresses available for lease. 
++SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE )
++
++#Classes
++
++( 2.16.840.1.113719.1.203.6.1 NAME 'dhcpService' DESC ' Service object
++that represents the actual DHCP Service configuration. This is a
++container object.' SUP top MUST (cn $ dhcpPrimaryDN) MAY
++(dhcpSecondaryDN $ dhcpSharedNetworkDN $ dhcpSubnetDN $ dhcpGroupDN $
++dhcpHostDN $  dhcpClassesDN $ dhcpOptionsDN $ dhcpStatements ) )
++
++( 2.16.840.1.113719.1.203.6.2 NAME 'dhcpSharedNetwork' DESC 'This stores
++configuration information for a shared network.' SUP top MUST  cn MAY
++(dhcpSubnetDN $ dhcpPoolDN $ dhcpOptionsDN $ dhcpStatements) X-
++NDS_CONTAINMENT ('dhcpService' ) )
++
++( 2.16.840.1.113719.1.203.6.3 NAME 'dhcpSubnet' DESC 'This class defines
++a subnet. This is a container object.' SUP top MUST ( cn $ dhcpNetMask )
++MAY (dhcpRange $ dhcpPoolDN $ dhcpGroupDN $ dhcpHostDN $ dhcpClassesDN $
++dhcpLeasesDN $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++('dhcpService' 'dhcpSharedNetwork') )
++
++( 2.16.840.1.113719.1.203.6.4 NAME 'dhcpPool' DESC 'This stores
++configuration information about a pool.' SUP top MUST ( cn $ dhcpRange )
++MAY (dhcpClassesDN $ dhcpPermitList $ dhcpLeasesDN $ dhcpOptionsDN $
++dhcpStatements) X-NDS_CONTAINMENT ('dhcpSubnet' 'dhcpSharedNetwork') )
++
++( 2.16.840.1.113719.1.203.6.5 NAME 'dhcpGroup' DESC 'Group object that
++lists host DNs and parameters. This is a container object.' SUP top MUST
++cn MAY ( dhcpHostDN $ dhcpOptionsDN $ dhcpStatements ) X-NDS_CONTAINMENT
++('dhcpSubnet' 'dhcpService' ) )
++
++( 2.16.840.1.113719.1.203.6.6 NAME 'dhcpHost' DESC 'This represents
++information about a particular client' SUP top MUST cn MAY  (dhcpLeaseDN
++$ dhcpHWAddress $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++('dhcpService' 'dhcpSubnet' 'dhcpGroup') )
++
++( 2.16.840.1.113719.1.203.6.7 NAME 'dhcpClass' DESC 'Represents
++information about a collection of related clients.' SUP top MUST cn MAY
++(dhcpSubClassesDN $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++('dhcpService' 'dhcpSubnet' ) )
++
++( 2.16.840.1.113719.1.203.6.8 NAME 'dhcpSubClass' DESC 'Represents
++information about a collection of related classes.' SUP top MUST cn MAY
++(dhcpClassData $ dhcpOptionsDN $ dhcpStatements) X-NDS_CONTAINMENT
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 14]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++'dhcpClass' )
++
++( 2.16.840.1.113719.1.203.6.9 NAME 'dhcpOptions' DESC 'Represents
++information about a collection of options defined.' SUP top MUST cn MAY
++( dhcpOption ) X-NDS_CONTAINMENT  ('dhcpService' 'dhcpSharedNetwork'
++'dhcpSubnet' 'dhcpPool' 'dhcpGroup' 'dhcpHost' 'dhcpClass' )
++
++( 2.16.840.1.113719.1.203.6.10 NAME 'dhcpLeases' DESC 'This class
++represents an IP Address, which may or may not have been leased.' SUP
++top MUST ( cn $ dhcpAddressState ) MAY ( dhcpExpirationTime $
++dhcpStartTimeOfState $ dhcpLastTransactionTime $ dhcpBootpFlag $
++dhcpDomainName $ dhcpDnsStatus $ dhcpRequestedHostName $
++dhcpAssignedHostName $ dhcpReservedForClient $ dhcpAssignedToClient $
++dhcpRelayAgentInfo $ dhcpHWAddress ) X-NDS_CONTAINMENT ( 'dhcpService'
++'dhcpSubnet' 'dhcpPool') )
++
++( 2.16.840.1.113719.1.203.6.11 NAME 'dhcpLog' DESC 'This is the object
++that holds past information about the IP address. The cn is the
++time/date stamp when the address was assigned or released, the address
++state at the time, if the address was assigned or released.' SUP top
++MUST ( cn ) MAY ( dhcpAddressState $ dhcpExpirationTime $
++dhcpStartTimeOfState $ dhcpLastTransactionTime $ dhcpBootpFlag $
++dhcpDomainName $ dhcpDnsStatus $ dhcpRequestedHostName $
++dhcpAssignedHostName $ dhcpReservedForClient $ dhcpAssignedToClient $
++dhcpRelayAgentInfo $ dhcpHWAddress $ dhcpErrorLog) X-NDS_CONTAINMENT 
++('dhcpLeases' 'dhcpPool' 'dhcpSubnet' 'dhcpSharedNetwork' 'dhcpService' ) )
++
++( 2.16.840.1.113719.1.203.6.12 NAME 'dhcpServer' DESC 'DHCP Server
++Object' SUP top MUST (cn, dhcpServiceDN) MAY (dhcpVersion $
++dhcpImplementation $ dhcpHashBucketAssignment $
++dhcpDelayedServiceParameter $ dhcpMaxClientLeadTime $
++dhcpFailOverEndpointState $ dhcpStatements) X-NDS_CONTAINMENT ('O' 'OU' 
++'dc') )
++
++9. Security Considerations
++
++Since the DHCP Configuration information is stored in a directory, the
++security of the information is limited to the security offered by the
++directory including the security of the objects within that directory.
++
++10.  Intellectual Property Rights Notices
++
++The IETF takes no position regarding the validity or scope of any
++intellectual property or other rights that might be claimed to pertain
++to the implementation or use of the technology described in this
++document or the extent to which any license under such rights might or
++might not be available; neither does it represent that it has made any
++effort to identify any such rights.  Information on the IETF's
++procedures with respect to rights in standards-track and standards-
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 15]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++related documentation can be found in BCP-11.  Copies of claims of
++rights made available for publication and any assurances of licenses to
++be made available, or the result of an attempt made to obtain a general
++license or permission for the use of such proprietary rights by
++implementors or users of this specification can be obtained from the
++IETF Secretariat.
++
++The IETF invites any interested party to bring to its attention any
++copyrights, patents or patent applications, or other proprietary rights
++which may cover technology that may be required to practice this
++standard.  Please address the information to the IETF Executive
++Director.
++
++11.  Full Copyright Statement
++
++Copyright (C) The Internet Society (2001).  All Rights Reserved.
++
++This document and translations of it may be copied and furnished to
++others, and derivative works that comment on or otherwise explain it or
++assist in its implementation may be prepared, copied, published and
++distributed, in whole or in part, without restriction of any kind,
++provided that the above copyright notice and this paragraph are included
++on all such copies and derivative works.  However, this document itself
++may not be modified in any way, such as by removing the copyright notice
++or references to the Internet Society or other Internet organizations,
++except as needed for the purpose of developing Internet standards in
++which case the procedures for copyrights defined in the Internet
++Standards process must be followed, or as required to translate it into
++languages other than English.
++
++The limited permissions granted above are perpetual and will not be
++revoked by the Internet Society or its successors or assigns.
++
++This document and the information contained herein is provided on an &quot;AS
++IS&quot; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK
++FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT
++LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT
++INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR
++FITNESS FOR A PARTICULAR PURPOSE.
++
++12. References
++
++[RFC2131] Droms, R., &quot;Dynamic Host Configuration Protocol&quot;, RFC 2131,
++March 1997.
++
++[RFC2132] Alexander, S., Droms, R., &quot;DHCP Options and BOOTP Vendor
++Extensions&quot;, RFC 2132, March 1997.
++
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 16]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++[MSDHCP]  Gu, Y., Vyaghrapuri, R., &quot;An LDAP Schema for Dynamic Host
++Configuration Protocol Service&quot;, Internet Draft &lt;draft-gu-dhcp-ldap-
++schema-00.txt&gt;, August 1998.
++
++[NOVDHCP] Miller, T., Patel, A., Rao, P., &quot;Lightweight Directory Access
++Protocol (v3): Schema for Dynamic Host Configuration Protocol (DHCP)&quot;,
++Internet Draft &lt;draft-miller-dhcp-ldap-schema-00.txt&gt;, June 1998.
++
++[FAILOVR] Droms, R., Rabil, G., Dooley, M., Kapur, A., Gonczi, S., Volz,
++B., &quot;DHCP Failover Protocol&quot;, Internet Draft &lt;draft-ietf-dhc-
++failover-08.txt&gt;, July 2000.
++
++[RFC 3074] Volz B., Gonczi S., Lemon T., Stevens R., &quot;DHC Load Balancing
++Algorithm&quot;, February 2001
++
++[AGENT]   Patrick, M., &quot;DHCP Relay Agent Information Option&quot;, Internet
++Draft &lt;draft-ietf-dhc-agent-options-09.txt&gt;, March 2000.
++
++[DHCPOPT] Carney, M., &quot;New Option Review Guidelines and Additional
++Option Namespace&quot;, Internet Draft &lt;draft-ietf-dhc-
++option_review_and_namespace-01.txt&gt;, October 1999.
++
++[POLICY]  Strassner, J., Elleson, E., Moore, B., &quot;Policy Framework LDAP
++Core Schema&quot;, Internet Draft &lt;draft-ietf-policy-core-schema-06.txt&gt;,
++November 1999.
++
++[RFC2251] Wahl, M., Howes, T., Kille, S., &quot;Lightweight Directory Access
++Protocol (v3)&quot;, RFC 2251, December 1997.
++
++[RFC2252] Wahl, M., Coulbeck, A., Howes, T., Kille, S., &quot;Lightweight
++Directory Access Protocol (v3) Attribute Syntax Definitions&quot;, RFC 2252,
++December 1997.
++
++[RFC2255] Howes, T., Smith, M., &quot;The LDAP URL Format&quot;, RFC 2255,
++December 1997.
++
++[RFC951]  Croft, B., Gilmore, J., &quot;Bootstrap Protocol (BOOTP)&quot;, RFC 951,
++September 1985.
++
++[RFC2119] Bradner, S. &quot;Key words for use in RFCs to Indicate Requirement
++Levels&quot;, RFC 2119, March 1997.
++
++13. Acknowledgments
++
++This work is partially based on a previous draft draft-ietf-dhc-
++schema-02.doc.
++
++
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 17]
++
++
++
++
++
++INTERNET-DRAFT            LDAP Schema for DHCP              16 June 2001
++
++
++14. Author's Addresses
++
++Comments regarding this draft may be sent to the authors at the
++following address:
++
++Mark Meredith
++Mark Hinckley
++Novell Inc.
++1800 S. Novell Place
++Provo, Utah 84606
++
++Vijay K. Nanjundaswamy
++Novell Software Development (I) Ltd
++49/1 &amp; 49/3, Garvebhavi Palya,
++7th Mile, Hosur Road
++Bangalore 560068
++
++email: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mark_meredith at novell.com</A>
++email: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">knvijay at novell.com</A>
++email: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">mhinckley at novell.com</A>
++
++This Internet Draft expires December 16, 2001.
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++
++M. Meredith et al.        Expires December 2001                [Page 18]
++
++
++
++
+diff -Naur dhcp-3.0.5/dst/Makefile.dist dhcp-3.0.5-ldap/dst/Makefile.dist
+--- dhcp-3.0.5/dst/Makefile.dist	2004-06-10 13:59:28.000000000 -0400
++++ dhcp-3.0.5-ldap/dst/Makefile.dist	2007-02-23 13:41:54.000000000 -0500
+@@ -23,12 +23,13 @@
+ 
+ SRC    = dst_support.c dst_api.c hmac_link.c md5_dgst.c base64.c prandom.c
+ OBJ    = dst_support.o dst_api.o hmac_link.o md5_dgst.o base64.o prandom.o
++OBJ_NM5= dst_support.o dst_api.o hmac_link.o base64.o prandom.o
+ HDRS   = dst_internal.h md5.h md5_locl.h
+ 
+ INCLUDES = $(BINDINC) -I$(TOP)/includes
+ CFLAGS = $(DEBUG) $(PREDEFINES) $(INCLUDES) $(COPTS) -DHMAC_MD5 -DMINIRES_LIB
+ 
+-all:	libdst.a
++all:	libdst.a libdst-nomd5.a
+ 
+ install:
+ 
+@@ -37,11 +38,16 @@
+ 	ar cruv libdst.a $(OBJ)
+ 	$(RANLIB) libdst.a
+ 
++libdst-nomd5.a:	$(OBJ_NM5)
++	rm -f libdst-nomd5.a
++	ar cruv libdst-nomd5.a $(OBJ_NM5)
++	$(RANLIB) libdst-nomd5.a
++
+ depend:
+ 	$(MKDEP) $(INCLUDES) $(PREDEFINES) $(SRC)
+ 
+ clean:
+-	-rm -f $(OBJ) libdst.a
++	-rm -f $(OBJ) libdst.a libdst-nomd5.a
+ 
+ realclean: clean
+ 	-rm -f *~ $(CATMANPAGES) $(SEDMANPAGES)
+diff -Naur dhcp-3.0.5/includes/dhcpd.h dhcp-3.0.5-ldap/includes/dhcpd.h
+--- dhcp-3.0.5/includes/dhcpd.h	2006-05-17 16:16:59.000000000 -0400
++++ dhcp-3.0.5-ldap/includes/dhcpd.h	2007-02-23 13:13:36.000000000 -0500
+@@ -79,6 +79,11 @@
+ #include &lt;isc-dhcp/result.h&gt;
+ #include &lt;omapip/omapip_p.h&gt;
+ 
++#if defined(LDAP_CONFIGURATION)
++# include &lt;ldap.h&gt;
++# include &lt;sys/utsname.h&gt; /* for uname() */
++#endif
++
+ #if !defined (OPTION_HASH_SIZE)
+ # define OPTION_HASH_SIZE 17
+ # define OPTION_HASH_PTWO 32	/* Next power of two above option hash. */
+@@ -139,6 +144,8 @@
+ 	char *inbuf;
+ 	unsigned bufix, buflen;
+ 	unsigned bufsiz;
++
++	int (*read_function) (struct parse *);
+ };
+ 
+ /* Variable-length array of data. */
+@@ -244,6 +251,32 @@
+ 	u_int8_t hbuf [17];
+ };
+ 
++#if defined(LDAP_CONFIGURATION)
++# define LDAP_BUFFER_SIZE		8192
++# define LDAP_METHOD_STATIC		0
++# define LDAP_METHOD_DYNAMIC		1
++#if defined (USE_SSL)
++# define LDAP_SSL_OFF			0
++# define LDAP_SSL_ON			1
++# define LDAP_SSL_TLS			2
++# define LDAP_SSL_LDAPS			3
++#endif
++
++/* This is a tree of the current configuration we are building from LDAP */
++
++struct ldap_config_stack {
++	LDAPMessage * res; 	/* Pointer returned from ldap_search */
++	LDAPMessage * ldent; 	/* Current item in LDAP that we're processing 
++				   in res */
++	int close_brace;	/* Put a closing } after we're through with
++				   this item */
++	int processed; 		/* We set this flag if this base item has been
++				   processed. After this base item is processed,
++				   we can start processing the children */
++	struct ldap_config_stack *next;
++};
++#endif
++
+ typedef enum {
+ 	server_startup = 0,
+ 	server_running = 1,
+@@ -426,6 +459,29 @@
+ # define DEFAULT_PING_TIMEOUT 1
+ #endif
+ 
++#if defined(LDAP_CONFIGURATION)
++# define SV_LDAP_SERVER  		47
++# define SV_LDAP_PORT  			48
++# define SV_LDAP_USERNAME  		49
++# define SV_LDAP_PASSWORD  		50
++# define SV_LDAP_BASE_DN 		51
++# define SV_LDAP_METHOD			52
++# define SV_LDAP_DEBUG_FILE		53
++# define SV_LDAP_DHCP_SERVER_CN		54
++# define SV_LDAP_REFERRALS              55
++#if defined (USE_SSL)
++# define SV_LDAP_SSL			56
++# define SV_LDAP_TLS_REQCERT		57
++# define SV_LDAP_TLS_CA_FILE		58
++# define SV_LDAP_TLS_CA_DIR		59
++# define SV_LDAP_TLS_CERT		60
++# define SV_LDAP_TLS_KEY		61
++# define SV_LDAP_TLS_CRLCHECK		62
++# define SV_LDAP_TLS_CIPHERS		63
++# define SV_LDAP_TLS_RANDFILE		64
++#endif
++#endif
++
+ #if !defined (DEFAULT_DEFAULT_LEASE_TIME)
+ # define DEFAULT_DEFAULT_LEASE_TIME 43200
+ #endif
+@@ -1531,7 +1587,7 @@
+ char *quotify_string (const char *, const char *, int);
+ char *quotify_buf (const unsigned char *, unsigned, const char *, int);
+ char *print_base64 (const unsigned char *, unsigned, const char *, int);
+-char *print_hw_addr PROTO ((int, int, unsigned char *));
++char *print_hw_addr PROTO ((const int, const int, const unsigned char *));
+ void print_lease PROTO ((struct lease *));
+ void dump_raw PROTO ((const unsigned char *, unsigned));
+ void dump_packet_option (struct option_cache *, struct packet *,
+@@ -2632,3 +2688,19 @@
+ #endif /* FAILOVER_PROTOCOL */
+ 
+ const char *binding_state_print (enum failover_state);
++
++/* ldap.c */
++#if defined(LDAP_CONFIGURATION)
++extern struct enumeration ldap_methods;
++#if defined (USE_SSL)
++extern struct enumeration ldap_ssl_usage_enum;
++extern struct enumeration ldap_tls_reqcert_enum;
++extern struct enumeration ldap_tls_crlcheck_enum;
++#endif
++isc_result_t ldap_read_config (void);
++int find_haddr_in_ldap (struct host_decl **, int, unsigned,
++                        const unsigned char *, const char *, int);
++int find_subclass_in_ldap (struct class *, struct class **, 
++			   struct data_string *);
++#endif
++
+diff -Naur dhcp-3.0.5/includes/ldap_casa.h dhcp-3.0.5-ldap/includes/ldap_casa.h
+--- dhcp-3.0.5/includes/ldap_casa.h	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/includes/ldap_casa.h	2006-12-14 10:03:41.000000000 -0500
+@@ -0,0 +1,83 @@
++/* ldap_casa.h
++   
++   Definition for CASA modules... */
++
++/* Copyright (c) 2004 Internet Systems Consorium, Inc. (&quot;ISC&quot;)
++ * Copyright (c) 1995-2003 Internet Software Consortium.
++ * Copyright (c) 2006 Novell, Inc.
++
++ * All rights reserved.
++ * Redistribution and use in source and binary forms, with or without 
++ * modification, are permitted provided that the following conditions are met: 
++ * 1.Redistributions of source code must retain the above copyright notice, 
++ *   this list of conditions and the following disclaimer. 
++ * 2.Redistributions in binary form must reproduce the above copyright notice, 
++ *   this list of conditions and the following disclaimer in the documentation 
++ *   and/or other materials provided with the distribution. 
++ * 3.Neither the name of ISC, ISC DHCP, nor the names of its contributors 
++ *   may be used to endorse or promote products derived from this software 
++ *   without specific prior written permission. 
++
++ * THIS SOFTWARE IS PROVIDED BY INTERNET SYSTEMS CONSORTIUM AND CONTRIBUTORS 
++ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
++ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
++ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ISC OR CONTRIBUTORS BE LIABLE 
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
++ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
++ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
++ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
++ * POSSIBILITY OF SUCH DAMAGE.
++
++ * This file was written by S Kalyanasundaram &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">skalyanasundaram at novell.com</A>&gt;
++ */
++
++#if defined(LDAP_CASA_AUTH)
++#ifndef __LDAP_CASA_H__
++#define __LDAP_CASA_H__
++
++#include &lt;micasa_mgmd.h&gt;
++#include &lt;dlfcn.h&gt;
++#include &lt;string.h&gt;
++
++#define MICASA_LIB     &quot;libmicasa.so.1&quot;
++
++SSCS_TYPEDEF_LIBCALL(int, CASA_GetCredential_T)
++(
++       uint32_t            ssFlags,
++       SSCS_SECRET_ID_T   *appSecretID,
++       SSCS_SECRET_ID_T   *sharedSecretID,
++       uint32_t           *credentialType,
++       void               *credential,
++       SSCS_EXT_T         *ext 
++);
++SSCS_TYPEDEF_LIBCALL(int, CASA_SetCredential_T)
++(
++       uint32_t            ssFlags,
++       SSCS_SECRET_ID_T   *appSecretID,
++       SSCS_SECRET_ID_T   *sharedSecretID,
++       uint32_t            credentialType,
++       void               *credential,
++       SSCS_EXT_T         *ext
++);
++
++SSCS_TYPEDEF_LIBCALL(int, CASA_RemoveCredential_T)
++(
++       uint32_t            ssFlags,
++       SSCS_SECRET_ID_T   *appSecretID,
++       SSCS_SECRET_ID_T   *sharedSecretID,
++       SSCS_EXT_T         *ext
++);
++static CASA_GetCredential_T            p_miCASAGetCredential = NULL;
++static CASA_SetCredential_T            p_miCASASetCredential = NULL;
++static CASA_RemoveCredential_T         p_miCASARemoveCredential = NULL;
++static void                            *casaIDK = NULL;
++
++int load_casa(void);
++static void release_casa(void);
++int load_uname_pwd_from_miCASA(char **, char **);
++
++#endif /* __LDAP_CASA_H__ */
++#endif /* LDAP_CASA_AUTH */
++
+diff -Naur dhcp-3.0.5/includes/site.h dhcp-3.0.5-ldap/includes/site.h
+--- dhcp-3.0.5/includes/site.h	2002-03-12 13:33:39.000000000 -0500
++++ dhcp-3.0.5-ldap/includes/site.h	2006-12-14 10:03:41.000000000 -0500
+@@ -177,3 +177,13 @@
+    traces. */
+ 
+ #define TRACING
++
++/* Define this if you want to read your config from LDAP. Read README.ldap
++   about how to set this up */
++
++#define LDAP_CONFIGURATION
++
++/* Define this if you want to enable LDAP over a SSL connection. You will need
++   to add -lcrypto -lssl to the LIBS= line of server/Makefile */
++
++/* #define USE_SSL */
+diff -Naur dhcp-3.0.5/server/Makefile.dist dhcp-3.0.5-ldap/server/Makefile.dist
+--- dhcp-3.0.5/server/Makefile.dist	2004-06-10 13:59:50.000000000 -0400
++++ dhcp-3.0.5-ldap/server/Makefile.dist	2007-02-23 13:41:54.000000000 -0500
+@@ -25,14 +25,14 @@
+ CATMANPAGES = dhcpd.cat8 dhcpd.conf.cat5 dhcpd.leases.cat5
+ SEDMANPAGES = dhcpd.man8 dhcpd.conf.man5 dhcpd.leases.man5
+ SRCS   = dhcpd.c dhcp.c bootp.c confpars.c db.c class.c failover.c \
+-	 omapi.c mdb.c stables.c salloc.c ddns.c
++	 ldap.c ldap_casa.c omapi.c mdb.c stables.c salloc.c ddns.c
+ OBJS   = dhcpd.o dhcp.o bootp.o confpars.o db.o class.o failover.o \
+-	 omapi.o mdb.o stables.o salloc.o ddns.o
++	 ldap.o ldap_casa.o omapi.o mdb.o stables.o salloc.o ddns.o
+ PROG   = dhcpd
+ MAN    = dhcpd.8 dhcpd.conf.5 dhcpd.leases.5
+ 
+ INCLUDES = -I$(TOP) $(BINDINC) -I$(TOP)/includes
+-DHCPLIB = ../common/libdhcp.a $(BINDLIB) ../omapip/libomapi.a ../dst/libdst.a
++DHCPLIB = ../common/libdhcp.a $(BINDLIB) ../omapip/libomapi.a ../dst/libdst-nomd5.a -lssl -lcrypto -lldap -llber
+ CFLAGS = $(DEBUG) $(PREDEFINES) $(INCLUDES) $(COPTS)
+ 
+ all:	$(PROG) $(CATMANPAGES)
+diff -Naur dhcp-3.0.5/server/class.c dhcp-3.0.5-ldap/server/class.c
+--- dhcp-3.0.5/server/class.c	2004-06-10 13:59:51.000000000 -0400
++++ dhcp-3.0.5-ldap/server/class.c	2006-12-14 10:03:41.000000000 -0500
+@@ -90,6 +90,7 @@
+ 	int matched = 0;
+ 	int status;
+ 	int ignorep;
++	int classfound;
+ 
+ 	for (class = collection -&gt; classes; class; class = class -&gt; nic) {
+ #if defined (DEBUG_CLASS_MATCHING)
+@@ -135,9 +136,19 @@
+ 				   class -&gt; submatch, MDL));
+ 			if (status &amp;&amp; data.len) {
+ 				nc = (struct class *)0;
+-				if (class_hash_lookup (&amp;nc, class -&gt; hash,
+-						       (const char *)data.data,
+-						       data.len, MDL)) {
++                                classfound = class_hash_lookup (&amp;nc, 
++						class -&gt; hash, 
++						(const char *)data.data,
++						data.len, MDL);
++
++#ifdef LDAP_CONFIGURATION
++                                if (!classfound &amp;&amp; 
++						find_subclass_in_ldap (class, 
++								&amp;nc, &amp;data)) 
++					classfound = 1;
++#endif
++
++				if (classfound) {
+ #if defined (DEBUG_CLASS_MATCHING)
+ 					log_info (&quot;matches subclass %s.&quot;,
+ 					      print_hex_1 (data.len,
+diff -Naur dhcp-3.0.5/server/confpars.c dhcp-3.0.5-ldap/server/confpars.c
+--- dhcp-3.0.5/server/confpars.c	2006-07-20 12:02:52.000000000 -0400
++++ dhcp-3.0.5-ldap/server/confpars.c	2006-12-14 10:03:41.000000000 -0500
+@@ -63,7 +63,17 @@
+ 
+ isc_result_t readconf ()
+ {
+-	return read_conf_file (path_dhcpd_conf, root_group, ROOT_GROUP, 0);
++	isc_result_t res;
++
++	res = read_conf_file (path_dhcpd_conf, root_group, ROOT_GROUP, 0);
++#if defined(LDAP_CONFIGURATION)
++	if (res != ISC_R_SUCCESS)
++		return (res);
++
++	return ldap_read_config ();
++#else
++	return (res);
++#endif
+ }
+ 
+ isc_result_t read_conf_file (const char *filename, struct group *group,
+diff -Naur dhcp-3.0.5/server/dhcpd.c dhcp-3.0.5-ldap/server/dhcpd.c
+--- dhcp-3.0.5/server/dhcpd.c	2006-07-17 11:23:44.000000000 -0400
++++ dhcp-3.0.5-ldap/server/dhcpd.c	2007-02-23 13:13:36.000000000 -0500
+@@ -436,6 +436,14 @@
+ 	/* Add the ddns update style enumeration prior to parsing. */
+ 	add_enumeration (&amp;ddns_styles);
+ 	add_enumeration (&amp;syslog_enum);
++#if defined (LDAP_CONFIGURATION)
++	add_enumeration (&amp;ldap_methods);
++#if defined (USE_SSL)
++	add_enumeration (&amp;ldap_ssl_usage_enum);
++	add_enumeration (&amp;ldap_tls_reqcert_enum);
++	add_enumeration (&amp;ldap_tls_crlcheck_enum);
++#endif
++#endif
+ 
+ 	if (!group_allocate (&amp;root_group, MDL))
+ 		log_fatal (&quot;Can't allocate root group!&quot;);
+diff -Naur dhcp-3.0.5/server/ldap.c dhcp-3.0.5-ldap/server/ldap.c
+--- dhcp-3.0.5/server/ldap.c	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/server/ldap.c	2007-02-23 13:36:24.000000000 -0500
+@@ -0,0 +1,1977 @@
++/* ldap.c
++
++   Routines for reading the configuration from LDAP */
++
++/*
++ * Copyright (c) 2003-2006 Ntelos, Inc.
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. Neither the name of The Internet Software Consortium nor the names
++ *    of its contributors may be used to endorse or promote products derived
++ *    from this software without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
++ * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
++ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
++ * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
++ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
++ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
++ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
++ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
++ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
++ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ * This LDAP module was written by Brian Masney &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">masneyb at ntelos.net</A>&gt;. Its
++ * development was sponsored by Ntelos, Inc. (www.ntelos.com).
++ */
++
++#include &quot;dhcpd.h&quot;
++#include &lt;signal.h&gt;
++
++#if defined(LDAP_CONFIGURATION)
++
++#if defined(LDAP_CASA_AUTH)
++#include &quot;ldap_casa.h&quot;
++#endif
++
++static LDAP * ld = NULL;
++static char *ldap_server = NULL, 
++            *ldap_username = NULL, 
++            *ldap_password = NULL,
++            *ldap_base_dn = NULL,
++            *ldap_dhcp_server_cn = NULL,
++            *ldap_debug_file = NULL;
++static int ldap_port = LDAP_PORT,
++           ldap_method = LDAP_METHOD_DYNAMIC,
++           ldap_referrals = -1,
++           ldap_debug_fd = -1;
++#if defined (USE_SSL)
++static int ldap_use_ssl = -1,        /* try TLS if possible */
++           ldap_tls_reqcert = -1,
++           ldap_tls_crlcheck = -1;
++static char *ldap_tls_ca_file = NULL,
++            *ldap_tls_ca_dir = NULL,
++            *ldap_tls_cert = NULL,
++            *ldap_tls_key = NULL,
++            *ldap_tls_ciphers = NULL,
++            *ldap_tls_randfile = NULL;
++#endif
++static struct ldap_config_stack *ldap_stack = NULL;
++
++typedef struct ldap_dn_node {
++    struct ldap_dn_node *next;
++    size_t refs;
++    char *dn;
++} ldap_dn_node;
++
++static ldap_dn_node *ldap_service_dn_head = NULL;
++static ldap_dn_node *ldap_service_dn_tail = NULL;
++
++
++static char *
++x_strncat(char *dst, const char *src, size_t dst_size)
++{
++  size_t len = strlen(dst);
++  return strncat(dst, src, dst_size &gt; len ? dst_size - len - 1: 0);
++}
++
++static void
++ldap_parse_class (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  x_strncat (cfile-&gt;inbuf, &quot;class \&quot;&quot;, LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, &quot;\&quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++}
++
++
++static void
++ldap_parse_subclass (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr, **classdata;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  if ((classdata = ldap_get_values (ld, item-&gt;ldent, 
++                                  &quot;dhcpClassData&quot;)) == NULL || 
++      classdata[0] == NULL)
++    {
++      if (classdata != NULL)
++        ldap_value_free (classdata);
++      ldap_value_free (tempstr);
++
++      return;
++    }
++
++  x_strncat (cfile-&gt;inbuf, &quot;subclass &quot;, LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, classdata[0], LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, &quot; &quot;, LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, &quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++  ldap_value_free (classdata);
++}
++
++
++static void
++ldap_parse_host (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr, **hwaddr;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  hwaddr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpHWAddress&quot;);
++
++  x_strncat (cfile-&gt;inbuf, &quot;host &quot;, LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++
++  if (hwaddr != NULL &amp;&amp; hwaddr[0] != NULL)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot; {\nhardware &quot;, LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, hwaddr[0], LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (hwaddr);
++    }
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++}
++
++
++static void
++ldap_parse_shared_network (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  x_strncat (cfile-&gt;inbuf, &quot;shared-network \&quot;&quot;, LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, &quot;\&quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  item-&gt;close_brace = 1;
++  ldap_value_free (tempstr);
++}
++
++
++static void
++parse_netmask (int netmask, char *netmaskbuf)
++{
++  unsigned long nm;
++  int i;
++
++  nm = 0;
++  for (i=1; i &lt;= netmask; i++)
++    {
++      nm |= 1 &lt;&lt; (32 - i);
++    }
++
++  sprintf (netmaskbuf, &quot;%d.%d.%d.%d&quot;, (int) (nm &gt;&gt; 24) &amp; 0xff, 
++                                      (int) (nm &gt;&gt; 16) &amp; 0xff, 
++                                      (int) (nm &gt;&gt; 8) &amp; 0xff, 
++                                      (int) nm &amp; 0xff);
++}
++
++
++static void
++ldap_parse_subnet (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr, **netmaskstr, netmaskbuf[16];
++  int i;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      return;
++    }
++
++  if ((netmaskstr = ldap_get_values (ld, item-&gt;ldent, 
++                                     &quot;dhcpNetmask&quot;)) == NULL || 
++      netmaskstr[0] == NULL)
++    {
++      if (netmaskstr != NULL)
++        ldap_value_free (netmaskstr);
++      ldap_value_free (tempstr);
++
++      return;
++    }
++
++  x_strncat (cfile-&gt;inbuf, &quot;subnet &quot;, LDAP_BUFFER_SIZE);
++  x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++
++  x_strncat (cfile-&gt;inbuf, &quot; netmask &quot;, LDAP_BUFFER_SIZE);
++  parse_netmask (strtol (netmaskstr[0], NULL, 10), netmaskbuf);
++  x_strncat (cfile-&gt;inbuf, netmaskbuf, LDAP_BUFFER_SIZE);
++
++  x_strncat (cfile-&gt;inbuf, &quot; {\n&quot;, LDAP_BUFFER_SIZE);
++
++  ldap_value_free (tempstr);
++  ldap_value_free (netmaskstr);
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpRange&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          x_strncat (cfile-&gt;inbuf, &quot;range&quot;, LDAP_BUFFER_SIZE);
++          x_strncat (cfile-&gt;inbuf, &quot; &quot;, LDAP_BUFFER_SIZE);
++          x_strncat (cfile-&gt;inbuf, tempstr[i], LDAP_BUFFER_SIZE);
++          x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++        }
++      ldap_value_free (tempstr);
++    }
++
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++ldap_parse_pool (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr;
++  int i;
++
++  x_strncat (cfile-&gt;inbuf, &quot;pool {\n&quot;, LDAP_BUFFER_SIZE);
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpRange&quot;)) != NULL)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;range&quot;, LDAP_BUFFER_SIZE);
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          x_strncat (cfile-&gt;inbuf, &quot; &quot;, LDAP_BUFFER_SIZE);
++          x_strncat (cfile-&gt;inbuf, tempstr[i], LDAP_BUFFER_SIZE);
++        }
++      x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpPermitList&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          x_strncat (cfile-&gt;inbuf, tempstr[i], LDAP_BUFFER_SIZE);
++          x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++        }
++      ldap_value_free (tempstr);
++    }
++
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++ldap_parse_group (struct ldap_config_stack *item, struct parse *cfile)
++{
++  x_strncat (cfile-&gt;inbuf, &quot;group {\n&quot;, LDAP_BUFFER_SIZE);
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++ldap_parse_key (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char **tempstr;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) != NULL)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;key &quot;, LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, &quot; {\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpKeyAlgorithm&quot;)) != NULL)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;algorithm &quot;, LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpKeySecret&quot;)) != NULL)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;secret &quot;, LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (tempstr);
++    }
++
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++ldap_parse_zone (struct ldap_config_stack *item, struct parse *cfile)
++{
++  char *cnFindStart, *cnFindEnd;
++  char **tempstr;
++  char *keyCn;
++  size_t len;
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;cn&quot;)) != NULL)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;zone &quot;, LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, &quot; {\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpDnsZoneServer&quot;)) != NULL)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;primary &quot;, LDAP_BUFFER_SIZE);
++      x_strncat (cfile-&gt;inbuf, tempstr[0], LDAP_BUFFER_SIZE);
++
++      x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, item-&gt;ldent, &quot;dhcpKeyDN&quot;)) != NULL)
++    {
++      cnFindStart = strchr(tempstr[0],'=');
++      if (cnFindStart != NULL)
++        cnFindEnd = strchr(++cnFindStart,',');
++      else
++        cnFindEnd = NULL;
++
++      if (cnFindEnd != NULL &amp;&amp; cnFindEnd &gt; cnFindStart)
++        {
++          len = cnFindEnd - cnFindStart;
++          keyCn = dmalloc (len + 1, MDL);
++        }
++      else
++        {
++          len = 0;
++          keyCn = NULL;
++        }
++
++      if (keyCn != NULL)
++        {
++          strncpy (keyCn, cnFindStart, len);
++          keyCn[len] = '\0';
++
++          x_strncat (cfile-&gt;inbuf, &quot;key &quot;, LDAP_BUFFER_SIZE);
++          x_strncat (cfile-&gt;inbuf, keyCn, LDAP_BUFFER_SIZE);
++          x_strncat (cfile-&gt;inbuf, &quot;;\n&quot;, LDAP_BUFFER_SIZE);
++
++          dfree (keyCn, MDL);
++        }
++
++      ldap_value_free (tempstr);
++     }
++
++  item-&gt;close_brace = 1;
++}
++
++
++static void
++add_to_config_stack (LDAPMessage * res, LDAPMessage * ent)
++{
++  struct ldap_config_stack *ns;
++
++  ns = dmalloc (sizeof (*ns), MDL);
++  ns-&gt;res = res;
++  ns-&gt;ldent = ent;
++  ns-&gt;close_brace = 0;
++  ns-&gt;processed = 0;
++  ns-&gt;next = ldap_stack;
++  ldap_stack = ns;
++}
++
++
++static void
++ldap_stop()
++{
++  struct sigaction old, new;
++
++  if (ld == NULL)
++    return;
++
++  /*
++   ** ldap_unbind after a LDAP_SERVER_DOWN result
++   ** causes a SIGPIPE and dhcpd gets terminated,
++   ** since it doesn't handle it...
++   */
++
++  new.sa_flags   = 0;
++  new.sa_handler = SIG_IGN;
++  sigemptyset (&amp;new.sa_mask);
++  sigaction (SIGPIPE, &amp;new, &amp;old);
++
++  ldap_unbind (ld);
++  ld = NULL;
++
++  sigaction (SIGPIPE, &amp;old, &amp;new);
++}
++
++
++static char *
++_do_lookup_dhcp_string_option (struct option_state *options, int option_name)
++{
++  struct option_cache *oc;
++  struct data_string db;
++  char *ret;
++
++  memset (&amp;db, 0, sizeof (db));
++  oc = lookup_option (&amp;server_universe, options, option_name);
++  if (oc &amp;&amp;
++      evaluate_option_cache (&amp;db, (struct packet*) NULL,
++                             (struct lease *) NULL,
++                             (struct client_state *) NULL, options,
++                             (struct option_state *) NULL,
++                             &amp;global_scope, oc, MDL) &amp;&amp;
++      db.data != NULL &amp;&amp; *db.data != '\0')
++
++    {
++      ret = dmalloc (db.len + 1, MDL);
++      if (ret == NULL)
++        log_fatal (&quot;no memory for ldap option %d value&quot;, option_name);
++
++      memcpy (ret, db.data, db.len);
++      ret[db.len] = 0;
++      data_string_forget (&amp;db, MDL);
++    }
++  else
++    ret = NULL;
++
++  return (ret);
++}
++
++
++static int
++_do_lookup_dhcp_int_option (struct option_state *options, int option_name)
++{
++  struct option_cache *oc;
++  struct data_string db;
++  int ret;
++
++  memset (&amp;db, 0, sizeof (db));
++  oc = lookup_option (&amp;server_universe, options, option_name);
++  if (oc &amp;&amp;
++      evaluate_option_cache (&amp;db, (struct packet*) NULL,
++                             (struct lease *) NULL,
++                             (struct client_state *) NULL, options,
++                             (struct option_state *) NULL,
++                             &amp;global_scope, oc, MDL) &amp;&amp;
++      db.data != NULL &amp;&amp; *db.data != '\0')
++    {
++      ret = strtol (db.data, NULL, 10);
++      data_string_forget (&amp;db, MDL);
++    }
++  else
++    ret = 0;
++
++  return (ret);
++}
++
++
++static int
++_do_lookup_dhcp_enum_option (struct option_state *options, int option_name)
++{
++  struct option_cache *oc;
++  struct data_string db;
++  int ret;
++
++  memset (&amp;db, 0, sizeof (db));
++  oc = lookup_option (&amp;server_universe, options, option_name);
++  if (oc &amp;&amp;
++      evaluate_option_cache (&amp;db, (struct packet*) NULL,
++                             (struct lease *) NULL,
++                             (struct client_state *) NULL, options,
++                             (struct option_state *) NULL,
++                             &amp;global_scope, oc, MDL) &amp;&amp;
++      db.data != NULL &amp;&amp; *db.data != '\0')
++    {
++      if (db.len == 1) 
++        ret = db.data [0];
++      else
++        log_fatal (&quot;invalid option name %d&quot;, option_name);
++
++      data_string_forget (&amp;db, MDL);
++    }
++  else
++    ret = 0;
++
++  return (ret);
++}
++
++int
++ldap_rebind_cb (LDAP *ld, LDAP_CONST char *url, ber_tag_t request, ber_int_t msgid, void *parms)
++{
++  int ret;
++  LDAPURLDesc *ldapurl = NULL;
++  char *who = NULL, *pwd = NULL;
++
++  log_info(&quot;LDAP rebind to '%s'&quot;, url);
++  if ((ret = ldap_url_parse(url, &amp;ldapurl)) != LDAP_SUCCESS)
++    {
++      log_error (&quot;Error: Can not parse ldap rebind url '%s': %s&quot;,
++                 url, ldap_err2string(ret));
++      return ret;
++    }
++
++
++#if defined (USE_SSL)
++  if (strcasecmp(ldapurl-&gt;lud_scheme, &quot;ldaps&quot;) == 0)
++    {
++      int opt = LDAP_OPT_X_TLS_HARD;
++      if ((ret = ldap_set_option (ld, LDAP_OPT_X_TLS, &amp;opt)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error: Cannot init LDAPS session to %s:%d: %s&quot;,
++                    ldapurl-&gt;lud_host, ldapurl-&gt;lud_port, ldap_err2string (ret));
++          return ret;
++        }
++      else
++        {
++          log_info (&quot;LDAPS session successfully enabled to %s&quot;, ldap_server);
++        }
++    }
++  else
++  if (strcasecmp(ldapurl-&gt;lud_scheme, &quot;ldap&quot;) == 0 &amp;&amp;
++      ldap_use_ssl != LDAP_SSL_OFF)
++    {
++      if ((ret = ldap_start_tls_s (ld, NULL, NULL)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error: Cannot start TLS session to %s:%d: %s&quot;,
++                     ldapurl-&gt;lud_host, ldapurl-&gt;lud_port, ldap_err2string (ret));
++          return ret;
++        }
++      else
++        {
++          log_info (&quot;TLS session successfully started to %s:%d&quot;,
++                    ldapurl-&gt;lud_host, ldapurl-&gt;lud_port);
++        }
++    }
++#endif
++
++
++  if (ldap_username != NULL || *ldap_username != '\0')
++    {
++      who = ldap_username;
++      pwd = ldap_password;
++    }
++
++  if ((ret = ldap_simple_bind_s (ld, who, pwd)) != LDAP_SUCCESS)
++    {
++      log_error (&quot;Error: Cannot login into ldap server %s:%d: %s&quot;,
++                 ldapurl-&gt;lud_host, ldapurl-&gt;lud_port, ldap_err2string (ret));
++    }
++  return ret;
++}
++
++static void
++ldap_start (void)
++{
++  struct option_state *options;
++  int ret, version;
++
++  if (ld != NULL)
++    return;
++
++  if (ldap_server == NULL)
++    {
++      options = NULL;
++      option_state_allocate (&amp;options, MDL);
++
++      execute_statements_in_scope ((struct binding_value **) NULL,
++                 (struct packet *) NULL, (struct lease *) NULL,
++                 (struct client_state *) NULL, (struct option_state *) NULL,
++                 options, &amp;global_scope, root_group, (struct group *) NULL);
++
++      ldap_server = _do_lookup_dhcp_string_option (options, SV_LDAP_SERVER);
++      ldap_dhcp_server_cn = _do_lookup_dhcp_string_option (options,
++                                                      SV_LDAP_DHCP_SERVER_CN);
++      ldap_port = _do_lookup_dhcp_int_option (options, SV_LDAP_PORT);
++      ldap_base_dn = _do_lookup_dhcp_string_option (options, SV_LDAP_BASE_DN);
++      ldap_method = _do_lookup_dhcp_enum_option (options, SV_LDAP_METHOD);
++      ldap_debug_file = _do_lookup_dhcp_string_option (options,
++                                                       SV_LDAP_DEBUG_FILE);
++      ldap_referrals = _do_lookup_dhcp_enum_option (options, SV_LDAP_REFERRALS);
++
++#if defined (USE_SSL)
++      ldap_use_ssl = _do_lookup_dhcp_enum_option (options, SV_LDAP_SSL);
++      if( ldap_use_ssl != LDAP_SSL_OFF)
++        {
++          ldap_tls_reqcert = _do_lookup_dhcp_enum_option (options, SV_LDAP_TLS_REQCERT);
++          ldap_tls_ca_file = _do_lookup_dhcp_string_option (options, SV_LDAP_TLS_CA_FILE);
++          ldap_tls_ca_dir = _do_lookup_dhcp_string_option (options, SV_LDAP_TLS_CA_DIR);
++          ldap_tls_cert = _do_lookup_dhcp_string_option (options, SV_LDAP_TLS_CERT);
++          ldap_tls_key = _do_lookup_dhcp_string_option (options, SV_LDAP_TLS_KEY);
++          ldap_tls_crlcheck = _do_lookup_dhcp_enum_option (options, SV_LDAP_TLS_CRLCHECK);
++          ldap_tls_ciphers = _do_lookup_dhcp_string_option (options, SV_LDAP_TLS_CIPHERS);
++          ldap_tls_randfile = _do_lookup_dhcp_string_option (options, SV_LDAP_TLS_RANDFILE);
++        }
++#endif
++
++#if defined (LDAP_CASA_AUTH)
++      if (!load_uname_pwd_from_miCASA(&amp;ldap_username,&amp;ldap_password))
++        {
++#if defined (DEBUG_LDAP)
++          log_info (&quot;Authentication credential taken from file&quot;);
++#endif
++#endif
++
++      ldap_username = _do_lookup_dhcp_string_option (options, SV_LDAP_USERNAME);
++      ldap_password = _do_lookup_dhcp_string_option (options, SV_LDAP_PASSWORD);
++
++#if defined (LDAP_CASA_AUTH)
++      }
++#endif
++
++      option_state_dereference (&amp;options, MDL);
++    }
++
++  if (ldap_server == NULL || ldap_base_dn == NULL)
++    {
++      log_info (&quot;Not searching LDAP since ldap-server, ldap-port and ldap-base-dn were not specified in the config file&quot;);
++      ldap_method = LDAP_METHOD_STATIC;
++      return;
++    }
++
++  if (ldap_debug_file != NULL &amp;&amp; ldap_debug_fd == -1)
++    {
++      if ((ldap_debug_fd = open (ldap_debug_file, O_CREAT | O_TRUNC | O_WRONLY,
++                                 S_IRUSR | S_IWUSR)) &lt; 0)
++        log_error (&quot;Error opening debug LDAP log file %s: %s&quot;, ldap_debug_file,
++                   strerror (errno));
++    }
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Connecting to LDAP server %s:%d&quot;, ldap_server, ldap_port);
++#endif
++
++#if defined (USE_SSL)
++  if (ldap_use_ssl == -1)
++    {
++      /*
++      ** There was no &quot;ldap-ssl&quot; option in dhcpd.conf (also not &quot;off&quot;).
++      ** Let's try, if we can use an anonymous TLS session without to
++      ** verify the server certificate -- if not continue without TLS.
++      */
++      int opt = LDAP_OPT_X_TLS_ALLOW;
++      if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_REQUIRE_CERT,
++                                  &amp;opt)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Warning: Cannot set LDAP TLS require cert option to 'allow': %s&quot;,
++                     ldap_err2string (ret));
++        }
++    }
++
++  if (ldap_use_ssl != LDAP_SSL_OFF)
++    {
++      if (ldap_tls_reqcert != -1)
++        {
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_REQUIRE_CERT,
++                                      &amp;ldap_tls_reqcert)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS require cert option: %s&quot;,
++                         ldap_err2string (ret));
++            }
++        }
++
++      if( ldap_tls_ca_file != NULL)
++        {
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_CACERTFILE,
++                                      ldap_tls_ca_file)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS CA certificate file %s: %s&quot;,
++                         ldap_tls_ca_file, ldap_err2string (ret));
++            }
++        }
++      if( ldap_tls_ca_dir != NULL)
++        {
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_CACERTDIR,
++                                      ldap_tls_ca_dir)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS CA certificate dir %s: %s&quot;,
++                         ldap_tls_ca_dir, ldap_err2string (ret));
++            }
++        }
++      if( ldap_tls_cert != NULL)
++        {
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_CERTFILE,
++                                      ldap_tls_cert)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS client certificate file %s: %s&quot;,
++                         ldap_tls_cert, ldap_err2string (ret));
++            }
++        }
++      if( ldap_tls_key != NULL)
++        {
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_KEYFILE,
++                                      ldap_tls_key)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS certificate key file %s: %s&quot;,
++                         ldap_tls_key, ldap_err2string (ret));
++            }
++        }
++      if( ldap_tls_crlcheck != -1)
++        {
++          int opt = ldap_tls_crlcheck;
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_CRLCHECK,
++                                      &amp;opt)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS crl check option: %s&quot;,
++                         ldap_err2string (ret));
++            }
++        }
++      if( ldap_tls_ciphers != NULL)
++        {
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_CIPHER_SUITE,
++                                      ldap_tls_ciphers)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS cipher suite %s: %s&quot;,
++                         ldap_tls_ciphers, ldap_err2string (ret));
++            }
++        }
++      if( ldap_tls_randfile != NULL)
++        {
++          if ((ret = ldap_set_option (NULL, LDAP_OPT_X_TLS_RANDOM_FILE,
++                                      ldap_tls_randfile)) != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot set LDAP TLS random file %s: %s&quot;,
++                         ldap_tls_randfile, ldap_err2string (ret));
++            }
++        }
++    }
++#endif
++
++  if ((ld = ldap_init (ldap_server, ldap_port)) == NULL)
++    {
++      log_error (&quot;Cannot init ldap session to %s:%d&quot;, ldap_server, ldap_port);
++      return;
++    }
++
++  version = LDAP_VERSION3;
++  if ((ret = ldap_set_option (ld, LDAP_OPT_PROTOCOL_VERSION, &amp;version)) != LDAP_OPT_SUCCESS)
++    {
++      log_error (&quot;Cannot set LDAP version to %d: %s&quot;, version,
++                 ldap_err2string (ret));
++    }
++
++  if (ldap_referrals != -1)
++    {
++      if ((ret = ldap_set_option (ld, LDAP_OPT_REFERRALS, ldap_referrals ?
++                                  LDAP_OPT_ON : LDAP_OPT_OFF)) != LDAP_OPT_SUCCESS)
++        {
++          log_error (&quot;Cannot %s LDAP referrals option: %s&quot;,
++                     (ldap_referrals ? &quot;enable&quot; : &quot;disable&quot;),
++                     ldap_err2string (ret));
++        }
++    }
++
++  if ((ret = ldap_set_rebind_proc(ld, ldap_rebind_cb, NULL)) != LDAP_SUCCESS)
++    {
++      log_error (&quot;Warning: Cannot set ldap rebind procedure: %s&quot;,
++                 ldap_err2string (ret));
++    }
++
++#if defined (USE_SSL)
++  if (ldap_use_ssl == LDAP_SSL_LDAPS ||
++     (ldap_use_ssl == LDAP_SSL_ON &amp;&amp; ldap_port == LDAPS_PORT))
++    {
++      int opt = LDAP_OPT_X_TLS_HARD;
++      if ((ret = ldap_set_option (ld, LDAP_OPT_X_TLS, &amp;opt)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error: Cannot init LDAPS session to %s:%d: %s&quot;,
++                    ldap_server, ldap_port, ldap_err2string (ret));
++          ldap_stop();
++          return;
++        }
++      else
++        {
++          log_info (&quot;LDAPS session successfully enabled to %s:%d&quot;,
++                    ldap_server, ldap_port);
++        }
++    }
++  else if (ldap_use_ssl != LDAP_SSL_OFF)
++    {
++      if ((ret = ldap_start_tls_s (ld, NULL, NULL)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error: Cannot start TLS session to %s:%d: %s&quot;,
++                     ldap_server, ldap_port, ldap_err2string (ret));
++          ldap_stop();
++          return;
++        }
++      else
++        {
++          log_info (&quot;TLS session successfully started to %s:%d&quot;,
++                    ldap_server, ldap_port);
++        }
++    }
++#endif
++
++  if (ldap_username != NULL &amp;&amp; *ldap_username != '\0')
++    {
++      if ((ret = ldap_simple_bind_s (ld, ldap_username,
++                                     ldap_password)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error: Cannot login into ldap server %s:%d: %s&quot;,
++                     ldap_server, ldap_port, ldap_err2string (ret));
++          ldap_stop();
++          return;
++        }
++    }
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Successfully logged into LDAP server %s&quot;, ldap_server);
++#endif
++}
++
++
++static void
++parse_external_dns (LDAPMessage * ent)
++{
++  char *search[] = {&quot;dhcpOptionsDN&quot;, &quot;dhcpSharedNetworkDN&quot;, &quot;dhcpSubnetDN&quot;,
++                    &quot;dhcpGroupDN&quot;, &quot;dhcpHostDN&quot;, &quot;dhcpClassesDN&quot;,
++                    &quot;dhcpPoolDN&quot;, NULL};
++  LDAPMessage * newres, * newent;
++  struct ldap_config_stack *ns;
++  char **tempstr;
++  int i, j, ret;
++#if defined (DEBUG_LDAP)
++  char *dn;
++
++  dn = ldap_get_dn (ld, ent);
++  if (dn != NULL)
++    {
++      log_info (&quot;Parsing external DNs for '%s'&quot;, dn);
++      ldap_memfree (dn);
++    }
++#endif
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return;
++
++  for (i=0; search[i] != NULL; i++)
++    {
++      if ((tempstr = ldap_get_values (ld, ent, search[i])) == NULL)
++        continue;
++
++      for (j=0; tempstr[j] != NULL; j++)
++        {
++          if (*tempstr[j] == '\0')
++            continue;
++
++          if ((ret = ldap_search_s (ld, tempstr[j], LDAP_SCOPE_BASE, 
++                                    &quot;objectClass=*&quot;, NULL, 0, 
++                                    &amp;newres)) != LDAP_SUCCESS)
++            {
++              ldap_value_free (tempstr);
++              ldap_stop();
++              return;
++            }
++    
++#if defined (DEBUG_LDAP)
++          log_info (&quot;Adding contents of subtree '%s' to config stack from '%s' reference&quot;, tempstr[j], search[i]);
++#endif
++          for (newent = ldap_first_entry (ld, newres);
++               newent != NULL;
++               newent = ldap_next_entry (ld, newent))
++            {
++#if defined (DEBUG_LDAP)
++              dn = ldap_get_dn (ld, newent);
++              if (dn != NULL)
++                {
++                  log_info (&quot;Adding LDAP result set starting with '%s' to config stack&quot;, dn);
++                  ldap_memfree (dn);
++                }
++#endif
++
++              add_to_config_stack (newres, newent);
++              /* don't free newres here */
++            }
++        }
++
++      ldap_value_free (tempstr);
++    }
++}
++
++
++static void
++free_stack_entry (struct ldap_config_stack *item)
++{
++  struct ldap_config_stack *look_ahead_pointer = item;
++  int may_free_msg = 1;
++
++  while (look_ahead_pointer-&gt;next != NULL)
++    {
++      look_ahead_pointer = look_ahead_pointer-&gt;next;
++      if (look_ahead_pointer-&gt;res == item-&gt;res)
++        {
++          may_free_msg = 0;
++          break;
++        }
++    }
++
++  if (may_free_msg) 
++    ldap_msgfree (item-&gt;res);
++
++  dfree (item, MDL);
++}
++
++
++static void
++next_ldap_entry (struct parse *cfile)
++{
++  struct ldap_config_stack *temp_stack;
++
++  if (ldap_stack != NULL &amp;&amp; ldap_stack-&gt;close_brace)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;}\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_stack-&gt;close_brace = 0;
++    }
++
++  while (ldap_stack != NULL &amp;&amp; 
++         (ldap_stack-&gt;ldent == NULL ||
++          (ldap_stack-&gt;ldent = ldap_next_entry (ld, ldap_stack-&gt;ldent)) == NULL))
++    {
++      if (ldap_stack-&gt;close_brace)
++        {
++          x_strncat (cfile-&gt;inbuf, &quot;}\n&quot;, LDAP_BUFFER_SIZE);
++          ldap_stack-&gt;close_brace = 0;
++        }
++
++      temp_stack = ldap_stack;
++      ldap_stack = ldap_stack-&gt;next;
++      free_stack_entry (temp_stack);
++    }
++
++  if (ldap_stack != NULL &amp;&amp; ldap_stack-&gt;close_brace)
++    {
++      x_strncat (cfile-&gt;inbuf, &quot;}\n&quot;, LDAP_BUFFER_SIZE);
++      ldap_stack-&gt;close_brace = 0;
++    }
++}
++
++
++static char
++check_statement_end (const char *statement)
++{
++  char *ptr;
++
++  if (statement == NULL || *statement == '\0')
++    return ('\0');
++
++  /*
++  ** check if it ends with &quot;}&quot;, e.g.:
++  **   &quot;zone my.domain. { ... }&quot;
++  ** optionally followed by spaces
++  */
++  ptr = strrchr (statement, '}');
++  if (ptr != NULL)
++    {
++      /* skip following white-spaces */
++      for (++ptr; isspace ((int)*ptr); ptr++);
++
++      /* check if we reached the end */
++      if (*ptr == '\0')
++        return ('}'); /* yes, block end */
++      else
++        return (*ptr);
++    }
++
++  /*
++  ** this should not happen, but...
++  ** check if it ends with &quot;;&quot;, e.g.:
++  **   &quot;authoritative;&quot;
++  ** optionally followed by spaces
++  */
++  ptr = strrchr (statement, ';');
++  if (ptr != NULL)
++    {
++      /* skip following white-spaces */
++      for (++ptr; isspace ((int)*ptr); ptr++);
++
++      /* check if we reached the end */
++      if (*ptr == '\0')
++        return (';'); /* ends with a ; */
++      else
++        return (*ptr);
++    }
++
++  return ('\0');
++}
++
++
++static isc_result_t
++ldap_parse_entry_options (LDAPMessage *ent, char *buffer, size_t size,
++                          int *lease_limit)
++{
++  char **tempstr;
++  int i;
++
++  if (ent == NULL || buffer == NULL || size == 0)
++    return (ISC_R_FAILURE);
++
++  if ((tempstr = ldap_get_values (ld, ent, &quot;dhcpStatements&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          if (lease_limit != NULL &amp;&amp;
++              strncasecmp (&quot;lease limit &quot;, tempstr[i], 12) == 0)
++            {
++              *lease_limit = (int) strtol ((tempstr[i]) + 12, NULL, 10);
++              continue;
++            }
++
++          x_strncat (buffer, tempstr[i], size);
++
++          switch((int) check_statement_end (tempstr[i]))
++            {
++              case '}':
++              case ';':
++                x_strncat (buffer, &quot;\n&quot;, size);
++                break;
++              default:
++                x_strncat (buffer, &quot;;\n&quot;, size);
++                break;
++            }
++        }
++      ldap_value_free (tempstr);
++    }
++
++  if ((tempstr = ldap_get_values (ld, ent, &quot;dhcpOption&quot;)) != NULL)
++    {
++      for (i=0; tempstr[i] != NULL; i++)
++        {
++          x_strncat (buffer, &quot;option &quot;, size);
++          x_strncat (buffer, tempstr[i], size);
++          switch ((int) check_statement_end (tempstr[i]))
++            {
++              case ';':
++                x_strncat (buffer, &quot;\n&quot;, size);
++                break;
++              default:
++                x_strncat (buffer, &quot;;\n&quot;, size);
++                break;
++            }
++        }
++      ldap_value_free (tempstr);
++    }
++
++  return (ISC_R_SUCCESS);
++}
++
++
++static void
++ldap_generate_config_string (struct parse *cfile)
++{
++  char **objectClass, *dn;
++  struct ldap_config_stack *entry;
++  LDAPMessage * ent, * res;
++  int i, j, ignore, found;
++  int ret;
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return;
++
++  entry = ldap_stack;
++  if ((objectClass = ldap_get_values (ld, entry-&gt;ldent, 
++                                      &quot;objectClass&quot;)) == NULL)
++    return;
++    
++  ignore = 0;
++  found = 1;
++  for (i=0; objectClass[i] != NULL; i++)
++    {
++      if (strcasecmp (objectClass[i], &quot;dhcpSharedNetwork&quot;) == 0)
++        ldap_parse_shared_network (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpClass&quot;) == 0)
++        ldap_parse_class (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpSubnet&quot;) == 0)
++        ldap_parse_subnet (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpPool&quot;) == 0)
++        ldap_parse_pool (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpGroup&quot;) == 0)
++        ldap_parse_group (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpTSigKey&quot;) == 0)
++        ldap_parse_key (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpDnsZone&quot;) == 0)
++        ldap_parse_zone (entry, cfile);
++      else if (strcasecmp (objectClass[i], &quot;dhcpHost&quot;) == 0)
++        {
++          if (ldap_method == LDAP_METHOD_STATIC)
++            ldap_parse_host (entry, cfile);
++          else
++            {
++              ignore = 1;
++              break;
++            }
++        }
++      else if (strcasecmp (objectClass[i], &quot;dhcpSubClass&quot;) == 0)
++        {
++          if (ldap_method == LDAP_METHOD_STATIC)
++            ldap_parse_subclass (entry, cfile);
++          else
++            {
++              ignore = 1;
++              break;
++            }
++        }
++      else
++        found = 0;
++
++      if (found &amp;&amp; cfile-&gt;inbuf[0] == '\0')
++        {
++          ignore = 1;
++          break;
++        }
++    }
++
++  ldap_value_free (objectClass);
++
++  if (ignore)
++    {
++      next_ldap_entry (cfile);
++      return;
++    }
++
++  ldap_parse_entry_options(entry-&gt;ldent, cfile-&gt;inbuf,
++                           LDAP_BUFFER_SIZE-1, NULL);
++
++  dn = ldap_get_dn (ld, entry-&gt;ldent);
++
++#if defined(DEBUG_LDAP)
++  if (dn != NULL)
++    log_info (&quot;Found LDAP entry '%s'&quot;, dn);
++#endif
++
++  if (dn == NULL ||
++      (ret = ldap_search_s (ld, dn, LDAP_SCOPE_ONELEVEL, &quot;objectClass=*&quot;, 
++                            NULL, 0, &amp;res)) != LDAP_SUCCESS)
++    {
++      if (dn)
++        ldap_memfree (dn);
++
++      ldap_stop();
++      return;
++    }
++
++  ldap_memfree (dn);
++
++  if ((ent = ldap_first_entry (ld, res)) != NULL)
++    {
++      add_to_config_stack (res, ent);
++      parse_external_dns (entry-&gt;ldent);
++    }
++  else
++    {
++      ldap_msgfree (res);
++      parse_external_dns (entry-&gt;ldent);
++      next_ldap_entry (cfile);
++    }
++}
++
++
++static void
++ldap_close_debug_fd()
++{
++  if (ldap_debug_fd != -1)
++    {
++      close (ldap_debug_fd);
++      ldap_debug_fd = -1;
++    }
++}
++
++
++static void
++ldap_write_debug (const void *buff, size_t size)
++{
++  if (ldap_debug_fd != -1)
++    {
++      if (write (ldap_debug_fd, buff, size) &lt; 0)
++        {
++          log_error (&quot;Error writing to LDAP debug file %s: %s.&quot;
++                     &quot; Disabling log file.&quot;, ldap_debug_file,
++                     strerror (errno));
++          ldap_close_debug_fd();
++        }
++    }
++}
++
++static int
++ldap_read_function (struct parse *cfile)
++{
++  cfile-&gt;inbuf[0] = '\0';
++  cfile-&gt;buflen = 0;
++ 
++  while (ldap_stack != NULL &amp;&amp; *cfile-&gt;inbuf == '\0')
++    ldap_generate_config_string (cfile);
++
++  if (ldap_stack == NULL &amp;&amp; *cfile-&gt;inbuf == '\0')
++    return (EOF);
++
++  cfile-&gt;bufix = 1;
++  cfile-&gt;buflen = strlen (cfile-&gt;inbuf);
++  if (cfile-&gt;buflen &gt; 0)
++    ldap_write_debug (cfile-&gt;inbuf, cfile-&gt;buflen);
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Sending config line '%s'&quot;, cfile-&gt;inbuf);
++#endif
++
++  return (cfile-&gt;inbuf[0]);
++}
++
++
++static char *
++ldap_get_host_name (LDAPMessage * ent)
++{
++  char **name, *ret;
++
++  ret = NULL;
++  if ((name = ldap_get_values (ld, ent, &quot;cn&quot;)) == NULL || name[0] == NULL)
++    {
++      if (name != NULL)
++        ldap_value_free (name);
++
++#if defined (DEBUG_LDAP)
++      ret = ldap_get_dn (ld, ent);
++      if (ret != NULL)
++        {
++          log_info (&quot;Cannot get cn attribute for LDAP entry %s&quot;, ret);
++          ldap_memfree(ret);
++        }
++#endif
++      return (NULL);
++    }
++
++  ret = dmalloc (strlen (name[0]) + 1, MDL);
++  strcpy (ret, name[0]);
++  ldap_value_free (name);
++
++  return (ret);
++}
++
++
++static int
++getfqhostname(char *fqhost, size_t size)
++{
++#if defined(MAXHOSTNAMELEN)
++  char   hname[MAXHOSTNAMELEN];
++#else
++  char   hname[65];
++#endif
++  struct hostent *hp;
++
++  if(NULL == fqhost || 1 &gt;= size)
++    return -1;
++
++  memset(hname, 0, sizeof(hname));
++  if( gethostname(hname, sizeof(hname)-1))
++    return -1;
++
++  if(NULL == (hp = gethostbyname(hname)))
++    return -1;
++
++  strncpy(fqhost, hp-&gt;h_name, size-1);
++  fqhost[size-1] = '\0';
++  return 0;
++}
++
++
++isc_result_t
++ldap_read_config (void)
++{
++  LDAPMessage * ldres, * hostres, * ent, * hostent;
++  char hfilter[1024], sfilter[1024], fqdn[257];
++  char *buffer, **tempstr = NULL, *hostdn;
++  ldap_dn_node *curr = NULL;
++  struct parse *cfile;
++  struct utsname unme;
++  isc_result_t res;
++  size_t length;
++  int ret, cnt;
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return (ldap_server == NULL ? ISC_R_SUCCESS : ISC_R_FAILURE);
++ 
++  buffer = dmalloc (LDAP_BUFFER_SIZE+1, MDL);
++  if (buffer == NULL)
++    return (ISC_R_FAILURE);
++
++  cfile = (struct parse *) NULL;
++  res = new_parse (&amp;cfile, -1, buffer, LDAP_BUFFER_SIZE, &quot;LDAP&quot;, 0);
++  if (res != ISC_R_SUCCESS)
++    return (res);
++ 
++  uname (&amp;unme);
++  if (ldap_dhcp_server_cn != NULL)
++    {
++     snprintf (hfilter, sizeof (hfilter),
++                &quot;(&amp;(objectClass=dhcpServer)(cn=%s))&quot;, ldap_dhcp_server_cn);
++    }
++  else
++  {
++  if(0 == getfqhostname(fqdn, sizeof(fqdn)))
++    {
++      snprintf (hfilter, sizeof (hfilter),
++                &quot;(&amp;(objectClass=dhcpServer)(|(cn=%s)(cn=%s)))&quot;, 
++                unme.nodename, fqdn);
++    }
++  else
++    {
++      snprintf (hfilter, sizeof (hfilter),
++                &quot;(&amp;(objectClass=dhcpServer)(cn=%s))&quot;, unme.nodename);
++    }
++
++  }
++  hostres = NULL;
++  if ((ret = ldap_search_s (ld, ldap_base_dn, LDAP_SCOPE_SUBTREE,
++                            hfilter, NULL, 0, &amp;hostres)) != LDAP_SUCCESS)
++    {
++      log_error (&quot;Cannot find host LDAP entry %s %s&quot;,
++		 ((ldap_dhcp_server_cn == NULL)?(unme.nodename):(ldap_dhcp_server_cn)), hfilter);
++      if(NULL != hostres)
++        ldap_msgfree (hostres);
++      ldap_stop();
++      return (ISC_R_FAILURE);
++    }
++
++  if ((hostent = ldap_first_entry (ld, hostres)) == NULL)
++    {
++      log_error (&quot;Error: Cannot find LDAP entry matching %s&quot;, hfilter);
++      ldap_msgfree (hostres);
++      ldap_stop();
++      return (ISC_R_FAILURE);
++    }
++
++  hostdn = ldap_get_dn (ld, hostent);
++#if defined(DEBUG_LDAP)
++  if (hostdn != NULL)
++    log_info (&quot;Found dhcpServer LDAP entry '%s'&quot;, hostdn);
++#endif
++
++  if (hostdn == NULL ||
++      (tempstr = ldap_get_values (ld, hostent, &quot;dhcpServiceDN&quot;)) == NULL ||
++      tempstr[0] == NULL)
++    {
++      log_error (&quot;Error: Cannot find LDAP entry matching %s&quot;, hfilter);
++
++      if (tempstr != NULL)
++        ldap_value_free (tempstr);
++
++      if (hostdn)
++        ldap_memfree (hostdn);
++      ldap_msgfree (hostres);
++      ldap_stop();
++      return (ISC_R_FAILURE);
++    }
++
++#if defined(DEBUG_LDAP)
++  log_info (&quot;LDAP: Parsing dhcpServer options '%s' ...&quot;, hostdn);
++#endif
++
++  cfile-&gt;inbuf[0] = '\0';
++  ldap_parse_entry_options(hostent, cfile-&gt;inbuf, LDAP_BUFFER_SIZE, NULL);
++  cfile-&gt;buflen = strlen (cfile-&gt;inbuf);
++  if(cfile-&gt;buflen &gt; 0)
++    {
++      ldap_write_debug (cfile-&gt;inbuf, cfile-&gt;buflen);
++
++      res = conf_file_subparse (cfile, root_group, ROOT_GROUP);
++      if (res != ISC_R_SUCCESS)
++        {
++          log_error (&quot;LDAP: cannot parse dhcpServer entry '%s'&quot;, hostdn);
++          ldap_memfree (hostdn);
++          ldap_stop();
++          return res;
++        }
++      cfile-&gt;inbuf[0] = '\0';
++    }
++  ldap_msgfree (hostres);
++
++  /*
++  ** attach ldap (tree) read function now
++  */
++  cfile-&gt;bufix = cfile-&gt;buflen = 0;
++  cfile-&gt;read_function = ldap_read_function;
++
++  res = ISC_R_SUCCESS;
++  for (cnt=0; tempstr[cnt] != NULL; cnt++)
++    {
++      snprintf(sfilter, sizeof(sfilter), &quot;(&amp;(objectClass=dhcpService)&quot;
++                        &quot;(|(dhcpPrimaryDN=%s)(dhcpSecondaryDN=%s)))&quot;,
++                        hostdn, hostdn);
++      ldres = NULL;
++      if ((ret = ldap_search_s (ld, tempstr[cnt], LDAP_SCOPE_BASE,
++                                sfilter, NULL, 0, &amp;ldres)) != LDAP_SUCCESS)
++        {
++          log_error (&quot;Error searching for dhcpServiceDN '%s': %s. Please update the LDAP entry '%s'&quot;,
++                     tempstr[cnt], ldap_err2string (ret), hostdn);
++          if(NULL != ldres)
++            ldap_msgfree(ldres);
++          res = ISC_R_FAILURE;
++          break;
++        }
++
++      if ((ent = ldap_first_entry (ld, ldres)) == NULL)
++        {
++          log_error (&quot;Error: Cannot find dhcpService DN '%s' with primary or secondary server reference. Please update the LDAP server entry '%s'&quot;,
++                     tempstr[cnt], hostdn);
++
++          ldap_msgfree(ldres);
++          res = ISC_R_FAILURE;
++          break;
++        }
++
++      /*
++      ** FIXME: how to free the remembered dn's on exit?
++      **        This should be OK if dmalloc registers the
++      **        memory it allocated and frees it on exit..
++      */
++
++      curr = dmalloc (sizeof (*curr), MDL);
++      if (curr != NULL)
++        {
++          length = strlen (tempstr[cnt]);
++          curr-&gt;dn = dmalloc (length + 1, MDL);
++          if (curr-&gt;dn == NULL)
++            {
++              dfree (curr, MDL);
++              curr = NULL;
++            }
++          else
++            strcpy (curr-&gt;dn, tempstr[cnt]);
++        }
++
++      if (curr != NULL)
++        {
++          curr-&gt;refs++;
++
++          /* append to service-dn list */
++          if (ldap_service_dn_tail != NULL)
++            ldap_service_dn_tail-&gt;next = curr;
++          else
++            ldap_service_dn_head = curr;
++
++          ldap_service_dn_tail = curr;
++        }
++      else
++        log_fatal (&quot;no memory to remember ldap service dn&quot;);
++
++#if defined (DEBUG_LDAP)
++      log_info (&quot;LDAP: Parsing dhcpService DN '%s' ...&quot;, tempstr[cnt]);
++#endif
++      add_to_config_stack (ldres, ent);
++      res = conf_file_subparse (cfile, root_group, ROOT_GROUP);
++      if (res != ISC_R_SUCCESS)
++        {
++          log_error (&quot;LDAP: cannot parse dhcpService entry '%s'&quot;, tempstr[cnt]);
++          break;
++        }
++    }
++
++  end_parse (&amp;cfile);
++  ldap_close_debug_fd();
++
++  ldap_memfree (hostdn);
++  ldap_value_free (tempstr);
++
++  if (res != ISC_R_SUCCESS)
++    {
++      struct ldap_config_stack *temp_stack;
++
++      while ((curr = ldap_service_dn_head) != NULL)
++        {
++          ldap_service_dn_head = curr-&gt;next;
++          dfree (curr-&gt;dn, MDL);
++          dfree (curr, MDL);
++        }
++
++      ldap_service_dn_tail = NULL;
++
++      while ((temp_stack = ldap_stack) != NULL)
++        {
++          ldap_stack = temp_stack-&gt;next;
++          free_stack_entry (temp_stack);
++        }
++
++      ldap_stop();
++    }
++
++  /* Unbind from ldap immediately after reading config in static mode. */
++  if (ldap_method == LDAP_METHOD_STATIC)
++    ldap_stop();
++
++  return (res);
++}
++
++
++/* This function will parse the dhcpOption and dhcpStatements field in the LDAP
++   entry if it exists. Right now, type will be either HOST_DECL or CLASS_DECL.
++   If we are parsing a HOST_DECL, this always returns 0. If we are parsing a 
++   CLASS_DECL, this will return what the current lease limit is in LDAP. If
++   there is no lease limit specified, we return 0 */
++
++static int
++ldap_parse_options (LDAPMessage * ent, struct group *group,
++                         int type, struct host_decl *host,
++                         struct class **class)
++{
++  int i, declaration, lease_limit;
++  char option_buffer[8192];
++  enum dhcp_token token;
++  struct parse *cfile;
++  isc_result_t res;
++  const char *val;
++
++  lease_limit = 0;
++  *option_buffer = '\0';
++ 
++ /* This block of code will try to find the parent of the host, and
++    if it is a group object, fetch the options and apply to the host. */
++  if (type == HOST_DECL) 
++    {
++      char *hostdn, *basedn, *temp1, *temp2, filter[1024];
++      LDAPMessage *groupdn, *entry;
++      int ret;
++
++      hostdn = ldap_get_dn (ld, ent);
++      if( hostdn != NULL)
++        {
++          basedn = NULL;
++
++          temp1 = strchr (hostdn, '=');
++          if (temp1 != NULL)
++            temp1 = strchr (++temp1, '=');
++          if (temp1 != NULL)
++            temp2 = strchr (++temp1, ',');
++          else
++            temp2 = NULL;
++
++          if (temp2 != NULL)
++            {
++              snprintf (filter, sizeof(filter),
++                        &quot;(&amp;(cn=%.*s)(objectClass=dhcpGroup))&quot;,
++                        (int)(temp2 - temp1), temp1);
++
++              basedn = strchr (temp1, ',');
++              if (basedn != NULL)
++                ++basedn;
++            }
++
++          if (basedn != NULL &amp;&amp; *basedn != '\0')
++            {
++              ret = ldap_search_s (ld, basedn, LDAP_SCOPE_SUBTREE,
++                                   filter, NULL, 0, &amp;groupdn);
++              if (ret == LDAP_SUCCESS)
++                {
++                  if ((entry = ldap_first_entry (ld, groupdn)) != NULL)
++                    {
++                      res = ldap_parse_entry_options (entry, option_buffer,
++                                                      sizeof(option_buffer) - 1,
++                                                      &amp;lease_limit);
++                      if (res != ISC_R_SUCCESS)
++                        {
++                          /* reset option buffer discarding any results */
++                          *option_buffer = '\0';
++                          lease_limit = 0;
++                        }
++                    }
++                  ldap_msgfree( groupdn);
++                }
++            }
++          ldap_memfree( hostdn);
++        }
++    }
++
++  res = ldap_parse_entry_options (ent, option_buffer, sizeof(option_buffer) - 1,
++                                  &amp;lease_limit);
++  if (res != ISC_R_SUCCESS)
++    return (lease_limit);
++
++  option_buffer[sizeof(option_buffer) - 1] = '\0';
++  if (*option_buffer == '\0')
++    return (lease_limit);
++
++  cfile = (struct parse *) NULL;
++  res = new_parse (&amp;cfile, -1, option_buffer, strlen (option_buffer), 
++                   type == HOST_DECL ? &quot;LDAP-HOST&quot; : &quot;LDAP-SUBCLASS&quot;, 0);
++  if (res != ISC_R_SUCCESS)
++    return (lease_limit);
++
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Sending the following options: '%s'&quot;, option_buffer);
++#endif
++
++  declaration = 0;
++  do
++    {
++      token = peek_token (&amp;val, NULL, cfile);
++      if (token == END_OF_FILE)
++        break;
++       declaration = parse_statement (cfile, group, type, host, declaration);
++    } while (1);
++
++  end_parse (&amp;cfile);
++
++  return (lease_limit);
++}
++
++
++
++int
++find_haddr_in_ldap (struct host_decl **hp, int htype, unsigned hlen,
++                    const unsigned char *haddr, const char *file, int line)
++{
++  char buf[128], *type_str, **tempstr, *addr_str;
++  LDAPMessage * res, *ent;
++  struct host_decl * host;
++  isc_result_t status;
++  ldap_dn_node *curr;
++  int ret;
++
++  if (ldap_method == LDAP_METHOD_STATIC)
++    return (0);
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return (0);
++
++  switch (htype)
++    {
++      case HTYPE_ETHER:
++        type_str = &quot;ethernet&quot;;
++        break;
++      case HTYPE_IEEE802:
++        type_str = &quot;token-ring&quot;;
++        break;
++      case HTYPE_FDDI:
++        type_str = &quot;fddi&quot;;
++        break;
++      default:
++        log_info (&quot;Ignoring unknown type %d&quot;, htype);
++        return (0);
++    }
++
++  /*
++  ** FIXME: It is not guaranteed, that the dhcpHWAddress attribute
++  **        contains _exactly_ &quot;type addr&quot; with one space between!
++  */
++  snprintf (buf, sizeof (buf),
++            &quot;(&amp;(objectClass=dhcpHost)(dhcpHWAddress=%s %s))&quot;,
++           type_str, print_hw_addr (htype, hlen, haddr));
++
++  res = ent = NULL;
++  for (curr = ldap_service_dn_head;
++       curr != NULL &amp;&amp; *curr-&gt;dn != '\0';
++       curr = curr-&gt;next)
++    {
++#if defined (DEBUG_LDAP)
++      log_info (&quot;Searching for %s in LDAP tree %s&quot;, buf, curr-&gt;dn);
++#endif
++      ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                           buf, NULL, 0, &amp;res);
++
++      if(ret == LDAP_SERVER_DOWN)
++        {
++          log_info (&quot;LDAP server was down, trying to reconnect...&quot;);
++
++          ldap_stop();
++          ldap_start();
++          if(ld == NULL)
++            {
++              log_info (&quot;LDAP reconnect failed - try again later...&quot;);
++              return (0);
++            }
++
++          ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                               buf, NULL, 0, &amp;res);
++        }
++
++      if (ret == LDAP_SUCCESS)
++        {
++          if( (ent = ldap_first_entry (ld, res)) != NULL)
++            break; /* search OK and have entry */
++
++#if defined (DEBUG_LDAP)
++          log_info (&quot;No host entry for %s in LDAP tree %s&quot;,
++                    buf, curr-&gt;dn);
++#endif
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++        }
++      else
++        {
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++
++          if (ret != LDAP_NO_SUCH_OBJECT &amp;&amp; ret != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot search for %s in LDAP tree %s: %s&quot;, buf, 
++                         curr-&gt;dn, ldap_err2string (ret));
++              ldap_stop();
++              return (0);
++            }
++#if defined (DEBUG_LDAP)
++          else
++            {
++              log_info (&quot;ldap_search_s returned %s when searching for %s in %s&quot;,
++                        ldap_err2string (ret), buf, curr-&gt;dn);
++            }
++#endif
++        }
++    }
++
++  if (res &amp;&amp; ent)
++    {
++#if defined (DEBUG_LDAP)
++      char *dn = ldap_get_dn (ld, ent);
++      if (dn != NULL)
++        {
++          log_info (&quot;Found dhcpHWAddress LDAP entry %s&quot;, dn);
++          ldap_memfree(dn);
++        }
++#endif
++
++      host = (struct host_decl *)0;
++      status = host_allocate (&amp;host, MDL);
++      if (status != ISC_R_SUCCESS)
++        {
++          log_fatal (&quot;can't allocate host decl struct: %s&quot;, 
++                     isc_result_totext (status)); 
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      host-&gt;name = ldap_get_host_name (ent);
++      if (host-&gt;name == NULL)
++        {
++          host_dereference (&amp;host, MDL);
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      if (!clone_group (&amp;host-&gt;group, root_group, MDL))
++        {
++          log_fatal (&quot;can't clone group for host %s&quot;, host-&gt;name);
++          host_dereference (&amp;host, MDL);
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      ldap_parse_options (ent, host-&gt;group, HOST_DECL, host, NULL);
++
++      *hp = host;
++      ldap_msgfree (res);
++      return (1);
++    }
++
++
++  if(res) ldap_msgfree (res);
++  return (0);
++}
++
++
++int
++find_subclass_in_ldap (struct class *class, struct class **newclass, 
++                       struct data_string *data)
++{
++  LDAPMessage * res, * ent;
++  int i, ret, lease_limit;
++  isc_result_t status;
++  ldap_dn_node *curr;
++  char buf[1024];
++
++  if (ldap_method == LDAP_METHOD_STATIC)
++    return (0);
++
++  if (ld == NULL)
++    ldap_start ();
++  if (ld == NULL)
++    return (0);
++
++  snprintf (buf, sizeof (buf),
++            &quot;(&amp;(objectClass=dhcpSubClass)(cn=%s)(dhcpClassData=%s))&quot;,
++            print_hex_1 (data-&gt;len, data-&gt;data, 60),
++            print_hex_2 (strlen (class-&gt;name), class-&gt;name, 60));
++#if defined (DEBUG_LDAP)
++  log_info (&quot;Searching LDAP for %s&quot;, buf);
++#endif
++
++  res = ent = NULL;
++  for (curr = ldap_service_dn_head;
++       curr != NULL &amp;&amp; *curr-&gt;dn != '\0';
++       curr = curr-&gt;next)
++    {
++#if defined (DEBUG_LDAP)
++      log_info (&quot;Searching for %s in LDAP tree %s&quot;, buf, curr-&gt;dn);
++#endif
++      ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                           buf, NULL, 0, &amp;res);
++
++      if(ret == LDAP_SERVER_DOWN)
++        {
++          log_info (&quot;LDAP server was down, trying to reconnect...&quot;);
++
++          ldap_stop();
++          ldap_start();
++
++          if(ld == NULL)
++            {
++              log_info (&quot;LDAP reconnect failed - try again later...&quot;);
++              return (0);
++            }
++
++          ret = ldap_search_s (ld, curr-&gt;dn, LDAP_SCOPE_SUBTREE,
++                               buf, NULL, 0, &amp;res);
++        }
++
++      if (ret == LDAP_SUCCESS)
++        {
++          if( (ent = ldap_first_entry (ld, res)) != NULL)
++            break; /* search OK and have entry */
++
++#if defined (DEBUG_LDAP)
++          log_info (&quot;No subclass entry for %s in LDAP tree %s&quot;,
++                    buf, curr-&gt;dn);
++#endif
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++        }
++      else
++        {
++          if(res)
++            {
++              ldap_msgfree (res);
++              res = NULL;
++            }
++
++          if (ret != LDAP_NO_SUCH_OBJECT &amp;&amp; ret != LDAP_SUCCESS)
++            {
++              log_error (&quot;Cannot search for %s in LDAP tree %s: %s&quot;, buf, 
++                         curr-&gt;dn, ldap_err2string (ret));
++              ldap_stop();
++              return (0);
++            }
++#if defined (DEBUG_LDAP)
++          else
++            {
++              log_info (&quot;ldap_search_s returned %s when searching for %s in %s&quot;,
++                        ldap_err2string (ret), buf, curr-&gt;dn);
++            }
++#endif
++        }
++    }
++
++  if (res &amp;&amp; ent)
++    {
++#if defined (DEBUG_LDAP)
++      char *dn = ldap_get_dn (ld, ent);
++      if (dn != NULL)
++        {
++          log_info (&quot;Found subclass LDAP entry %s&quot;, dn);
++          ldap_memfree(dn);
++        }
++#endif
++
++      status = class_allocate (newclass, MDL);
++      if (status != ISC_R_SUCCESS)
++        {
++          log_error (&quot;Cannot allocate memory for a new class&quot;);
++          ldap_msgfree (res);
++          return (0);
++        }
++
++      group_reference (&amp;(*newclass)-&gt;group, class-&gt;group, MDL);
++      class_reference (&amp;(*newclass)-&gt;superclass, class, MDL);
++      lease_limit = ldap_parse_options (ent, (*newclass)-&gt;group, 
++                                        CLASS_DECL, NULL, newclass);
++      if (lease_limit == 0)
++        (*newclass)-&gt;lease_limit = class-&gt;lease_limit; 
++      else
++        class-&gt;lease_limit = lease_limit;
++
++      if ((*newclass)-&gt;lease_limit) 
++        {
++          (*newclass)-&gt;billed_leases = 
++              dmalloc ((*newclass)-&gt;lease_limit * sizeof (struct lease *), MDL);
++          if (!(*newclass)-&gt;billed_leases) 
++            {
++              log_error (&quot;no memory for billing&quot;);
++              class_dereference (newclass, MDL);
++              ldap_msgfree (res);
++              return (0);
++            }
++          memset ((*newclass)-&gt;billed_leases, 0, 
++                ((*newclass)-&gt;lease_limit * sizeof (*newclass)-&gt;billed_leases));
++        }
++
++      data_string_copy (&amp;(*newclass)-&gt;hash_string, data, MDL);
++
++      ldap_msgfree (res);
++      return (1);
++    }
++
++  if(res) ldap_msgfree (res);
++  return (0);
++}
++
++#endif
+diff -Naur dhcp-3.0.5/server/ldap_casa.c dhcp-3.0.5-ldap/server/ldap_casa.c
+--- dhcp-3.0.5/server/ldap_casa.c	1969-12-31 19:00:00.000000000 -0500
++++ dhcp-3.0.5-ldap/server/ldap_casa.c	2007-02-23 12:48:56.000000000 -0500
+@@ -0,0 +1,138 @@
++/* ldap_casa.c
++   
++   CASA routines for DHCPD... */
++
++/* Copyright (c) 2004 Internet Systems Consorium, Inc. (&quot;ISC&quot;)
++ * Copyright (c) 1995-2003 Internet Software Consortium.
++ * Copyright (c) 2006 Novell, Inc.
++
++ * All rights reserved.
++ * Redistribution and use in source and binary forms, with or without 
++ * modification, are permitted provided that the following conditions are met: 
++ * 1.Redistributions of source code must retain the above copyright notice, 
++ *   this list of conditions and the following disclaimer. 
++ * 2.Redistributions in binary form must reproduce the above copyright notice, 
++ *   this list of conditions and the following disclaimer in the documentation 
++ *   and/or other materials provided with the distribution. 
++ * 3.Neither the name of ISC, ISC DHCP, nor the names of its contributors 
++ *   may be used to endorse or promote products derived from this software 
++ *   without specific prior written permission. 
++
++ * THIS SOFTWARE IS PROVIDED BY INTERNET SYSTEMS CONSORTIUM AND CONTRIBUTORS 
++ * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
++ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
++ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ISC OR CONTRIBUTORS BE LIABLE 
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
++ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
++ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
++ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
++ * POSSIBILITY OF SUCH DAMAGE.
++
++ * This file was written by S Kalyanasundaram &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">skalyanasundaram at novell.com</A>&gt;
++ */
++
++#if defined(LDAP_CASA_AUTH)
++#include &quot;ldap_casa.h&quot;
++#include &quot;dhcpd.h&quot;
++
++int
++load_casa (void)
++{
++       if( !(casaIDK = dlopen(MICASA_LIB,RTLD_LAZY)))
++       	  return 0;
++       p_miCASAGetCredential = (CASA_GetCredential_T) dlsym(casaIDK, &quot;miCASAGetCredential&quot;);
++       p_miCASASetCredential = (CASA_SetCredential_T) dlsym(casaIDK, &quot;miCASASetCredential&quot;);
++       p_miCASARemoveCredential = (CASA_RemoveCredential_T) dlsym(casaIDK, &quot;miCASARemoveCredential&quot;);
++
++       if((p_miCASAGetCredential == NULL) ||
++         (p_miCASASetCredential == NULL) ||
++         (p_miCASARemoveCredential == NULL))
++       {
++          if(casaIDK)
++            dlclose(casaIDK);
++          casaIDK = NULL;
++          p_miCASAGetCredential = NULL;
++          p_miCASASetCredential = NULL;
++          p_miCASARemoveCredential = NULL;
++          return 0;
++       }
++       else
++          return 1;
++}
++
++static void
++release_casa(void)
++{
++   if(casaIDK)
++   {
++      dlclose(casaIDK);
++      casaIDK = NULL;
++   }
++
++   p_miCASAGetCredential = NULL;
++   p_miCASASetCredential = NULL;
++   p_miCASARemoveCredential = NULL;
++
++}
++
++int
++load_uname_pwd_from_miCASA (char **ldap_username, char **ldap_password)
++ {
++   int                     result = 0;
++   uint32_t                credentialtype = SSCS_CRED_TYPE_SERVER_F;
++   SSCS_BASIC_CREDENTIAL   credential;
++   SSCS_SECRET_ID_T        applicationSecretId;
++   char                    *tempVar = NULL;
++
++   const char applicationName[10] = &quot;dhcp-ldap&quot;;
++
++   if ( load_casa() )
++   {
++      memset(&amp;credential, 0, sizeof(SSCS_BASIC_CREDENTIAL));
++      memset(&amp;applicationSecretId, 0, sizeof(SSCS_SECRET_ID_T));
++
++      applicationSecretId.len = strlen(applicationName) + 1;
++      memcpy (applicationSecretId.id, applicationName, applicationSecretId.len);
++
++      credential.unFlags = USERNAME_TYPE_CN_F;
++
++      result = p_miCASAGetCredential (0,
++                 &amp;applicationSecretId,NULL,&amp;credentialtype,
++                 &amp;credential,NULL);
++
++      if(credential.unLen)
++      {
++         tempVar = dmalloc (credential.unLen + 1, MDL);
++         if (!tempVar)
++             log_fatal (&quot;no memory for ldap_username&quot;);
++         memcpy(tempVar , credential.username, credential.unLen);
++         *ldap_username = tempVar;
++
++         tempVar = dmalloc (credential.pwordLen + 1, MDL);
++         if (!tempVar)
++             log_fatal (&quot;no memory for ldap_password&quot;);
++         memcpy(tempVar, credential.password, credential.pwordLen);
++         *ldap_password = tempVar;
++
++#if defined (DEBUG_LDAP)
++         log_info (&quot;Authentication credential taken from CASA&quot;);
++#endif
++
++         release_casa();
++         return 1;
++
++        }
++        else
++        {
++            release_casa();
++            return 0;
++        }
++      }
++      else
++          return 0; //casa libraries not loaded
++ }
++
++#endif /* LDAP_CASA_AUTH */
++
+diff -Naur dhcp-3.0.5/server/mdb.c dhcp-3.0.5-ldap/server/mdb.c
+--- dhcp-3.0.5/server/mdb.c	2006-07-18 14:16:25.000000000 -0400
++++ dhcp-3.0.5-ldap/server/mdb.c	2006-12-14 10:03:41.000000000 -0500
+@@ -375,6 +375,12 @@
+ {
+ 	struct host_decl *foo;
+ 	struct hardware h;
++	int ret;
++
++#if defined(LDAP_CONFIGURATION)
++	if ((ret = find_haddr_in_ldap (hp, htype, hlen, haddr, file, line)))
++		return ret;
++#endif
+ 
+ 	h.hlen = hlen + 1;
+ 	h.hbuf [0] = htype;
+diff -Naur dhcp-3.0.5/server/stables.c dhcp-3.0.5-ldap/server/stables.c
+--- dhcp-3.0.5/server/stables.c	2004-06-10 13:59:58.000000000 -0400
++++ dhcp-3.0.5-ldap/server/stables.c	2007-02-23 13:13:36.000000000 -0500
+@@ -483,6 +483,38 @@
+ 	{ &quot;log-facility&quot;, &quot;Nsyslog-facilities.&quot;,	&amp;server_universe, 44 },
+ 	{ &quot;do-forward-updates&quot;, &quot;f&quot;,			&amp;server_universe, 45 },
+ 	{ &quot;ping-timeout&quot;, &quot;T&quot;,				&amp;server_universe, 46 },
++#if defined(LDAP_CONFIGURATION)
++	{ &quot;ldap-server&quot;, &quot;t&quot;,				&amp;server_universe, 47 },
++	{ &quot;ldap-port&quot;, &quot;d&quot;,				&amp;server_universe, 48 },
++	{ &quot;ldap-username&quot;, &quot;t&quot;,				&amp;server_universe, 49 },
++	{ &quot;ldap-password&quot;, &quot;t&quot;,				&amp;server_universe, 50 },
++	{ &quot;ldap-base-dn&quot;, &quot;t&quot;,				&amp;server_universe, 51 },
++	{ &quot;ldap-method&quot;, &quot;Nldap-methods.&quot;,		&amp;server_universe, 52 },
++	{ &quot;ldap-debug-file&quot;, &quot;t&quot;,			&amp;server_universe, 53 },
++	{ &quot;ldap-dhcp-server-cn&quot;, &quot;t&quot;,			&amp;server_universe, 54 },
++	{ &quot;ldap-referrals&quot;, &quot;f&quot;,			&amp;server_universe, 55 },
++#if defined(USE_SSL)
++	{ &quot;ldap-ssl&quot;, &quot;Nldap-ssl-usage.&quot;,		&amp;server_universe, 56 },
++	{ &quot;ldap-tls-reqcert&quot;, &quot;Nldap-tls-reqcert.&quot;,	&amp;server_universe, 57 },
++	{ &quot;ldap-tls-ca-file&quot;, &quot;t&quot;,			&amp;server_universe, 58 },
++	{ &quot;ldap-tls-ca-dir&quot;, &quot;t&quot;,			&amp;server_universe, 59 },
++	{ &quot;ldap-tls-cert&quot;, &quot;t&quot;,				&amp;server_universe, 60 },
++	{ &quot;ldap-tls-key&quot;, &quot;t&quot;,				&amp;server_universe, 61 },
++	{ &quot;ldap-tls-crlcheck&quot;, &quot;Nldap-tls-crlcheck.&quot;,	&amp;server_universe, 62 },
++	{ &quot;ldap-tls-ciphers&quot;, &quot;t&quot;,			&amp;server_universe, 63 },
++	{ &quot;ldap-tls-randfile&quot;, &quot;t&quot;,			&amp;server_universe, 64 },
++#else
++	{ &quot;unknown-56&quot;, &quot;X&quot;,				&amp;server_universe, 56 },
++	{ &quot;unknown-57&quot;, &quot;X&quot;,				&amp;server_universe, 57 },
++	{ &quot;unknown-58&quot;, &quot;X&quot;,				&amp;server_universe, 58 },
++	{ &quot;unknown-59&quot;, &quot;X&quot;,				&amp;server_universe, 59 },
++	{ &quot;unknown-60&quot;, &quot;X&quot;,				&amp;server_universe, 60 },
++	{ &quot;unknown-61&quot;, &quot;X&quot;,				&amp;server_universe, 61 },
++	{ &quot;unknown-62&quot;, &quot;X&quot;,				&amp;server_universe, 62 },
++	{ &quot;unknown-63&quot;, &quot;X&quot;,				&amp;server_universe, 63 },
++	{ &quot;unknown-64&quot;, &quot;X&quot;,				&amp;server_universe, 64 },
++#endif
++#else
+ 	{ &quot;unknown-47&quot;, &quot;X&quot;,				&amp;server_universe, 47 },
+ 	{ &quot;unknown-48&quot;, &quot;X&quot;,				&amp;server_universe, 48 },
+ 	{ &quot;unknown-49&quot;, &quot;X&quot;,				&amp;server_universe, 49 },
+@@ -501,6 +533,7 @@
+ 	{ &quot;unknown-62&quot;, &quot;X&quot;,				&amp;server_universe, 62 },
+ 	{ &quot;unknown-63&quot;, &quot;X&quot;,				&amp;server_universe, 63 },
+ 	{ &quot;unknown-64&quot;, &quot;X&quot;,				&amp;server_universe, 64 },
++#endif
+ 	{ &quot;unknown-65&quot;, &quot;X&quot;,				&amp;server_universe, 65 },
+ 	{ &quot;unknown-66&quot;, &quot;X&quot;,				&amp;server_universe, 66 },
+ 	{ &quot;unknown-67&quot;, &quot;X&quot;,				&amp;server_universe, 67 },
+@@ -694,6 +727,61 @@
+ 	{ &quot;option-end&quot;, &quot;e&quot;,				&amp;server_universe, 255 },
+ };
+ 
++#if defined(LDAP_CONFIGURATION)
++struct enumeration_value ldap_values [] = {
++	{ &quot;static&quot;, LDAP_METHOD_STATIC },
++	{ &quot;dynamic&quot;, LDAP_METHOD_DYNAMIC },
++	{ (char *) 0, 0 }
++};
++
++struct enumeration ldap_methods = {
++	(struct enumeration *)0,
++	&quot;ldap-methods&quot;,
++	ldap_values
++};
++
++#if defined(USE_SSL)
++struct enumeration_value ldap_ssl_usage_values [] = {
++	{ &quot;off&quot;,       LDAP_SSL_OFF  },
++	{ &quot;on&quot;,        LDAP_SSL_ON   },
++	{ &quot;ldaps&quot;,     LDAP_SSL_LDAPS},
++	{ &quot;start_tls&quot;, LDAP_SSL_TLS  },
++	{ (char *) 0, 0 }
++};
++struct enumeration ldap_ssl_usage_enum = {
++	(struct enumeration *)0,
++	&quot;ldap-ssl-usage&quot;,
++	ldap_ssl_usage_values
++};
++
++struct enumeration_value ldap_tls_reqcert_values [] = {
++	{ &quot;never&quot;,  LDAP_OPT_X_TLS_NEVER },
++	{ &quot;hard&quot;,   LDAP_OPT_X_TLS_HARD  },
++	{ &quot;demand&quot;, LDAP_OPT_X_TLS_DEMAND},
++	{ &quot;allow&quot;,  LDAP_OPT_X_TLS_ALLOW },
++	{ &quot;try&quot;,    LDAP_OPT_X_TLS_TRY   },
++	{ (char *) 0, 0 }
++};
++struct enumeration ldap_tls_reqcert_enum = {
++	(struct enumeration *)0,
++	&quot;ldap-tls-reqcert&quot;,
++	ldap_tls_reqcert_values
++};
++
++struct enumeration_value ldap_tls_crlcheck_values [] = {
++	{ &quot;none&quot;, LDAP_OPT_X_TLS_CRL_NONE},
++	{ &quot;peer&quot;, LDAP_OPT_X_TLS_CRL_PEER},
++	{ &quot;all&quot;,  LDAP_OPT_X_TLS_CRL_ALL },
++	{ (char *) 0, 0 }
++};
++struct enumeration ldap_tls_crlcheck_enum = {
++	(struct enumeration *)0,
++	&quot;ldap-tls-crlcheck&quot;,
++	ldap_tls_crlcheck_values
++};
++#endif
++#endif
++
+ struct enumeration_value ddns_styles_values [] = {
+ 	{ &quot;none&quot;, 0 },
+ 	{ &quot;ad-hoc&quot;, 1 },
+diff -Naur dhcp-3.0.5/site.conf dhcp-3.0.5-ldap/site.conf
+--- dhcp-3.0.5/site.conf	1999-07-07 11:20:10.000000000 -0400
++++ dhcp-3.0.5-ldap/site.conf	2007-02-23 13:41:54.000000000 -0500
+@@ -1,2 +1,3 @@
+ # Put local site configuration stuff here to override the default
+ # settings in Makefile.conf
++#COPTS = -DDEBUG_LDAP -DLDAP_CASA_AUTH -DDEBUG_CLASS_MATCHING -Wall -O -Wno-unused

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-libdhcp4client.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-libdhcp4client.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-libdhcp4client.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,1345 @@
+--- dhcp-3.0.5/client/dhclient.c.libdhcp4client	2006-11-29 10:50:20.000000000 -0500
++++ dhcp-3.0.5/client/dhclient.c	2006-11-29 10:50:20.000000000 -0500
+@@ -78,7 +78,9 @@
+ int extended_option_environment = 0;
+ #endif
+ int bootp_broadcast_always = 0;
+-
++#ifdef LIBDHCP
++FILE *leaseFile=0;
++#endif
+ static void usage PROTO ((void));
+ 
+ void do_release(struct client_state *);
+@@ -89,10 +91,57 @@
+ 
+ extern u_int32_t default_requested_options[];
+ 
+-int main (argc, argv, envp)
++#ifdef LIBDHCP
++#include &quot;libdhcp_control.h&quot;
++LIBDHCP_Control *libdhcp_control;
++static void libdhcp_dispatch(void)
++{
++    struct timeval tv={0,0}, *tvp;
++    isc_result_t status;
++
++    /* Wait for a packet, or a timeout, or libdhcp being finished */
++    do {
++	tvp = process_outstanding_timeouts (&amp;tv);	
++	status = omapi_one_dispatch (0, tvp);
++	if ( libdhcp_control 
++	   &amp;&amp;( (status == ISC_R_TIMEDOUT)
++	     ||(libdhcp_control-&gt;timeout
++	       &amp;&amp;( time(0L) &gt;= 
++	           ( libdhcp_control-&gt;timeout 
++	            +libdhcp_control-&gt;now
++	           )
++	         )
++	       )
++	     )
++	   )
++	{
++	    if( libdhcp_control -&gt; callback )
++		libdhcp_control -&gt; callback
++		    ( libdhcp_control, DHC_TIMEDOUT, 0L );
++	    break;
++	}
++    } while 
++      ( (status != ISC_R_TIMEDOUT) 
++      &amp;&amp;( (!libdhcp_control)
++        ||(!(libdhcp_control-&gt;finished))
++	)
++      );
++}
++
++extern void omapi_free_all_pointers(void);
++int dhcpv4_client
++(libdhcp_ctl, argc, argv, envp)
++LIBDHCP_Control *libdhcp_ctl;
++#else
++int main
++(argc, argv, envp)
++#endif
+ 	int argc;
+ 	char **argv, **envp;
+ {
++#ifdef LIBDHCP
++        libdhcp_control = libdhcp_ctl;
++#endif
+ 	int i;
+ 	struct servent *ent;
+ 	struct interface_info *ip;
+@@ -105,7 +154,6 @@
+ 	omapi_object_t *listener;
+ 	isc_result_t result;
+ 	int persist = 0;
+-	int omapi_port;
+ 	int no_dhclient_conf = 0;
+ 	int no_dhclient_db = 0;
+ 	int no_dhclient_pid = 0;
+@@ -119,7 +167,7 @@
+ 	int timeout_arg = 0;
+ 	char *arg_conf = 0L;
+ 	int arg_conf_len=0;
+-
++#ifndef LIBDHCP
+ 	/* Make sure we have stdin, stdout and stderr. */
+ 	i = open (&quot;/dev/null&quot;, O_RDWR);
+ 	if (i == 0)
+@@ -140,7 +188,7 @@
+ #if !(defined (DEBUG) || defined (SYSLOG_4_2) || defined (__CYGWIN32__))
+ 	setlogmask (LOG_UPTO (LOG_INFO));
+ #endif	
+-
++#endif
+ 	/* Set up the OMAPI. */
+ 	status = omapi_init ();
+ 	if (status != ISC_R_SUCCESS)
+@@ -469,9 +517,12 @@
+ 		log_fatal(&quot;dhclient(%u) is already running - exiting. &quot;, dhcpid);
+ 		return(1);
+ 	    }	    
+-	}	
++	}
++#ifdef LIBDHCP
++	if ( libdhcp_control &amp;&amp; (libdhcp_control-&gt;capability &amp; DHCP_USE_PID_FILE) )
++#endif
+ 	write_client_pid_file();
+-
++#ifndef LIBDHCP
+ 	if (!quiet) {
+ 		log_info (&quot;%s %s&quot;, message, DHCP_VERSION);
+ 		log_info (copyright);
+@@ -480,7 +531,7 @@
+ 		log_info (&quot;%s&quot;, &quot;&quot;);
+ 	} else
+ 		log_perror = 0;
+-
++#endif
+ 	/* If we're given a relay agent address to insert, for testing
+ 	   purposes, figure out what it is. */
+ 	if (relay) {
+@@ -767,12 +818,18 @@
+ 		arg_conf_len = 0L;
+ 	}
+ 		
++#ifdef LIBDHCP
++	if ( libdhcp_control &amp;&amp; (libdhcp_control-&gt;capability &amp; DHCP_USE_LEASE_DATABASE))
++	{
++#endif
+ 	/* Parse the lease database. */
+ 	read_client_leases ();
+ 
+ 	/* Rewrite the lease database... */
+ 	rewrite_client_leases ();
+-
++#ifdef LIBDHCP
++	}
++#endif
+ 	/* XXX */
+ /* 	config_counter(&amp;snd_counter, &amp;rcv_counter); */
+ 
+@@ -790,7 +847,7 @@
+ 		if (!persist) {
+ 			/* Nothing more to do. */
+ 			log_info (&quot;No broadcast interfaces found - exiting.&quot;);
+-			exit (0);
++			return (0);
+ 		}
+ 	} else if (!release_mode) {
+ 		/* Call the script with the list of interfaces. */
+@@ -885,7 +942,7 @@
+ 	dmalloc_longterm = dmalloc_outstanding;
+ 	dmalloc_outstanding = 0;
+ #endif
+-
++#ifndef LIBDHCP
+ 	/* If we're not supposed to wait before getting the address,
+ 	   don't. */
+ 	if (nowait)
+@@ -898,7 +955,125 @@
+ 
+ 	/* Start dispatching packets and timeouts... */
+ 	dispatch ();
++#else
++	if (  libdhcp_control )
++	{
++	   if ( libdhcp_control-&gt;timeout ) 
++	       libdhcp_control-&gt;now = time(0L);
++	   else
++	       libdhcp_control-&gt;now = 0;
++	}
++	libdhcp_dispatch();
++
++	/* libdhcp is finished with us. */
++
++	/* close all file descriptors:  */
++	for (ip = interfaces; ip; ip = ip -&gt; next) {
++	    shutdown( ip -&gt; wfdesc, SHUT_RDWR );
++	    close(ip -&gt; wfdesc);
++	    if( ip -&gt; rfdesc != ip -&gt; wfdesc )
++		close(ip -&gt; rfdesc);
++	}
++	if( fallback_interface != 0 )
++	{
++	    ip = fallback_interface;
++	    shutdown( ip -&gt; wfdesc, SHUT_RDWR );
++	    close(ip -&gt; wfdesc);
++	    if( ip -&gt; rfdesc != ip -&gt; wfdesc )
++		close(ip -&gt; rfdesc);
++	}
++	if (leaseFile)
++	    fclose (leaseFile);
++	closelog();
++	
++	char *current_pid_file = _PATH_DHCLIENT_PID;
++
++	/* Free ALL allocated memory: */
++	omapi_free_all_pointers();
+ 
++	/* Re-Initialize globals: */
++	client_env = 0;
++	client_env_count = 0;
++	default_lease_time = 43200;
++
++	dhcp_max_agent_option_packet_length = 0;
++	extended_option_environment = 0;
++	iaddr_any.len = 4;
++	memset(&amp;(iaddr_any.iabuf[0]),'\0',4);
++	iaddr_broadcast.len = 4;
++	memset(&amp;(iaddr_broadcast.iabuf[0]),0xff,4);
++	interfaces_requested = 0;
++	leaseFile = 0;
++
++	libdhcp_control = 0;
++	
++	local_port = 0;
++	no_daemon=0;
++	nowait=0;
++	onetry=0;
++	quiet=0;
++	max_lease_time = 86400;
++	path_dhclient_conf = _PATH_DHCLIENT_CONF;
++	path_dhclient_db = _PATH_DHCLIENT_DB;	
++	path_dhclient_pid = _PATH_DHCLIENT_PID;
++	strcpy(&amp;(path_dhclient_script_array[0]), _PATH_DHCLIENT_SCRIPT);
++	path_dhclient_script = path_dhclient_script_array;
++	remote_port = 0;
++	resolver_inited = 0;
++	new_option_info_tree = 0;
++	log_isc_blurb = 0;
++	log_perror = 1;
++	global_scope = 0L;
++	root_group = 0L;
++	group_name_hash = 0L;
++	interfaces = 0L;
++	dummy_interfaces = 0L;
++	fallback_interface = 0L;
++extern int have_setup_fallback;
++        have_setup_fallback=0;
++	quiet_interface_discovery=1;
++#ifndef LIBDHCP
++	timeouts = 0L;
++#endif
++	dhcp_type_interface=0L;
++	interface_vector = 0L;
++	interface_count =0;
++	interface_max = 0;
++	name_servers = 0;
++	domains = 0;
++	dhcp_type_interface=0L;
++	dhcp_type_group=0L;
++	dhcp_type_shared_network=0L;
++	dhcp_type_control=0L;
++	memset(&amp;dhcp_universe, '\0', sizeof(struct universe));
++	memset(&amp;nwip_universe, '\0', sizeof(struct universe));
++	memset(&amp;fqdn_universe, '\0', sizeof(struct universe));
++	universe_hash = 0;
++	universes=0;
++	universe_count=0;
++	universe_max=0;
++	config_universe = 0;	
++extern struct hash_bucket *free_hash_buckets;
++	free_hash_buckets=0L;
++extern struct dhcp_packet *dhcp_free_list;
++	dhcp_free_list = 0L;
++extern struct packet *packet_free_list;
++	packet_free_list = 0L;
++extern struct binding_value *free_binding_values;
++	free_binding_values=0L;
++extern struct expression *free_expressions;
++	free_expressions=0L;
++extern struct option_cache *free_option_caches;
++	free_option_caches=0L;
++extern  struct packet *free_packets;
++	free_packets=0L;
++extern  pair free_pairs;
++	free_pairs=0L;
++extern omapi_io_object_t omapi_io_states;
++        memset(&amp;omapi_io_states, '\0', sizeof(omapi_io_states));
++	dhcp_control_object=0L;
++	unlink(current_pid_file);
++#endif
+ 	/*NOTREACHED*/
+ 	return 0;
+ }
+@@ -1091,7 +1266,6 @@
+ 			picked = lp;
+ 			picked -&gt; next = (struct client_lease *)0;
+ 		} else {
+-		      freeit:
+ 			destroy_client_lease (lp);
+ 		}
+ 	}
+@@ -1149,7 +1323,6 @@
+ 	struct client_lease *lease;
+ 	struct option_cache *oc;
+ 	struct data_string ds;
+-	int i;
+ 	
+ 	/* If we're not receptive to an offer right now, or if the offer
+ 	   has an unrecognizable transaction id, then just drop it. */
+@@ -1294,15 +1467,30 @@
+ 	client -&gt; new -&gt; rebind += cur_time;
+ 	if (client -&gt; new -&gt; rebind &lt; cur_time)
+ 		client -&gt; new -&gt; rebind = TIME_MAX;
++#ifdef LIBDHCP
++	/* We need the server's siaddr for the 'bootServer'
++         * pump option 
++	 */
++	u_int32_t set_siaddr = 0;	
++
++	set_siaddr = client -&gt; packet.siaddr.s_addr ;
++	     
++	client-&gt;packet.siaddr.s_addr = packet-&gt;raw-&gt;siaddr.s_addr ;
++#endif
+ 
+ 	bind_lease (client);
++
++
++#ifdef LIBDHCP
++
++	client -&gt; packet.siaddr.s_addr = set_siaddr ;
++#endif
++	
+ }
+ 
+ void bind_lease (client)
+ 	struct client_state *client;
+ {
+-	struct interface_info *ip = client -&gt; interface;
+-
+ 	/* Remember the medium. */
+ 	client -&gt; new -&gt; medium = client -&gt; medium;
+ 
+@@ -1333,6 +1521,9 @@
+ 		return;
+ 	}
+ 
++#ifdef LIBDHCP
++	if ( libdhcp_control &amp;&amp; (libdhcp_control-&gt;capability &amp; DHCP_USE_LEASE_DATABASE))
++#endif
+ 	/* Write out the new lease. */
+ 	write_client_lease (client, client -&gt; new, 0, 0);
+ 
+@@ -1368,7 +1559,6 @@
+ 	void *cpp;
+ {
+ 	struct client_state *client = cpp;
+-	int i;
+ 	struct option_cache *oc;
+ 	struct data_string ds;
+ 
+@@ -1411,7 +1601,6 @@
+ 	void *cpp;
+ {
+ 	struct client_state *client = cpp;
+-	int i;
+ 
+ 	/* Cancel all timeouts. */
+ 	cancel_timeout (state_selecting, client);
+@@ -1434,13 +1623,13 @@
+ {
+ 	return 0;
+ }
+-
++#ifndef LIBDHCP
+ int write_lease (lease)
+ 	struct lease *lease;
+ {
+ 	return 0;
+ }
+-
++#endif
+ int write_host (host)
+ 	struct host_decl *host;
+ {
+@@ -1524,8 +1713,6 @@
+ 	int i;
+ 	int stop_selecting;
+ 	const char *name = packet -&gt; packet_type ? &quot;DHCPOFFER&quot; : &quot;BOOTREPLY&quot;;
+-	struct iaddrlist *ap;
+-	struct option_cache *oc;
+ 	char obuf [1024];
+ 	
+ #ifdef DEBUG_PACKET
+@@ -2013,6 +2200,10 @@
+ 	   tell the shell script that we failed to allocate an address,
+ 	   and try again later. */
+ 	if (onetry) {
++#ifdef LIBDHCP
++	    script_init (client, &quot;FAIL&quot;, (struct string_list *)0);
++	    return;
++#endif
+ 		if (!quiet)
+ 			log_info (&quot;Unable to obtain a lease on first try.%s&quot;,
+ 				  &quot;  Exiting.&quot;);
+@@ -2344,7 +2535,6 @@
+ 	struct client_lease *lease;
+ {
+ 	unsigned char discover = DHCPDISCOVER;
+-	int i;
+ 	struct option_state *options = (struct option_state *)0;
+ 
+ 	memset (&amp;client -&gt; packet, 0, sizeof (client -&gt; packet));
+@@ -2409,9 +2599,6 @@
+ 	struct client_lease *lease;
+ {
+ 	unsigned char request = DHCPREQUEST;
+-	int i, j;
+-	unsigned char *tmp, *digest;
+-	unsigned char *old_digest_loc;
+ 	struct option_cache *oc;
+ 
+ 	memset (&amp;client -&gt; packet, 0, sizeof (client -&gt; packet));
+@@ -2500,7 +2687,6 @@
+ 	struct client_lease *lease;
+ {
+ 	unsigned char decline = DHCPDECLINE;
+-	int i;
+ 	struct option_cache *oc;
+ 
+ 	struct option_state *options = (struct option_state *)0;
+@@ -2557,7 +2743,6 @@
+ 	struct client_lease *lease;
+ {
+ 	unsigned char request = DHCPRELEASE;
+-	int i;
+ 	struct option_cache *oc;
+ 
+ 	struct option_state *options = (struct option_state *)0;
+@@ -2614,8 +2799,6 @@
+ void destroy_client_lease (lease)
+ 	struct client_lease *lease;
+ {
+-	int i;
+-
+ 	if (lease -&gt; server_name)
+ 		dfree (lease -&gt; server_name, MDL);
+ 	if (lease -&gt; filename)
+@@ -2624,7 +2807,9 @@
+ 	free_client_lease (lease, MDL);
+ }
+ 
++#ifndef LIBDHCP
+ FILE *leaseFile;
++#endif
+ 
+ void rewrite_client_leases ()
+ {
+@@ -2678,8 +2863,6 @@
+ {
+ 	const char *name, *dot;
+ 	struct data_string ds;
+-	int status;
+-	struct client_state *client;
+ 
+ 	memset (&amp;ds, 0, sizeof ds);
+ 
+@@ -2710,9 +2893,7 @@
+ 	int i;
+ 	struct tm *t;
+ 	static int leases_written;
+-	struct option_cache *oc;
+ 	struct data_string ds;
+-	pair *hash;
+ 	int errors = 0;
+ 	char *s;
+ 
+@@ -2992,8 +3173,6 @@
+ 	int i;
+ 	struct data_string data;
+ 	struct option_cache *oc;
+-	pair *hash;
+-	char *s, *t;
+ 	struct envadd_state es;
+ 
+ 	es.client = client;
+@@ -3071,16 +3250,60 @@
+ int script_go (client)
+ 	struct client_state *client;
+ {
+-	int rval;
++    struct string_list *sp;
++
++#ifdef LIBDHCP
++    if ( libdhcp_control &amp;&amp; libdhcp_control-&gt;callback )
++    {
++	char *reason=&quot;&quot;;
++	for (sp = client-&gt;env; sp; sp = sp -&gt; next) 
++	    if( strncmp(sp-&gt;string, &quot;reason=&quot;, 7) == 0 )
++	    {
++		reason = sp-&gt;string + 7;
++		break;
++	    }
++	(*libdhcp_control-&gt;callback) 
++	(   libdhcp_control, 
++	     (strcmp(reason,&quot;NBI&quot;)==0)
++	     ? DHC4_NBI
++	     :(strcmp(reason,&quot;PREINIT&quot;)==0)
++	      ? DHC4_PREINIT
++	      :(strcmp(reason,&quot;BOUND&quot;)==0)
++	       ? DHC4_BOUND
++	       :(strcmp(reason,&quot;RENEW&quot;)==0)
++	        ? DHC4_RENEW
++	        :(strcmp(reason,&quot;REBOOT&quot;)==0)
++	         ? DHC4_REBOOT
++	         :(strcmp(reason,&quot;REBIND&quot;)==0)
++	          ? DHC4_REBIND
++	          :(strcmp(reason,&quot;STOP&quot;)==0)
++	           ? DHC4_STOP
++	           :(strcmp(reason,&quot;MEDIUM&quot;)==0)
++	            ? DHC4_MEDIUM
++	            :(strcmp(reason,&quot;TIMEOUT&quot;)==0)
++	             ? DHC4_TIMEOUT
++	             :(strcmp(reason,&quot;FAIL&quot;)==0)
++	              ? DHC4_FAIL
++	              :(strcmp(reason,&quot;EXPIRE&quot;)==0)
++	               ? DHC4_EXPIRE
++	               :(strcmp(reason,&quot;RELEASE&quot;)==0)
++			? DHC4_RELEASE
++	                : DHC4_NBI,	                
++	    client
++	);
++	if ( libdhcp_control-&gt;decline )
++	    return 1;
++    }
++    return 0;
++#else
+ 	char *scriptName;
+ 	char *argv [2];
+ 	char **envp;
+-	char *epp [3];
+ 	char reason [] = &quot;REASON=NBI&quot;;
+ 	static char client_path [] = CLIENT_PATH;
+ 	int i;
+-	struct string_list *sp, *next;
+ 	int pid, wpid, wstatus;
++	struct string_list *next;
+ 
+ 	if (client)
+ 		scriptName = client -&gt; config -&gt; script_name;
+@@ -3146,6 +3369,7 @@
+ 	GET_TIME (&amp;cur_time);
+ 	return (WIFEXITED (wstatus) ?
+ 		WEXITSTATUS (wstatus) : -WTERMSIG (wstatus));
++#endif
+ }
+ 
+ void client_envadd (struct client_state *client,
+@@ -3153,7 +3377,7 @@
+ {
+ 	char spbuf [1024];
+ 	char *s;
+-	unsigned len, i;
++	unsigned len;
+ 	struct string_list *val;
+ 	va_list list;
+ 
+@@ -3236,6 +3460,9 @@
+ 
+ 	/* Don't become a daemon if the user requested otherwise. */
+ 	if (no_daemon) {
++#ifdef LIBDHCP
++	    if ( libdhcp_control &amp;&amp; (libdhcp_control-&gt;capability &amp; DHCP_USE_PID_FILE ) )
++#endif
+ 		write_client_pid_file ();
+ 		return;
+ 	}
+@@ -3244,7 +3471,9 @@
+ 	if (state)
+ 		return;
+ 	state = 1;
+-
++#ifdef LIBDHCP
++	return;
++#endif
+ 	/* Stop logging to stderr... */
+ 	log_perror = 0;
+ 
+@@ -3588,7 +3817,7 @@
+ 
+ isc_result_t client_dns_update (struct client_state *client, int addp, int ttl)
+ {
+-	struct data_string ddns_fqdn, ddns_fwd_name,
++	struct data_string ddns_fwd_name,
+ 	       ddns_dhcid, client_identifier;
+ 	struct option_cache *oc;
+ 	int ignorep;
+--- dhcp-3.0.5/common/alloc.c.libdhcp4client	2006-11-29 10:50:20.000000000 -0500
++++ dhcp-3.0.5/common/alloc.c	2006-11-29 10:50:20.000000000 -0500
+@@ -48,7 +48,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int size;
+ 	struct option_chain_head *h;
+ 
+ 	if (!ptr) {
+@@ -109,7 +108,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int i;
+ 	struct option_chain_head *option_chain_head;
+ 	pair car, cdr;
+ 
+@@ -161,7 +159,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int size;
+ 	struct group *g;
+ 
+ 	if (!ptr) {
+@@ -222,7 +219,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int i;
+ 	struct group *group;
+ 
+ 	if (!ptr || !*ptr) {
+@@ -745,8 +741,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	struct buffer *bp;
+-
+ 	if (!ptr) {
+ 		log_error (&quot;%s(%d): null pointer&quot;, file, line);
+ #if defined (POINTER_DEBUG)
+@@ -834,8 +828,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	struct dns_host_entry *bp;
+-
+ 	if (!ptr || !*ptr) {
+ 		log_error (&quot;%s(%d): null pointer&quot;, file, line);
+ #if defined (POINTER_DEBUG)
+@@ -1016,9 +1008,11 @@
+ 	rc_register (file, line, ptr, bp, bp -&gt; refcnt, 0, RC_MISC);
+ 	return 1;
+ }
+-
++#ifdef LIBDHCP
++struct packet *free_packets;
++#else
+ static struct packet *free_packets;
+-
++#endif
+ #if defined (DEBUG_MEMORY_LEAKAGE) || \
+ 		defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
+ void relinquish_free_packets ()
+@@ -1037,7 +1031,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int size;
+ 	struct packet *p;
+ 
+ 	if (!ptr) {
+@@ -1157,7 +1150,6 @@
+ 	const char *file;
+ 	int line;
+ {
+-	int size;
+ 	struct dns_zone *d;
+ 
+ 	if (!ptr) {
+--- dhcp-3.0.5/common/discover.c.libdhcp4client	2006-11-29 10:50:20.000000000 -0500
++++ dhcp-3.0.5/common/discover.c	2006-11-29 10:50:20.000000000 -0500
+@@ -120,28 +120,30 @@
+    For each interface that's of type INET and not the loopback interface,
+    register that interface with the network I/O software, figure out what
+    subnet it's on, and add it to the list of interfaces. */
+-
++#ifdef LIBDHCP
++int have_setup_fallback = 0;
++#endif
+ void discover_interfaces (state)
+ 	int state;
+ {
+-	struct interface_info *tmp, *ip;
++	struct interface_info *tmp;
+ 	struct interface_info *last, *next;
+ 	char buf [2048];
+ 	struct ifconf ic;
+ 	struct ifreq ifr;
+ 	int i;
+ 	int sock;
+-	int address_count = 0;
+ 	struct subnet *subnet;
+-	struct shared_network *share;
+ 	struct sockaddr_in foo;
+ 	int ir;
+ 	struct ifreq *tif;
+ #ifdef ALIAS_NAMES_PERMUTED
+ 	char *s;
+ #endif
+-	isc_result_t status;
++#ifndef LIBDHCP
+ 	static int setup_fallback = 0;
++#endif
++	isc_result_t status;
+ 	int wifcount = 0;
+ 
+ 	/* Create an unbound datagram socket to do the SIOCGIFADDR ioctl on. */
+@@ -435,7 +437,6 @@
+ 	for (tmp = interfaces; tmp; tmp = tmp -&gt; next) {
+ 		struct ifreq ifr;
+ 		struct sockaddr sa;
+-		int b, sk;
+ 		
+ 		if (!tmp -&gt; ifp) {
+ 			/* Make up an ifreq structure. */
+@@ -694,12 +695,17 @@
+ 		log_info (&quot;%s&quot;, &quot;&quot;);
+ 		log_fatal (&quot;Not configured to listen on any interfaces!&quot;);
+ 	}
+-
++#ifdef LIBDHCP
++	if (!have_setup_fallback) {
++		have_setup_fallback = 1;
++		maybe_setup_fallback ();
++	}
++#else
+ 	if (!setup_fallback) {
+ 		setup_fallback = 1;
+ 		maybe_setup_fallback ();
+ 	}
+-
++#endif
+ #if defined (HAVE_SETFD)
+ 	if (fallback_interface) {
+ 	    if (fcntl (fallback_interface -&gt; rfdesc, F_SETFD, 1) &lt; 0)
+@@ -815,7 +821,6 @@
+ {
+ 	struct interface_info *interface;
+ 	isc_result_t status;
+-	int foo;
+ 
+ 	if (h -&gt; type != dhcp_type_interface)
+ 		return ISC_R_INVALIDARG;
+@@ -858,7 +863,6 @@
+ 					 const char *file, int line)
+ {
+ 	struct interface_info *interface;
+-	isc_result_t status;
+ 
+ 	if (h -&gt; type != dhcp_type_interface)
+ 		return ISC_R_INVALIDARG;
+@@ -888,8 +892,6 @@
+ 					    const char *name, va_list ap)
+ {
+ 	struct interface_info *ip, *interface;
+-	struct client_config *config;
+-	struct client_state *client;
+ 	isc_result_t status;
+ 
+ 	if (h -&gt; type != dhcp_type_interface)
+--- dhcp-3.0.5/common/lpf.c.libdhcp4client	2004-11-24 12:39:15.000000000 -0500
++++ dhcp-3.0.5/common/lpf.c	2006-11-29 10:50:20.000000000 -0500
+@@ -69,8 +69,6 @@
+ 	struct interface_info *info;
+ {
+ 	int sock;
+-	char filename[50];
+-	int b;
+ 	struct sockaddr sa;
+ 
+ 	/* Make an LPF socket. */
+@@ -216,6 +214,7 @@
+ 	struct interface_info *info;
+ {
+ 	struct sock_fprog p;
++	memset(&amp;p,'\0', sizeof(struct sock_fprog));
+ 
+ 	/* Set up the bpf filter program structure.    This is defined in
+ 	   bpf.c */
+@@ -334,7 +333,6 @@
+ 	struct sockaddr_in *from;
+ 	struct hardware *hfrom;
+ {
+-	int nread;
+ 	int length = 0;
+ 	int offset = 0;
+ 	unsigned char ibuf [1536];
+--- dhcp-3.0.5/dst/hmac_link.c.libdhcp4client	2001-02-22 02:22:08.000000000 -0500
++++ dhcp-3.0.5/dst/hmac_link.c	2006-11-29 10:50:20.000000000 -0500
+@@ -38,6 +38,10 @@
+ 
+ #include &quot;dst_internal.h&quot;
+ 
++#ifdef LIBDHCP
++extern void* dmalloc(size_t,char *,int);
++#endif
++
+ #ifdef USE_MD5
+ # include &quot;md5.h&quot;
+ # ifndef _MD5_H_
+@@ -86,7 +90,11 @@
+ 	MD5_CTX *ctx = NULL;
+ 
+ 	if (mode &amp; SIG_MODE_INIT) 
++#ifdef LIBDHCP
++		ctx = (MD5_CTX *) dmalloc(sizeof(*ctx),__FILE__,__LINE__);
++#else
+ 		ctx = (MD5_CTX *) malloc(sizeof(*ctx));
++#endif
+ 	else if (context)
+ 		ctx = (MD5_CTX *) *context;
+ 	if (ctx == NULL) 
+@@ -153,7 +161,11 @@
+ 	MD5_CTX *ctx = NULL;
+ 
+ 	if (mode &amp; SIG_MODE_INIT) 
+-		ctx = (MD5_CTX *) malloc(sizeof(*ctx));
++#ifdef LIBDHCP
++		ctx = (MD5_CTX *) dmalloc(sizeof(*ctx),__FILE__,__LINE__);
++#else
++	        ctx = (MD5_CTX *) malloc(sizeof(*ctx));
++#endif
+ 	else if (context)
+ 		ctx = (MD5_CTX *) *context;
+ 	if (ctx == NULL) 
+@@ -217,8 +229,11 @@
+ 
+ 	if (dkey == NULL || key == NULL || keylen &lt; 0)
+ 		return (-1);
+-
++#ifdef  LIBDHCP
++	if ((hkey = (HMAC_Key *) dmalloc(sizeof(HMAC_Key),__FILE__,__LINE__)) == NULL)
++#else
+ 	if ((hkey = (HMAC_Key *) malloc(sizeof(HMAC_Key))) == NULL)
++#endif
+ 		  return (-2);
+ 
+ 	memset(hkey-&gt;hk_ipad, 0, sizeof(hkey-&gt;hk_ipad));
+@@ -347,7 +362,11 @@
+ 	if (eol == NULL)
+ 		return (-4);
+ 	len = eol - p;
++#ifdef LIBDHCP
++	tmp = dmalloc(len + 2,__FILE__,__LINE__);
++#else
+ 	tmp = malloc(len + 2);
++#endif
+ 	memcpy(tmp, p, len);
+ 	*(tmp + len) = 0x0;
+ 	key_len = b64_pton((char *)tmp, key, HMAC_LEN+1);	/* see above */
+@@ -439,8 +458,11 @@
+ 		return(0);
+ 	
+ 	len = size &gt; 64 ? 64 : size;
++#ifdef LIBDHCP
++	buff = dmalloc(len+8,__FILE__,__LINE__);
++#else
+ 	buff = malloc(len+8);
+-
++#endif
+ 	n = dst_random(DST_RAND_SEMI, len, buff);
+ 	n += dst_random(DST_RAND_KEY, len, buff);
+ 	if (n &lt;= len) {	/* failed getting anything */
+@@ -463,7 +485,11 @@
+ {
+ 	if (dst_t_func[KEY_HMAC_MD5] != NULL)
+ 		return (1);
++#ifdef LIBDHCP
++	dst_t_func[KEY_HMAC_MD5] = dmalloc(sizeof(struct dst_func),__FILE__,__LINE__);
++#else
+ 	dst_t_func[KEY_HMAC_MD5] = malloc(sizeof(struct dst_func));
++#endif
+ 	if (dst_t_func[KEY_HMAC_MD5] == NULL)
+ 		return (0);
+ 	memset(dst_t_func[KEY_HMAC_MD5], 0, sizeof(struct dst_func));
+--- dhcp-3.0.5/omapip/alloc.c.libdhcp4client	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/alloc.c	2006-11-29 10:50:20.000000000 -0500
+@@ -40,6 +40,41 @@
+ 
+ #include &lt;omapip/omapip_p.h&gt;
+ 
++#ifdef LIBDHCP
++/* OK, we need a quick and dirty way of freeing all memory used by libdhcp. 
++   All pointers will be stored in a glibc tree on alloc, and removed on free.
++   This is not too expensive for light single-call library use.
++*/
++#include &lt;search.h&gt;  
++extern void tdestroy (void *root, void (*free_node)(void *nodep));
++static void *all_pointers=0L;
++static int ptr_comparator( const void *p1, const void *p2 )
++{
++    return
++	(  (p1 == p2) 
++	   ? 0
++	   :( (p1 &gt; p2)
++	      ? 1
++	      : -1
++	    )
++	);
++}
++static void record_pointer( void *ptr )
++{
++    tsearch(ptr, &amp;(all_pointers), ptr_comparator);
++}
++static void forget_pointer( void *ptr )
++{
++    tdelete(ptr, &amp;(all_pointers), ptr_comparator);
++}
++void omapi_free_all_pointers(void)
++{
++    if( all_pointers != 0L )
++	tdestroy(all_pointers, free);
++    all_pointers = 0L;
++}
++#endif
++
+ #if defined (DEBUG_MEMORY_LEAKAGE) || defined (DEBUG_MALLOC_POOL) || \
+ 		defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
+ struct dmalloc_preamble *dmalloc_list;
+@@ -66,7 +101,6 @@
+ {
+ 	unsigned char *foo;
+ 	unsigned len;
+-	int i;
+ 	VOIDPTR *bar;
+ #if defined (DEBUG_MEMORY_LEAKAGE) || defined (DEBUG_MALLOC_POOL) || \
+ 		defined (DEBUG_MEMORY_LEAKAGE_ON_EXIT)
+@@ -78,7 +112,9 @@
+ 		return (VOIDPTR)0;
+ 
+ 	foo = malloc(len);
+-
++#ifdef LIBDHCP
++	record_pointer(foo);
++#endif
+ 	if (!foo)
+ 		return (VOIDPTR)0;
+ 	bar = (VOIDPTR)(foo + DMDOFFSET);
+@@ -200,6 +236,9 @@
+ 		     0, (unsigned char *)ptr + DMDOFFSET, 0, 1, RC_MALLOC);
+ #endif
+ 	free (ptr);
++#ifdef LIBDHCP
++	forget_pointer(ptr);
++#endif
+ }
+ 
+ #if defined (DEBUG_MEMORY_LEAKAGE) || defined (DEBUG_MALLOC_POOL) || \
+--- dhcp-3.0.5/omapip/dispatch.c.libdhcp4client	2006-11-29 10:50:20.000000000 -0500
++++ dhcp-3.0.5/omapip/dispatch.c	2006-11-29 10:50:20.000000000 -0500
+@@ -34,7 +34,7 @@
+ 
+ #include &lt;omapip/omapip_p.h&gt;
+ 
+-static omapi_io_object_t omapi_io_states;
++omapi_io_object_t omapi_io_states;
+ TIME cur_time;
+ 
+ OMAPI_OBJECT_ALLOC (omapi_io,
+--- dhcp-3.0.5/omapip/errwarn.c.libdhcp4client	2006-11-29 10:50:20.000000000 -0500
++++ dhcp-3.0.5/omapip/errwarn.c	2006-11-29 10:50:20.000000000 -0500
+@@ -39,6 +39,11 @@
+ #include &lt;omapip/omapip_p.h&gt;
+ #include &lt;errno.h&gt;
+ 
++#ifdef LIBDHCP
++#include &lt;libdhcp_control.h&gt;
++extern LIBDHCP_Control *libdhcp_control;
++#endif
++
+ #ifdef DEBUG
+ int log_perror = -1;
+ #else
+@@ -50,7 +55,9 @@
+ void (*log_cleanup) (void);
+ 
+ #define CVT_BUF_MAX 1023
++#ifndef LIBDHCP
+ static char mbuf [CVT_BUF_MAX + 1];
++#endif
+ static char fbuf [CVT_BUF_MAX + 1];
+ 
+ /* Log an error message, then exit... */
+@@ -60,6 +67,17 @@
+   va_list list;
+ 
+   do_percentm (fbuf, fmt);
++  
++#ifdef LIBDHCP
++  if ( libdhcp_control &amp;&amp; (libdhcp_control-&gt;eh) )
++  {
++      va_start (list, fmt);
++      libdhcp_control-&gt;eh(libdhcp_control, LOG_FATAL, fbuf, list);
++      va_end(list);
++      libdhcp_control-&gt;finished = 1;
++      return;
++  }
++#else
+ 
+   /* %Audit% This is log output. %2004.06.17,Safe%
+    * If we truncate we hope the user can get a hint from the log.
+@@ -108,6 +126,7 @@
+   if (log_cleanup)
+ 	  (*log_cleanup) ();
+   exit (1);
++#endif
+ }
+ 
+ /* Log an error message... */
+@@ -118,6 +137,14 @@
+ 
+   do_percentm (fbuf, fmt);
+ 
++#ifdef LIBDHCP
++  if ( libdhcp_control &amp;&amp; libdhcp_control-&gt;eh )
++  {
++      va_start (list, fmt);
++      libdhcp_control-&gt;eh(libdhcp_control, LOG_ERR, fbuf, list);
++      va_end(list);
++  }
++#else
+   /* %Audit% This is log output. %2004.06.17,Safe%
+    * If we truncate we hope the user can get a hint from the log.
+    */
+@@ -134,7 +161,7 @@
+ 	  r=write (STDERR_FILENO, mbuf, strlen (mbuf));
+ 	  r=write (STDERR_FILENO, &quot;\n&quot;, 1);
+   }
+-
++#endif
+   return 0;
+ }
+ 
+@@ -146,6 +173,14 @@
+ 
+   do_percentm (fbuf, fmt);
+ 
++#ifdef LIBDHCP
++  if ( libdhcp_control &amp;&amp; libdhcp_control-&gt;eh )
++  {
++      va_start (list, fmt);
++      libdhcp_control-&gt;eh(libdhcp_control, LOG_INFO, fbuf, list);
++      va_end(list);
++  }
++#else
+   /* %Audit% This is log output. %2004.06.17,Safe%
+    * If we truncate we hope the user can get a hint from the log.
+    */
+@@ -162,7 +197,7 @@
+ 	  r=write (STDERR_FILENO, mbuf, strlen (mbuf));
+ 	  r=write (STDERR_FILENO, &quot;\n&quot;, 1);
+   }
+-
++#endif
+   return 0;
+ }
+ 
+@@ -173,7 +208,14 @@
+   va_list list;
+ 
+   do_percentm (fbuf, fmt);
+-
++#ifdef LIBDHCP
++  if ( libdhcp_control &amp;&amp; libdhcp_control-&gt;eh )
++  {
++      va_start (list, fmt);
++      libdhcp_control-&gt;eh(libdhcp_control, LOG_DEBUG, fbuf, list);
++      va_end(list);
++  }
++#else
+   /* %Audit% This is log output. %2004.06.17,Safe%
+    * If we truncate we hope the user can get a hint from the log.
+    */
+@@ -190,7 +232,7 @@
+ 	  r=write (STDERR_FILENO, mbuf, strlen (mbuf));
+ 	  r=write (STDERR_FILENO, &quot;\n&quot;, 1);
+   }
+-
++#endif
+   return 0;
+ }
+ 
+--- dhcp-3.0.5/configure.libdhcp4client	2004-09-10 17:02:30.000000000 -0400
++++ dhcp-3.0.5/configure	2006-11-29 10:50:20.000000000 -0500
+@@ -246,7 +246,7 @@
+ fi
+ 
+ if [ x&quot;$dirs&quot; = x ]; then
+-  dirs=&quot;. client server relay common omapip dhcpctl minires dst&quot;
++  dirs=&quot;. client server relay common omapip dhcpctl minires dst libdhcp4client&quot;
+ fi
+ 
+ for foo in $dirs; do
+--- /dev/null	2006-11-25 13:38:58.174646239 -0500
++++ dhcp-3.0.5/libdhcp4client/Makefile.dist	2006-11-29 10:51:12.000000000 -0500
+@@ -0,0 +1,104 @@
++# Makefile.dist for libdhcp4client
++#
++# We get the libdhcp4client library from the patched ISC source code.  We
++# rebuild key C files with -DLIBDHCP to turn on the library features we
++# need.  Normal build results in standard ISC code (i.e., not LIBDHCP
++# stuff enabled).  We then link together a static library and a shared
++# library with the new resulting objects.
++#
++# David Cantrell &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dcantrell at redhat.com</A>&gt;
++
++PROGS = libdhcp4client.a libdhcp4client.so.1
++HDRS  = dhcp4client.h libdhcp_control.h
++SRCS  = client_dhclient.c common_alloc.c common_discover.c dst_hmac_link.c \
++        omapip_alloc.c omapip_errwarn.c common_tables.c common_options.c \
++        common_dispatch.c common_tree.c omapip_hash.c omapip_dispatch.c \
++        omapip_support.c omapip_trace.c common_ctrace.c common_print.c \
++        common_socket.c common_inet.c omapip_auth.c omapip_buffer.c \
++        omapip_connection.c omapip_generic.c omapip_array.c omapip_listener.c \
++        omapip_message.c omapip_protocol.c omapip_toisc.c omapip_mrtrace.c \
++        client_clparse.c common_memory.c omapip_convert.c common_parse.c \
++        common_conflex.c common_bpf.c common_dlpi.c common_lpf.c common_nit.c \
++        common_upf.c common_packet.c common_dns.c common_comapi.c \
++        dst_dst_api.c dst_base64.c common_ethernet.c common_tr.c \
++        dst_dst_support.c common_execute.c omapip_result.c omapip_handle.c \
++        dst_prandom.c dst_md5_dgst.c
++
++OBJS     = $(SRCS:.c=.o)
++INCLUDES = -I$(TOP) -I$(TOP)/includes -I$(TOP)/dst -I.
++CFLAGS   = $(DEBUG) $(PREDEFINES) $(INCLUDES) $(COPTS) \
++           -DCLIENT_PATH=${CLIENT_PATH} -DLIBDHCP -DUSE_MD5
++
++all: $(PROGS)
++
++install: all
++	install -p -m 0755 -D libdhcp4client.so.1 $(DESTDIR)$(LIBDIR)/libdhcp4client.so.1
++	ln -sf libdhcp4client.so.1 $(DESTDIR)/$(LIBDIR)/libdhcp4client.so
++	install -p -m 0644 -D libdhcp4client.a $(DESTDIR)$(LIBDIR)/libdhcp4client.a
++	install -p -m 0644 -D dhcp4client.h $(DESTDIR)$(INCDIR)/dhcp4client/dhcp4client.h
++	install -p -m 0644 -D libdhcp_control.h $(DESTDIR)$(INCDIR)/dhcp4client/libdhcp_control.h
++	( cd $(TOP)/includes ; \
++	  find . -name &quot;*.h&quot; -type f | while read h ; do \
++	      install -p -m 0644 -D $$h $(DESTDIR)$(INCDIR)/dhcp4client/isc_dhcp/$$h ; \
++	  done ; \
++	)
++
++depend:
++	$(MKDEP) $(INCLUDES) $(PREDEFINES) $(SRCS)
++
++clean:
++	-rm -f $(OBJS)
++
++realclean: clean
++	-rm -f $(PROG) *~ #*
++
++distclean: realclean
++	-rm -f Makefile
++
++# This isn't the cleanest way to set up links, but I prefer this so I don't
++# need object targets for each subdirectory.  The idea is simple.  Since
++# libdhcp4client is a linked together wad of objects from across the source
++# tree, we change / to _ when linking source files here.  Follow this example:
++#
++# We need to use client/dhclient.c, so we make this link:
++#     rm -f client_dhclient.c
++#     ln -s $(TOP)/client/dhclient.c client_dhclient.c
++#
++# Simple.  Given the way the ISC build system works, this is the easiest to
++# maintain and least invasive.
++#
++# David Cantrell &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dcantrell at redhat.com</A>&gt;
++links:
++	@for target in $(SRCS); do \
++		source=&quot;`echo $$target | sed -e 's|_|/|'`&quot;; \
++		if [ ! -b $$target ]; then \
++			rm -f $$target; \
++		fi; \
++		ln -s $(TOP)/$$source $$target; \
++	done; \
++	for hdr in $(HDRS); do \
++		if [ ! -b $$hdr ]; then \
++			rm -f $$hdr; \
++		fi; \
++		ln -s $(TOP)/libdhcp4client/$$hdr $$hdr; \
++	done
++
++# minires is difficult to build because it overrides things in common and dst,
++# so we just link with the already built libres.a since we need it all anyway
++libres.a:
++	if [ ! -f ../minires/$@ ]; then \
++		$(MAKE) -C ../minires; \
++	fi; \
++	ln ../minires/libres.a .; \
++	$(AR) x libres.a
++
++# minires/res_query.o contains an undefined symbol __h_errno_set, is not
++# used by any dhcp code, and is optimized out by the linker when producing
++# the dhclient executable or a shared library
++libdhcp4client.a: $(OBJS) libres.a
++	$(AR) crus $@ $(OBJS) `$(AR) t libres.a | grep -v res_query.o`
++
++libdhcp4client.so.1: $(OBJS) libres.a
++	$(CC) -shared -o $@ -Wl,-soname,$@ $(OBJS) `$(AR) t libres.a | grep -v res_query.o`
++
++# Dependencies (semi-automatically-generated)
+--- /dev/null	2006-11-25 13:38:58.174646239 -0500
++++ dhcp-3.0.5/libdhcp4client/dhcp4client.h	2006-11-29 10:50:20.000000000 -0500
+@@ -0,0 +1,24 @@
++/* dhcp4client.h
++ *
++ *  Interface to the ISC dhcp IPv4 client libdhcp4client library.
++ *
++ *
++ *  Copyright(C) Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; Red Hat Inc. May 2006
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation at 
++ *           <A HREF="http://www.fsf.org/licensing/licenses/gpl.txt">http://www.fsf.org/licensing/licenses/gpl.txt</A>
++ *  and included in this software distribution as the &quot;LICENSE&quot; file.
++ *
++ *  This program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *  GNU General Public License for more details.
++ */
++
++struct libdhcp_control_s;  /* include libdhcp_control.h or libdhcp.h for this */
++
++extern int dhcpv4_client( struct libdhcp_control_s *dhc_ctl, int argc, char **argv, char **envp);
++    /* The ISC IPv4 DHCP client main() function .
++     */
+--- /dev/null	2006-11-25 13:38:58.174646239 -0500
++++ dhcp-3.0.5/libdhcp4client/libdhcp_control.h	2006-11-29 10:50:20.000000000 -0500
+@@ -0,0 +1,102 @@
++/* libdhcp_control.h
++ *
++ *  DHCP client control API for libdhcp, a minimal interface to the
++ *  ISC dhcp IPv4 client libdhcp4client library,
++ *  and to the dhcpv6 DHCPv6 client libdhcp6client library.
++ *
++ *  Each DHCP client library must include this file to be controlled
++ *  by libdhcp.
++ *
++ *  Copyright(C) Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; Red Hat Inc. May 2006
++ *
++ *  This program is free software; you can redistribute it and/or modify
++ *  it under the terms of the GNU General Public License as published by
++ *  the Free Software Foundation at 
++ *           <A HREF="http://www.fsf.org/licensing/licenses/gpl.txt">http://www.fsf.org/licensing/licenses/gpl.txt</A>
++ *  and included in this software distribution as the &quot;LICENSE&quot; file.
++ *
++ *  This program is distributed in the hope that it will be useful,
++ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *  GNU General Public License for more details.
++ */
++#ifndef LIBDHCP_CONTROL_H
++#define LIBDHCP_CONTROL_H
++
++#include &lt;stdint.h&gt;
++
++#define  LOG_FATAL 8
++
++typedef enum dhcp_state_e
++{
++
++    /* DHCPv4 client states - third callback arg will be a 'struct client_state *'    */
++    DHC4_NBI,         		/* failed: no broadcast interfaces found              */
++    DHC4_PREINIT, 		/* configuration started - bring the interface &quot;UP&quot;   */
++    DHC4_BOUND, 		/* lease obtained                                     */
++    DHC4_RENEW, 		/* lease renewed                                      */
++    DHC4_REBOOT,	        /* have valid lease, but now obtained a different one */
++    DHC4_REBIND, 		/* new, different lease                               */
++    DHC4_STOP,  		/* remove old lease                                   */
++    DHC4_MEDIUM, 		/* media selection begun                              */
++    DHC4_TIMEOUT, 		/* timed out contacting DHCP server                   */
++    DHC4_FAIL, 			/* all attempts to contact server timed out, sleeping */
++    DHC4_EXPIRE, 		/* lease has expired, renewing                        */
++    DHC4_RELEASE, 		/* releasing lease                                    */
++    /* This state raised by both clients: */
++    DHC_TIMEDOUT,               /* libdhcp_control timeout has been exceeded          */
++    /* DHCPv6 client states:    */
++    DHC6_BOUND,                 /* new lease obtained             - arg is optinfo *  */
++    DHC6_REBIND,                /* existing expired lease rebound - arg is optinfo *  */
++    DHC6_RELEASE                /* existing lease expired         - arg is dhcp6_iaidaddr*/
++} DHCP_State;
++
++struct libdhcp_control_s;
++
++typedef
++int ( *LIBDHCP_Error_Handler )
++    ( struct libdhcp_control_s *ctl,
++      int priority,  /* ala syslog(3): LOG_EMERG=0 - LOG_DEBUG=7 (+ LOG_FATAL=8 : finished -&gt; 1)   */
++      const char *fmt,
++      va_list ap
++    );
++
++typedef 
++int ( *LIBDHCP_Callback ) ( struct libdhcp_control_s *control, enum dhcp_state_e, void* );
++    /* The DHCP clients will call the users' callback on important state change events,
++     * with the second arg set to the client DHCP_State, and the third arg set to
++     * a client specific pointer as described below.
++     */
++
++typedef 
++struct libdhcp_control_s
++{
++    LIBDHCP_Callback    callback;    	/* the DHCP clients' main loop calls this on state changes */
++    uint16_t            capability;     /* LIBDHCP_Capability bits to enable                       */
++    uint8_t             finished;       /* set to one to make clients exit their main loop         */
++    uint8_t             decline;        /* set to one to decline the lease (DHCPv4 only)           */
++    time_t              timeout;        /* (timeout+now) == time after which clients MUST return   */
++    time_t              now;            /* clients set this to time(0) on entering main loop       */
++    void               *arg;            /* user data pointer                                       */
++    LIBDHCP_Error_Handler eh;
++} LIBDHCP_Control;
++
++typedef enum libdhcp_capability_e
++{/* DHCP client &quot;capabilities&quot; */ 
++    DHCP_USE_LEASE_DATABASE   = 1,  	/* use / do not use persistent lease database files */
++    DHCP_USE_PID_FILE         = 2,  	/* use / do not use pid file                        */
++ /*
++  * DHCPv6 supports these capabilities in process, 
++  * while the DHCPv4 client will fork and exec the dhclient-script to implement them if these
++  * bits are set - otherwise, if no bits are set, the callback is called and the script is 
++  * not run.
++  */
++    DHCP_CONFIGURE_INTERFACES = 4,  	/* configure interfaces UP/DOWN as required         */
++    DHCP_CONFIGURE_ADDRESSES  = 8,  	/* configure interface addresses as required        */
++    DHCP_CONFIGURE_ROUTES     =16,  	/* configure routes as required                     */
++    DHCP_CONFIGURE_RESOLVER   =32,  	/* configure resolv.conf as required                */
++    /* DHCPv6 only: */
++    DHCP_CONFIGURE_RADVD      =64,  	/* configure radvd.conf &amp; restart radvd as required */
++} LIBDHCP_Capability;
++
++#endif
+--- dhcp-3.0.5/Makefile.dist.libdhcp4client	2004-06-10 13:59:10.000000000 -0400
++++ dhcp-3.0.5/Makefile.dist	2006-11-29 10:50:20.000000000 -0500
+@@ -22,7 +22,7 @@
+ #   <A HREF="http://www.isc.org/">http://www.isc.org/</A>
+ 
+ 
+-SUBDIRS=	common $(MINIRES) dst omapip server client relay dhcpctl
++SUBDIRS=	common $(MINIRES) dst omapip server client relay dhcpctl libdhcp4client
+ 
+ all:
+ 	@for dir in ${SUBDIRS}; do \

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-minires.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-minires.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-minires.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,73 @@
+--- dhcp-3.0.5/includes/minires/minires.h.minires	2004-06-10 13:59:37.000000000 -0400
++++ dhcp-3.0.5/includes/minires/minires.h	2006-11-13 22:33:13.000000000 -0500
+@@ -65,7 +65,7 @@
+ #define res_protocolname MRres_protocolname
+ #define res_servicename MRres_servicename
+ #define ns_datetosecs MRns_datetosecs
+-#define b64_pton MRb64_pton
++/* #define b64_pton MRb64_pton */
+ #define res_ninit minires_ninit
+ #define res_randomid MRres_randomid
+ #define res_findzonecut MRres_findzonecut
+--- dhcp-3.0.5/minires/ns_name.c.minires	2004-06-10 13:59:40.000000000 -0400
++++ dhcp-3.0.5/minires/ns_name.c	2006-11-13 22:32:04.000000000 -0500
+@@ -71,6 +71,11 @@
+ 	dn = dst;
+ 	eom = dst + dstsiz;
+ 
++	if (dn &gt;= eom) {
++ 		errno = EMSGSIZE;
++ 		return (-1);
++ 	}
++
+ 	while ((n = *cp++) != 0) {
+ 		if ((n &amp; NS_CMPRSFLGS) != 0) {
+ 			/* Some kind of compression pointer. */
+--- dhcp-3.0.5/minires/res_update.c.minires	2004-06-10 13:59:44.000000000 -0400
++++ dhcp-3.0.5/minires/res_update.c	2006-11-13 22:32:04.000000000 -0500
+@@ -172,7 +172,7 @@
+ 	if (rcode != ISC_R_SUCCESS)
+ 		goto undone;
+ 
+-	rcode = ns_rcode_to_isc (((HEADER *)answer)-&gt;rcode);
++	rcode = ns_rcode_to_isc (((HEADER *)(void*)answer)-&gt;rcode);
+ 	if (zcookie &amp;&amp; rcode == ISC_R_BADSIG) {
+ 		repudiate_zone (&amp;zcookie);
+ 	}
+--- dhcp-3.0.5/minires/res_mkupdate.c.minires	2004-06-10 13:59:43.000000000 -0400
++++ dhcp-3.0.5/minires/res_mkupdate.c	2006-11-13 22:32:04.000000000 -0500
+@@ -49,6 +49,10 @@
+ #include &quot;minires/minires.h&quot;
+ #include &quot;arpa/nameser.h&quot;
+ 
++/* prototypes */
++extern int b64_pton(char const *src, u_char *target, size_t targsize);
++int dn_comp(const char *src, u_char *dst, unsigned dstsiz, u_char **dnptrs, u_char **lastdnptr);
++
+ /* Options.  Leave them on. */
+ #define DEBUG
+ #define MAXPORT 1024
+--- dhcp-3.0.5/minires/res_comp.c.minires	2004-06-10 13:59:42.000000000 -0400
++++ dhcp-3.0.5/minires/res_comp.c	2006-11-13 22:32:04.000000000 -0500
+@@ -91,6 +91,11 @@
+ #include &quot;minires/minires.h&quot;
+ #include &quot;arpa/nameser.h&quot;
+ 
++/* Prototypes */
++int ns_name_uncompress(const u_char *msg, const u_char *eom, const u_char *src, char *dst, size_t dstsiz);
++int ns_name_compress(const char *src, u_char *dst, size_t dstsiz, const u_char **dnptrs, const u_char **lastdnptr);
++int ns_name_skip(const u_char **ptrptr, const u_char *eom);
++
+ /*
+  * Expand compressed domain name 'comp_dn' to full domain name.
+  * 'msg' is a pointer to the begining of the message,
+--- dhcp-3.0.5/minires/res_init.c.minires	2004-06-10 13:59:43.000000000 -0400
++++ dhcp-3.0.5/minires/res_init.c	2006-11-13 22:32:04.000000000 -0500
+@@ -102,6 +102,7 @@
+ #define DEBUG
+ 
+ static void res_setoptions (res_state, const char *, const char *);
++u_int res_randomid(void);
+ 
+ #ifdef RESOLVSORT
+ static const char sort_mask[] = &quot;/&amp;&quot;;

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-omapip.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-omapip.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-omapip.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,234 @@
+--- dhcp-3.0.5/omapip/connection.c.omapip	2004-11-24 12:39:17.000000000 -0500
++++ dhcp-3.0.5/omapip/connection.c	2006-11-10 11:54:45.000000000 -0500
+@@ -174,7 +174,7 @@
+ 			
+ 			if (bind (obj -&gt; socket, (struct sockaddr *)&amp;local_sin,
+ 				  sizeof local_sin) &lt; 0) {
+-				omapi_object_dereference ((omapi_object_t **)
++				omapi_object_dereference ((void*)
+ 							  &amp;obj, MDL);
+ 				if (errno == EADDRINUSE)
+ 					return ISC_R_ADDRINUSE;
+--- dhcp-3.0.5/omapip/dispatch.c.omapip	2004-11-24 12:39:17.000000000 -0500
++++ dhcp-3.0.5/omapip/dispatch.c	2006-11-10 11:54:45.000000000 -0500
+@@ -139,7 +139,7 @@
+ 
+ isc_result_t omapi_dispatch (struct timeval *t)
+ {
+-	return omapi_wait_for_completion ((omapi_object_t *)&amp;omapi_io_states,
++	return omapi_wait_for_completion ((void *)&amp;omapi_io_states,
+ 					  t);
+ }
+ 
+@@ -449,7 +449,7 @@
+ 						     tmp, MDL);
+ 					else
+ 						omapi_signal_in
+-							((omapi_object_t *)
++							((void *)
+ 							 &amp;omapi_io_states,
+ 							 &quot;ready&quot;);
+ 				}
+--- dhcp-3.0.5/omapip/errwarn.c.omapip	2004-09-30 16:38:32.000000000 -0400
++++ dhcp-3.0.5/omapip/errwarn.c	2006-11-10 11:54:45.000000000 -0500
+@@ -45,6 +45,8 @@
+ int log_perror = 1;
+ #endif
+ int log_priority;
++int log_isc_blurb=1;
++
+ void (*log_cleanup) (void);
+ 
+ #define CVT_BUF_MAX 1023
+@@ -72,11 +74,14 @@
+ 
+   /* Also log it to stderr? */
+   if (log_perror) {
+-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+-	  write (STDERR_FILENO, &quot;\n&quot;, 1);
++	  int r;
++	  r=write (STDERR_FILENO, mbuf, strlen (mbuf));
++	  r=write (STDERR_FILENO, &quot;\n&quot;, 1);
+   }
+ 
+-#if !defined (NOMINUM)
++#if !defined(NOMINUM)
++  if ( log_isc_blurb )
++  {
+   log_error (&quot;%s&quot;, &quot;&quot;);
+   log_error (&quot;If you did not get this software from ftp.isc.org, please&quot;);
+   log_error (&quot;get the latest from ftp.isc.org and install that before&quot;);
+@@ -94,7 +99,12 @@
+   log_error (&quot;the README file.&quot;);
+   log_error (&quot;%s&quot;, &quot;&quot;);
+   log_error (&quot;exiting.&quot;);
++  }else
++  {
++      log_error (&quot;exiting.&quot;);
++  }
+ #endif
++
+   if (log_cleanup)
+ 	  (*log_cleanup) ();
+   exit (1);
+@@ -120,8 +130,9 @@
+ #endif
+ 
+   if (log_perror) {
+-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+-	  write (STDERR_FILENO, &quot;\n&quot;, 1);
++	  int r;
++	  r=write (STDERR_FILENO, mbuf, strlen (mbuf));
++	  r=write (STDERR_FILENO, &quot;\n&quot;, 1);
+   }
+ 
+   return 0;
+@@ -147,8 +158,9 @@
+ #endif
+ 
+   if (log_perror) {
+-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+-	  write (STDERR_FILENO, &quot;\n&quot;, 1);
++	  int r;
++	  r=write (STDERR_FILENO, mbuf, strlen (mbuf));
++	  r=write (STDERR_FILENO, &quot;\n&quot;, 1);
+   }
+ 
+   return 0;
+@@ -174,8 +186,9 @@
+ #endif
+ 
+   if (log_perror) {
+-	  write (STDERR_FILENO, mbuf, strlen (mbuf));
+-	  write (STDERR_FILENO, &quot;\n&quot;, 1);
++	  int r;
++	  r=write (STDERR_FILENO, mbuf, strlen (mbuf));
++	  r=write (STDERR_FILENO, &quot;\n&quot;, 1);
+   }
+ 
+   return 0;
+--- dhcp-3.0.5/omapip/message.c.omapip	2004-11-24 12:39:17.000000000 -0500
++++ dhcp-3.0.5/omapip/message.c	2006-11-10 11:54:45.000000000 -0500
+@@ -58,7 +58,7 @@
+ 	}
+ 	status = omapi_object_reference (&amp;m -&gt; inner, g, file, line);
+ 	if (status != ISC_R_SUCCESS) {
+-		omapi_object_dereference ((omapi_object_t **)&amp;m, file, line);
++		omapi_object_dereference ((void*)&amp;m, file, line);
+ 		omapi_object_dereference (&amp;g, file, line);
+ 		return status;
+ 	}
+@@ -66,7 +66,7 @@
+ 					 (omapi_object_t *)m, file, line);
+ 
+ 	if (status != ISC_R_SUCCESS) {
+-		omapi_object_dereference ((omapi_object_t **)&amp;m, file, line);
++		omapi_object_dereference ((void*)&amp;m, file, line);
+ 		omapi_object_dereference (&amp;g, file, line);
+ 		return status;
+ 	}
+@@ -286,16 +286,16 @@
+ 
+ 	if (omapi_registered_messages) {
+ 		omapi_object_reference
+-			((omapi_object_t **)&amp;m -&gt; next,
++			((void*)&amp;m -&gt; next,
+ 			 (omapi_object_t *)omapi_registered_messages, MDL);
+ 		omapi_object_reference
+-			((omapi_object_t **)&amp;omapi_registered_messages -&gt; prev,
++			((void*)&amp;omapi_registered_messages -&gt; prev,
+ 			 (omapi_object_t *)m, MDL);
+ 		omapi_object_dereference
+-			((omapi_object_t **)&amp;omapi_registered_messages, MDL);
++			((void*)&amp;omapi_registered_messages, MDL);
+ 	}
+ 	omapi_object_reference
+-		((omapi_object_t **)&amp;omapi_registered_messages,
++		((void*)&amp;omapi_registered_messages,
+ 		 (omapi_object_t *)m, MDL);
+ 	return ISC_R_SUCCESS;;
+ }
+@@ -315,34 +315,34 @@
+ 
+ 	n = (omapi_message_object_t *)0;
+ 	if (m -&gt; next) {
+-		omapi_object_reference ((omapi_object_t **)&amp;n,
++		omapi_object_reference ((void*)&amp;n,
+ 					(omapi_object_t *)m -&gt; next, MDL);
+-		omapi_object_dereference ((omapi_object_t **)&amp;m -&gt; next, MDL);
+-		omapi_object_dereference ((omapi_object_t **)&amp;n -&gt; prev, MDL);
++		omapi_object_dereference ((void*)&amp;m -&gt; next, MDL);
++		omapi_object_dereference ((void*)&amp;n -&gt; prev, MDL);
+ 	}
+ 	if (m -&gt; prev) {
+ 		omapi_message_object_t *tmp = (omapi_message_object_t *)0;
+-		omapi_object_reference ((omapi_object_t **)&amp;tmp,
++		omapi_object_reference ((void*)&amp;tmp,
+ 					(omapi_object_t *)m -&gt; prev, MDL);
+-		omapi_object_dereference ((omapi_object_t **)&amp;m -&gt; prev, MDL);
++		omapi_object_dereference ((void*)&amp;m -&gt; prev, MDL);
+ 		if (tmp -&gt; next)
+ 			omapi_object_dereference
+-				((omapi_object_t **)&amp;tmp -&gt; next, MDL);
++				((void*)&amp;tmp -&gt; next, MDL);
+ 		if (n)
+ 			omapi_object_reference
+-				((omapi_object_t **)&amp;tmp -&gt; next,
++				((void*)&amp;tmp -&gt; next,
+ 				 (omapi_object_t *)n, MDL);
+-		omapi_object_dereference ((omapi_object_t **)&amp;tmp, MDL);
++		omapi_object_dereference ((void*)&amp;tmp, MDL);
+ 	} else {
+ 		omapi_object_dereference
+-			((omapi_object_t **)&amp;omapi_registered_messages, MDL);
++			((void*)&amp;omapi_registered_messages, MDL);
+ 		if (n)
+ 			omapi_object_reference
+-				((omapi_object_t **)&amp;omapi_registered_messages,
++				((void*)&amp;omapi_registered_messages,
+ 				 (omapi_object_t *)n, MDL);
+ 	}
+ 	if (n)
+-		omapi_object_dereference ((omapi_object_t **)&amp;n, MDL);
++		omapi_object_dereference ((void*)&amp;n, MDL);
+ 	return ISC_R_SUCCESS;
+ }
+ 
+--- dhcp-3.0.5/omapip/protocol.c.omapip	2006-02-22 17:43:27.000000000 -0500
++++ dhcp-3.0.5/omapip/protocol.c	2006-11-10 11:54:45.000000000 -0500
+@@ -498,7 +498,7 @@
+ 		}
+ 		previous_outstanding = dmalloc_outstanding;
+ #endif
+-		status = omapi_message_new ((omapi_object_t **)&amp;p -&gt; message,
++		status = omapi_message_new ((void*)&amp;p -&gt; message,
+ 					    MDL);
+ 		if (status != ISC_R_SUCCESS) {
+ 			omapi_disconnect (c, 1);
+@@ -1151,7 +1151,7 @@
+ 	if (po -&gt; type != omapi_type_protocol)
+ 		return ISC_R_INVALIDARG;
+ 
+-	status = omapi_message_new ((omapi_object_t **)&amp;message, MDL);
++	status = omapi_message_new ((void*)&amp;message, MDL);
+ 	if (status != ISC_R_SUCCESS)
+ 		return status;
+ 	mo = (omapi_object_t *)message;
+@@ -1209,7 +1209,7 @@
+ 	if (po -&gt; type != omapi_type_protocol)
+ 		return ISC_R_INVALIDARG;
+ 
+-	status = omapi_message_new ((omapi_object_t **)&amp;message, MDL);
++	status = omapi_message_new ((void*)&amp;message, MDL);
+ 	mo = (omapi_object_t *)message;
+ 
+ 	if (status == ISC_R_SUCCESS)
+@@ -1268,7 +1268,7 @@
+ 	if (po -&gt; type != omapi_type_protocol)
+ 		return ISC_R_INVALIDARG;
+ 
+-	status = omapi_message_new ((omapi_object_t **)&amp;message, MDL);
++	status = omapi_message_new ((void*)&amp;message, MDL);
+ 	if (status != ISC_R_SUCCESS)
+ 		return status;
+ 	mo = (omapi_object_t *)message;

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-server.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-server.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-server.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,213 @@
+--- dhcp-3.0.5/server/bootp.c.server	2005-05-18 15:54:17.000000000 -0400
++++ dhcp-3.0.5/server/bootp.c	2006-11-10 11:56:36.000000000 -0500
+@@ -62,6 +62,7 @@
+ 	char msgbuf [1024];
+ 	int ignorep;
+ 	int peer_has_leases = 0;
++	int norelay = 0;
+ 
+ 	if (packet -&gt; raw -&gt; op != BOOTREQUEST)
+ 		return;
+@@ -77,7 +78,7 @@
+ 		 ? inet_ntoa (packet -&gt; raw -&gt; giaddr)
+ 		 : packet -&gt; interface -&gt; name);
+ 
+-	if (!locate_network (packet)) {
++	if ((norelay = locate_network (packet)) == 0) {
+ 		log_info (&quot;%s: network unknown&quot;, msgbuf);
+ 		return;
+ 	}
+@@ -357,6 +358,16 @@
+ 					      from, &amp;to, &amp;hto);
+ 			goto out;
+ 		}
++	} else if (norelay == 2) {
++		to.sin_addr = raw.ciaddr;
++		to.sin_port = remote_port;
++		if (fallback_interface) {
++			result = send_packet (fallback_interface,
++					      (struct packet *)0,
++					      &amp;raw, outgoing.packet_length,
++					      from, &amp;to, &amp;hto);
++			goto out;                
++		}
+ 
+ 	/* If it comes from a client that already knows its address
+ 	   and is not requesting a broadcast response, and we can
+--- dhcp-3.0.5/server/confpars.c.server	2006-07-20 12:02:52.000000000 -0400
++++ dhcp-3.0.5/server/confpars.c	2006-11-10 11:56:38.000000000 -0500
+@@ -992,10 +992,17 @@
+ 		parse_warn (cfile, &quot;peer address may not be omitted&quot;);
+ 
+ 	/* XXX - when/if we get a port number assigned, just set as default */
++	/* See Red Hat Bugzilla 167292:
++	 * we do now:  dhcp-failover 647/tcp
++         *             dhcp-failover 647/udp
++         *             dhcp-failover 847/tcp
++         *             dhcp-failover 847/udp
++         * IANA registration by Bernard Volz&lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">volz at cisco.com</A> 
++         */
+ 	if (!peer -&gt; me.port)
+-		parse_warn (cfile, &quot;local port may not be omitted&quot;);
++	    peer -&gt; me.port = 647;
+ 	if (!peer -&gt; partner.port)
+-		parse_warn (cfile, &quot;peer port may not be omitted&quot;);
++	    peer -&gt; partner.port = 847;
+ 
+ 	if (peer -&gt; i_am == primary) {
+ 	    if (!peer -&gt; hba) {
+@@ -2909,7 +2916,7 @@
+ 				 *p; p = &amp;((*p) -&gt; cdr))
+ 				    ;
+ 			    *p = cons (0, 0);
+-			    option_cache_reference (((struct option_cache **)
++			    option_cache_reference (((void*)
+ 						     &amp;((*p) -&gt; car)), oc, MDL);
+ 			    option_cache_dereference (&amp;oc, MDL);
+ 			}
+--- dhcp-3.0.5/server/dhcp.c.server	2006-08-22 13:15:56.000000000 -0400
++++ dhcp-3.0.5/server/dhcp.c	2006-11-10 11:56:41.000000000 -0500
+@@ -3828,6 +3828,7 @@
+ 	struct data_string data;
+ 	struct subnet *subnet = (struct subnet *)0;
+ 	struct option_cache *oc;
++	int norelay = 0;
+ 
+ 	/* See if there's a subnet selection option. */
+ 	oc = lookup_option (&amp;dhcp_universe, packet -&gt; options,
+@@ -3837,12 +3838,27 @@
+ 	   from the interface, if there is one.   If not, fail. */
+ 	if (!oc &amp;&amp; !packet -&gt; raw -&gt; giaddr.s_addr) {
+ 		if (packet -&gt; interface -&gt; shared_network) {
+-			shared_network_reference
+-				(&amp;packet -&gt; shared_network,
+-				 packet -&gt; interface -&gt; shared_network, MDL);
+-			return 1;
+-		}
+-		return 0;
++			struct in_addr any_addr;
++			any_addr.s_addr = INADDR_ANY;
++			if (!packet -&gt; packet_type &amp;&amp;
++			    memcmp(&amp;packet -&gt; raw -&gt; ciaddr, &amp;any_addr, 4)) {
++				struct iaddr cip;
++				memcpy(cip.iabuf, &amp;packet -&gt; raw -&gt; ciaddr, 4);
++				cip.len = 4;
++				if (!find_grouped_subnet(&amp;subnet,
++				    packet -&gt; interface -&gt; shared_network, 
++				    cip, MDL)) 
++					norelay = 2;
++			}
++			if (!norelay) {
++				shared_network_reference
++					(&amp;packet -&gt; shared_network,
++					 packet -&gt; interface -&gt; shared_network,
++					 MDL);
++				return 1;
++			}
++		} else
++			return 0;
+ 	}
+ 
+ 	/* If there's an SSO, and it's valid, use it to figure out the
+@@ -3864,7 +3880,10 @@
+ 		data_string_forget (&amp;data, MDL);
+ 	} else {
+ 		ia.len = 4;
+-		memcpy (ia.iabuf, &amp;packet -&gt; raw -&gt; giaddr, 4);
++		if (norelay)
++			memcpy (ia.iabuf, &amp;packet -&gt; raw -&gt; ciaddr, 4);
++		else
++			memcpy (ia.iabuf, &amp;packet -&gt; raw -&gt; giaddr, 4);
+ 	}
+ 
+ 	/* If we know the subnet on which the IP address lives, use it. */
+@@ -3872,7 +3891,10 @@
+ 		shared_network_reference (&amp;packet -&gt; shared_network,
+ 					  subnet -&gt; shared_network, MDL);
+ 		subnet_dereference (&amp;subnet, MDL);
+-		return 1;
++		if (norelay)
++			return norelay;
++		else
++			return 1;
+ 	}
+ 
+ 	/* Otherwise, fail. */
+--- dhcp-3.0.5/server/dhcpd.c.server	2006-07-17 11:23:44.000000000 -0400
++++ dhcp-3.0.5/server/dhcpd.c	2006-11-10 11:56:44.000000000 -0500
+@@ -551,7 +551,8 @@
+ 				if ((i = open (path_dhcpd_pid,
+ 					O_WRONLY | O_CREAT, 0644)) &gt;= 0) {
+ 				    sprintf (pbuf, &quot;%d\n&quot;, (int)getpid ());
+-				    write (i, pbuf, strlen (pbuf));
++				    if((status = write (i, pbuf, strlen (pbuf))) != strlen(pbuf))
++					log_fatal(&quot;Unable to write %s&quot;,path_dhcpd_pid);
+ 				    close (i);
+ 				    pidfilewritten = 1;
+ 				}
+@@ -584,7 +585,8 @@
+ 		if ((i = open (path_dhcpd_pid,
+ 			       O_WRONLY | O_CREAT, 0644)) &gt;= 0) {
+ 			sprintf (pbuf, &quot;%d\n&quot;, (int)getpid ());
+-			write (i, pbuf, strlen (pbuf));
++			if((status = write (i, pbuf, strlen (pbuf))) != strlen(pbuf))
++			    log_fatal(&quot;Unable to write %s&quot;,path_dhcpd_pid);
+ 			close (i);
+ 			pidfilewritten = 1;
+ 		}
+--- dhcp-3.0.5/server/dhcpd.conf.5.server	2006-07-09 11:02:24.000000000 -0400
++++ dhcp-3.0.5/server/dhcpd.conf.5	2006-11-10 11:56:46.000000000 -0500
+@@ -531,9 +531,9 @@
+ failover peer &quot;foo&quot; {
+   primary;
+   address anthrax.rc.vix.com;
+-  port 519;
++  port 647;
+   peer address trantor.rc.vix.com;
+-  peer port 520;
++  peer port 847;
+   max-response-delay 60;
+   max-unacked-updates 10;
+   mclt 3600;
+@@ -592,9 +592,7 @@
+ .B port \fIport-number\fR\fB;\fR
+ .PP
+ The \fBport\fR statement declares the TCP port on which the server
+-should listen for connections from its failover peer.   This statement
+-may not currently be omitted, because the failover protocol does not
+-yet have a reserved TCP port number.
++should listen for connections from its failover peer.  
+ .RE
+ .PP
+ The 
+@@ -606,10 +604,8 @@
+ .PP
+ The \fBpeer port\fR statement declares the TCP port to which the
+ server should connect to reach its failover peer for failover
+-messages.   This statement may not be omitted because the failover
+-protocol does not yet have a reserved TCP port number.   The port
+-number declared in the \fBpeer port\fR statement may be the same as
+-the port number declared in the \fBport\fR statement.
++messages. The port number declared in the \fBpeer port\fR statement 
++may be the same as the port number declared in the \fBport\fR statement.
+ .RE
+ .PP
+ The 
+@@ -1133,7 +1129,7 @@
+ .PP
+ .nf
+ key DHCP_UPDATER {
+-  algorithm HMAC-MD5.SIG-ALG.REG.INT;
++  algorithm hmac-md5;
+   secret pRP5FapFoJ95JEL06sv4PQ==;
+ };
+ 
+@@ -1156,7 +1152,7 @@
+ .PP
+ .nf
+ key DHCP_UPDATER {
+-  algorithm HMAC-MD5.SIG-ALG.REG.INT;
++  algorithm hmac-md5;
+   secret pRP5FapFoJ95JEL06sv4PQ==;
+ };
+ 

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-timeouts.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-timeouts.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-timeouts.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,295 @@
+--- dhcp-3.0.5/common/dispatch.c.timeouts	2006-11-13 19:08:34.000000000 -0500
++++ dhcp-3.0.5/common/dispatch.c	2006-11-13 19:15:03.000000000 -0500
+@@ -39,8 +39,24 @@
+ 
+ #include &quot;dhcpd.h&quot;
+ 
+-struct timeout *timeouts;
+-static struct timeout *free_timeouts;
++struct timeout {
++#ifndef LIBDHCP
++	struct timeout *next;
++#endif
++	TIME when;
++	void (*func) PROTO ((void *));
++	void *what;
++	tvref_t ref;
++	tvunref_t unref;
++};
++
++#ifdef LIBDHCP
++static struct timeout *timeouts = NULL;
++static int ntimeouts = 0;
++#else
++static struct timeout *timeouts = NULL;
++static struct timeout *free_timeouts = NULL;
++#endif
+ 
+ void set_time(TIME t)
+ {
+@@ -53,9 +69,41 @@
+ 
+ struct timeval *process_outstanding_timeouts (struct timeval *tvp)
+ {
++#ifdef LIBDHCP
++	int i;
++	struct timeout t = { 0 };
++#endif
+ 	/* Call any expired timeouts, and then if there's
+ 	   still a timeout registered, time out the select
+ 	   call then. */
++#ifdef LIBDHCP
++	if (!ntimeouts)
++		return NULL;
++
++	for (i = 0; i &lt; ntimeouts &amp;&amp; timeouts[i].when &lt;= cur_time;) {
++		struct timeout *new_timeouts;
++		size_t n;
++
++		memmove(&amp;t, &amp;timeouts[i], sizeof (t));
++
++		n = (ntimeouts - i - 1) * sizeof (t);
++		memmove(&amp;timeouts[i+1], &amp;timeouts[i], n);
++
++		n = --ntimeouts * sizeof (t);
++		new_timeouts = realloc(timeouts, n);
++		/* XXX broken API, no way to return error here */
++		if (new_timeouts || !n)
++			timeouts = new_timeouts;
++
++		if (t.func)
++			t.func(t.what);
++		if (t.unref)
++			t.unref(t.what, MDL);
++	}
++	if (tvp &amp;&amp; ntimeouts) {
++		tvp-&gt;tv_sec = timeouts[0].when;
++		tvp-&gt;tv_usec = 0;
++#else
+       another:
+ 	if (timeouts) {
+ 		struct timeout *t;
+@@ -73,9 +121,15 @@
+ 			tvp -&gt; tv_sec = timeouts -&gt; when;
+ 			tvp -&gt; tv_usec = 0;
+ 		}
++#endif
+ 		return tvp;
++#ifdef LIBDHCP
++	}
++	return NULL;
++#else
+ 	} else
+ 		return (struct timeval *)0;
++#endif
+ }
+ 
+ /* Wait for packets to come in using select().   When one does, call
+@@ -104,13 +158,28 @@
+ 	tvref_t ref;
+ 	tvunref_t unref;
+ {
++#ifdef LIBDHCP
++	struct timeout t = {
++		.when = when,
++		.func = where,
++		.what = what,
++		.ref = ref,
++		.unref = unref
++	};
++	struct timeout *new_timeouts;
++	int i, pos = 0;
++#else
+ 	struct timeout *t, *q;
++#endif
+ 
+ 	/* See if this timeout supersedes an existing timeout. */
++#ifdef LIBDHCP
++	for (i = 0; i &lt; ntimeouts; i++) {
++		struct timeout *q = &amp;timeouts[i];
++#else
+ 	t = (struct timeout *)0;
+ 	for (q = timeouts; q; q = q -&gt; next) {
+-		if ((where == NULL || q -&gt; func == where) &amp;&amp;
+-		    q -&gt; what == what) {
++		if ((where == NULL || q -&gt; func == where) &amp;&amp; q -&gt; what == what) {
+ 			if (t)
+ 				t -&gt; next = q -&gt; next;
+ 			else
+@@ -119,7 +188,29 @@
+ 		}
+ 		t = q;
+ 	}
++#endif
+ 
++#ifdef LIBDHCP
++		/* If this one is already in the list with a different time,
++		 * remove it and re-add */
++		if ((where == NULL || q-&gt;func == where) &amp;&amp;
++				q-&gt;what == what) {
++			size_t n = (--ntimeouts - i) * sizeof (*q);
++			memmove(&amp;t, q, sizeof (t));
++
++			if (n)
++				memmove(&amp;timeouts[i], &amp;timeouts[i+1], n);
++
++			if (ntimeouts) {
++				new_timeouts = realloc(timeouts, ntimeouts * sizeof (*q));
++				/* XXX broken API, no way to return error here */
++				if (new_timeouts)
++					timeouts = new_timeouts;
++			} else {
++				timeouts = NULL;
++			}
++			add_timeout(when, where, what, ref, unref);
++#else
+ 	/* If we didn't supersede a timeout, allocate a timeout
+ 	   structure now. */
+ 	if (!q) {
+@@ -128,7 +219,7 @@
+ 			free_timeouts = q -&gt; next;
+ 		} else {
+ 			q = ((struct timeout *)
+-			     dmalloc (sizeof (struct timeout), MDL));
++				dmalloc (sizeof (struct timeout), MDL));
+ 			if (!q)
+ 				log_fatal (&quot;add_timeout: no memory!&quot;);
+ 		}
+@@ -158,22 +249,76 @@
+ 		if (t -&gt; next -&gt; when &gt; q -&gt; when) {
+ 			q -&gt; next = t -&gt; next;
+ 			t -&gt; next = q;
++#endif
+ 			return;
++#ifdef LIBDHCP
++		} else if (timeouts[i].when &gt; when) {
++			pos = i;
++#endif
+ 		}
+ 	}
+ 
++#ifdef LIBDHCP
++	/* If we didn't supersede an existing timeout, then pos is set
++	 * to the timeout which will post after this one.  Insert this
++	 * one before it. */
++
++	new_timeouts = realloc(timeouts, sizeof (t) * (ntimeouts+1));
++	/* XXX broken API, no way to return error here */
++	if (new_timeouts) {
++		/* ntimeouts = 10
++		 * pos = 3;
++		 * n = 10-3 * sizeof (t) = 7 * sizeof (t) 
++		 */
++		size_t n = (ntimeouts - pos) * sizeof (t);
++
++		timeouts = new_timeouts;
++		memmove(&amp;timeouts[pos+1], &amp;timeouts[pos], n);
++		memmove(&amp;timeouts[pos], &amp;t, sizeof (t));
++		ntimeouts++;
++	}
++#else
+ 	/* End of list. */
+ 	t -&gt; next = q;
+ 	q -&gt; next = (struct timeout *)0;
++#endif
+ }
+ 
+ void cancel_timeout (where, what)
+ 	void (*where) PROTO ((void *));
+ 	void *what;
+ {
++#ifdef LIBDHCP
++	struct timeout t;
++	int i = 0;
++#else
+ 	struct timeout *t, *q;
++#endif
+ 
+ 	/* Look for this timeout on the list, and unlink it if we find it. */
++#ifdef LIBDHCP
++	for (i = 0; i &lt; ntimeouts; i++) {
++		struct timeout *new_timeouts, *q = &amp;timeouts[i];
++
++		if (q-&gt;func == where &amp;&amp; q-&gt;what == what) {
++			size_t n;
++
++			memmove(&amp;t, q, sizeof (t));
++
++			n = (ntimeouts - i - 1) * sizeof (t);
++			memmove(&amp;timeouts[i+1], &amp;timeouts[i], n);
++
++			n = --ntimeouts * sizeof (t);
++			new_timeouts = realloc(timeouts, n);
++			/* XXX broken API, no way to return error here */
++			if (new_timeouts || !n)
++				timeouts = new_timeouts;
++
++			if (t.unref)
++				t.unref(t.what, MDL);
++		}
++	}
++#else
+ 	t = (struct timeout *)0;
+ 	for (q = timeouts; q; q = q -&gt; next) {
+ 		if (q -&gt; func == where &amp;&amp; q -&gt; what == what) {
+@@ -193,10 +338,15 @@
+ 		q -&gt; next = free_timeouts;
+ 		free_timeouts = q;
+ 	}
++#endif
+ }
+ 
+ void cancel_all_timeouts ()
+ {
++#ifdef LIBDHCP
++	cur_time = TIME_MAX;
++	process_outstanding_timeouts(NULL);
++#else
+ 	struct timeout *t, *n;
+ 	for (t = timeouts; t; t = n) {
+ 		n = t -&gt; next;
+@@ -205,13 +355,19 @@
+ 		t -&gt; next = free_timeouts;
+ 		free_timeouts = t;
+ 	}
++#endif
+ }
+ 
+ void relinquish_timeouts ()
+ {
++#ifdef LIBDHCP
++	while (ntimeouts)
++		cancel_timeout(timeouts[0].func, timeouts[0].what);
++#else
+ 	struct timeout *t, *n;
+ 	for (t = free_timeouts; t; t = n) {
+ 		n = t -&gt; next;
+ 		dfree (t, MDL);
+ 	}
++#endif
+ }
+--- dhcp-3.0.5/includes/dhcpd.h.timeouts	2006-11-13 19:08:34.000000000 -0500
++++ dhcp-3.0.5/includes/dhcpd.h	2006-11-13 19:08:43.000000000 -0500
+@@ -817,14 +817,6 @@
+ 
+ typedef void (*tvref_t)(void *, void *, const char *, int);
+ typedef void (*tvunref_t)(void *, const char *, int);
+-struct timeout {
+-	struct timeout *next;
+-	TIME when;
+-	void (*func) PROTO ((void *));
+-	void *what;
+-	tvref_t ref;
+-	tvunref_t unref;
+-};
+ 
+ struct protocol {
+ 	struct protocol *next;
+@@ -1751,7 +1743,6 @@
+ 					    struct dhcp_packet *, unsigned,
+ 					    unsigned int,
+ 					    struct iaddr, struct hardware *));
+-extern struct timeout *timeouts;
+ extern omapi_object_type_t *dhcp_type_interface;
+ #if defined (TRACING)
+ trace_type_t *interface_trace;

Added: trunk/rpms/dhcp-ldap/dhcp-3.0.5-version.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0.5-version.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0.5-version.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,7 @@
+--- dhcp-3.0.5/includes/version.h.version	2006-10-26 18:19:38.000000000 -0400
++++ dhcp-3.0.5/includes/version.h	2006-11-10 11:16:04.000000000 -0500
+@@ -1,3 +1,3 @@
+ /* Current version of ISC DHCP Distribution. */
+ 
+-#define DHCP_VERSION	&quot;V3.0.5&quot;
++#define DHCP_VERSION	&quot;V3.0.5-RedHat&quot;

Added: trunk/rpms/dhcp-ldap/dhcp-3.0pl1-minires.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0pl1-minires.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0pl1-minires.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,15 @@
+--- dhcp-3.0pl1/minires/ns_name.c~	2000-02-02 02:28:14.000000000 -0500
++++ dhcp-3.0pl1/minires/ns_name.c	2003-01-08 04:25:23.000000000 -0500
+@@ -255,6 +255,11 @@
+ 	dn = dst;
+ 	eom = dst + dstsiz;
+ 
++	if (dn &gt;= eom) {
++ 		errno = EMSGSIZE;
++ 		return (-1);
++ 	}
++
+ 	while ((n = *cp++) != 0) {
+ 		if ((n &amp; NS_CMPRSFLGS) != 0) {
+ 			/* Some kind of compression pointer. */
+ 		

Added: trunk/rpms/dhcp-ldap/dhcp-3.0pl1-miscfixes.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0pl1-miscfixes.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0pl1-miscfixes.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,40 @@
+--- dhcp-3.0pl1/client/clparse.c.sopwith	2002-08-26 06:58:04.000000000 -0400
++++ dhcp-3.0pl1/client/clparse.c	2002-08-26 06:59:57.000000000 -0400
+@@ -60,6 +60,9 @@
+ 	DHO_DOMAIN_NAME,
+ 	DHO_DOMAIN_NAME_SERVERS,
+ 	DHO_HOST_NAME,
++	DHO_NIS_DOMAIN,
++	DHO_NIS_SERVERS,
++	DHO_NTP_SERVERS,
+ 	0
+ };
+ 
+--- dhcp-3.0pl1/client/dhclient.conf.5.sopwith	2002-08-26 07:02:27.000000000 -0400
++++ dhcp-3.0pl1/client/dhclient.conf.5	2002-08-26 07:03:28.000000000 -0400
+@@ -191,7 +191,8 @@
+ options.   Only the option names should be specified in the request
+ statement - not option parameters.   By default, the DHCP server
+ requests the subnet-mask, broadcast-address, time-offset, routers,
+-domain-name, domain-name-servers and host-name options. 
++domain-name, domain-name-servers, host-name, nis-domain, nis-servers,
++and ntp-servers options.
+ .PP
+ In some cases, it may be desirable to send no parameter request list
+ at all.   To do this, simply write the request statement but specify
+--- dhcp-3.0pl1/dst/Makefile.dist.sopwith	2002-08-26 07:10:48.000000000 -0400
++++ dhcp-3.0pl1/dst/Makefile.dist	2002-08-26 07:18:07.000000000 -0400
+@@ -26,7 +26,12 @@
+ 
+ all:	libdst.a
+ 
+-install:
++install: all
++	if [ ! -d $(DESTDIR)$(LIBDIR) ]; then \
++		mkdir $(DESTDIR)$(LIBDIR); chmod 755 $(DESTDIR)$(LIBDIR); \
++	fi
++	$(INSTALL) libdst.a $(DESTDIR)$(LIBDIR)
++	$(CHMOD) 644 $(DESTDIR)$(LIBDIR)/libdst.a
+ 
+ libdst.a:	$(OBJ)
+ 	rm -f dst.a

Added: trunk/rpms/dhcp-ldap/dhcp-3.0pl2-initialize.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0pl2-initialize.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0pl2-initialize.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,10 @@
+--- dhcp-3.0pl2/common/packet.c.initialize	2004-01-21 15:04:27.424131872 -0500
++++ dhcp-3.0pl2/common/packet.c	2004-01-21 15:05:33.257662255 -0500
+@@ -149,6 +149,7 @@
+ 	struct ip ip;
+ 	struct udphdr udp;
+ 
++	memset( &amp;ip, sizeof ip, 0);
+ 	/* Fill out the IP header */
+ 	IP_V_SET (&amp;ip, 4);
+ 	IP_HL_SET (&amp;ip, 20);

Added: trunk/rpms/dhcp-ldap/dhcp-3.0pl2-selinux.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-3.0pl2-selinux.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-3.0pl2-selinux.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,11 @@
+--- dhcp-3.0pl2/client/dhclient.c.selinux	2003-10-08 09:59:43.000000000 -0400
++++ dhcp-3.0pl2/client/dhclient.c	2004-01-05 09:10:35.065642283 -0500
+@@ -2559,6 +2559,8 @@
+ 			wstatus = 0;
+ 		}
+ 	} else {
++	        if (leaseFile)
++		  fclose (leaseFile);
+ 		execve (scriptName, argv, envp);
+ 		log_error (&quot;execve (%s, ...): %m&quot;, scriptName);
+ 		exit (0);

Added: trunk/rpms/dhcp-ldap/dhcp-ldap-3.0.3.spec
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-ldap-3.0.3.spec	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-ldap-3.0.3.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,631 @@
+# $Id$
+# Authority: dag
+
+# tag: test
+
+Summary: DHCP server (with LDAP as backend) and relay agent
+Name: dhcp-ldap
+Version: 3.0.3
+Release: 1
+License: distributable
+Group: System Environment/Daemons
+URL: <A HREF="http://isc.org/products/DHCP/">http://isc.org/products/DHCP/</A>
+
+Source0: <A HREF="ftp://ftp.isc.org/isc/dhcp/dhcp-%{version">ftp://ftp.isc.org/isc/dhcp/dhcp-%{version</A>}.tar.gz
+Source1: dhcpd.conf.sample
+Source2: dhcpd.init
+Source3: dhcrelay.init
+Patch: dhcp-3.0.3-alignment.patch
+Patch100: dhcp-3.0-jbuild.patch
+Patch102: dhcp-3.0.1rc13-dhcpctlman.patch
+Patch103: dhcp-3.0pl1-miscfixes.patch
+Patch106: dhcp-3.0pl1-minires.patch
+Patch109: dhcpd-manpage.patch
+Patch113: dhcp-3.0pl2-selinux.patch
+Patch114: dhcp-3.0pl2-initialize.patch
+Patch115: dhcp-3.0.1rc12-RHscript.patch
+Patch116: dhcp-3.0.1rc12-staticroutes.patch
+Patch117: dhcp-3.0.1rc12-pie.patch
+Patch118: dhcp-3.0.1rc12-inherit-leases.patch
+Patch119: dhcp-3.0.1rc13-noexpr.patch
+Patch120: dhcp-3.0.1rc14-noconfig.patch
+Patch121: dhcp-3.0.1-change_resolv_conf.patch
+Patch122: dhcp-3.0.1-default_gateway.patch
+Patch123: dhcp-3.0.1.preserve-sent-options.patch
+Patch124: dhcp-3.0.3-mis_host.patch
+Patch125: dhcp-3.0.1-new-host.patch
+Patch126: dhcp-3.0.1-host_dereference.patch
+Patch127: dhcp-3.0.1-restrict-unconfigured-IF.patch
+Patch128: dhcp-3.0.1-check-empty-new-routers.patch
+Patch130: dhcp-3.0.3-ldap-patch
+BuildRoot: %{_tmppath}/%{name}-%{version}-root
+
+BuildRequires: groff
+#BuildRequires: gcc &gt;= 3.4.3
+Requires: /sbin/chkconfig
+Requires: kernel &gt;= 2.2.18
+Conflicts: dhcp
+
+%description
+DHCP (Dynamic Host Configuration Protocol) is a protocol which allows
+individual devices on an IP network to get their own network
+configuration information (IP address, subnetmask, broadcast address,
+etc.) from a DHCP server. The overall purpose of DHCP is to make it
+easier to administer a large network.  The dhcp package includes the
+ISC DHCP service and relay agent.
+
+To use DHCP on your network, install a DHCP service (or relay agent),
+and on clients run a DHCP client daemon.  The dhcp package provides
+the ISC DHCP service and relay agent.
+
+%package -n dhclient
+Summary: Development headers and libraries for interfacing to the DHCP server
+Requires: initscripts &gt;= 6.75
+Group: System Environment/Base
+Obsoletes: dhcpcd
+
+%package devel
+Summary: Development headers and libraries for interfacing to the DHCP server
+Requires: dhcp = %{version}
+Group: Development/Libraries
+
+%description -n dhclient
+DHCP (Dynamic Host Configuration Protocol) is a protocol which allows
+individual devices on an IP network to get their own network
+configuration information (IP address, subnetmask, broadcast address,
+etc.) from a DHCP server. The overall purpose of DHCP is to make it
+easier to administer a large network.
+
+To use DHCP on your network, install a DHCP service (or relay agent),
+and on clients run a DHCP client daemon.  The dhclient package 
+provides the ISC DHCP client daemon.
+
+%description devel
+Libraries for interfacing with the ISC DHCP server.
+
+%prep
+%setup -n dhcp-%{version}
+
+#patch -b .alignment
+%patch100 -p1 -b .jbuild
+%patch102 -p1 -b .dhcpctlman
+%patch103 -p1 -b .miscfixes
+%patch106 -p1 -b .minires
+%patch109 -p1 -b .dhcpdman
+%patch113 -p1 -b .selinux
+%patch114 -p1 -b .initialize
+%patch115 -p1 -b .RHscript
+%patch116 -p1 -b .staticroutes
+%patch117 -p1 -b .pie
+%patch118 -p1 -b .inherit-leases
+%patch119 -p1 -b .noexp
+%patch120 -p1 -b .noconfig
+%patch121 -p1 -b .change_resolv_conf
+%patch122 -p1 -b .default_gateway
+#patch123 -p1 -b .preserve-sent-options
+%patch124 -b .mis-host 
+#patch125 -p1 -b .new-host
+#patch126 -p1 -b .host-dereference
+%patch127 -p1 -b .restrict-unconfigured-IF
+%patch128 -p1 -b .check-empty-new-routers
+%patch130 -p1 -b .ldap
+
+%{__cp} -av %{SOURCE1} .
+%{__cat} &lt;&lt;EOF &gt;site.conf
+VARDB=%{_localstatedir}/lib/dhcp
+ADMMANDIR=%{_mandir}/man8
+FFMANDIR=%{_mandir}/man5
+LIBMANDIR=%{_mandir}/man3
+USRMANDIR=%{_mandir}/man1
+LIBDIR=%{_libdir}
+INCDIR=%{_includedir}
+EOF
+
+%{__cat} &lt;&lt;EOF &gt;&gt;includes/site.h
+#define _PATH_DHCPD_DB          &quot;%{_localstatedir}/lib/dhcp/dhcpd.leases&quot;
+#define _PATH_DHCLIENT_DB       &quot;%{_localstatedir}/lib/dhcp/dhclient.leases&quot;
+EOF
+
+%{__cat} &lt;&lt;EOF &gt;findptrsize.c
+#include &lt;stdio.h&gt;
+int main(void) { printf(&quot;%%d\n&quot;, sizeof(void *)); return 0; }
+EOF
+
+%{__cat} &lt;&lt;EOF &gt;dhcpd.sysconfig
+# Command line options here
+DHCPDARGS=
+EOF
+
+%{__cat} &lt;&lt;EOF &gt;dhcrelay.sysconfig
+# Command line options here
+INTERFACES=&quot;&quot;
+DHCPSERVERS=&quot;&quot;
+EOF
+
+%build
+%{__cc} -o findptrsize findptrsize.c
+[ &quot;`./findptrsize`&quot; -ge 8 ] &amp;&amp; RPM_OPT_FLAGS=&quot;%{optflags} -DPTRSIZE_64BIT&quot;
+
+./configure --copts &quot;$RPM_OPT_FLAGS -fPIC&quot;
+
+%{__make} %{?_smp_mflags} CC=&quot;%{__cc}&quot; DEBUG=&quot;&quot;
+
+%install
+%{__rm} -rf %{buildroot}
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+
+%{__install} -Dp -m0755 %{SOURCE2} %{buildroot}%{_initrddir}/dhcpd
+%{__install} -Dp -m0755 %{SOURCE3} %{buildroot}/etc/rc.d/init.d/dhcrelay
+%{__install} -Dp -m0644 dhcpd.sysconfig %{buildroot}%{_sysconfdir}/sysconfig/dhcpd
+%{__install} -Dp -m0644 dhcrelay.sysconfig %{buildroot}%{_sysconfdir}/sysconfig/dhcrelay
+
+touch %{buildroot}%{_localstatedir}/lib/dhcp/dhcpd.leases
+
+%{__install} -Dp -m0644 contrib/dhcp.schema %{buildroot}%{_sysconfdir}/openldap/schema/dhcp.schema
+%{__install} -Dp -m0755 contrib/dhcpd-conf-to-ldap.pl %{buildroot}/usr/sbin/dhcpd-conf-to-ldap.pl
+%{__install} -Dp -m0644 client/dhclient.conf dhclient.conf.sample
+%{__chmod} 0755 %{buildroot}/sbin/dhclient-script
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%post
+/sbin/chkconfig --add dhcpd
+/sbin/chkconfig --add dhcrelay
+
+%preun
+if [ $1 -eq 0 ]; then	# execute this only if we are NOT doing an upgrade
+    service dhcpd stop &gt;/dev/null 2&gt;&amp;1
+    service dhcrelay stop &gt;/dev/null 2&gt;&amp;1
+    /sbin/chkconfig --del dhcpd 
+    /sbin/chkconfig --del dhcrelay
+fi
+
+%postun
+if [ $1 -ge 1 ]; then
+    service dhcpd condrestart &gt;/dev/null 2&gt;&amp;1
+    service dhcrelay condrestart &gt;/dev/null 2&gt;&amp;1
+fi
+
+%files
+%defattr(-, root, root, 0755)
+%doc Changelog-LDAP README README.ldap RELNOTES dhcpd.conf.sample doc/draft-ietf-dhc-ldap-schema-01.txt
+%doc %{_mandir}/man1/omshell.1*
+%doc %{_mandir}/man5/dhcp-eval.5*
+%doc %{_mandir}/man5/dhcpd*.5*
+%doc %{_mandir}/man8/dhcpd.8*
+%doc %{_mandir}/man8/dhcrelay.8*
+%dir %{_localstatedir}/lib/dhcp/
+%verify(not size md5 mtime) %config(noreplace) %{_localstatedir}/lib/dhcp/dhcpd.leases
+%config(noreplace) %{_sysconfdir}/sysconfig/dhcpd
+%config(noreplace) %{_sysconfdir}/sysconfig/dhcrelay
+%config %{_initrddir}/dhcpd
+%config %{_initrddir}/dhcrelay
+%config %{_sysconfdir}/openldap/schema/dhcp.schema
+%{_bindir}/omshell
+%{_sbindir}/dhcpd
+%{_sbindir}/dhcpd-conf-to-ldap.pl
+%{_sbindir}/dhcrelay
+
+%files -n dhclient
+%defattr(-, root, root, 0755)
+%doc dhclient.conf.sample
+%doc %{_mandir}/man5/dhclient*.5*
+%doc %{_mandir}/man5/dhcp-options.5*
+%doc %{_mandir}/man8/dhclient*.8*
+%dir %{_localstatedir}/lib/dhcp/
+/sbin/dhclient
+/sbin/dhclient-script
+
+%files devel
+%defattr(-, root, root, 0755)
+%doc %{_mandir}/man3/*.3*
+%{_includedir}/*.h
+%{_includedir}/isc-dhcp/
+%{_includedir}/omapip/
+%{_libdir}/libdhcpctl.a
+%{_libdir}/libdst.a
+%{_libdir}/libomapi.a
+
+%changelog
+* Tue Aug 09 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.0.3-1
+- Added dhcp-ldap patch.
+- Cleanup and conflict with dhcp.
+
+* Sun May 23 2005 Alain Rykaert
+- include <A HREF="http://www.newwave.net/~masneyb/dhcp-3.0.2-ldap-patch">http://www.newwave.net/~masneyb/dhcp-3.0.2-ldap-patch</A>
+
+* Tue Nov 16 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-12
+- fix bug 138181 &amp; bug 139468: do not attempt to listen/send on
+-     unconfigured  loopback, point-to-point or non-broadcast 
+-     interfaces (don't generate annoying log messages)
+- fix bug 138869: dhclient-script: check if '$new_routers' is
+-     empty before doing 'set $new_routers;...;ping ... $1'
+
+* Wed Oct 06 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-11
+- dhcp-3.0.2b1 came out today. A diff of the 'ack_lease' function
+- Dave Hankins and I patched exposed a missing '!' on an if clause
+- that got dropped with the 'new-host' patch. Replacing the '!' .
+- Also found one missing host_dereference.
+
+* Wed Oct 06 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-10
+- clean-up last patch: new-host.patch adds host_reference(host)
+- without host_dereference(host) before returns in ack_lease
+- (dhcp-3.0.1-host_dereference.patch)
+ 
+* Mon Sep 27 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-9
+- Fix bug 133522:
+- PXE Boot clients with static leases not given 'file' option
+- 104 by server - PXE booting was disabled for 'fixed-address'
+- clients. 
+
+* Fri Sep 10 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-8
+- Fix bug 131212: 
+- If &quot;deny booting&quot; is defined for some group of hosts,
+- then after one of those hosts is denied booting, all
+- hosts are denied booting, because of a pointer not being
+- cleared in the lease record. 
+- An upstream patch was obtained which will be in dhcp-3.0.2 .
+
+* Mon Aug 16 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-7
+- Forward DNS update by client was disabled by a bug that I
+- found in code where 'client-&gt;sent_options' was being 
+- freed too early.
+- Re-enabled it after contacting upstream maintainer
+- who confirmed that this was a bug (bug #130069) -
+- submitted patch dhcp-3.0.1.preserve-sent-options.patch.
+- Upstream maintainer informs me this patch will be in dhcp-3.0.2 .
+
+* Tue Aug 3  2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 6:3.0.1-6
+- Allow 2.0 kernels to obtain default gateway via dhcp 
+
+* Mon Aug 2  2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 5:3.0.1-5
+- Invoke 'change_resolv_conf' function to change resolv.conf
+
+* Fri Jul 16 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 3:3.0.1
+- Upgraded to new ISC 3.0.1 version
+
+* Thu Jun 24 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-5
+- Allow dhclient-script to continue without a config file.  
+- It will use default values.
+
+* Wed Jun 23 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-4
+- fix inherit-leases patch
+
+* Tue Jun 22 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-2
+- Turn on inherit-leases patch
+
+* Tue Jun 22 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-1
+- User kernelversion instead of uname-r
+- Update to latest package from ISC
+- Remove inherit-leases patch for now.
+
+* Tue Jun 15 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Thu Jun 10 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc13-1
+- Update to latest package from ISC
+
+* Thu Jun 10 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-9
+- add route back in after route up call
+
+* Wed Jun 9 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-8
+- add alex's dhcp-3.0.1rc12-inherit-leases.patch patch
+
+* Tue Jun  8 2004 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt; 1:3.0.1rc12-7
+- set device on default gateway route
+
+* Mon May 17 2004 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 1:3.0.1rc12-6
+- compiling dhcpd PIE
+
+* Thu Mar 25 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-5
+- Add static routes patch to dhclient-script
+
+* Wed Mar 25 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-4
+- Fix init to check config during restart 
+
+* Wed Mar 24 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-3
+- Fix init script to create leases file if missing
+
+* Tue Mar 02 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Fri Feb 13 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Wed Jan 21 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.20
+- Fix initialization of memory to prevent compiler error
+
+* Mon Jan 5 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.19
+- Close leaseFile before exec, to fix selinux error message
+
+* Mon Dec 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.18
+- Add BuildRequires groff
+- Replace resolv.conf if renew and data changes
+
+* Sun Nov 30 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.17
+- Add obsoletes dhcpcd
+
+* Wed Oct 8 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.16
+- Fix location of ntp driftfile
+
+* Fri Sep 5 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.15
+- Bump Release
+
+* Fri Sep 5 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.14
+- Add div0 patch
+
+* Wed Aug 20 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.13
+- Add SEARCH to client script
+
+* Wed Aug 20 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.12
+- Bump Release
+
+* Wed Aug 20 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.11
+- Add configtest
+
+* Fri Aug 1 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.10
+- increment for base 
+
+* Fri Aug 1 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.9
+- Don't update resolv.conf on renewals
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.8
+- increment for base 
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.7
+- Fix name of driftfile
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.6
+- increment for base 
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.5
+- Change dhcrelay script to check DHCPSERVERS
+
+* Mon Jul  7 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.4
+- increment for base 
+
+* Mon Jul  7 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.3
+- Fix dhclient-script to support PEERNTP and PEERNIS flags.
+- patch submitted by <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">aoliva at redhat.com</A>
+
+* Sun Jun  8 2003 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt; 1:3.0pl2-6.1
+- add epoch to dhcp-devel versioned requires on dhcp
+- build for RHEL
+
+* Wed Jun 04 2003 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Tue May 27 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-5
+- Fix memory leak in parser.
+
+* Mon May 19 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-4
+- Change Rev for RHEL
+
+* Mon May 19 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-3
+- Change example to not give out 255 address.
+
+* Tue Apr 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-2
+- Change Rev for RHEL
+
+* Mon Apr 28 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-1
+- upgrade to 3.0pl2
+
+* Wed Mar 26 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-26
+- add usage for dhcprelay -c
+- add man page for dhcprelay -c
+
+* Fri Mar 7 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-25
+- Fix man dhcpd.conf man page
+
+* Tue Mar 4 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-24
+- Fix man dhcpctl.3 page
+
+* Mon Feb 3 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-23
+- fix script to handle ntp.conf correctly
+
+* Thu Jan 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-22
+- Increment release to add to 8.1
+
+* Wed Jan 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-21
+- Implement max hops patch
+
+* Wed Jan 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-20
+- It has now been decided to just have options within dhclient kit
+
+* Sun Jan 26 2003 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- add defattr() to have files not owned by root
+
+* Fri Jan 24 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-17
+- require kernel version
+
+* Fri Jan 24 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-16
+- move dhcp-options to separate package 
+
+* Wed Jan 22 2003 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- rebuilt
+
+* Thu Jan 9 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-15
+- eliminate dhcp-options from dhclient in order to get errata out
+
+* Wed Jan 8 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-14
+- VU#284857 - ISC DHCPD minires library contains multiple buffer overflows
+
+* Mon Jan 6 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-13
+- Fix when ntp is not installed.
+
+* Mon Jan 6 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-12
+- Fix #73079 (dhcpctl man page) 
+
+* Thu Nov 14 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-11
+- Use generic PTRSIZE_64BIT detection instead of ifarch.
+
+* Thu Nov 14 2002 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt; 3.0pl1-10
+- fix parsing of command line args in dhclient.  It was missing a few.
+
+* Mon Oct 07 2002 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- work on 64bit archs
+
+* Wed Aug 28 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-9
+- Fix #72795
+
+* Mon Aug 26 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-8
+- More #68650 (modify requested options)
+- Fix #71453 (dhcpctl man page) and #71474 (include libdst.a) and
+  #72622 (hostname setting)
+
+* Thu Aug 15 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-7
+- More #68650 (modify existing patch to also set NIS domain)
+
+* Tue Aug 13 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-6
+- Patch102 (dhcp-3.0pl1-dhcpctlman-69731.patch) to fix #69731
+
+* Tue Aug 13 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-5
+- Patch101 (dhcp-3.0pl1-dhhostname-68650.patch) to fix #68650
+
+* Fri Jul 12 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-4
+- Fix unaligned accesses when decoding a UDP packet
+
+* Thu Jul 11 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-3
+- No apparent reason for the dhclient -&gt; dhcp dep mentioned in #68001,
+  so removed it
+
+* Wed Jun 27 2002 David Sainty &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">saint at redhat.com</A>&gt; 3.0pl1-2
+- Move dhclient.conf.sample from dhcp to dhclient
+
+* Mon Jun 25 2002 David Sainty &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">saint at redhat.com</A>&gt; 3.0pl1-1
+- Change to dhclient, dhcp, dhcp-devel packaging
+- Move to 3.0pl1, do not strip binaries
+- Drop in sysconfig-enabled dhclient-script
+
+* Thu May 23 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- automated rebuild
+
+* Sat Jan 26 2002 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- prereq chkconfig
+
+* Tue Jan 22 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0-5
+- Split headers/libs into a devel subpackage (#58656)
+
+* Wed Jan 09 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- automated rebuild
+
+* Fri Dec 28 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0-3
+- Fix the #52856 nit.
+- Include dhcrelay scripts from #49186
+
+* Thu Dec 20 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0-2
+- Update to 3.0, include devel files installed by it (as part of the main package).
+
+* Sun Aug 26 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 2.0pl5-8
+- Fix #26446
+
+* Mon Aug 20 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- Fix #5405 for real - it is dhcpd.leases not dhcp.leases.
+
+* Mon Jul 16 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- /etc/sysconfig/dhcpd
+- Include dhcp.leases file (#5405)
+
+* Sun Jun 24 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- Bump release + rebuild.
+
+* Wed Feb 14 2001 Tim Waugh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twaugh at redhat.com</A>&gt;
+- Fix initscript typo (bug #27624).
+
+* Wed Feb  7 2001 Trond Eivind Glomsr&#248;d &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">teg at redhat.com</A>&gt;
+- Improve spec file i18n
+
+* Mon Feb  5 2001 Bernhard Rosenkraenzer &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bero at redhat.com</A>&gt;
+- i18nize init script (#26084)
+
+* Sun Sep 10 2000 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- update to 2.0pl5
+- redo buildroot patch
+
+* Wed Aug 30 2000 Matt Wilson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">msw at redhat.com</A>&gt;
+- rebuild to cope with glibc locale binary incompatibility, again
+
+* Mon Aug 14 2000 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt;
+- check for existence of /var/lib/dhcpd.leases in initscript before starting
+
+* Wed Jul 19 2000 Jakub Jelinek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jakub at redhat.com</A>&gt;
+- rebuild to cope with glibc locale binary incompatibility
+
+* Sat Jul 15 2000 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- move initscript back
+
+* Wed Jul 12 2000 Prospector &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bugzilla at redhat.com</A>&gt;
+- automatic rebuild
+
+* Fri Jul  7 2000 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.com</A>&gt;
+- /etc/rc.d/init.d -&gt; /etc/init.d
+- fix /var/state/dhcp -&gt; /var/lib/dhcp
+
+* Fri Jun 16 2000 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt;
+- condrestart for initscript, graceful upgrades.
+
+* Thu Feb 03 2000 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- gzipped man pages
+- marked /etc/rc.d/init.d/dhcp as a config file
+
+* Mon Jan 24 2000 Jakub Jelinek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jakub at redhat.com</A>&gt;
+- fix booting of JavaStations
+  (reported by Pete Zaitcev &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">zaitcev at metabyte.com</A>&gt;).
+- fix SIGBUS crashes on SPARC (apparently gcc is too clever).
+
+* Fri Sep 10 1999 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- chkconfig --del in %preun, not %postun
+
+* Mon Aug 16 1999 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- initscript munging
+
+* Fri Jun 25 1999 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- update to 2.0.
+
+* Fri Jun 18 1999 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- don't run by default
+
+* Wed Jun  2 1999 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- update to 2.0b1pl28.
+
+* Tue Apr 06 1999 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt;
+- strip binaries
+
+* Mon Apr 05 1999 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt;
+- copy the source file in prep, not move
+
+* Sun Mar 21 1999 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt; 
+- auto rebuild in the new build environment (release 4)
+
+* Mon Jan 11 1999 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- added a sample dhcpd.conf file
+- we don't need to dump rfc's in /usr/doc
+
+* Sun Sep 13 1998 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt;
+- modify dhcpd.init to exit if /etc/dhcpd.conf is not present
+
+* Sat Jun 27 1998 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- Upgraded to 2.0b1pl6 (patch1 no longer needed).
+
+* Thu Jun 11 1998 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- applied patch from Chris Evans which makes the server a bit more paranoid
+  about dhcp requests coming in from the wire
+
+* Mon Jun 01 1998 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- updated to dhcp 2.0b1pl1
+- got proper man pages in the package
+
+* Tue Mar 31 1998 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- updated to build in a buildroot properly
+- don't package up the client, as it doens't work very well &lt;sigh&gt;
+
+* Tue Mar 17 1998 Bryan C. Andregg &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bandregg at redhat.com</A>&gt;
+- Build rooted and corrected file listing.
+
+* Mon Mar 16 1998 Mike Wangsmo &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">wanger at redhat.com</A>&gt;
+- removed the actual inet.d links (chkconfig takes care of this for us)
+  and made the %postun section handle upgrades.
+
+* Mon Mar 16 1998 Bryan C. Andregg &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bandregg at redhat.com</A>&gt;
+- First package.


Property changes on: trunk/rpms/dhcp-ldap/dhcp-ldap-3.0.3.spec
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:keywords
   + Id Revision
Name: svn:eol-style
   + native

Added: trunk/rpms/dhcp-ldap/dhcp-ldap.spec
===================================================================
--- trunk/rpms/dhcp-ldap/dhcp-ldap.spec	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcp-ldap.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,1091 @@
+# $Id$
+# Authority: dag
+
+# Tag: test
+
+%define real_name dhcp
+%define workdir work.linux-2.2
+
+Summary: DHCP (Dynamic Host Configuration Protocol) server and relay agent.
+Name: dhcp-ldap
+Version: 3.0.5
+Release: 1
+Epoch: 12
+License: distributable
+Group: System Environment/Daemons
+URL: <A HREF="http://isc.org/products/DHCP/">http://isc.org/products/DHCP/</A>
+
+Source0: <A HREF="ftp://ftp.isc.org/isc/dhcp/dhcp-%{version">ftp://ftp.isc.org/isc/dhcp/dhcp-%{version</A>}.tar.gz
+Source1: dhcpd.conf.sample
+Source2: dhcpd.init
+Source3: dhcrelay.init
+Source4: dhcpd.conf
+Source5: libdhcp4client.pc
+Source6: dhcptables.pl
+
+Patch0: dhcp-3.0.5-extended-new-option-info.patch
+Patch1: dhcp-3.0.5-Makefile.patch
+Patch2: dhcp-3.0.5-version.patch
+Patch3: dhcp-3.0.5-client.patch
+Patch4: dhcp-3.0.5-common.patch
+Patch5: dhcp-3.0.5-dhcpctl.patch
+Patch6: dhcp-3.0.5-dst.patch
+Patch7: dhcp-3.0.5-includes.patch
+Patch8: dhcp-3.0.5-omapip.patch
+Patch9: dhcp-3.0.5-minires.patch
+Patch10: dhcp-3.0.5-server.patch
+Patch11: dhcp-3.0.5-libdhcp4client.patch
+Patch12: dhcp-3.0.5-timeouts.patch
+Patch13: dhcp-3.0.5-fix-warnings.patch
+Patch14: <A HREF="http://www.newwave.net/~masneyb/dhcp-3.0.5-ldap-patch">http://www.newwave.net/~masneyb/dhcp-3.0.5-ldap-patch</A>
+BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
+
+BuildRequires: groff, perl, openldap-devel, openssl-devel
+Conflicts: dhcp
+Requires(post): chkconfig, coreutils
+Requires(preun): chkconfig
+Requires(postun): coreutils
+
+%description
+DHCP (Dynamic Host Configuration Protocol) is a protocol which allows
+individual devices on an IP network to get their own network
+configuration information (IP address, subnetmask, broadcast address,
+etc.) from a DHCP server. The overall purpose of DHCP is to make it
+easier to administer a large network.  The dhcp package includes the
+ISC DHCP service and relay agent.
+
+To use DHCP on your network, install a DHCP service (or relay agent),
+and on clients run a DHCP client daemon.  The dhcp package provides
+the ISC DHCP service and relay agent.
+
+%package -n dhclient
+Summary: Provides the dhclient ISC DHCP client daemon and dhclient-script .
+Requires: initscripts &gt;= 6.75
+Group: System Environment/Base
+Obsoletes: dhcpcd
+
+%package devel
+Summary: Development headers and libraries for interfacing to the DHCP server
+Requires: dhcp = %{epoch}:%{version}
+Group: Development/Libraries
+
+%description -n dhclient
+DHCP (Dynamic Host Configuration Protocol) is a protocol which allows
+individual devices on an IP network to get their own network
+configuration information (IP address, subnetmask, broadcast address,
+etc.) from a DHCP server. The overall purpose of DHCP is to make it
+easier to administer a large network.
+
+To use DHCP on your network, install a DHCP service (or relay agent),
+and on clients run a DHCP client daemon.  The dhclient package
+provides the ISC DHCP client daemon.
+
+%description devel
+Libraries for interfacing with the ISC DHCP server.
+
+%package -n libdhcp4client
+Summary: ISC DHCP IPv4 client in a library for invocation from other programs
+Group: Development/Libraries
+
+%description -n libdhcp4client
+The Internet Software Consortium (ISC) Dynamic Host Configuration Protocol
+(DHCP) Internet Protocol version 4 (IPv4) client software in a library
+suitable for linkage with and invocation by other programs.
+
+%package -n libdhcp4client-devel
+Summary: Header files for development with the ISC DHCP IPv4 client library
+Group: Development/Libraries
+
+%description -n libdhcp4client-devel
+Header files for development with the Internet Software Consortium (ISC)
+Dynamic Host Configuration Protocol (DHCP) Internet Protocol version 4 (IPv4)
+client library .
+
+%prep
+%setup -n %{real_name}-%{version}
+
+# Extended new option info patch.  Adds the -x option to dhclient, which is
+# needed for dhcdbd and NetworkManager
+%patch0 -p1 -b .enoi
+
+# Build fixes
+%patch1 -p1 -b .Makefile
+
+# Add -RedHat to the version number
+%patch2 -p1 -b .version
+
+# Patches for the client/ subdirectory
+%patch3 -p1 -b .client
+
+# Patches for the common/ subdirectory
+%patch4 -p1 -b .common
+
+# Patches for the dhcpctl/ subdirectory
+%patch5 -p1 -b .dhcpctl
+
+# Patches for the dst/ subdirectory
+%patch6 -p1 -b .dst
+
+# Patches for the includes/ subdirectory
+%patch7 -p1 -b .includes
+
+# Patches for the omapip/ subdirectory
+%patch8 -p1 -b .omapip
+
+# Patches for the minires/ subdirectory
+%patch9 -p1 -b .minires
+
+# Patches for the server/ subdirectory
+%patch10 -p1 -b .server
+
+# Add the libdhcp4client target (library version of dhclient)
+%patch11 -p1 -b .libdhcp4client
+
+# Fix up timeout handling in dhclient and libdhcp4client
+%patch12 -p1 -b .timeouts
+
+# Fix up anything that fails -Wall -Werror
+%patch13 -p1 -b .warnings
+
+### LDAP patch from Brian Masney
+%patch14 -p1 -b .ldap
+
+### Fix broken permissions on empty LDAP schema
+%{__chmod} 0644 doc/draft-ietf-dhc-ldap-schema-01.txt.ldap
+
+%build
+%{__cp} %{SOURCE1} .
+
+%{__cat} &lt;&lt;EOF &gt;site.conf
+VARDB=%{_localstatedir}/lib/dhcpd
+ADMMANDIR=%{_mandir}/man8
+FFMANDIR=%{_mandir}/man5
+LIBMANDIR=%{_mandir}/man3
+USRMANDIR=%{_mandir}/man1
+LIBDIR=%{_libdir}
+INCDIR=%{_includedir}
+EOF
+
+%{__cat} &lt;&lt;EOF &gt;&gt;includes/site.h
+#define _PATH_DHCPD_DB    &quot;%{_localstatedir}/lib/dhcpd/dhcpd.leases&quot;
+#define _PATH_DHCLIENT_DB &quot;%{_localstatedir}/lib/dhclient/dhclient.leases&quot;
+EOF
+
+RPM_OPT_FLAGS=&quot;%{optflags} -fPIC -Dlint -DEXTENDED_NEW_OPTION_INFO&quot;
+
+# DO NOT use the %%configure macro because this configure script is not autognu
+CC=&quot;%{__cc}&quot; ./configure \
+   --copts &quot;${RPM_OPT_FLAGS} %{?bigptrs}&quot; \
+   --work-dir %{workdir}
+
+sed 's/@DHCP_VERSION@/'%{version}'/' &lt;%{SOURCE5} &gt;libdhcp4client.pc
+%{__make} %{?_smp_mflags} CC=&quot;%{__cc}&quot;
+
+%install
+%{__rm} -rf %{buildroot}
+
+%{__make} install DESTDIR=&quot;%{buildroot}&quot;
+
+%{__install} -Dp -m0755 %{SOURCE2} %{buildroot}%{_initrddir}/dhcpd
+%{__install} -Dp -m0755 %{SOURCE3} %{buildroot}%{_initrddir}/dhcrelay
+
+touch $RPM_BUILD_ROOT%{_localstatedir}/lib/dhcpd/dhcpd.leases
+mkdir -p  $RPM_BUILD_ROOT%{_localstatedir}/lib/dhclient/
+
+%{__install} -d -m0755 %{buildroot}%{_sysconfdir}/sysconfig/
+%{__cat} &lt;&lt;EOF &gt;%{buildroot}%{_sysconfdir}/sysconfig/dhcpd
+# Command line options here
+DHCPDARGS=
+EOF
+
+%{__cat} &lt;&lt;EOF &gt;%{buildroot}%{_sysconfdir}/sysconfig/dhcrelay
+# Command line options here
+INTERFACES=&quot;&quot;
+DHCPSERVERS=&quot;&quot;
+EOF
+
+# Copy sample dhclient.conf file into position
+%{__install} -Dp -m0775 client/dhclient.conf dhclient.conf.sample
+
+# Create per-package copies of dhcp-options and dhcp-eval common man-pages:
+cp -fp $RPM_BUILD_ROOT%{_mandir}/man5/dhcp-options.5 $RPM_BUILD_ROOT%{_mandir}/man5/dhcpd-options.5
+cp -fp $RPM_BUILD_ROOT%{_mandir}/man5/dhcp-options.5 $RPM_BUILD_ROOT%{_mandir}/man5/dhclient-options.5
+cp -fp $RPM_BUILD_ROOT%{_mandir}/man5/dhcp-eval.5 $RPM_BUILD_ROOT%{_mandir}/man5/dhcpd-eval.5
+cp -fp $RPM_BUILD_ROOT%{_mandir}/man5/dhcp-eval.5 $RPM_BUILD_ROOT%{_mandir}/man5/dhclient-eval.5
+
+# Install default (empty) dhcpd.conf:
+%{__install} -Dp -m0644 %{SOURCE4} %{buildroot}%{_sysconfdir}/dhcpd.conf
+
+%{__install} -Dp -m0644 libdhcp4client.pc %{buildroot}%{_libdir}/pkgconfig/libdhcp4client.pc
+
+# Sources files can't be symlinks for debuginfo package generation
+find %{workdir} -type l |
+while read f; do
+    rm -f linkderef
+    cp $f linkderef
+    rm -f $f
+    mv linkderef $f
+done
+
+%clean
+%{__rm} -rf %{buildroot}
+
+%post
+/sbin/chkconfig --add dhcpd
+/sbin/chkconfig --add dhcrelay
+if [ &quot;$1&quot; -ge 1 ]; then
+    if [ ! -e %{_mandir}/man5/dhcp-options.5.gz ]; then
+        ln -s %{_mandir}/man5/dhcpd-options.5.gz %{_mandir}/man5/dhcp-options.5.gz
+    fi
+    if [ ! -e %{_mandir}/man5/dhcp-eval.5.gz ]; then
+        ln -s %{_mandir}/man5/dhcpd-eval.5.gz %{_mandir}/man5/dhcp-eval.5.gz
+    fi
+fi
+exit 0
+
+%preun
+if [ $1 = 0 ]; then	# execute this only if we are NOT doing an upgrade
+    service dhcpd stop &gt;/dev/null 2&gt;&amp;1
+    service dhcrelay stop &gt;/dev/null 2&gt;&amp;1
+    /sbin/chkconfig --del dhcpd
+    /sbin/chkconfig --del dhcrelay
+fi
+exit 0
+
+%postun
+if [ &quot;$1&quot; -ge &quot;1&quot; ]; then
+    service dhcpd condrestart &gt;/dev/null 2&gt;&amp;1
+    service dhcrelay condrestart &gt;/dev/null 2&gt;&amp;1
+elif [ &quot;$1&quot; -eq 0 ]; then
+    if [ -e %{_mandir}/man5/dhclient-options.5.gz ]; then
+        ln -sf %{_mandir}/man5/dhclient-options.5.gz %{_mandir}/man5/dhcp-options.5.gz
+    fi
+    if [ -e %{_mandir}/man5/dhclient-eval.5.gz ]; then
+        ln -sf %{_mandir}/man5/dhclient-eval.5.gz %{_mandir}/man5/dhcp-eval.5.gz
+    fi
+fi
+exit 0
+
+%post -n dhclient
+if [ &quot;$1&quot; -ge 1 ]; then
+    if [ ! -e %{_mandir}/man5/dhcp-options.5.gz ]; then
+        ln -s %{_mandir}/man5/dhclient-options.5.gz %{_mandir}/man5/dhcp-options.5.gz
+    fi
+    if [ ! -e %{_mandir}/man5/dhcp-eval.5.gz ]; then
+        ln -s %{_mandir}/man5/dhclient-eval.5.gz %{_mandir}/man5/dhcp-eval.5.gz
+    fi
+fi
+exit 0
+
+%postun -n dhclient
+if [ &quot;$1&quot; -eq 0 ]; then
+    if [ -e %{_mandir}/man5/dhcpd-options.5.gz  ]; then
+        ln -sf %{_mandir}/man5/dhcpd-options.5.gz %{_mandir}/man5/dhcp-options.5.gz
+    fi
+    if [ -e %{_mandir}/man5/dhcpd-eval.5.gz  ]; then
+        ln -sf %{_mandir}/man5/dhcpd-eval.5.gz %{_mandir}/man5/dhcp-eval.5.gz
+    fi
+fi
+exit 0
+
+%post -n libdhcp4client -p /sbin/ldconfig
+%postun -n libdhcp4client -p /sbin/ldconfig
+
+%files
+%defattr(-, root, root, 0755)
+%doc README RELNOTES dhcpd.conf.sample doc/*
+%dir %{_localstatedir}/lib/dhcpd/
+%verify(not size md5 mtime) %config(noreplace) %{_localstatedir}/lib/dhcpd/dhcpd.leases
+%config(noreplace) /etc/sysconfig/dhcpd
+%config(noreplace) /etc/sysconfig/dhcrelay
+%config(noreplace) /etc/dhcpd.conf
+%config /etc/rc.d/init.d/dhcpd
+%config /etc/rc.d/init.d/dhcrelay
+%{_bindir}/omshell
+%{_sbindir}/dhcpd
+%{_sbindir}/dhcrelay
+%{_mandir}/man1/omshell.1*
+%{_mandir}/man5/dhcpd.conf.5*
+%{_mandir}/man5/dhcpd.leases.5*
+%{_mandir}/man8/dhcpd.8*
+%{_mandir}/man8/dhcrelay.8*
+%{_mandir}/man5/dhcpd-options.5*
+%{_mandir}/man5/dhcpd-eval.5*
+%ghost %{_mandir}/man5/dhcp-options.5.gz
+%ghost %{_mandir}/man5/dhcp-eval.5.gz
+
+%files -n dhclient
+%defattr(-, root, root, 0755)
+%doc dhclient.conf.sample
+%dir %{_localstatedir}/lib/dhclient/
+/sbin/dhclient
+/sbin/dhclient-script
+%{_mandir}/man5/dhclient.conf.5*
+%{_mandir}/man5/dhclient.leases.5*
+%{_mandir}/man8/dhclient.8*
+%{_mandir}/man8/dhclient-script.8*
+%{_mandir}/man5/dhclient-options.5*
+%{_mandir}/man5/dhclient-eval.5*
+%ghost %{_mandir}/man5/dhcp-options.5.gz
+%ghost %{_mandir}/man5/dhcp-eval.5.gz
+
+%files devel
+%defattr(-, root, root, 0755)
+%exclude %{_libdir}/libdhcp4client*
+%exclude %{_includedir}/dhcp4client
+%{_includedir}/*
+%{_libdir}/*.a
+%{_mandir}/man3/*
+
+%files -n libdhcp4client
+%defattr(0755, root, root, 0755)
+%{_libdir}/libdhcp4client.so.*
+
+%files -n libdhcp4client-devel
+%defattr(0644, root, root, 0755)
+%{_includedir}/dhcp4client*
+%{_libdir}/pkgconfig/libdhcp4client.pc
+%{_libdir}/libdhcp4client.a
+%{_libdir}/libdhcp4client.so
+
+%changelog
+* Sun Mar 04 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 12:3.0.5-1
+- Added dhcp-ldap patch.
+- Cleanup and conflict with dhcp.
+
+* Wed Nov 29 2006 David Cantrell &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dcantrell at redhat.com</A>&gt; - 12:3.0.5-1
+- Upgrade to ISC dhcp-3.0.5
+- Roll md5 patch in to libdhcp4client patch since it's related
+- Do not overwrite /etc/ntp/step-tickers (#217663)
+- Resolves: rhbz#217663
+- Build the MD5 functions we link against.
+- Set permission of libdhcp4client.so.1 to 0755 (#215910)
+- Do not link res_query.o in to libdhcp4client (#215501)
+- Enable relinquish_timeouts() and cancel_all_timeouts() even when
+  DEBUG_MEMORY_LEAKAGE_ON_EXIT is not defined
+- Add prototypes for b64_pton() and b64_ntop in dst/
+- Move variable declarations and labels around in the fix-warnings patch
+- Expand the list of objects needed for libdhcp4client (#215328)
+- Use libres.a in libdhcp4client since it gives correct minires objects
+- Remove the dhcp options table in C, Perl, Python, and text format (these
+  were reference files added to /usr/share/doc)
+- Remove struct universe *universe from envadd_state in the client patch
+- Add struct universe *universe to envadd_state in the enoi patch
+- Add example dbusified dhclient-script in the enoi patch
+- Change the way libdhcp4client is compiled (patch main source, create new
+  Makefile rather than copy and patch code after main patches)
+- Fix up problems generating compiler warnings
+- Use 'gcc' for making dependencies
+- Pass -fPIC instead of -fpie/-fPIE in compiler flags
+- Combine the extended new option info changes in to one patch file (makes
+  it easier for outside projects that want to use dhcdbd and NetworkManager)
+- Put typedef for dhcp_state_e before it's used in libdhcp_control.h (#212612)
+- Remove dhcpctl.3 from minires/Makefile.dist because it's in dhcpctl
+- Remove findptrsize.c and just set compiler flag for ppc64 and s390x
+- Remove NODEBUGINFO junk from the spec file as well as old/unused code
+- Rolled all 68 patches in to one patch since more than half of them get
+  overridden by later patches anyway.
+- Send usage() screen in dhclient to stdout rather than the syslog (#210524)
+
+* Mon Sep 11 2006 David Cantrell &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dcantrell at redhat.com</A>&gt; - 12:3.0.4-21
+- Rebuild (#205505)
+
+* Fri Aug 18 2006 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt; - 12:3.0.4-20
+- rebuilt with latest binutils to pick up 64K -z commonpagesize on ppc*
+  (#203001)
+
+* Thu Aug 17 2006 David Cantrell &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dcantrell at redhat.com</A>&gt; - 12:3.0.4-19
+- Fix mkdir problem in libdhcp4client.Makefile
+
+* Thu Aug 17 2006 David Cantrell &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dcantrell at redhat.com</A>&gt; - 12:3.0.4-18
+- Fix dhclient on s390x platform (#202911)
+
+* Wed Jul 12 2006 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt; - 12:3.0.4-17.1
+- rebuild
+
+* Wed Jun 28 2006 Peter Jones &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pjones at redhat.com</A>&gt; - 12:3.0.4-17
+- export timeout cancellation functions in libdhcp4client
+
+* Wed Jun 28 2006 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">laroche at redhat.com</A>&gt; - 12:3.0.4-16
+- add proper coreutils requires for the scripts
+
+* Thu Jun 22 2006 Peter Jones &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pjones at redhat.com</A>&gt; - 12:3.0.4-15
+- Make timeout dispatch code not recurse while traversing a linked
+  list, so it doesn't try to free an entries that have been removed.
+  (bz #195723)
+- Don't patch in a makefile, do it in the spec.
+
+* Thu Jun 08 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-14
+- fix bug 191461: preserve ntp.conf local clock fudge statements
+- fix bug 193047: both dhcp and dhclient need to ship common
+                  man-pages: dhcp-options(5) dhcp-eval(5)
+
+* Tue May 30 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-12
+- Make -R option take effect in per-interface client configs
+
+* Fri May 26 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-10
+- fix bug 193047: allow $METRIC to be specified for dhclient routes
+- add a '-R &lt;request option list&gt;' dhclient argument
+
+* Fri May 26 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-8.1
+- fix a libdhcp4client memory leak (1 strdup) and 
+  fill in client-&gt;packet.siaddr before bind_lease() for pump
+  nextServer option.
+
+* Fri May 19 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-8
+- Make libdhcp4client a versioned .so (BZ 192146)
+
+* Wed May 17 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-4
+- Enable libdhcp4client build
+
+* Tue May 16 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-2
+- Fix bug 191470: prevent dhcpd writing 8 byte dhcp-lease-time 
+                  option in packets on 64-bit platforms
+
+* Sun May 14 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-2
+- Add the libdhcp4client library package for use by the new libdhcp 
+  package, which enables dhclient to be invoked by programs in a 
+  single process from the library. The normal dhclient code is
+  unmodified by this.
+
+* Mon May 08 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-2
+- Add new dhclient command line argument:
+  -V &lt;vendor-class-identifier&gt;
+
+* Sat May 06 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 12:3.0.4-1
+- Upgrade to upstream version 3.0.4, released Friday 2006-05-05 .
+- Add new dhclient command line arguments:
+  -H &lt;host-name&gt; : parse as dhclient.conf 'send host-name &quot;&lt;host-name&gt;&quot;;'
+  -F &lt;fqdn&gt;      : parse as dhclient.conf 'send fqdn.fqdn &quot;&lt;fqdn&gt;&quot;;'
+  -T &lt;timeout&gt;   : parse as dhclient.conf 'timeout &lt;timeout&gt;;'
+
+* Thu Mar 02 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-26
+- fix bug 181908: enable dhclient to operate on IBM zSeries z/OS linux guests:
+  o add -I &lt;dhcp-client-identifier&gt; dhclient command line option
+  o add -B &quot;always broadcast&quot; dhclient command line option
+  o add 'bootp-broadcast-always;' dhclient.conf statement
+
+* Mon Feb 20 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-24
+- Apply upstream fix for bug 176615 / ISC RT#15811
+
+* Tue Feb 14 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-22
+- fix bug 181482: resolv.conf not updated on RENEW :
+  since dhcp-3.0.1rc12-RHScript.patch: &quot;$new_domain_servers&quot; should have
+  been &quot;$new_domain_name_servers&quot; :-(
+
+* Fri Feb 10 2006 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt; - 11:3.0.3-21.1.1
+- bump again for double-long bug on ppc(64)
+
+* Mon Feb 06 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-21.1
+- Rebuild for new gcc, glibc and glibc-kernheaders
+
+* Sun Jan 22 2006 Dan Williams &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dcbw at redhat.com</A>&gt; - 11:3.0.3-21
+- Fix dhclient-script to use /bin/dbus-send now that all dbus related
+    binaries are in /bin rather than /usr/bin
+
+* Mon Jan 16 2006 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-20
+- fix bug 177845: allow client ip-address as default router 
+- fix bug 176615: fix DDNS update when Windows-NT client sends 
+	          host-name with trailing nul
+
+* Tue Dec 20 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-18
+- fix bug 176270: allow routers with an octet of 255 in their IP address
+
+* Fri Dec 09 2005 Jesse Keating &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jkeating at redhat.com</A>&gt;
+- rebuilt
+
+* Mon Dec 05 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-16
+- fix gcc 4.1 compile warnings (-Werror)
+
+* Fri Nov 19 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-12
+- fix bug 173619: dhclient-script should reconfig on RENEW if 
+                  subnet-mask, broadcast-address, mtu, routers, etc.
+		  have changed
+- apply upstream improvements to trailing nul options fix of bug 160655
+  
+* Tue Nov 15 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-11
+- Rebuild for FC-5
+- fix bug 167028 - test IBM's unicast bootp patch (from <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">xma at us.ibm.com</A>)
+- fix bug 171312 - silence chkconfig error message if ypbind not installed
+- fix dhcpd.init when -cf arg given to dhcpd
+- make dhcpd init touch /var/lib/dhcpd/dhcpd.leases, not /var/lib/dhcp/dhcpd.leases
+
+* Tue Oct 18 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-10
+- Allow dhclient route metrics to be specified with DHCP options:
+  The dhcp-options(5) man-page states:
+  'option routers ... Routers should be listed in order of preference' 
+  and
+  'option static-routes ... are listed in descending order of priority' .
+  No preference / priority could be set with previous dhclient-script .
+  Now, dhclient-script provides: 
+  Default Gateway (option 'routers') metrics:
+    Instead of allowing only one default gateway, if more than one router 
+    is specified in the routers option, routers following the first router
+    will have a 'metric' of their position in the list (1,...N&gt;1).
+  Option static-routes metrics:
+    If a target appears in the list more than once, routes for duplicate
+    targets will have successively greater metrics, starting at 1.
+
+* Mon Oct 17 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-8
+- further fix for bug 160655 / ISC bug 15293 - upstream patch:
+  do NOT always strip trailing nulls in the dhcpd server
+- handle static-routes option properly in dhclient-script :
+  trailing 0 octets in the 'target' IP specify the class -
+  ie '172.16.0.0 w.x.y.z' specifies '172.16/16 via w.x.y.z'.
+
+* Fri Sep 23 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-7
+- fix bug 169164: separate /var/lib/{dhcpd,dhclient} directories
+- fix bug 167292: update failover port info in dhcpd.conf.5; give
+                  failover ports default values in server/confpars.c
+ 
+* Mon Sep 12 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-6
+- fix bug 167273: time-offset should not set timezone by default
+                  tzdata's Etc/* files are named with reverse sign
+                  for hours west - ie. 'GMT+5' is GMT offset -18000seconds.
+
+* Mon Aug 29 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-4
+- fix bug 166926: make dhclient-script handle interface-mtu option
+  make dhclient-script support /etc/dhclient{,-$IF}-{up,down}-hooks scripts
+  to allow easy customization to support other non-default DHCP options -
+  documented in 'man 8 dhclient-script' .
+- handle the 'time-offset' DHCP option, requested by default.
+
+* Tue Aug 23 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; - 11:3.0.3-3
+- fix bug 160655: strip trailing '\0' bytes from text options before append
+- fix gcc4 compiler warnings ; now compiles with -Werror
+- add RPM_OPT_FLAGS to link as suggested in gcc man-page on '-pie' option
+- change ISC version string to 'V3.0.3-RedHat' at request of ISC
+
+* Tue Aug  9 2005 Jeremy Katz &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">katzj at redhat.com</A>&gt; - 11:3.0.3-2
+- don't explicitly require 2.2 era kernel, it's fairly overkill at this point
+
+* Tue Aug 09 2005 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.0.3-1
+- Added dhcp-ldap patch.
+- Cleanup and conflict with dhcp.
+
+* Fri Jul 29 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 11:3.0.3-1
+- Upgrade to upstream version 3.0.3 
+- Don't apply the 'default boot file server' patch: legacy
+  dhcp behaviour broke RFC 2131, which requires that the siaddr
+  field only be non-zero if the next-server or tftp-server-name
+  options are specified.
+- Try removing the 1-5 second wait on dhclient startup altogether.
+- fix bug 163367: supply default configuration file for dhcpd
+ 
+* Thu Jul 14 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.3rc1-1
+- Upgrade to upstream version 3.0.3rc1
+- fix bug 163203: silence ISC blurb on configtest 
+- fix default 'boot file server' value (packet-&gt;siaddr):
+  In dhcp-3.0.2(-), this was defaulted to the server address;
+  now it defaults to 0.0.0.0 (a rather silly default!) and 
+  must be specified with the 'next-server' option ( not the tftp-boot-server option ?!?)
+  which causes PXE boot clients to fail to load anything after the boot file.
+
+* Fri Jul 08 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-14.FC5
+- Allow package to compile with glibc-headers-2.3.5-11 (tr.c's use of __u16)
+
+* Sun May 23 2005 Alain Rykaert
+- include <A HREF="http://www.newwave.net/~masneyb/dhcp-3.0.2-ldap-patch">http://www.newwave.net/~masneyb/dhcp-3.0.2-ldap-patch</A>
+
+* Fri May 10 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-14
+- Fix bug 159929: prevent dhclient flooding network on repeated DHCPDECLINE
+- dhclient fast startup: 
+   remove dhclient's  random 1-5 second delay on startup if only
+   configuring one interface 
+   remove dhclient_script's &quot;sleep 1&quot; on PREINIT
+- fix new gcc-4.0.0-11 compiler warnings for binding_state_t
+
+* Tue May 03 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-12
+- Rebuild for new glibc
+- Fix dhcdbd set for multiple interfaces
+
+* Wed Apr 27 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-11
+- as pointed out by Peter Jones, dhclient-script spews
+- 'chkconfig: Usage' if run in init state 1 (runlevel returns &quot;unknown&quot;.)
+- this is now corrected.
+
+* Mon Apr 25 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-10
+- dhclient-script dhcdbd extensions. 
+- Tested to have no effect unless dhcdbd invokes dhclient.
+ 
+* Thu Apr 21 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-9
+- bugs 153244 &amp; 155143 are now fixed with SELinux policy; 
+  autotrans now works for dhcpc_t, so restorecons are not required,
+  and dhclient runs OK under dhcpc_t with SELinux enforcing.
+- fix bug 155506: 'predhclien' typo (emacs!).
+ 
+* Mon Apr 18 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-8
+- Fix bugs 153244 &amp; 155143: 
+      o restore dhclient-script 'restorecon's
+      o give dhclient and dhclient-script an exec context of 
+        'system_u:object_r:sbin_t' that allows them to run
+        domainname / hostname and to update configuration files
+        in dhclient post script.       
+- Prevent dhclient emitting verbose ISC 'blurb' on error exit in -q mode
+
+* Mon Apr 04 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-7
+- Add '-x' &quot;extended option environment&quot; dhclient argument:
+-  When -x option given to dhclient:
+-    dhclient enables arbitrary option processing by writing information
+-    about user or vendor defined option space options to environment.
+-
+- fix bug 153244: dhclient should not use restorecon
+- fix bug 151023: dhclient no 'headers &amp; libraries' 
+- fix bug 149780: add 'DHCLIENT_IGNORE_GATEWAY' variable
+- remove all usage of /sbin/route from dhclient-script
+
+* Thu Mar 24 2005 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">laroche at redhat.com</A>&gt;
+- add &quot;exit 0&quot; to post script
+
+* Mon Mar 07 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10.3.0.2-3
+- rebuild for gcc4/glibc-2.3.4-14; fix bad memset
+
+* Thu Feb 24 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-2
+- Fix bug 143640: do not allow more than one dhclient to configure an interface
+
+* Mon Feb 21 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 10:3.0.2-1
+- Upgrade to ISC 3.0.2 Final Release (documentation change only).
+
+* Tue Feb 14 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 8:3.0.2rc3-8
+- Add better execshield security link options
+- fix dhcpd.init when no /etc/dhcpd.conf exists and -cf in DHCPDARGS
+
+* Mon Feb 14 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 8:3.0.2rc3-4
+- make dhclient-script TIMEOUT mode do exactly the same configuration
+- as BOUND / RENEW / REBIND / REBOOT if router ping succeeds
+
+* Mon Feb 14 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 3.0.2rc3-4
+- fix bug 147926: dhclient-script should do restorecon for modified conf files
+- optimize execshield protection
+
+* Thu Feb 10 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 8.3.0.4rc3-3
+- fix bug 147375: dhcpd heap corruption on 32-bit 'subnet' masks
+- fix bug 147502: dhclient should honor GATEWAYDEV and GATEWAY settings            
+- fix bug 146600: dhclient's timeout mode ping should use -I
+- fix bug 146524: dhcpd.init should discard dhcpd's initial output message
+- fix bug 147739: dhcpd.init configtest should honor -cf in DHCPDARGS
+
+* Mon Jan 24 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 8:3.0.2rc3-2
+- fix bug 145997: allow hex 32-bit integers in user specified options
+
+* Thu Jan 06 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 8:3.0.2rc3-1
+- still need an epoch to get past nvre test 
+
+* Thu Jan 06 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 3.0.2rc3-1
+- fix bug 144417: much improved dhclient-script 
+
+* Thu Jan 06 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 3.0.2rc3-1
+- Upgrade to latest release from ISC, which includes most of our
+- recent patches anyway.
+
+* Thu Jan 06 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-17
+- fix bug 144250: gcc-3.4.3-11 is broken :
+- log_error (&quot;Lease with bogus binding state: %d size: %d&quot;,
+-			   comp -&gt; binding_state,
+-			   sizeof(comp-&gt;binding_state));
+- prints:    'Lease with bogus binding state: 257 1'    !
+- compiling with gcc33 (compat-gcc-8-3.3.4.2 fixes for now).
+
+* Mon Jan 03 2005 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-16
+- fix bug 143704: dhclient -r does not work if lease held by
+- dhclient run from ifup . dhclient will now look for the pid
+- files created by ifup .
+
+* Wed Nov 17 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-14
+- NTP: fix bug 139715: merge in new ntp servers only rather than replace
+- all the ntp configuration files; restart ntpd if configuration changed.
+
+* Tue Nov 16 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-12
+- fix bug 138181 &amp; bug 139468: do not attempt to listen/send on
+-     unconfigured  loopback, point-to-point or non-broadcast 
+-     interfaces (don't generate annoying log messages)
+- fix bug 138869: dhclient-script: check if '$new_routers' is
+-     empty before doing 'set $new_routers;...;ping ... $1'
+
+* Wed Oct 06 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-11
+- dhcp-3.0.2b1 came out today. A diff of the 'ack_lease' function
+- Dave Hankins and I patched exposed a missing '!' on an if clause
+- that got dropped with the 'new-host' patch. Replacing the '!' .
+- Also found one missing host_dereference.
+
+* Wed Oct 06 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-10
+- clean-up last patch: new-host.patch adds host_reference(host)
+- without host_dereference(host) before returns in ack_lease
+- (dhcp-3.0.1-host_dereference.patch)
+ 
+* Mon Sep 27 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-9
+- Fix bug 133522:
+- PXE Boot clients with static leases not given 'file' option
+- 104 by server - PXE booting was disabled for 'fixed-address'
+- clients. 
+
+* Fri Sep 10 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-8
+- Fix bug 131212: 
+- If &quot;deny booting&quot; is defined for some group of hosts,
+- then after one of those hosts is denied booting, all
+- hosts are denied booting, because of a pointer not being
+- cleared in the lease record. 
+- An upstream patch was obtained which will be in dhcp-3.0.2 .
+
+* Mon Aug 16 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 7:3.0.1-7
+- Forward DNS update by client was disabled by a bug that I
+- found in code where 'client-&gt;sent_options' was being 
+- freed too early.
+- Re-enabled it after contacting upstream maintainer
+- who confirmed that this was a bug (bug #130069) -
+- submitted patch dhcp-3.0.1.preserve-sent-options.patch.
+- Upstream maintainer informs me this patch will be in dhcp-3.0.2 .
+
+* Tue Aug 3  2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 6:3.0.1-6
+- Allow 2.0 kernels to obtain default gateway via dhcp 
+
+* Mon Aug 2  2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 5:3.0.1-5
+- Invoke 'change_resolv_conf' function to change resolv.conf
+
+* Fri Jul 16 2004 Jason Vas Dias &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jvdias at redhat.com</A>&gt; 3:3.0.1
+- Upgraded to new ISC 3.0.1 version
+
+* Thu Jun 24 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-5
+- Allow dhclient-script to continue without a config file.  
+- It will use default values.
+
+* Wed Jun 23 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-4
+- fix inherit-leases patch
+
+* Tue Jun 22 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-2
+- Turn on inherit-leases patch
+
+* Tue Jun 22 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc14-1
+- User kernelversion instead of uname-r
+- Update to latest package from ISC
+- Remove inherit-leases patch for now.
+
+* Tue Jun 15 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Thu Jun 10 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc13-1
+- Update to latest package from ISC
+
+* Thu Jun 10 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-9
+- add route back in after route up call
+
+* Wed Jun 9 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-8
+- add alex's dhcp-3.0.1rc12-inherit-leases.patch patch
+
+* Tue Jun  8 2004 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt; 1:3.0.1rc12-7
+- set device on default gateway route
+
+* Mon May 17 2004 Thomas Woerner &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twoerner at redhat.com</A>&gt; 1:3.0.1rc12-6
+- compiling dhcpd PIE
+
+* Thu Mar 25 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-5
+- Add static routes patch to dhclient-script
+
+* Wed Mar 25 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-4
+- Fix init to check config during restart 
+
+* Wed Mar 24 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0.1rc12-3
+- Fix init script to create leases file if missing
+
+* Tue Mar 02 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Fri Feb 13 2004 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Wed Jan 21 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.20
+- Fix initialization of memory to prevent compiler error
+
+* Mon Jan 5 2004 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.19
+- Close leaseFile before exec, to fix selinux error message
+
+* Mon Dec 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.18
+- Add BuildRequires groff
+- Replace resolv.conf if renew and data changes
+
+* Sun Nov 30 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.17
+- Add obsoletes dhcpcd
+
+* Wed Oct 8 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.16
+- Fix location of ntp driftfile
+
+* Fri Sep 5 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.15
+- Bump Release
+
+* Fri Sep 5 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.14
+- Add div0 patch
+
+* Wed Aug 20 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.13
+- Add SEARCH to client script
+
+* Wed Aug 20 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.12
+- Bump Release
+
+* Wed Aug 20 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.11
+- Add configtest
+
+* Fri Aug 1 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.10
+- increment for base 
+
+* Fri Aug 1 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.9
+- Don't update resolv.conf on renewals
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.8
+- increment for base 
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.7
+- Fix name of driftfile
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.6
+- increment for base 
+
+* Tue Jul  29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.5
+- Change dhcrelay script to check DHCPSERVERS
+
+* Mon Jul  7 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.4
+- increment for base 
+
+* Mon Jul  7 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 1:3.0pl2-6.3
+- Fix dhclient-script to support PEERNTP and PEERNIS flags.
+- patch submitted by <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">aoliva at redhat.com</A>
+
+* Sun Jun  8 2003 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt; 1:3.0pl2-6.1
+- add epoch to dhcp-devel versioned requires on dhcp
+- build for RHEL
+
+* Wed Jun 04 2003 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- rebuilt
+
+* Tue May 27 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-5
+- Fix memory leak in parser.
+
+* Mon May 19 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-4
+- Change Rev for RHEL
+
+* Mon May 19 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-3
+- Change example to not give out 255 address.
+
+* Tue Apr 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-2
+- Change Rev for RHEL
+
+* Mon Apr 28 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl2-1
+- upgrade to 3.0pl2
+
+* Wed Mar 26 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-26
+- add usage for dhcprelay -c
+- add man page for dhcprelay -c
+
+* Fri Mar 7 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-25
+- Fix man dhcpd.conf man page
+
+* Tue Mar 4 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-24
+- Fix man dhcpctl.3 page
+
+* Mon Feb 3 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-23
+- fix script to handle ntp.conf correctly
+
+* Thu Jan 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-22
+- Increment release to add to 8.1
+
+* Wed Jan 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-21
+- Implement max hops patch
+
+* Wed Jan 29 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-20
+- It has now been decided to just have options within dhclient kit
+
+* Sun Jan 26 2003 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- add defattr() to have files not owned by root
+
+* Fri Jan 24 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-17
+- require kernel version
+
+* Fri Jan 24 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-16
+- move dhcp-options to separate package 
+
+* Wed Jan 22 2003 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- rebuilt
+
+* Thu Jan 9 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-15
+- eliminate dhcp-options from dhclient in order to get errata out
+
+* Wed Jan 8 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-14
+- VU#284857 - ISC DHCPD minires library contains multiple buffer overflows
+
+* Mon Jan 6 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-13
+- Fix when ntp is not installed.
+
+* Mon Jan 6 2003 Dan Walsh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dwalsh at redhat.com</A>&gt; 3.0pl1-12
+- Fix #73079 (dhcpctl man page) 
+
+* Thu Nov 14 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-11
+- Use generic PTRSIZE_64BIT detection instead of ifarch.
+
+* Thu Nov 14 2002 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt; 3.0pl1-10
+- fix parsing of command line args in dhclient.  It was missing a few.
+
+* Mon Oct 07 2002 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- work on 64bit archs
+
+* Wed Aug 28 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-9
+- Fix #72795
+
+* Mon Aug 26 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-8
+- More #68650 (modify requested options)
+- Fix #71453 (dhcpctl man page) and #71474 (include libdst.a) and
+  #72622 (hostname setting)
+
+* Thu Aug 15 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-7
+- More #68650 (modify existing patch to also set NIS domain)
+
+* Tue Aug 13 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-6
+- Patch102 (dhcp-3.0pl1-dhcpctlman-69731.patch) to fix #69731
+
+* Tue Aug 13 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-5
+- Patch101 (dhcp-3.0pl1-dhhostname-68650.patch) to fix #68650
+
+* Fri Jul 12 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-4
+- Fix unaligned accesses when decoding a UDP packet
+
+* Thu Jul 11 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0pl1-3
+- No apparent reason for the dhclient -&gt; dhcp dep mentioned in #68001,
+  so removed it
+
+* Wed Jun 27 2002 David Sainty &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">saint at redhat.com</A>&gt; 3.0pl1-2
+- Move dhclient.conf.sample from dhcp to dhclient
+
+* Mon Jun 25 2002 David Sainty &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">saint at redhat.com</A>&gt; 3.0pl1-1
+- Change to dhclient, dhcp, dhcp-devel packaging
+- Move to 3.0pl1, do not strip binaries
+- Drop in sysconfig-enabled dhclient-script
+
+* Thu May 23 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- automated rebuild
+
+* Sat Jan 26 2002 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- prereq chkconfig
+
+* Tue Jan 22 2002 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0-5
+- Split headers/libs into a devel subpackage (#58656)
+
+* Wed Jan 09 2002 Tim Powers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">timp at redhat.com</A>&gt;
+- automated rebuild
+
+* Fri Dec 28 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0-3
+- Fix the #52856 nit.
+- Include dhcrelay scripts from #49186
+
+* Thu Dec 20 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 3.0-2
+- Update to 3.0, include devel files installed by it (as part of the main package).
+
+* Sun Aug 26 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt; 2.0pl5-8
+- Fix #26446
+
+* Mon Aug 20 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- Fix #5405 for real - it is dhcpd.leases not dhcp.leases.
+
+* Mon Jul 16 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- /etc/sysconfig/dhcpd
+- Include dhcp.leases file (#5405)
+
+* Sun Jun 24 2001 Elliot Lee &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">sopwith at redhat.com</A>&gt;
+- Bump release + rebuild.
+
+* Wed Feb 14 2001 Tim Waugh &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">twaugh at redhat.com</A>&gt;
+- Fix initscript typo (bug #27624).
+
+* Wed Feb  7 2001 Trond Eivind Glomsr&#195;&#184;d &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">teg at redhat.com</A>&gt;
+- Improve spec file i18n
+
+* Mon Feb  5 2001 Bernhard Rosenkraenzer &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bero at redhat.com</A>&gt;
+- i18nize init script (#26084)
+
+* Sun Sep 10 2000 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.de</A>&gt;
+- update to 2.0pl5
+- redo buildroot patch
+
+* Wed Aug 30 2000 Matt Wilson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">msw at redhat.com</A>&gt;
+- rebuild to cope with glibc locale binary incompatibility, again
+
+* Mon Aug 14 2000 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt;
+- check for existence of /var/lib/dhcpd.leases in initscript before starting
+
+* Wed Jul 19 2000 Jakub Jelinek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jakub at redhat.com</A>&gt;
+- rebuild to cope with glibc locale binary incompatibility
+
+* Sat Jul 15 2000 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- move initscript back
+
+* Wed Jul 12 2000 Prospector &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bugzilla at redhat.com</A>&gt;
+- automatic rebuild
+
+* Fri Jul  7 2000 Florian La Roche &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">Florian.LaRoche at redhat.com</A>&gt;
+- /etc/rc.d/init.d -&gt; /etc/init.d
+- fix /var/state/dhcp -&gt; /var/lib/dhcp
+
+* Fri Jun 16 2000 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt;
+- condrestart for initscript, graceful upgrades.
+
+* Thu Feb 03 2000 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- gzipped man pages
+- marked /etc/rc.d/init.d/dhcp as a config file
+
+* Mon Jan 24 2000 Jakub Jelinek &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jakub at redhat.com</A>&gt;
+- fix booting of JavaStations
+  (reported by Pete Zaitcev &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">zaitcev at metabyte.com</A>&gt;).
+- fix SIGBUS crashes on SPARC (apparently gcc is too clever).
+
+* Fri Sep 10 1999 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- chkconfig --del in %preun, not %postun
+
+* Mon Aug 16 1999 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- initscript munging
+
+* Fri Jun 25 1999 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- update to 2.0.
+
+* Fri Jun 18 1999 Bill Nottingham &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">notting at redhat.com</A>&gt;
+- don't run by default
+
+* Wed Jun  2 1999 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- update to 2.0b1pl28.
+
+* Tue Apr 06 1999 Preston Brown &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">pbrown at redhat.com</A>&gt;
+- strip binaries
+
+* Mon Apr 05 1999 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt;
+- copy the source file in prep, not move
+
+* Sun Mar 21 1999 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt; 
+- auto rebuild in the new build environment (release 4)
+
+* Mon Jan 11 1999 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- added a sample dhcpd.conf file
+- we don't need to dump rfc's in /usr/doc
+
+* Sun Sep 13 1998 Cristian Gafton &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">gafton at redhat.com</A>&gt;
+- modify dhcpd.init to exit if /etc/dhcpd.conf is not present
+
+* Sat Jun 27 1998 Jeff Johnson &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">jbj at redhat.com</A>&gt;
+- Upgraded to 2.0b1pl6 (patch1 no longer needed).
+
+* Thu Jun 11 1998 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- applied patch from Chris Evans which makes the server a bit more paranoid
+  about dhcp requests coming in from the wire
+
+* Mon Jun 01 1998 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- updated to dhcp 2.0b1pl1
+- got proper man pages in the package
+
+* Tue Mar 31 1998 Erik Troan &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">ewt at redhat.com</A>&gt;
+- updated to build in a buildroot properly
+- don't package up the client, as it doens't work very well &lt;sigh&gt;
+
+* Tue Mar 17 1998 Bryan C. Andregg &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bandregg at redhat.com</A>&gt;
+- Build rooted and corrected file listing.
+
+* Mon Mar 16 1998 Mike Wangsmo &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">wanger at redhat.com</A>&gt;
+- removed the actual inet.d links (chkconfig takes care of this for us)
+  and made the %postun section handle upgrades.
+
+* Mon Mar 16 1998 Bryan C. Andregg &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">bandregg at redhat.com</A>&gt;
+- First package.


Property changes on: trunk/rpms/dhcp-ldap/dhcp-ldap.spec
___________________________________________________________________
Name: svn:keywords
   + Id Revision
Name: svn:eol-style
   + native

Added: trunk/rpms/dhcp-ldap/dhcpd-manpage.patch
===================================================================
--- trunk/rpms/dhcp-ldap/dhcpd-manpage.patch	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcpd-manpage.patch	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,52 @@
+*** dhcp-3.0pl1/server/dhcpd.conf.5~	2003-03-05 00:59:56.000000000 -0500
+--- dhcp-3.0pl1/server/dhcpd.conf.5	2003-03-05 01:00:36.000000000 -0500
+***************
+*** 1106,1116 ****
+  one for the zone containing A records that will be updates and one for
+  the zone containing PTR records - for ISC BIND, something like this:
+  .PP
+  .nf
+  key DHCP_UPDATER {
+!   algorithm HMAC-MD5.SIG-ALG.REG.INT;
+    secret pRP5FapFoJ95JEL06sv4PQ==;
+  };
+  
+  zone &quot;example.org&quot; {
+  	type master;
+--- 1106,1116 ----
+  one for the zone containing A records that will be updates and one for
+  the zone containing PTR records - for ISC BIND, something like this:
+  .PP
+  .nf
+  key DHCP_UPDATER {
+!   algorithm hmac-md5;
+    secret pRP5FapFoJ95JEL06sv4PQ==;
+  };
+  
+  zone &quot;example.org&quot; {
+  	type master;
+***************
+*** 1129,1139 ****
+  these zones.   To do so, you need to add something like this to your
+  dhcpd.conf file:
+  .PP
+  .nf
+  key DHCP_UPDATER {
+!   algorithm HMAC-MD5.SIG-ALG.REG.INT;
+    secret pRP5FapFoJ95JEL06sv4PQ==;
+  };
+  
+  zone EXAMPLE.ORG. {
+    primary 127.0.0.1;
+--- 1129,1139 ----
+  these zones.   To do so, you need to add something like this to your
+  dhcpd.conf file:
+  .PP
+  .nf
+  key DHCP_UPDATER {
+!   algorithm hmac-md5;
+    secret pRP5FapFoJ95JEL06sv4PQ==;
+  };
+  
+  zone EXAMPLE.ORG. {
+    primary 127.0.0.1;

Added: trunk/rpms/dhcp-ldap/dhcpd.conf
===================================================================
--- trunk/rpms/dhcp-ldap/dhcpd.conf	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcpd.conf	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,4 @@
+#
+# DHCP Server Configuration file.
+#   see /usr/share/doc/dhcp*/dhcpd.conf.sample  
+#
\ No newline at end of file

Added: trunk/rpms/dhcp-ldap/dhcpd.conf.sample
===================================================================
--- trunk/rpms/dhcp-ldap/dhcpd.conf.sample	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcpd.conf.sample	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,31 @@
+ddns-update-style interim;
+ignore client-updates;
+
+subnet 192.168.0.0 netmask 255.255.255.0 {
+
+# --- default gateway
+	option routers			192.168.0.1;
+	option subnet-mask		255.255.255.0;
+
+	option nis-domain		&quot;domain.org&quot;;
+	option domain-name		&quot;domain.org&quot;;
+	option domain-name-servers	192.168.1.1;
+
+	option time-offset		-18000;	# Eastern Standard Time
+#	option ntp-servers		192.168.1.1;
+#	option netbios-name-servers	192.168.1.1;
+# --- Selects point-to-point node (default is hybrid). Don't change this unless
+# -- you understand Netbios very well
+#	option netbios-node-type 2;
+
+	range dynamic-bootp 192.168.0.128 192.168.0.254;
+	default-lease-time 21600;
+	max-lease-time 43200;
+
+	# we want the nameserver to appear at a fixed address
+	host ns {
+		next-server marvin.redhat.com;
+		hardware ethernet 12:34:56:78:AB:CD;
+		fixed-address 207.175.42.254;
+	}
+}

Added: trunk/rpms/dhcp-ldap/dhcpd.init
===================================================================
--- trunk/rpms/dhcp-ldap/dhcpd.init	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcpd.init	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,89 @@
+#!/bin/sh
+#
+# dhcpd         This shell script takes care of starting and stopping
+#               dhcpd.
+#
+# chkconfig: - 65 35
+# description: dhcpd provide access to Dynamic Host Control Protocol.
+
+# Source function library.
+. /etc/rc.d/init.d/functions
+
+# Source networking configuration.
+. /etc/sysconfig/network
+. /etc/sysconfig/dhcpd
+
+# Check that networking is up.
+[ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0
+
+[ -f /usr/sbin/dhcpd ] || exit 0
+[ -f /etc/dhcpd.conf ] || exit 0
+if [ ! -f /var/lib/dhcp/dhcpd.leases ] ; then
+   touch /var/lib/dhcp/dhcpd.leases
+   [ -x /sbin/restorecon ] &amp;&amp; [ -d /selinux ] &amp;&amp; /sbin/restorecon /var/lib/dhcp/dhcpd.leases 
+fi
+RETVAL=0
+prog=&quot;dhcpd&quot;
+
+configtest()
+{
+	/usr/sbin/dhcpd -t	
+	return $?
+}
+
+start() {
+	# Start daemons.
+	echo -n $&quot;Starting $prog: &quot;
+	daemon /usr/sbin/dhcpd ${DHCPDARGS}
+	RETVAL=$?
+	echo
+	[ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/dhcpd
+	return $RETVAL
+}
+
+stop() {
+	# Stop daemons.
+	echo -n $&quot;Shutting down $prog: &quot;
+	killproc dhcpd
+	RETVAL=$?
+	echo
+	[ $RETVAL -eq 0 ] &amp;&amp; rm -f /var/lock/subsys/dhcpd
+	return $RETVAL
+}
+
+# See how we were called.
+case &quot;$1&quot; in
+  start)
+	start
+	;;
+  stop)
+	stop
+	;;
+  restart|reload)
+	configtest || exit $?
+	stop
+	start
+	RETVAL=$?
+	;;
+  condrestart)
+	if [ -f /var/lock/subsys/dhcpd ]; then
+	    stop
+	    start
+	    RETVAL=$?
+	fi
+	;;
+  configtest)
+	configtest
+	RETVAL=$?
+	;;
+  status)
+	status dhcpd
+	RETVAL=$?
+	;;
+  *)
+	echo $&quot;Usage: $0 {start|stop|restart|condrestart|configtest|status}&quot;
+	exit 1
+esac
+
+exit $RETVAL
+

Added: trunk/rpms/dhcp-ldap/dhcptables.pl
===================================================================
--- trunk/rpms/dhcp-ldap/dhcptables.pl	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcptables.pl	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,170 @@
+#!/usr/bin/perl
+#
+#  dhcptables.pl
+#
+#  Parse the ISC DHCP common/tables.c to produce a
+#  table of currently defined dhcp options as either
+#  a C header, a PERL hash, a python dict, or a text file.
+#
+#  Arguments:
+#  
+#  &lt;filename&gt; :       alternative location of tables.c - default: ./common/tables.c
+#                     If ./common/tables.c does not exist, and no filename is given,
+#                     expects tables.c to be on &lt;STDIN&gt; .
+#  -c   / --c:        produce C header on stdout (the default)
+#  -pe  / --perl:     produce perl hash on stdout
+#  -py  / --python:   produce python dict on stdout
+#  -d   / --doc:      produce plain text / CSV spreadsheet table on stdout
+#
+use Getopt::Long;
+use IO::Handle;
+
+my($c_header, $perl_hash, $python_dict, $doc_table)=(0,0,0,0);
+
+if ( ! GetOptions('c'     =&gt; \$c_header,
+		  'perl'  =&gt; \$perl_hash,
+		  'python'=&gt; \$python_dict,
+		  'doc'   =&gt; \$doc_table
+		  ) 
+   )
+{
+    print &quot;Usage:\n&quot;,
+'  &lt;filename&gt; :       alternative location of ISC DHCP tables.c - default: ./common/tables.c
+                     If ./common/tables.c does not exist, and no filename is given,
+                     expects tables.c to be on the standard input .
+  -c   / --c:        produce C header on stdout (the default)
+  -pe  / --perl:     produce perl hash on stdout
+  -py  / --python:   produce python dict on stdout
+  -d   / --doc:      produce plain text / CSV spreadsheet table on stdout',
+    &quot;\n&quot;;
+    exit(1);
+};
+
+my($tables_c_name) = ($#ARGV &gt; -1) ?  shift(@ARGV) : &quot;common/tables.c&quot;;
+
+if( -r $tables_c_name )
+{
+    close STDIN;
+    open(STDIN, '&lt;'.$tables_c_name) || die(&quot;Cannot open $tables_c_name: $? $!&quot;);
+};
+
+$universes={};
+while(&lt;&gt;)
+{
+    if( /^\s*{\s*\&quot;([^\&quot;]+)\&quot;[,\s]*\&quot;([^\&quot;]*)\&quot;[,\s]*&amp;([^_]+)_universe[,\s]*(\d+)/ ) #\s*}[\s\n\r]*$/ )
+    {
+	if( ! exists ${$universes}{$3} )
+	{
+	    ${$universes}{$3} = {};
+	};
+        ${ ${$universes} { $3 } }{ $1 }={ 'type' =&gt; $2, 'code' =&gt; $4 };
+    };
+};
+if ( $perl_hash )
+{
+    print '# DHCP Options:
+%dhcp_options = (',&quot;\n&quot;;
+}elsif 
+   ( $python_dict )
+{
+    print '# DHCP Options:
+dhcp_options = [',&quot;\n&quot;;
+}elsif
+   ( $doc_table )
+{
+    print &quot;dhcp_universe_name\tdhcp_option_name\tdhcp_option_code\tdhcp_option_type\n&quot;;
+}else # $c_header
+{
+    $c_header = 1;
+    print '/* DHCP Options: 
+*/
+#ifndef DHCP_OPTION_H
+#define DHCP_OPTION_H
+#ifndef DHCP_OPTION_EXTRA_MEMBER_DECL
+#define DHCP_OPTION_EXTRA_MEMBER_DECL
+#endif
+#ifndef DHCP_OPTION_EXTRA_MEMBER_INITIALIZER
+#define DOEMI
+#else
+#define DOEMI DHCP_OPTION_EXTRA_MEMBER_INITIALIZER
+#endif
+enum dhcp_universe_code { DHCP_UNIVERSE, NWIP_UNIVERSE, FQDN_UNIVERSE };
+struct dhcp_option 
+{   unsigned char dhcp_universe_code, 
+                  dhcp_option_code;
+    unsigned short flags;
+    const char   *dhcp_option_name;
+    const char   *dhcp_option_format;
+    DHCP_OPTION_EXTRA_MEMBER_DECL
+} dhcp_options [] =
+{',&quot;\n&quot;;
+}
+    
+foreach $u ( sort keys %{$universes} )
+{
+    if ( $perl_hash )
+    {
+	print &quot;\t'&quot;,$u,&quot;',\n\t{\n&quot;;
+    }
+    elsif
+       ( $python_dict )
+    {
+	print &quot;\t'&quot;,$u,&quot;' = {&quot;, &quot;\n&quot;;
+    };
+    foreach $o ( sort { ${${${$universes}{$u}}{$a}}{'code'} &lt;=&gt; ${${${$universes}{$u}}{$b}}{'code'} } keys %{${$universes}{$u}} )
+    {
+	if( $o =~ /^unknown-/ )
+	{
+	    next;
+	};
+	if ( $c_header )
+        {
+	    print &quot;\t{ &quot;, 
+	          ($u eq 'dhcp') 
+		  ? 'DHCP_UNIVERSE'
+		  :($u eq 'nwip') 
+		  ? 'NWIP_UNIVERSE'
+		  :($u eq 'fqdn')
+		  ? 'FQDN_UNIVERSE'
+		  : 'DHCP_UNIVERSE',
+		  ',',&quot;\t&quot;,
+		  ${${${$universes}{$u}}{$o}}{'code'},
+		  &quot;,\t0,\t&quot;,'&quot;',
+		  $o,
+		  '&quot;,',&quot;\t\t\t&quot;,'&quot;',
+		  ${${${$universes}{$u}}{$o}}{'type'},
+		  '&quot;', &quot;\tDOEMI &quot;,
+		  &quot;},\n&quot;;  
+	}elsif
+	   ( $perl_hash )
+        {
+	    print &quot;\t\t'&quot;,$o,&quot;'&quot;,' =&gt; { ',&quot;'code'&quot;, ' =&gt; ', ${${${$universes}{$u}}{$o}}{'code'} ,',',
+	                            &quot;\t'type'&quot;, ' =&gt; ',&quot;'&quot;, ${${${$universes}{$u}}{$o}}{'type'} ,&quot;'&quot;,
+            &quot; },\n&quot;;	    
+	}elsif
+	   ( $python_dict )
+        {
+	    print &quot;\t\t'&quot;,$o,&quot;' : { 'type':'&quot;,${${${$universes}{$u}}{$o}}{'type'},&quot;'&quot;, 
+	                         &quot;, 'code':&quot; ,${${${$universes}{$u}}{$o}}{'code'},&quot; },\n&quot;;
+	}else
+	{
+	    print $u,&quot;\t&quot;,$o,&quot;\t&quot;,${${${$universes}{$u}}{$o}}{'code'}, &quot;\t&quot;, ${${${$universes}{$u}}{$o}}{'type'},&quot;\n&quot;;
+	};
+    };
+    if( $perl_hash || $python_dict )
+    {
+	print &quot;\t},\n&quot;;
+    };
+};
+if( $perl_hash )
+{
+    print &quot;\n);\n&quot;;
+}elsif
+  ( $python_dict )
+{
+    print &quot;\n};\n&quot;
+}elsif
+  ( $c_header )
+{
+    print &quot;\n};\n#endif\n&quot;;
+};

Added: trunk/rpms/dhcp-ldap/dhcrelay.init
===================================================================
--- trunk/rpms/dhcp-ldap/dhcrelay.init	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/dhcrelay.init	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,82 @@
+#!/bin/sh
+#
+# dhcrelay      This shell script takes care of starting and stopping
+#               dhcrelay.
+#
+# chkconfig: - 66 34
+# description: dhcrelay provides a relay for Dynamic Host Control Protocol.
+
+# Source function library.
+. /etc/rc.d/init.d/functions
+
+# Source networking configuration.
+. /etc/sysconfig/network
+
+# Source dhcrelay configuration. We can't default a DHCPSERVERS entry!
+if [ -f /etc/sysconfig/dhcrelay ] ; then
+	. /etc/sysconfig/dhcrelay
+	[ -n &quot;$DHCPSERVERS&quot; ] || exit 0
+else
+	exit 0
+fi
+
+# Check that networking is up.
+[ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0
+
+[ -f /usr/sbin/dhcrelay ] || exit 0
+
+RETVAL=0
+prog=&quot;dhcrelay&quot;
+
+start() {
+	# Start daemons.
+	echo -n $&quot;Starting $prog: &quot;
+	daemon /usr/sbin/dhcrelay \
+		$([ -n &quot;$INTERFACES&quot; ] &amp;&amp; for int in $INTERFACES ; do echo -n &quot; -i $int&quot; ; done) \
+		$DHCPSERVERS
+	RETVAL=$?
+	echo
+	[ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/dhcrelay
+	return $RETVAL
+}
+
+stop() {
+	# Stop daemons.
+	echo -n $&quot;Shutting down $prog: &quot;
+	killproc dhcrelay
+	RETVAL=$?
+	echo
+	[ $RETVAL -eq 0 ] &amp;&amp; rm -f /var/lock/subsys/dhcrelay
+	return $RETVAL
+}
+
+# See how we were called.
+case &quot;$1&quot; in
+  start)
+	start
+	;;
+  stop)
+	stop
+	;;
+  restart|reload)
+	stop
+	start
+	RETVAL=$?
+	;;
+  condrestart)
+	if [ -f /var/lock/subsys/dhcrelay ]; then
+	    stop
+	    start
+	    RETVAL=$?
+	fi
+	;;
+  status)
+	status dhcrelay
+	RETVAL=$?
+	;;
+  *)
+	echo $&quot;Usage: $0 {start|stop|restart|condrestart|status}&quot;
+	exit 1
+esac
+
+exit $RETVAL

Added: trunk/rpms/dhcp-ldap/libdhcp4client.pc
===================================================================
--- trunk/rpms/dhcp-ldap/libdhcp4client.pc	                        (rev 0)
+++ trunk/rpms/dhcp-ldap/libdhcp4client.pc	2007-10-29 16:29:56 UTC (rev 5946)
@@ -0,0 +1,7 @@
+ISC.Cflags=-I/usr/include/dhcp4client/isc_dhcp
+
+Name: libdhcp4client
+Description: ISC DHCP IPv4 client library
+Version: @DHCP_VERSION@
+Libs: -ldhcp4client
+Cflags: -I/usr/include/dhcp4client

Modified: trunk/rpms/drupal4/drupal4.spec
===================================================================
--- trunk/rpms/drupal4/drupal4.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/drupal4/drupal4.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -5,7 +5,7 @@
 
 Summary: Drupal CMS
 Name: drupal4
-Version: 4.7.7
+Version: 4.7.8
 Release: 1
 License: GPL
 Group: Development/Languages
@@ -16,8 +16,12 @@
 
 BuildArch: noarch
 BuildRequires: php &gt;= 4.3.3
-Requires: httpd, mysql, php &gt;= 4.3.3, php-mysql &gt;= 4.3.3
+Requires: httpd, mysql, php &gt;= 4.3.3
+Requires: php-gd, php-mbstring, php-mysql
 
+Obsoletes: drupal &lt;= %{version}-%{release}
+Provides: drupal = %{version}-%{release}
+
 %description
 Drupal is an open source content management platform. Drupal is equipped
 with a powerful blend of features, Drupal can support a variety of
@@ -52,5 +56,8 @@
 %{_localstatedir}/www/drupal-%{version}/
 
 %changelog
+* Sun Oct 21 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 4.7.8-1
+- Updated to release 4.8.1.
+
 * Sun Sep 30 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 4.7.7-1
 - Initial package. (using DAR)

Modified: trunk/rpms/drupal5/drupal5.spec
===================================================================
--- trunk/rpms/drupal5/drupal5.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/drupal5/drupal5.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -5,8 +5,8 @@
 
 Summary: Drupal CMS
 Name: drupal5
-Version: 5.2
-Release: 3
+Version: 5.3
+Release: 1
 License: GPL
 Group: Development/Languages
 URL: <A HREF="http://drupal.org/">http://drupal.org/</A>
@@ -19,6 +19,9 @@
 Requires: httpd, mysql, php &gt;= 4.3.3
 Requires: php-gd, php-mbstring, php-mysql
 
+Obsoletes: drupal &lt;= %{version}-%{release}
+Provides: drupal = %{version}-%{release}
+
 %description
 Drupal is an open source content management platform. Drupal is equipped
 with a powerful blend of features, Drupal can support a variety of
@@ -42,6 +45,7 @@
 %{__install} -Dp -m0644 .htaccess %{buildroot}%{_localstatedir}/www/drupal-%{version}/.htaccess
 %{__cp} -av *.php %{buildroot}%{_localstatedir}/www/drupal-%{version}/
 %{__cp} -av includes/ misc/ modules/ profiles/ scripts/ sites/ themes/ %{buildroot}%{_localstatedir}/www/drupal-%{version}/
+%{__mkdir} %{buildroot}%{_localstatedir}/www/drupal-%{version}/files/
 
 %clean
 %{__rm} -rf %{buildroot}
@@ -54,6 +58,9 @@
 %{_localstatedir}/www/drupal-%{version}/
 
 %changelog
+* Sun Oct 21 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 5.3-1
+- Updated to release 5.3.
+
 * Fri Oct 05 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 5.2-3
 - Fixed typo in Requires. (Se&#195;&#161;n O Sullivan)
 

Modified: trunk/rpms/fuse-smb/fuse-smb.spec
===================================================================
--- trunk/rpms/fuse-smb/fuse-smb.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/fuse-smb/fuse-smb.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -5,7 +5,7 @@
 
 Summary: FUSE-Filesystem to fast and easy access remote resources via SMB
 Name: fuse-smb
-Version: 0.8.5
+Version: 0.8.7
 Release: 1
 License: GPL
 Group: System Environment/Kernel
@@ -46,5 +46,8 @@
 %{_bindir}/fusesmb.cache
 
 %changelog 
+* Wed Oct 24 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.7-1
+- Updated to release 0.8.7.
+
 * Sat May 12 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 0.8.5-1
 - Initial package. (using DAR)

Modified: trunk/rpms/phpmyadmin/phpmyadmin.spec
===================================================================
--- trunk/rpms/phpmyadmin/phpmyadmin.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/phpmyadmin/phpmyadmin.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -70,8 +70,8 @@
 %config(noreplace) %{_datadir}/phpmyadmin/config.inc.php
 
 %changelog
-* Wed Oct 17 2007 Jim &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">quien-sabe at metaorg.com</A>&gt; - 2.11.1.2-1
-- Updated to release 2.11.1.2-1
+* Wed Oct 17 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 2.11.1.2-1
+- Updated to release 2.11.1.2.
 
 * Sat Sep 22 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 2.11.1-1
 - Updated to release 2.11.1.

Modified: trunk/rpms/shntool/shntool.spec
===================================================================
--- trunk/rpms/shntool/shntool.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/shntool/shntool.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -3,7 +3,7 @@
 
 Summary: Multi-purpose WAVE data processing and reporting utility
 Name: shntool
-Version: 3.0.4
+Version: 3.0.5
 Release: 1
 License: GPL
 Group: Applications/Multimedia
@@ -57,6 +57,9 @@
 %{_bindir}/shntrim
 
 %changelog
+* Mon Oct 22 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.0.5-1
+- Updated to release 3.0.5.
+
 * Sat Sep 08 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.0.4-1
 - Updated to release 3.0.4.
 

Modified: trunk/rpms/tcpreplay/tcpreplay.spec
===================================================================
--- trunk/rpms/tcpreplay/tcpreplay.spec	2007-10-29 12:34:22 UTC (rev 5945)
+++ trunk/rpms/tcpreplay/tcpreplay.spec	2007-10-29 16:29:56 UTC (rev 5946)
@@ -10,7 +10,7 @@
 
 Summary: Replay captured network traffic
 Name: tcpreplay
-Version: 3.2.0
+Version: 3.2.1
 Release: 1
 License: BSD
 Group: Applications/Internet
@@ -74,6 +74,9 @@
 %{_bindir}/tcprewrite
 
 %changelog
+* Fri Oct 26 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.2.1-1
+- Updated to release 3.2.1.
+
 * Mon Aug 27 2007 Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt; - 3.2.0-1
 - Updated to release 3.2.0.
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004744.html">[svn] r5945 - in trunk/rpms: aria2 clex csockets gnofract4d kbibtex	mcabber
</A></li>
	<LI>Next message: <A HREF="004746.html">[svn] r5947 - in trunk/rpms: . collectd ipmiutil libnet
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4745">[ date ]</a>
              <a href="thread.html#4745">[ thread ]</a>
              <a href="subject.html#4745">[ subject ]</a>
              <a href="author.html#4745">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
