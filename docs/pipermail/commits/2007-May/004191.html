<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 <HEAD>
   <TITLE> [svn] r5392 - in trunk/tools/dstat: . examples plugins
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5392%20-%20in%20trunk/tools/dstat%3A%20.%20examples%20plugins&In-Reply-To=%3C20070512041229.83543944B64%40pooch.vmhosting.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004190.html">
   <LINK REL="Next"  HREF="004192.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[svn] r5392 - in trunk/tools/dstat: . examples plugins</H1>
    <B>packagers at lists.rpmforge.net</B> 
    <A HREF="mailto:commits%40lists.repoforge.org?Subject=Re:%20Re%3A%20%5Bsvn%5D%20r5392%20-%20in%20trunk/tools/dstat%3A%20.%20examples%20plugins&In-Reply-To=%3C20070512041229.83543944B64%40pooch.vmhosting.org%3E"
       TITLE="[svn] r5392 - in trunk/tools/dstat: . examples plugins">packagers at lists.rpmforge.net
       </A><BR>
    <I>Sat May 12 06:12:29 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004190.html">[svn] r5391 - in trunk/tools/mrepo: . docs tests
</A></li>
        <LI>Next message: <A HREF="004192.html">[svn] r5393 - in trunk/rpms: . cft cobbler facter koan pam_shield	pan puppet python-cheetah ruby-fam ruby-rpm vncreflector
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4191">[ date ]</a>
              <a href="thread.html#4191">[ thread ]</a>
              <a href="subject.html#4191">[ subject ]</a>
              <a href="author.html#4191">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dag
Date: 2007-05-12 06:12:27 +0200 (Sat, 12 May 2007)
New Revision: 5392

Modified:
   trunk/tools/dstat/dstat
   trunk/tools/dstat/dstat15
   trunk/tools/dstat/examples/curstest
   trunk/tools/dstat/examples/devtest.py
   trunk/tools/dstat/examples/mmpipe.py
   trunk/tools/dstat/examples/mstat.py
   trunk/tools/dstat/examples/tdbtest
   trunk/tools/dstat/plugins/dstat_app.py
   trunk/tools/dstat/plugins/dstat_battery.py
   trunk/tools/dstat/plugins/dstat_cpufreq.py
   trunk/tools/dstat/plugins/dstat_dbus.py
   trunk/tools/dstat/plugins/dstat_freespace.py
   trunk/tools/dstat/plugins/dstat_gpfs.py
   trunk/tools/dstat/plugins/dstat_gpfsop.py
   trunk/tools/dstat/plugins/dstat_nfs3.py
   trunk/tools/dstat/plugins/dstat_nfs3op.py
   trunk/tools/dstat/plugins/dstat_nfsd3.py
   trunk/tools/dstat/plugins/dstat_nfsd3op.py
   trunk/tools/dstat/plugins/dstat_postfix.py
   trunk/tools/dstat/plugins/dstat_rpc.py
   trunk/tools/dstat/plugins/dstat_rpcd.py
   trunk/tools/dstat/plugins/dstat_sendmail.py
   trunk/tools/dstat/plugins/dstat_thermal.py
   trunk/tools/dstat/plugins/dstat_utmp.py
   trunk/tools/dstat/plugins/dstat_vmkhba.py
   trunk/tools/dstat/plugins/dstat_vmkint.py
   trunk/tools/dstat/plugins/dstat_vzcpu.py
   trunk/tools/dstat/plugins/dstat_vzubc.py
   trunk/tools/dstat/plugins/dstat_wifi.py
Log:
Retab

Modified: trunk/tools/dstat/dstat
===================================================================
--- trunk/tools/dstat/dstat	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/dstat	2007-05-12 04:12:27 UTC (rev 5392)
@@ -19,219 +19,219 @@
 VERSION = '0.6.6'
 
 def inspath(path):
-	if os.path.isdir(path) and path not in sys.path:
-		sys.path.insert(1, path)
+    if os.path.isdir(path) and path not in sys.path:
+        sys.path.insert(1, path)
 
 try:
-	import sys, signal, os, re, time
-	import types, signal, resource, getpass
-	inspath('/usr/local/share/dstat/')
-	inspath('/usr/share/dstat/')
-	inspath(os.path.abspath(os.path.dirname(sys.argv[0])) + '/plugins/')	# binary path + /plugins/
-	inspath(os.getcwd() + '/plugins/')										# current path + /plugins/
-	inspath(os.getcwd())													# current path
-	inspath(os.path.expanduser('~/.dstat/'))								# home + /.dstat/
+    import sys, signal, os, re, time
+    import types, signal, resource, getpass
+    inspath('/usr/local/share/dstat/')
+    inspath('/usr/share/dstat/')
+    inspath(os.path.abspath(os.path.dirname(sys.argv[0])) + '/plugins/')    # binary path + /plugins/
+    inspath(os.getcwd() + '/plugins/')                                      # current path + /plugins/
+    inspath(os.getcwd())                                                    # current path
+    inspath(os.path.expanduser('~/.dstat/'))                                # home + /.dstat/
 except KeyboardInterrupt, e:
-	pass
+    pass
 
 if sys.version_info &lt; (2, 2):
-	sys.exit('error: Python 2.2 or later required, try dstat15 instead')
+    sys.exit('error: Python 2.2 or later required, try dstat15 instead')
 
 ### Workaround for python &lt;= 2.2.1
 try:
-	True, False
+    True, False
 except NameError:
-	True = 1
-	False = 0
+    True = 1
+    False = 0
 
 ### Workaround for python &lt; 2.3
 #if 'enumerate' not in __builtins__.__dict__.keys():
 if sys.version_info &lt; (2, 3) and sys.version_info &gt;= (2, 2):
-	def enumerate(sequence):
-		index = 0
-		for item in sequence:
-			yield index, item
-			index = index + 1
+    def enumerate(sequence):
+        index = 0
+        for item in sequence:
+            yield index, item
+            index = index + 1
 elif sys.version_info &lt; (2, 2):
-	def enumerate(sequence):
-		index = 0
-		list = []
-		for item in sequence:
-			list.append((index, item))
-			index = index + 1
-		return list
+    def enumerate(sequence):
+        index = 0
+        list = []
+        for item in sequence:
+            list.append((index, item))
+            index = index + 1
+        return list
 
 ### Workaround for python &lt; 2.3
 #if 'sum' not in __builtins__.__dict__.keys():
 if sys.version_info &lt; (2, 3):
-	def sum(sequence):
-		ret = 0
-		for i in sequence:
-			ret = ret + i
-		return ret
+    def sum(sequence):
+        ret = 0
+        for i in sequence:
+            ret = ret + i
+        return ret
 
 class Options:
-	def __init__(self, args):
-		self.args = args
-		self.count = -1
-		self.cpulist = None
-		self.debug = 0
-		self.delay = 1
-		self.disklist = None
-		self.full = False
-		self.integer = False
-		self.intlist = None
-		self.netlist = None
-		self.swaplist = None
-		self.color = False
-		self.update = True
-		self.header = True
-		self.output = False
-		self.isatty = sys.stdout.isatty()
+    def __init__(self, args):
+        self.args = args
+        self.count = -1
+        self.cpulist = None
+        self.debug = 0
+        self.delay = 1
+        self.disklist = None
+        self.full = False
+        self.integer = False
+        self.intlist = None
+        self.netlist = None
+        self.swaplist = None
+        self.color = False
+        self.update = True
+        self.header = True
+        self.output = False
+        self.isatty = sys.stdout.isatty()
 
-		### Implicit if no terminal is used
-		if not self.isatty:
-			self.update = False
-			self.header = False
+        ### Implicit if no terminal is used
+        if not self.isatty:
+            self.update = False
+            self.header = False
 
-		### Temporary hardcoded for my own project
-		self.diskset = {
-			'local': ('sda', 'hd[a-d]'),
-			'lores': ('sd[b-k]', 'sd[v-z]', 'sda[a-e]'),
-			'hires': ('sd[l-u]', 'sda[f-o]'),
-		}
+        ### Temporary hardcoded for my own project
+        self.diskset = {
+            'local': ('sda', 'hd[a-d]'),
+            'lores': ('sd[b-k]', 'sd[v-z]', 'sda[a-e]'),
+            'hires': ('sd[l-u]', 'sda[f-o]'),
+        }
 
-		try:
-			import getopt
-			opts, args = getopt.getopt (args, 'acdfghilmno:pstTvyC:D:I:M:N:S:V',
-				['cpu', 'disk', 'epoch', 'int', 'ipc', 'load', 'lock', 'mem', 'net',
-				'page', 'proc', 'raw', 'swap', 'sys', 'tcp', 'time', 'udp', 'unix', 
-				'all', 'debug', 'full', 'help', 'integer', 'mods', 'modules', 'nocolor',
-				'noheaders', 'noupdate', 'output=', 'version', 'vmstat'])
-		except getopt.error, exc:
-			print 'dstat: %s, try dstat -h for a list of all the options' % str(exc)
-			exit(1)
+        try:
+            import getopt
+            opts, args = getopt.getopt (args, 'acdfghilmno:pstTvyC:D:I:M:N:S:V',
+                ['cpu', 'disk', 'epoch', 'int', 'ipc', 'load', 'lock', 'mem', 'net',
+                'page', 'proc', 'raw', 'swap', 'sys', 'tcp', 'time', 'udp', 'unix', 
+                'all', 'debug', 'full', 'help', 'integer', 'mods', 'modules', 'nocolor',
+                'noheaders', 'noupdate', 'output=', 'version', 'vmstat'])
+        except getopt.error, exc:
+            print 'dstat: %s, try dstat -h for a list of all the options' % str(exc)
+            exit(1)
 
-		self.modlist = []
+        self.modlist = []
 
-		for opt, arg in opts:
-			if opt in ['-c', '--cpu']:
-				self.modlist.append('cpu')
-			elif opt in ['-C']:
-				self.cpulist = arg.split(',')
-			elif opt in ['-d', '--disk']:
-				self.modlist.append('disk')
-			elif opt in ['-D']:
-				self.disklist = arg.split(',')
-			elif opt in ['--debug']:
-				self.debug = self.debug + 1
-			elif opt in ['-g', '--page']:
-				self.modlist.append('page')
-			elif opt in ['-i', '--int']:
-				self.modlist.append('int')
-			elif opt in ['-I']:
-				self.intlist = arg.split(',')
-			elif opt in ['--ipc']:
-				self.modlist.append('ipc')
-			elif opt in ['-l', '--load']:
-				self.modlist.append('load')
-			elif opt in ['--lock']:
-				self.modlist.append('lock')
-			elif opt in ['-m', '--mem']:
-				self.modlist.append('mem')
-			elif opt in ['-M', '--mods', '--modules']:
-				self.modlist = self.modlist + arg.split(',')
-			elif opt in ['-n', '--net']:
-				self.modlist.append('net')
-			elif opt in ['-N']:
-				self.netlist = arg.split(',')
-			elif opt in ['-p', '--proc']:
-				self.modlist.append('proc')
-			elif opt in ['--raw']:
-				self.modlist.append('raw')
-			elif opt in ['-s', '--swap']:
-				self.modlist.append('swap')
-			elif opt in ['-S']:
-				self.swaplist = arg.split(',')
-			elif opt in ['--tcp']:
-				self.modlist.append('tcp')
-			elif opt in ['-t', '--time']:
-				self.modlist.append('time')
-			elif opt in ['-T', '--epoch']:
-				self.modlist.append('epoch')
-			elif opt in ['--udp']:
-				self.modlist.append('udp')
-			elif opt in ['--unix']:
-				self.modlist.append('unix')
-			elif opt in ['-y', '--sys']:
-				self.modlist.append('sys')
+        for opt, arg in opts:
+            if opt in ['-c', '--cpu']:
+                self.modlist.append('cpu')
+            elif opt in ['-C']:
+                self.cpulist = arg.split(',')
+            elif opt in ['-d', '--disk']:
+                self.modlist.append('disk')
+            elif opt in ['-D']:
+                self.disklist = arg.split(',')
+            elif opt in ['--debug']:
+                self.debug = self.debug + 1
+            elif opt in ['-g', '--page']:
+                self.modlist.append('page')
+            elif opt in ['-i', '--int']:
+                self.modlist.append('int')
+            elif opt in ['-I']:
+                self.intlist = arg.split(',')
+            elif opt in ['--ipc']:
+                self.modlist.append('ipc')
+            elif opt in ['-l', '--load']:
+                self.modlist.append('load')
+            elif opt in ['--lock']:
+                self.modlist.append('lock')
+            elif opt in ['-m', '--mem']:
+                self.modlist.append('mem')
+            elif opt in ['-M', '--mods', '--modules']:
+                self.modlist = self.modlist + arg.split(',')
+            elif opt in ['-n', '--net']:
+                self.modlist.append('net')
+            elif opt in ['-N']:
+                self.netlist = arg.split(',')
+            elif opt in ['-p', '--proc']:
+                self.modlist.append('proc')
+            elif opt in ['--raw']:
+                self.modlist.append('raw')
+            elif opt in ['-s', '--swap']:
+                self.modlist.append('swap')
+            elif opt in ['-S']:
+                self.swaplist = arg.split(',')
+            elif opt in ['--tcp']:
+                self.modlist.append('tcp')
+            elif opt in ['-t', '--time']:
+                self.modlist.append('time')
+            elif opt in ['-T', '--epoch']:
+                self.modlist.append('epoch')
+            elif opt in ['--udp']:
+                self.modlist.append('udp')
+            elif opt in ['--unix']:
+                self.modlist.append('unix')
+            elif opt in ['-y', '--sys']:
+                self.modlist.append('sys')
 
-			elif opt in ['-a', '--all']:
-				self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys' ]
-			elif opt in ['-v', '--vmstat']:
-				self.modlist = self.modlist + [ 'proc', 'mem', 'page', 'disk', 'sys', 'cpu' ]
-			elif opt in ['-f', '--full']:
-				self.full = True
+            elif opt in ['-a', '--all']:
+                self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys' ]
+            elif opt in ['-v', '--vmstat']:
+                self.modlist = self.modlist + [ 'proc', 'mem', 'page', 'disk', 'sys', 'cpu' ]
+            elif opt in ['-f', '--full']:
+                self.full = True
 
-			elif opt in ['--integer']:
-				self.integer = True
-			elif opt in ['--nocolor']:
-				self.color = False
-				self.update = False
-			elif opt in ['--noheaders']:
-				self.header = False
-			elif opt in ['--noupdate']:
-				self.update = False
-			elif opt in ['-o', '--output']:
-				self.output = arg
-			elif opt in ['-h', '--help']:
-				self.usage()
-				self.help()
-				exit(0)
-			elif opt in ['-V', '--version']:
-				self.version()
-				exit(0)
+            elif opt in ['--integer']:
+                self.integer = True
+            elif opt in ['--nocolor']:
+                self.color = False
+                self.update = False
+            elif opt in ['--noheaders']:
+                self.header = False
+            elif opt in ['--noupdate']:
+                self.update = False
+            elif opt in ['-o', '--output']:
+                self.output = arg
+            elif opt in ['-h', '--help']:
+                self.usage()
+                self.help()
+                exit(0)
+            elif opt in ['-V', '--version']:
+                self.version()
+                exit(0)
 
-		if not self.modlist:
-			self.modlist = [ 'cpu', 'disk', 'net', 'page', 'sys' ]
+        if not self.modlist:
+            self.modlist = [ 'cpu', 'disk', 'net', 'page', 'sys' ]
 
-		try:
-			if len(args) &gt; 0: self.delay = int(args[0])
-			if len(args) &gt; 1: self.count = int(args[1])
-		except:
-			print 'dstat: incorrect argument, try dstat -h for the correct syntax'
-			exit(1)
+        try:
+            if len(args) &gt; 0: self.delay = int(args[0])
+            if len(args) &gt; 1: self.count = int(args[1])
+        except:
+            print 'dstat: incorrect argument, try dstat -h for the correct syntax'
+            exit(1)
 
-		if self.delay &lt;= 0:
-			print 'dstat: delay must be an integer, greater than zero'
-			exit(1)
+        if self.delay &lt;= 0:
+            print 'dstat: delay must be an integer, greater than zero'
+            exit(1)
 
-	def version(self):
-		print 'Dstat %s' % VERSION
-		print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
-		print 'Homepage at <A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>'
-		print
-		print 'Platform %s/%s' % (os.name, sys.platform)
-		print 'Kernel %s' % os.uname()[2]
-		print 'Python %s' % sys.version
-		print
-		rows, cols = gettermsize()
-		print 'Terminal size: %d lines, %d columns' % (rows, cols)
-		print
-		print 'Processors: %d' % getcpunr()
-		print 'Pagesize: %d' % resource.getpagesize()
-#		print 'Clock ticks per secs: %d' % os.sysconf('SC_CLK_TCK')
-		print
+    def version(self):
+        print 'Dstat %s' % VERSION
+        print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
+        print 'Homepage at <A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>'
+        print
+        print 'Platform %s/%s' % (os.name, sys.platform)
+        print 'Kernel %s' % os.uname()[2]
+        print 'Python %s' % sys.version
+        print
+        rows, cols = gettermsize()
+        print 'Terminal size: %d lines, %d columns' % (rows, cols)
+        print
+        print 'Processors: %d' % getcpunr()
+        print 'Pagesize: %d' % resource.getpagesize()
+#       print 'Clock ticks per secs: %d' % os.sysconf('SC_CLK_TCK')
+        print
 
-		global op
-		op = self
-		listmodules()
+        global op
+        op = self
+        listmodules()
 
-	def usage(self):
-		print 'Usage: dstat [-afv] [options..] [delay [count]]'
+    def usage(self):
+        print 'Usage: dstat [-afv] [options..] [delay [count]]'
 
-	def help(self):
-		print '''Versatile tool for generating system resource statistics
+    def help(self):
+        print '''Versatile tool for generating system resource statistics
 
 Dstat options:
   -c, --cpu              enable cpu stats
@@ -278,1711 +278,1711 @@
 
 ### START STATS DEFINITIONS ###
 class dstat:
-	### Initialise default variables
-	def init(self, vars=(), len=0):
-		if vars:
-			self.val = {}; self.cn1 = {}; self.cn2 = {}
-			for name in vars:
-				if len &lt;= 1:
-					self.val[name] = self.cn1[name] = self.cn2[name] = 0
-				else:
-					self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
-					for i in range(len):
-						self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
+    ### Initialise default variables
+    def init(self, vars=(), len=0):
+        if vars:
+            self.val = {}; self.cn1 = {}; self.cn2 = {}
+            for name in vars:
+                if len &lt;= 1:
+                    self.val[name] = self.cn1[name] = self.cn2[name] = 0
+                else:
+                    self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
+                    for i in range(len):
+                        self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
 
-	def open(self, *files):
-		&quot;Open stat file descriptor&quot;
-		self.file = []
-		self.fd = []
-		for file in files:
-			fd = dopen(file)
-			if fd:
-				self.file.append(file)
-				self.fd.append(fd)
-			else:
-				raise Exception, 'Cannot open file %s.' % file
+    def open(self, *files):
+        &quot;Open stat file descriptor&quot;
+        self.file = []
+        self.fd = []
+        for file in files:
+            fd = dopen(file)
+            if fd:
+                self.file.append(file)
+                self.fd.append(fd)
+            else:
+                raise Exception, 'Cannot open file %s.' % file
 
-	def readlines(self):
-		for fd in self.fd:
-			fd.seek(0)
-			for line in fd.readlines():
-				yield line
+    def readlines(self):
+        for fd in self.fd:
+            fd.seek(0)
+            for line in fd.readlines():
+                yield line
 
-	def statwidth(self):
-		&quot;Return complete stat width&quot;
-		return len(self.vars) * self.width() + len(self.vars) - 1
+    def statwidth(self):
+        &quot;Return complete stat width&quot;
+        return len(self.vars) * self.width() + len(self.vars) - 1
 
-	def width(self):
-		&quot;Return column width&quot;
-		if isinstance(self.name, types.StringType):
-			return self.format[1]
-		else:
-			return len(self.nick) * self.format[1] + len(self.nick) - 1
+    def width(self):
+        &quot;Return column width&quot;
+        if isinstance(self.name, types.StringType):
+            return self.format[1]
+        else:
+            return len(self.nick) * self.format[1] + len(self.nick) - 1
 
-	def title(self, nr):
-		if nr == 1:
-			return self.title1()
-		else:
-			return self.title2()
+    def title(self, nr):
+        if nr == 1:
+            return self.title1()
+        else:
+            return self.title2()
 
-	def title1(self):
-		ret = ansi['darkblue']
-		if isinstance(self.name, types.StringType):
-			max = self.statwidth()
-			return ret + self.name[0:max].center(max).replace(' ', '-') + ansi['default']
-		for i, name in enumerate(self.name):
-			max = self.width()
-			ret = ret + name[0:max].center(max).replace(' ', '-')
-			if i + 1 != len(self.name): 
-				if op.color:
-					ret = ret + ansi['blue'] + char['dash'] + ansi['darkblue']
-				else:
-					ret = ret + char['space']
-		return ret
+    def title1(self):
+        ret = ansi['darkblue']
+        if isinstance(self.name, types.StringType):
+            max = self.statwidth()
+            return ret + self.name[0:max].center(max).replace(' ', '-') + ansi['default']
+        for i, name in enumerate(self.name):
+            max = self.width()
+            ret = ret + name[0:max].center(max).replace(' ', '-')
+            if i + 1 != len(self.name): 
+                if op.color:
+                    ret = ret + ansi['blue'] + char['dash'] + ansi['darkblue']
+                else:
+                    ret = ret + char['space']
+        return ret
 
-	def title2(self):
-		if isinstance(self.name, types.StringType):
-			ret = ''
-			for i, nick in enumerate(self.nick):
-				ret = ret + ansi['blue'] + ansi['underline'] + nick.center(self.format[1]) + ansi['default']
-				if i + 1 != len(self.nick): ret = ret + char['space']
-			return ret
-		else:
-			ret = ''
-			for i, name in enumerate(self.name):
-				for j, nick in enumerate(self.nick):
-					ret = ret + ansi['blue'] + ansi['underline'] + nick.center(self.format[1]) + ansi['default']
-					if j + 1 != len(self.nick): ret = ret + char['space']
-				if i + 1 != len(self.name): ret = ret + ansi['gray'] + char['colon']
-			return ret
+    def title2(self):
+        if isinstance(self.name, types.StringType):
+            ret = ''
+            for i, nick in enumerate(self.nick):
+                ret = ret + ansi['blue'] + ansi['underline'] + nick.center(self.format[1]) + ansi['default']
+                if i + 1 != len(self.nick): ret = ret + char['space']
+            return ret
+        else:
+            ret = ''
+            for i, name in enumerate(self.name):
+                for j, nick in enumerate(self.nick):
+                    ret = ret + ansi['blue'] + ansi['underline'] + nick.center(self.format[1]) + ansi['default']
+                    if j + 1 != len(self.nick): ret = ret + char['space']
+                if i + 1 != len(self.name): ret = ret + ansi['gray'] + char['colon']
+            return ret
 
-	def titlecsv(self, nr):
-		if nr == 1:
-			return self.titlecsv1()
-		else:
-			return self.titlecsv2()
+    def titlecsv(self, nr):
+        if nr == 1:
+            return self.titlecsv1()
+        else:
+            return self.titlecsv2()
 
-	def titlecsv1(self):
-		if isinstance(self.name, types.StringType):
-			return '&quot;' + self.name + '&quot;' + ',' * (len(self.nick) - 1)
-		else:
-			ret = ''
-			for i, name in enumerate(self.name):
-				ret = ret + '&quot;' + name + '&quot;' + ',' * (len(self.nick) - 1)
-				if i + 1 != len(self.name): ret = ret + ','
-			return ret
+    def titlecsv1(self):
+        if isinstance(self.name, types.StringType):
+            return '&quot;' + self.name + '&quot;' + ',' * (len(self.nick) - 1)
+        else:
+            ret = ''
+            for i, name in enumerate(self.name):
+                ret = ret + '&quot;' + name + '&quot;' + ',' * (len(self.nick) - 1)
+                if i + 1 != len(self.name): ret = ret + ','
+            return ret
 
-	def titlecsv2(self):
-		if isinstance(self.name, types.StringType):
-			ret = ''
-			for i, nick in enumerate(self.nick):
-				ret = ret + '&quot;' + nick + '&quot;'
-				if i + 1 != len(self.nick): ret = ret + ','
-			return ret
-		else:
-			ret = ''
-			for i, name in enumerate(self.name):
-				for j, nick in enumerate(self.nick):
-					ret = ret + '&quot;' + nick + '&quot;'
-					if j + 1 != len(self.nick): ret = ret + ','
-				if i + 1 != len(self.name): ret = ret + ','
-			return ret
+    def titlecsv2(self):
+        if isinstance(self.name, types.StringType):
+            ret = ''
+            for i, nick in enumerate(self.nick):
+                ret = ret + '&quot;' + nick + '&quot;'
+                if i + 1 != len(self.nick): ret = ret + ','
+            return ret
+        else:
+            ret = ''
+            for i, name in enumerate(self.name):
+                for j, nick in enumerate(self.nick):
+                    ret = ret + '&quot;' + nick + '&quot;'
+                    if j + 1 != len(self.nick): ret = ret + ','
+                if i + 1 != len(self.name): ret = ret + ','
+            return ret
 
-	def check(self):
-		&quot;Check if stat is applicable&quot;
-#		if hasattr(self, 'fd') and not self.fd:
-#			raise Exception, 'File %s does not exist' % self.file
-		if not self.vars:
-			raise Exception, 'No objects found, no stats available'
-		if not self.discover:
-			raise Exception, 'No objects discovered, no stats available'
-		if self.width():
-			return True
-		raise Exception, 'Unknown problem, please report'
+    def check(self):
+        &quot;Check if stat is applicable&quot;
+#       if hasattr(self, 'fd') and not self.fd:
+#           raise Exception, 'File %s does not exist' % self.file
+        if not self.vars:
+            raise Exception, 'No objects found, no stats available'
+        if not self.discover:
+            raise Exception, 'No objects discovered, no stats available'
+        if self.width():
+            return True
+        raise Exception, 'Unknown problem, please report'
 
-	def discover(self):
-		return True
+    def discover(self):
+        return True
 
-	def show(self):
-		&quot;Display stat results&quot;
-		line = ''
-		for i, name in enumerate(self.vars):
-			if isinstance(self.val[name], types.TupleType) or isinstance(self.val[name], types.ListType):
-				line = line + cprintlist(self.val[name], self.format)
-				sep = ansi['gray'] + char['colon']
-			else:
-				line = line + cprint(self.val[name], self.format)
-				sep = char['space']
-			if i + 1 != len(self.vars):
-				line = line + sep
-		return line
+    def show(self):
+        &quot;Display stat results&quot;
+        line = ''
+        for i, name in enumerate(self.vars):
+            if isinstance(self.val[name], types.TupleType) or isinstance(self.val[name], types.ListType):
+                line = line + cprintlist(self.val[name], self.format)
+                sep = ansi['gray'] + char['colon']
+            else:
+                line = line + cprint(self.val[name], self.format)
+                sep = char['space']
+            if i + 1 != len(self.vars):
+                line = line + sep
+        return line
 
-	def showend(self, totlist, vislist):
-		if self is not vislist[-1]:
-			return ansi['gray'] + char['pipe']
-		elif totlist != vislist:
-			return ansi['gray'] + char['gt']
-		return ''
+    def showend(self, totlist, vislist):
+        if self is not vislist[-1]:
+            return ansi['gray'] + char['pipe']
+        elif totlist != vislist:
+            return ansi['gray'] + char['gt']
+        return ''
 
-	def showcsv(self):
-		def printcsv(var):
-			if var != round(var):
-				return '%.3f' % var
-			return '%s' % round(var)
+    def showcsv(self):
+        def printcsv(var):
+            if var != round(var):
+                return '%.3f' % var
+            return '%s' % round(var)
 
-		line = ''
-		for i, name in enumerate(self.vars):
-			if isinstance(self.val[name], types.ListType) or isinstance(self.val[name], types.TupleType):
-				for j, val in enumerate(self.val[name]):
-					line = line + printcsv(val)
-					if j + 1 != len(self.val[name]):
-						line = line + ','
-			elif isinstance(self.val[name], types.StringType):
-				line = line + self.val[name]
-			else:
-				line = line + printcsv(self.val[name])
-			if i + 1 != len(self.vars):
-				line = line + ','
-		return line
+        line = ''
+        for i, name in enumerate(self.vars):
+            if isinstance(self.val[name], types.ListType) or isinstance(self.val[name], types.TupleType):
+                for j, val in enumerate(self.val[name]):
+                    line = line + printcsv(val)
+                    if j + 1 != len(self.val[name]):
+                        line = line + ','
+            elif isinstance(self.val[name], types.StringType):
+                line = line + self.val[name]
+            else:
+                line = line + printcsv(self.val[name])
+            if i + 1 != len(self.vars):
+                line = line + ','
+        return line
 
-	def showcsvend(self, totlist, vislist):
-		if self is not vislist[-1]:
-			return ','
-		elif self is not totlist[-1]:
-			return ','
-		return ''
+    def showcsvend(self, totlist, vislist):
+        if self is not vislist[-1]:
+            return ','
+        elif self is not totlist[-1]:
+            return ','
+        return ''
 
 class dstat_cpu(dstat):
-	def __init__(self):
-		self.format = ('p', 3, 34)
-		self.open('/proc/stat')
-		self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = self.name()
-		self.init(self.vars + ['total',], 6)
+    def __init__(self):
+        self.format = ('p', 3, 34)
+        self.open('/proc/stat')
+        self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = self.name()
+        self.init(self.vars + ['total',], 6)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
-			ret.append(l[0][3:])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
+            ret.append(l[0][3:])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def name(self):
-		ret = []
-		for name in self.vars:
-			if name == 'total':
-				ret.append('total cpu usage')
-			else:
-				ret.append('cpu' + name + ' usage')
-		return ret
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name == 'total':
+                ret.append('total cpu usage')
+            else:
+                ret.append('cpu' + name + ' usage')
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.cpulist:
-			list = op.cpulist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = []
-			cpu = 0
-			while cpu &lt; cpunr:
-				list.append(str(cpu))
-				cpu = cpu + 1
-#			if len(list) &gt; 2: list = list[0:2]
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.cpulist:
+            list = op.cpulist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = []
+            cpu = 0
+            while cpu &lt; cpunr:
+                list.append(str(cpu))
+                cpu = cpu + 1
+#           if len(list) &gt; 2: list = list[0:2]
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 8: continue
-			for name in self.vars:
-				if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-					self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
-		for name in self.vars:
-			for i in range(6):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 8: continue
+            for name in self.vars:
+                if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
+                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
+        for name in self.vars:
+            for i in range(6):
+                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_cpu24(dstat):
-	def __init__(self):
-		self.format = ('p', 3, 34)
-		self.open('/proc/stat')
-		self.nick = ( 'usr', 'sys', 'idl')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = self.name()
-		self.init(self.vars + ['total',], 3)
+    def __init__(self):
+        self.format = ('p', 3, 34)
+        self.open('/proc/stat')
+        self.nick = ( 'usr', 'sys', 'idl')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = self.name()
+        self.init(self.vars + ['total',], 3)
 
-	def name(self):
-		ret = []
-		for name in self.vars:
-			if name:
-				ret.append('cpu' + name)
-			else:
-				ret.append('cpu total')
-		return ret
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name:
+                ret.append('cpu' + name)
+            else:
+                ret.append('cpu total')
+        return ret
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) != 5 or l[0][0:3] != 'cpu': continue
-			ret.append(l[0][3:])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) != 5 or l[0][0:3] != 'cpu': continue
+            ret.append(l[0][3:])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.cpulist:
-			list = op.cpulist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = []
-			cpu = 0
-			while cpu &lt; cpunr:
-				list.append(str(cpu))
-				cpu = cpu + 1
-#			if len(list) &gt; 2: list = list[0:2]
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.cpulist:
+            list = op.cpulist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = []
+            cpu = 0
+            while cpu &lt; cpunr:
+                list.append(str(cpu))
+                cpu = cpu + 1
+#           if len(list) &gt; 2: list = list[0:2]
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			for name in self.vars:
-				if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-					self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
-		for name in self.vars:
-			for i in range(3):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            for name in self.vars:
+                if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
+                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
+        for name in self.vars:
+            for i in range(3):
+                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_disk(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/diskstats')
-		self.nick = ('read', 'writ')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = ['dsk/'+name for name in self.vars]
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/diskstats')
+        self.nick = ('read', 'writ')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = ['dsk/'+name for name in self.vars]
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 13: continue
-			if l[3:] == ['0',] * 11: continue
-			name = l[2]
-			if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
-			ret.append(name)
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 13: continue
+            if l[3:] == ['0',] * 11: continue
+            name = l[2]
+            if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
+            ret.append(name)
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.disklist:
-			list = op.disklist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total'] + op.diskset.keys():
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.disklist:
+            list = op.disklist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total'] + op.diskset.keys():
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 13: continue
-			if l[5] == '0' and l[9] == '0': continue
-			name = l[2]
-			if l[3:] == ['0',] * 11: continue
-			if not re.match('(md[0-9]+|dm-[0-9]+)', name):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
-			if name in self.vars and name != 'total':
-				self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
-			for set in self.vars:
-				if set in op.diskset.keys():
-					for disk in op.diskset[set]:
-						if re.match('^'+disk+'$', name):
-							self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
-		for name in self.cn2.keys():
-			self.val[name] = ( 
-				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-			)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for name in self.vars: self.cn2[name] = (0, 0)
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 13: continue
+            if l[5] == '0' and l[9] == '0': continue
+            name = l[2]
+            if l[3:] == ['0',] * 11: continue
+            if not re.match('(md[0-9]+|dm-[0-9]+)', name):
+                self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
+            if name in self.vars and name != 'total':
+                self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
+            for set in self.vars:
+                if set in op.diskset.keys():
+                    for disk in op.diskset[set]:
+                        if re.match('^'+disk+'$', name):
+                            self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
+        for name in self.cn2.keys():
+            self.val[name] = ( 
+                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+            )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_disk24(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/partitions')
-		self.nick = ('read', 'writ')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		if self.fd and not self.discover:
-			raise Exception, 'Kernel is not compiled with CONFIG_BLK_STATS'
-		self.name = ['dsk/'+sysfs_dev(name) for name in self.vars]
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/partitions')
+        self.nick = ('read', 'writ')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        if self.fd and not self.discover:
+            raise Exception, 'Kernel is not compiled with CONFIG_BLK_STATS'
+        self.name = ['dsk/'+sysfs_dev(name) for name in self.vars]
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
-			name = l[3]
-			if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
-			ret.append(name)	
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
+            name = l[3]
+            if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
+            ret.append(name)    
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.disklist:
-			list = op.disklist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total'] + op.diskset.keys():
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.disklist:
+            list = op.disklist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total'] + op.diskset.keys():
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
-			name = l[3]
-			if not re.match('(md[0-9]+|dm-[0-9]+)', name):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]) )
-			if name in self.vars:
-				self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
-			for set in self.vars:
-				if set in op.diskset.keys():
-					for disk in op.diskset[set]:
-						if re.match('^'+disk+'$', name):
-							self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
-		for name in self.cn2.keys():
-			self.val[name] = ( 
-				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-			)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for name in self.vars: self.cn2[name] = (0, 0)
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
+            name = l[3]
+            if not re.match('(md[0-9]+|dm-[0-9]+)', name):
+                self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]) )
+            if name in self.vars:
+                self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
+            for set in self.vars:
+                if set in op.diskset.keys():
+                    for disk in op.diskset[set]:
+                        if re.match('^'+disk+'$', name):
+                            self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
+        for name in self.cn2.keys():
+            self.val[name] = ( 
+                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+            )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 ### FIXME: Needs rework, does anyone care ?
 class dstat_disk24old(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/stat')
-		self.nick = ('read', 'writ')
-		self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = ['dsk/'+name for name in self.vars]
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/stat')
+        self.nick = ('read', 'writ')
+        self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = ['dsk/'+name for name in self.vars]
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split(':')
-			if len(l) &lt; 3: continue
-			name = l[0]
-			if name != 'disk_io': continue
-			for pair in line.split()[1:]:
-				m = self.regexp.match(pair)
-				if not m: continue
-				l = m.groups()
-				if len(l) &lt; 4: continue
-				name = dev(int(l[0]), int(l[1]))
-				if re.match('(md[0-9]+)', name): continue
-				ret.append(name)
-			break
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split(':')
+            if len(l) &lt; 3: continue
+            name = l[0]
+            if name != 'disk_io': continue
+            for pair in line.split()[1:]:
+                m = self.regexp.match(pair)
+                if not m: continue
+                l = m.groups()
+                if len(l) &lt; 4: continue
+                name = dev(int(l[0]), int(l[1]))
+                if re.match('(md[0-9]+)', name): continue
+                ret.append(name)
+            break
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.disklist:
-			list = op.disklist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total'] + op.diskset.keys():
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.disklist:
+            list = op.disklist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total'] + op.diskset.keys():
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in self.readlines():
-			l = line.split(':')
-			if len(l) &lt; 3: continue
-			name = l[0]
-			if name != 'disk_io': continue
-			for pair in line.split()[1:]:
-				m = self.regexp.match(pair)
-				if not m: continue
-				l = m.groups()
-				if len(l) &lt; 4: continue
-				name = dev(int(l[0]), int(l[1]))
-				if not re.match('(md[0-9]+)', name):
-					self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
-				if name in self.vars and name != 'total':
-					self.cn2[name] = ( self.cn2[name][0] + long(l[2]), self.cn2[name][1] + long(l[3]) )
-				for set in self.vars:
-					if set in op.diskset.keys():
-						for disk in op.diskset[set]:
-							if re.match('^'+disk+'$', name):
-								self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
-			break
-		for name in self.cn2.keys():
-			self.val[name] = (
-				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-			)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for name in self.vars: self.cn2[name] = (0, 0)
+        for line in self.readlines():
+            l = line.split(':')
+            if len(l) &lt; 3: continue
+            name = l[0]
+            if name != 'disk_io': continue
+            for pair in line.split()[1:]:
+                m = self.regexp.match(pair)
+                if not m: continue
+                l = m.groups()
+                if len(l) &lt; 4: continue
+                name = dev(int(l[0]), int(l[1]))
+                if not re.match('(md[0-9]+)', name):
+                    self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
+                if name in self.vars and name != 'total':
+                    self.cn2[name] = ( self.cn2[name][0] + long(l[2]), self.cn2[name][1] + long(l[3]) )
+                for set in self.vars:
+                    if set in op.diskset.keys():
+                        for disk in op.diskset[set]:
+                            if re.match('^'+disk+'$', name):
+                                self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
+            break
+        for name in self.cn2.keys():
+            self.val[name] = (
+                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+            )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_epoch(dstat):
-	def __init__(self):
-		self.name = 'epoch'
-		self.format = ('t', 10, 0)
-		if op.debug:
-			self.format = ('t', 14, 0)
-		self.nick = ('epoch',)
-		self.vars = self.nick
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'epoch'
+        self.format = ('t', 10, 0)
+        if op.debug:
+            self.format = ('t', 14, 0)
+        self.nick = ('epoch',)
+        self.vars = self.nick
+        self.init(self.vars, 1)
 
-	def extract(self):
-		self.val['epoch'] = time.time()
+    def extract(self):
+        self.val['epoch'] = time.time()
 
-#	def show(self):
-#		return ansi['reset'] + ( '%10.2f' % self.val['epoch'] )
+#   def show(self):
+#       return ansi['reset'] + ( '%10.2f' % self.val['epoch'] )
 
 class dstat_int(dstat):
-	def __init__(self):
-		self.name = 'interrupts'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/stat')
-		self.discover = self.discover()
-		self.intmap = self.intmap()
-		self.vars = self.vars()
-		self.nick = self.vars
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'interrupts'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/stat')
+        self.discover = self.discover()
+        self.intmap = self.intmap()
+        self.vars = self.vars()
+        self.nick = self.vars
+        self.init(self.vars, 1)
 
-	def intmap(self):
-		ret = {}
-		for line in dopen('/proc/interrupts').readlines():
-			l = line.split()
-			if len(l) &lt;= cpunr: continue
-			l1 = l[0].split(':')[0]
-			l2 = ' '.join(l[cpunr+2:]).split(',')
-			ret[l1] = l1
-			for name in l2:
-				ret[name.strip().lower()] = l1
-		return ret
+    def intmap(self):
+        ret = {}
+        for line in dopen('/proc/interrupts').readlines():
+            l = line.split()
+            if len(l) &lt;= cpunr: continue
+            l1 = l[0].split(':')[0]
+            l2 = ' '.join(l[cpunr+2:]).split(',')
+            ret[l1] = l1
+            for name in l2:
+                ret[name.strip().lower()] = l1
+        return ret
 
-	def discover(self):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if l[0] != 'intr': continue
-			for name, i in enumerate(l[2:]):
-				if long(i) &gt; 10: ret.append(str(name))
-		return ret
+    def discover(self):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if l[0] != 'intr': continue
+            for name, i in enumerate(l[2:]):
+                if long(i) &gt; 10: ret.append(str(name))
+        return ret
 
-#	def check(self):
-#		if self.fd[0] and self.vars:
-#			self.fd[0].seek(0)
-#			for line in self.fd[0].readlines():
-#				l = line.split()
-#				if l[0] != 'intr': continue
-#				return True
-#		return False
+#   def check(self):
+#       if self.fd[0] and self.vars:
+#           self.fd[0].seek(0)
+#           for line in self.fd[0].readlines():
+#               l = line.split()
+#               if l[0] != 'intr': continue
+#               return True
+#       return False
 
-	def vars(self):
-		ret = []
-		if op.intlist:
-			list = op.intlist
-		else:
-			list = self.discover
-			for name in list:
-				if name in ('0', '1', '2', '8', 'NMI', 'LOC', 'MIS', 'CPU0'):
-					list.remove(name)
-			if not op.full and len(list) &gt; 3: list = list[-3:]
-		for name in list:
-			if name in self.discover:
-				ret.append(name)
-			elif name.lower() in self.intmap.keys():
-				ret.append(self.intmap[name.lower()])
-		return ret
+    def vars(self):
+        ret = []
+        if op.intlist:
+            list = op.intlist
+        else:
+            list = self.discover
+            for name in list:
+                if name in ('0', '1', '2', '8', 'NMI', 'LOC', 'MIS', 'CPU0'):
+                    list.remove(name)
+            if not op.full and len(list) &gt; 3: list = list[-3:]
+        for name in list:
+            if name in self.discover:
+                ret.append(name)
+            elif name.lower() in self.intmap.keys():
+                ret.append(self.intmap[name.lower()])
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if not l or l[0] != 'intr': continue
-			for name in self.vars:
-				self.cn2[name] = long(l[int(name) + 2])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if not l or l[0] != 'intr': continue
+            for name in self.vars:
+                self.cn2[name] = long(l[int(name) + 2])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_int24(dstat):
-	def __init__(self):
-		self.name = 'interrupts'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/interrupts')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.nick = self.vars
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'interrupts'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/interrupts')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.nick = self.vars
+        self.init(self.vars, 1)
 
-	def intmap(self):
-		ret = {}
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt;= cpunr: continue
-			l1 = l[0].split(':')[0]
-			l2 = ' '.join(l[cpunr+2:]).split(',')
-			ret[l1] = l1
-			for name in l2:
-				ret[name.strip().lower()] = l1
-		return ret
+    def intmap(self):
+        ret = {}
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt;= cpunr: continue
+            l1 = l[0].split(':')[0]
+            l2 = ' '.join(l[cpunr+2:]).split(',')
+            ret[l1] = l1
+            for name in l2:
+                ret[name.strip().lower()] = l1
+        return ret
 
-	def discover(self):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; cpunr+1: continue
-			name = l[0].split(':')[0]
-			if long(l[1]) &gt; 10:
-				ret.append(name)
-		return ret
+    def discover(self):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; cpunr+1: continue
+            name = l[0].split(':')[0]
+            if long(l[1]) &gt; 10:
+                ret.append(name)
+        return ret
 
-#	def check(self):
-#		if self.fd and self.discover:
-#			self.fd[0].seek(0)
-#			for line in self.fd[0].readlines():
-#				l = line.split()
-#				if l[0] != 'intr' or len(l) &gt; 2: continue
-#				return True
-#		return False
+#   def check(self):
+#       if self.fd and self.discover:
+#           self.fd[0].seek(0)
+#           for line in self.fd[0].readlines():
+#               l = line.split()
+#               if l[0] != 'intr' or len(l) &gt; 2: continue
+#               return True
+#       return False
 
-	def vars(self):
-		ret = []
-		if op.intlist:
-			list = op.intlist
-		else:
-			list = self.discover
-			for name in list:
-				if name in ('0', '1', '2', '8', 'CPU0', 'ERR', 'LOC', 'MIS', 'NMI'):
-					list.remove(name)
-			if not op.full and len(list) &gt; 3: list = list[-3:]
-		for name in list:
-			if name in self.discover:
-				ret.append(name)
-			elif name.lower() in self.intmap.keys():
-				ret.append(self.intmap[name.lower()])
-		return ret
+    def vars(self):
+        ret = []
+        if op.intlist:
+            list = op.intlist
+        else:
+            list = self.discover
+            for name in list:
+                if name in ('0', '1', '2', '8', 'CPU0', 'ERR', 'LOC', 'MIS', 'NMI'):
+                    list.remove(name)
+            if not op.full and len(list) &gt; 3: list = list[-3:]
+        for name in list:
+            if name in self.discover:
+                ret.append(name)
+            elif name.lower() in self.intmap.keys():
+                ret.append(self.intmap[name.lower()])
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; cpunr+1: continue
-			name = l[0].split(':')[0]
-			if name in self.vars:
-				self.cn2[name] = 0
-				for i in l[1:1+cpunr]:
-					self.cn2[name] = self.cn2[name] + long(i)
-#			elif len(l) &gt; 2 + cpunr:
-#				for hw in self.vars:
-#					for mod in l[2+cpunr:]:
-#						self.cn2[mod] = long(l[1])
-		for name in self.cn2.keys():
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; cpunr+1: continue
+            name = l[0].split(':')[0]
+            if name in self.vars:
+                self.cn2[name] = 0
+                for i in l[1:1+cpunr]:
+                    self.cn2[name] = self.cn2[name] + long(i)
+#           elif len(l) &gt; 2 + cpunr:
+#               for hw in self.vars:
+#                   for mod in l[2+cpunr:]:
+#                       self.cn2[mod] = long(l[1])
+        for name in self.cn2.keys():
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_ipc(dstat):
-	def __init__(self):
-		self.name = 'sysv ipc'
-		self.format = ('d', 3, 10)
-		self.vars = ('msg', 'sem', 'shm')
-		self.nick = self.vars
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'sysv ipc'
+        self.format = ('d', 3, 10)
+        self.vars = ('msg', 'sem', 'shm')
+        self.nick = self.vars
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars:
-			self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
+    def extract(self):
+        for name in self.vars:
+            self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
 
 class dstat_load(dstat):
-	def __init__(self):
-		self.name = 'load avg'
-		self.format = ('f', 4, 10)
-		self.open('/proc/loadavg')
-		self.nick = ('1m', '5m', '15m')
-		self.vars = ('load1', 'load5', 'load15')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'load avg'
+        self.format = ('f', 4, 10)
+        self.open('/proc/loadavg')
+        self.nick = ('1m', '5m', '15m')
+        self.vars = ('load1', 'load5', 'load15')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 3: continue
-			self.val['load1'] = float(l[0])
-			self.val['load5'] = float(l[1])
-			self.val['load15'] = float(l[2])
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 3: continue
+            self.val['load1'] = float(l[0])
+            self.val['load5'] = float(l[1])
+            self.val['load15'] = float(l[2])
 
 class dstat_lock(dstat):
-	def __init__(self):
-		self.name = 'file locks'
-		self.format = ('f', 3, 10)
-		self.open('/proc/locks')
-		self.nick = ('pos', 'lck', 'rea', 'wri')
-		self.vars = ('posix', 'flock', 'read', 'write')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'file locks'
+        self.format = ('f', 3, 10)
+        self.open('/proc/locks')
+        self.nick = ('pos', 'lck', 'rea', 'wri')
+        self.vars = ('posix', 'flock', 'read', 'write')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 4: continue
-			if l[1] == 'POSIX':
-				self.val['posix'] = self.val['posix'] + 1
-			elif l[1] == 'FLOCK':
-				self.val['flock'] = self.val['flock'] + 1
-			if l[3] == 'READ':
-				self.val['read'] = self.val['read'] + 1
-			elif l[3] == 'WRITE':
-				self.val['write'] = self.val['write'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 4: continue
+            if l[1] == 'POSIX':
+                self.val['posix'] = self.val['posix'] + 1
+            elif l[1] == 'FLOCK':
+                self.val['flock'] = self.val['flock'] + 1
+            if l[3] == 'READ':
+                self.val['read'] = self.val['read'] + 1
+            elif l[3] == 'WRITE':
+                self.val['write'] = self.val['write'] + 1
 
 class dstat_mem(dstat):
-	def __init__(self):
-		self.name = 'memory usage'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/meminfo')
-		self.nick = ('used', 'buff', 'cach', 'free')
-		self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'memory usage'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/meminfo')
+        self.nick = ('used', 'buff', 'cach', 'free')
+        self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 2: continue
-			name = l[0].split(':')[0]
-			if name in self.vars + ('MemTotal', ):
-				self.val[name] = long(l[1]) * 1024.0
-		self.val['MemUsed'] = self.val['MemTotal'] - self.val['MemFree'] - self.val['Buffers'] - self.val['Cached']
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 2: continue
+            name = l[0].split(':')[0]
+            if name in self.vars + ('MemTotal', ):
+                self.val[name] = long(l[1]) * 1024.0
+        self.val['MemUsed'] = self.val['MemTotal'] - self.val['MemFree'] - self.val['Buffers'] - self.val['Cached']
 
 class dstat_net(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/net/dev')
-		self.nick = ('recv', 'send')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = ['net/'+name for name in self.vars]
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/net/dev')
+        self.nick = ('recv', 'send')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = ['net/'+name for name in self.vars]
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.replace(':', ' ').split()
-			if len(l) &lt; 17: continue
-			if l[2] == '0' and l[10] == '0': continue
-			name = l[0]
-			if name not in ('lo', 'face'):
-				ret.append(name)
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.replace(':', ' ').split()
+            if len(l) &lt; 17: continue
+            if l[2] == '0' and l[10] == '0': continue
+            name = l[0]
+            if name not in ('lo', 'face'):
+                ret.append(name)
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.netlist:
-			list = op.netlist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total', 'lo']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.netlist:
+            list = op.netlist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total', 'lo']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		self.cn2['total'] = [0, 0]
-		for line in self.readlines():
-			l = line.replace(':', ' ').split()
-			if len(l) &lt; 17: continue
-			if l[2] == '0' and l[10] == '0': continue
-			name = l[0]
-			if name in self.vars :
-				self.cn2[name] = ( long(l[1]), long(l[9]) )
-			if name not in ('lo','face'):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[9]))
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-					(self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
-				 )
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        self.cn2['total'] = [0, 0]
+        for line in self.readlines():
+            l = line.replace(':', ' ').split()
+            if len(l) &lt; 17: continue
+            if l[2] == '0' and l[10] == '0': continue
+            name = l[0]
+            if name in self.vars :
+                self.cn2[name] = ( long(l[1]), long(l[9]) )
+            if name not in ('lo','face'):
+                self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[9]))
+        if update:
+            for name in self.cn2.keys():
+                self.val[name] = ( 
+                    (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
+                    (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
+                 )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_page(dstat):
-	def __init__(self):
-		self.name = 'paging'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/vmstat')
-		self.nick = ('in', 'out')
-		self.vars = ('pswpin', 'pswpout')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'paging'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/vmstat')
+        self.nick = ('in', 'out')
+        self.vars = ('pswpin', 'pswpout')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 2: continue
-			name = l[0]
-			if name in self.vars:
-				self.cn2[name] = long(l[1])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 2: continue
+            name = l[0]
+            if name in self.vars:
+                self.cn2[name] = long(l[1])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_page24(dstat):
-	def __init__(self):
-		self.name = 'paging'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/stat')
-		self.nick = ('in', 'out')
-		self.vars = ('pswpin', 'pswpout')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'paging'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/stat')
+        self.nick = ('in', 'out')
+        self.vars = ('pswpin', 'pswpout')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 3: continue
-			name = l[0]
-			if name != 'swap': continue
-			self.cn2['pswpin'] = long(l[1])
-			self.cn2['pswpout'] = long(l[2])
-			break
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 3: continue
+            name = l[0]
+            if name != 'swap': continue
+            self.cn2['pswpin'] = long(l[1])
+            self.cn2['pswpout'] = long(l[2])
+            break
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_proc(dstat):
-	def __init__(self):
-		self.name = 'procs'
-		self.format = ('f', 3, 10)
-		self.open('/proc/stat')
-		self.nick = ('run', 'blk', 'new')
-		self.vars = ('procs_running', 'procs_blocked', 'processes')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'procs'
+        self.format = ('f', 3, 10)
+        self.open('/proc/stat')
+        self.nick = ('run', 'blk', 'new')
+        self.vars = ('procs_running', 'procs_blocked', 'processes')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 2: continue
-			name = l[0]
-			if name == 'processes':
-				self.val['processes'] = 0
-				self.cn2[name] = long(l[1])
-			elif name == 'procs_running':
-				self.cn2[name] = self.cn2[name] + long(l[1]) - 1
-			elif name == 'procs_blocked':
-				self.cn2[name] = self.cn2[name] + long(l[1])
-		self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
-		for name in ('procs_running', 'procs_blocked'):
-			self.val[name] = self.cn2[name] * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
-			for name in ('procs_running', 'procs_blocked'):
-				self.cn2[name] = 0
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 2: continue
+            name = l[0]
+            if name == 'processes':
+                self.val['processes'] = 0
+                self.cn2[name] = long(l[1])
+            elif name == 'procs_running':
+                self.cn2[name] = self.cn2[name] + long(l[1]) - 1
+            elif name == 'procs_blocked':
+                self.cn2[name] = self.cn2[name] + long(l[1])
+        self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
+        for name in ('procs_running', 'procs_blocked'):
+            self.val[name] = self.cn2[name] * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
+            for name in ('procs_running', 'procs_blocked'):
+                self.cn2[name] = 0
 
 class dstat_raw(dstat):
-	def __init__(self):
-		self.name = 'raw'
-		self.format = ('f', 3, 10)
-		self.open('/proc/net/raw')
-		self.nick = ('soc',)
-		self.vars = ('sockets',)
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'raw'
+        self.format = ('f', 3, 10)
+        self.open('/proc/net/raw')
+        self.nick = ('soc',)
+        self.vars = ('sockets',)
+        self.init(self.vars, 1)
 
-	def extract(self):
-		self.val['sockets'] = len(self.readlines()) - 1
+    def extract(self):
+        self.val['sockets'] = len(self.readlines()) - 1
 
 class dstat_swap(dstat):
-	def __init__(self):
-		self.name = 'swap'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/swaps')
-		self.nick = ('used', 'free')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = ['swp/'+improve(name) for name in self.vars]
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.name = 'swap'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/swaps')
+        self.nick = ('used', 'free')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = ['swp/'+improve(name) for name in self.vars]
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 5: continue
-			if l[0] == 'Filename': continue
-#			ret.append(improve(l[0]))
-			ret.append(l[0])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 5: continue
+            if l[0] == 'Filename': continue
+#           ret.append(improve(l[0]))
+            ret.append(l[0])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.swaplist:
-			list = op.swaplist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-		list.sort()
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.swaplist:
+            list = op.swaplist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+        list.sort()
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		self.val['total'] = [0, 0]
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 5 or l[0] == 'Filename': continue
-			name = l[0]
-			self.val[name] = ( long(l[3]) * 1024.0, (long(l[2]) - long(l[3])) * 1024.0 )
-			self.val['total'] = ( self.val['total'][0] + self.val[name][0], self.val['total'][1] + self.val[name][1])
+    def extract(self):
+        self.val['total'] = [0, 0]
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 5 or l[0] == 'Filename': continue
+            name = l[0]
+            self.val[name] = ( long(l[3]) * 1024.0, (long(l[2]) - long(l[3])) * 1024.0 )
+            self.val['total'] = ( self.val['total'][0] + self.val[name][0], self.val['total'][1] + self.val[name][1])
 
 class dstat_swapold(dstat):
-	def __init__(self):
-		self.name = 'swap'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/meminfo')
-		self.nick = ('used', 'free')
-		self.vars = ('SwapUsed', 'SwapFree')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'swap'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/meminfo')
+        self.nick = ('used', 'free')
+        self.vars = ('SwapUsed', 'SwapFree')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 2: continue
-			name = l[0].split(':')[0]
-			if name in self.vars + ('SwapTotal',):
-				self.val[name] = long(l[1]) * 1024.0
-		self.val['SwapUsed'] = self.val['SwapTotal'] - self.val['SwapFree']
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 2: continue
+            name = l[0].split(':')[0]
+            if name in self.vars + ('SwapTotal',):
+                self.val[name] = long(l[1]) * 1024.0
+        self.val['SwapUsed'] = self.val['SwapTotal'] - self.val['SwapFree']
 
 class dstat_sys(dstat):
-	def __init__(self):
-		self.name = 'system'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/stat')
-		self.nick = ('int', 'csw')
-		self.vars = ('intr', 'ctxt')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'system'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/stat')
+        self.nick = ('int', 'csw')
+        self.vars = ('intr', 'ctxt')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 2: continue
-			name = l[0]
-			if name in self.vars:
-				self.cn2[name] = long(l[1])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 2: continue
+            name = l[0]
+            if name in self.vars:
+                self.cn2[name] = long(l[1])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_tcp(dstat):
-	def __init__(self):
-		self.name = 'tcp sockets'
-		self.format = ('f', 3, 100)
-		self.open('/proc/net/tcp', '/proc/net/tcp6')
-		self.nick = ('lis', 'act', 'syn', 'tim', 'clo')
-		self.vars = ('listen', 'established', 'syn', 'wait', 'close')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'tcp sockets'
+        self.format = ('f', 3, 100)
+        self.open('/proc/net/tcp', '/proc/net/tcp6')
+        self.nick = ('lis', 'act', 'syn', 'tim', 'clo')
+        self.vars = ('listen', 'established', 'syn', 'wait', 'close')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 12: continue
-			### 01: established, 02: syn_sent,  03: syn_recv, 04: fin_wait1,
-			### 05: fin_wait2,   06: time_wait, 07: close,    08: close_wait,
-			### 09: last_ack,    0A: listen,    0B: closing
-			if l[3] in ('0A',): self.val['listen'] = self.val['listen'] + 1
-			elif l[3] in ('01',): self.val['established'] = self.val['established'] + 1
-			elif l[3] in ('02', '03', '09',): self.val['syn'] = self.val['syn'] + 1
-			elif l[3] in ('06',): self.val['wait'] = self.val['wait'] + 1
-			elif l[3] in ('04', '05', '07', '08', '0B',): self.val['close'] = self.val['close'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 12: continue
+            ### 01: established, 02: syn_sent,  03: syn_recv, 04: fin_wait1,
+            ### 05: fin_wait2,   06: time_wait, 07: close,    08: close_wait,
+            ### 09: last_ack,    0A: listen,    0B: closing
+            if l[3] in ('0A',): self.val['listen'] = self.val['listen'] + 1
+            elif l[3] in ('01',): self.val['established'] = self.val['established'] + 1
+            elif l[3] in ('02', '03', '09',): self.val['syn'] = self.val['syn'] + 1
+            elif l[3] in ('06',): self.val['wait'] = self.val['wait'] + 1
+            elif l[3] in ('04', '05', '07', '08', '0B',): self.val['close'] = self.val['close'] + 1
 
 class dstat_time(dstat):
-	def __init__(self):
-		self.name = 'time'
-		self.format = ('s', 14, 0)
-		self.nick = ('date/time',)
-		self.vars = ('time',)
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'time'
+        self.format = ('s', 14, 0)
+        self.nick = ('date/time',)
+        self.vars = ('time',)
+        self.init(self.vars, 1)
 
-	def extract(self):
-		### FIXME: Add milliseconds when using --debug (see dstat_epoch)
-		self.val['time'] = time.strftime('%d-%m %H:%M:%S', time.localtime())
+    def extract(self):
+        ### FIXME: Add milliseconds when using --debug (see dstat_epoch)
+        self.val['time'] = time.strftime('%d-%m %H:%M:%S', time.localtime())
 
-	def show(self):
-		if step == op.delay:
-			color = 'silver'
-		else:
-			color = 'gray'
-		return ansi[color] + self.val['time']
+    def show(self):
+        if step == op.delay:
+            color = 'silver'
+        else:
+            color = 'gray'
+        return ansi[color] + self.val['time']
 
 class dstat_udp(dstat):
-	def __init__(self):
-		self.name = 'udp'
-		self.format = ('f', 3, 100)
-		self.open('/proc/net/udp', '/proc/net/udp6')
-		self.nick = ('lis', 'act')
-		self.vars = ('listen', 'established')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'udp'
+        self.format = ('f', 3, 100)
+        self.open('/proc/net/udp', '/proc/net/udp6')
+        self.nick = ('lis', 'act')
+        self.vars = ('listen', 'established')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = line.split()
-			if l[3] == '07': self.val['listen'] = self.val['listen'] + 1
-			elif l[3] == '01': self.val['established'] = self.val['established'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = line.split()
+            if l[3] == '07': self.val['listen'] = self.val['listen'] + 1
+            elif l[3] == '01': self.val['established'] = self.val['established'] + 1
 
 class dstat_unix(dstat):
-	def __init__(self):
-		self.name = 'unix sockets'
-		self.format = ('d', 4, 100)
-		self.open('/proc/net/unix')
-		self.nick = ('dgrm', 'strm', 'lis', 'act')
-		self.vars = ('datagram', 'stream', 'listen', 'established')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'unix sockets'
+        self.format = ('d', 4, 100)
+        self.open('/proc/net/unix')
+        self.nick = ('dgrm', 'strm', 'lis', 'act')
+        self.vars = ('datagram', 'stream', 'listen', 'established')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = line.split()
-			if l[4] == '0002':
-				self.val['datagram'] = self.val['datagram'] + 1
-			elif l[4] == '0001':
-				self.val['stream'] = self.val['stream'] + 1
-				if l[5] == '01':
-					self.val['listen'] = self.val['listen'] + 1
-				elif l[5] == '03':
-					self.val['established'] = self.val['established'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = line.split()
+            if l[4] == '0002':
+                self.val['datagram'] = self.val['datagram'] + 1
+            elif l[4] == '0001':
+                self.val['stream'] = self.val['stream'] + 1
+                if l[5] == '01':
+                    self.val['listen'] = self.val['listen'] + 1
+                elif l[5] == '03':
+                    self.val['established'] = self.val['established'] + 1
 
 ### END STATS DEFINITIONS ###
 
 ansi = {
-	'black': '\033[0;30m',
-	'darkred': '\033[0;31m',
-	'darkgreen': '\033[0;32m',
-	'darkyellow': '\033[0;33m',
-	'darkblue': '\033[0;34m',
-	'darkmagenta': '\033[0;35m',
-	'darkcyan': '\033[0;36m',
-	'silver': '\033[0;37m',
+    'black': '\033[0;30m',
+    'darkred': '\033[0;31m',
+    'darkgreen': '\033[0;32m',
+    'darkyellow': '\033[0;33m',
+    'darkblue': '\033[0;34m',
+    'darkmagenta': '\033[0;35m',
+    'darkcyan': '\033[0;36m',
+    'silver': '\033[0;37m',
 
-	'gray': '\033[1;30m',
-	'red': '\033[1;31m',
-	'green': '\033[1;32m',
-	'yellow': '\033[1;33m',
-	'blue': '\033[1;34m',
-	'magenta': '\033[1;35m',
-	'cyan': '\033[1;36m',
-	'white': '\033[1;37m',
+    'gray': '\033[1;30m',
+    'red': '\033[1;31m',
+    'green': '\033[1;32m',
+    'yellow': '\033[1;33m',
+    'blue': '\033[1;34m',
+    'magenta': '\033[1;35m',
+    'cyan': '\033[1;36m',
+    'white': '\033[1;37m',
 
-	'blackbg': '\033[40m',
-	'redbg': '\033[41m',
-	'greenbg': '\033[42m',
-	'yellowbg': '\033[43m',
-	'bluebg': '\033[44m',
-	'magentabg': '\033[45m',
-	'cyanbg': '\033[46m',
-	'whitebg': '\033[47m',
+    'blackbg': '\033[40m',
+    'redbg': '\033[41m',
+    'greenbg': '\033[42m',
+    'yellowbg': '\033[43m',
+    'bluebg': '\033[44m',
+    'magentabg': '\033[45m',
+    'cyanbg': '\033[46m',
+    'whitebg': '\033[47m',
 
-	'reset': '\033[0;0m',
-	'bold': '\033[1m',
-	'reverse': '\033[2m',
-	'underline': '\033[4m',
+    'reset': '\033[0;0m',
+    'bold': '\033[1m',
+    'reverse': '\033[2m',
+    'underline': '\033[4m',
 
-	'clear': '\033[2J',
-#	'clearline': '\033[K',
-	'clearline': '\033[2K',
-#	'save': '\033[s',
-#	'restore': '\033[u',
-	'save': '\0337',
-	'restore': '\0338',
+    'clear': '\033[2J',
+#   'clearline': '\033[K',
+    'clearline': '\033[2K',
+#   'save': '\033[s',
+#   'restore': '\033[u',
+    'save': '\0337',
+    'restore': '\0338',
 
-	'up': '\033[1A',
-	'down': '\033[1B',
-	'right': '\033[1C',
-	'left': '\033[1D',
+    'up': '\033[1A',
+    'down': '\033[1B',
+    'right': '\033[1C',
+    'left': '\033[1D',
 
-	'default': '\033[0;0m',
+    'default': '\033[0;0m',
 }
 
 char = {
-	'pipe': '|',
-	'colon': ':',
-	'gt': '&gt;',
-	'space': ' ',
-	'dash': '-',
+    'pipe': '|',
+    'colon': ':',
+    'gt': '&gt;',
+    'space': ' ',
+    'dash': '-',
 }
 
 def ticks():
-	&quot;Return the number of 'ticks' since bootup&quot;
-	try:
-		for line in open('/proc/uptime', 'r', 0).readlines():
-			l = line.split()
-			if len(l) &lt; 2: continue
-			return float(l[0])
-	except:
-		for line in dopen('/proc/stat').readlines():
-			l = line.split()
-			if len(l) &lt; 2: continue
-			if l[0] == 'btime':
-				return time.time() - long(l[1])
+    &quot;Return the number of 'ticks' since bootup&quot;
+    try:
+        for line in open('/proc/uptime', 'r', 0).readlines():
+            l = line.split()
+            if len(l) &lt; 2: continue
+            return float(l[0])
+    except:
+        for line in dopen('/proc/stat').readlines():
+            l = line.split()
+            if len(l) &lt; 2: continue
+            if l[0] == 'btime':
+                return time.time() - long(l[1])
 
 def improve(str):
-	&quot;Improve a device name&quot;
-	if str.startswith('/dev/mapper/'):
-		str = str.split('/')[3]
-	elif str.startswith('/dev/'):
-		str = str.split('/')[2]
-	return str
+    &quot;Improve a device name&quot;
+    if str.startswith('/dev/mapper/'):
+        str = str.split('/')[3]
+    elif str.startswith('/dev/'):
+        str = str.split('/')[2]
+    return str
 
 def dopen(file):
-	&quot;Open a file for reuse, if already opened, return file descriptor&quot;
-	global fds
-	if not os.path.exists(file): return None
-	if 'fds' not in globals().keys(): fds = {}
-	if file not in fds.keys():
-		fds[file] = open(file, 'r', 0)
-	else:
-		fds[file].seek(0)
-	return fds[file]
+    &quot;Open a file for reuse, if already opened, return file descriptor&quot;
+    global fds
+    if not os.path.exists(file): return None
+    if 'fds' not in globals().keys(): fds = {}
+    if file not in fds.keys():
+        fds[file] = open(file, 'r', 0)
+    else:
+        fds[file].seek(0)
+    return fds[file]
 
 def dclose(file):
-	&quot;Close an open file and remove file descriptor from list&quot;
-	global fds
-	if not 'fds' in globals(): fds = {}
-	if file in fds:
-		fds[file].close()
-		del(fds[file])
+    &quot;Close an open file and remove file descriptor from list&quot;
+    global fds
+    if not 'fds' in globals(): fds = {}
+    if file in fds:
+        fds[file].close()
+        del(fds[file])
 
 def dpopen(cmd):
-	&quot;Open a pipe for reuse, if already opened, return pipes&quot;
-	global pipes
-	if 'pipes' not in globals().keys(): pipes = {}
-	if cmd not in pipes.keys():
-		pipes[cmd] = os.popen3(cmd, 't', 0)
-	return pipes[cmd]
+    &quot;Open a pipe for reuse, if already opened, return pipes&quot;
+    global pipes
+    if 'pipes' not in globals().keys(): pipes = {}
+    if cmd not in pipes.keys():
+        pipes[cmd] = os.popen3(cmd, 't', 0)
+    return pipes[cmd]
 
 def readpipe(file, tmout = 0.001):
-	&quot;Read available data from pipe in a non-blocking fashion&quot;
-	ret = ''
-	while not select.select([file.fileno()], [], [], tmout)[0]:
-		pass
-	while select.select([file.fileno()], [], [], tmout)[0]:
-		ret = ret + file.read(1)
-	return ret.split('\n')
-#	return ret
+    &quot;Read available data from pipe in a non-blocking fashion&quot;
+    ret = ''
+    while not select.select([file.fileno()], [], [], tmout)[0]:
+        pass
+    while select.select([file.fileno()], [], [], tmout)[0]:
+        ret = ret + file.read(1)
+    return ret.split('\n')
+#   return ret
 
 def dchg(var, max, base):
-	&quot;Convert decimal to string given base and length&quot;
-	c = 0
-	while True:
-		ret = str(long(round(var)))
-		if len(ret) &lt;= max:
-			break
-		var = var / base
-		c = c + 1
-	else:
-		c = -1
-	return ret, c
+    &quot;Convert decimal to string given base and length&quot;
+    c = 0
+    while True:
+        ret = str(long(round(var)))
+        if len(ret) &lt;= max:
+            break
+        var = var / base
+        c = c + 1
+    else:
+        c = -1
+    return ret, c
 
 def fchg(var, max, base):
-	&quot;Convert float to string given base and length&quot;
-	c = 0
-	while True:
-		if var == 0:
-			ret = str('0')
-			break
-#		ret = repr(round(var))
-#		ret = repr(long(round(var,max)))
-		ret = str(long(round(var,max)))
-		if len(ret) &lt;= max:
-			i = max - len(ret)
-			while i &gt; 0:
-				ret = ('%.'+str(i)+'f') % var
-				if len(ret) &lt; max and ret != repr(round(var)):
-					break
-				i = i - 1
-			else:
-				ret = str(long(round(var)))
-			break
-		var = var / base
-		c = c + 1
-	else:
-		c = -1
-	return ret, c
+    &quot;Convert float to string given base and length&quot;
+    c = 0
+    while True:
+        if var == 0:
+            ret = str('0')
+            break
+#       ret = repr(round(var))
+#       ret = repr(long(round(var,max)))
+        ret = str(long(round(var,max)))
+        if len(ret) &lt;= max:
+            i = max - len(ret)
+            while i &gt; 0:
+                ret = ('%.'+str(i)+'f') % var
+                if len(ret) &lt; max and ret != repr(round(var)):
+                    break
+                i = i - 1
+            else:
+                ret = str(long(round(var)))
+            break
+        var = var / base
+        c = c + 1
+    else:
+        c = -1
+    return ret, c
 
 def cprintlist(list, format):
-	ret = sep = ''
-	for var in list:
-		ret = ret + sep + cprint(var, format)
-		sep = ' '
-	return ret
+    ret = sep = ''
+    for var in list:
+        ret = ret + sep + cprint(var, format)
+        sep = ' '
+    return ret
 
 def cprint(var, format = ('f', 4, 1000)):
-	c = -1
-	type = format[0]
-	max = format[1]
-	mp = format[2]
+    c = -1
+    type = format[0]
+    max = format[1]
+    mp = format[2]
 
-	base = 1000
-	if mp == 1024:
-		base = 1024
+    base = 1000
+    if mp == 1024:
+        base = 1024
 
-	unit = False
-	if mp in (1000, 1024) and max &gt;= len(str(base)):
-		unit = True
-		max = max - 1
+    unit = False
+    if mp in (1000, 1024) and max &gt;= len(str(base)):
+        unit = True
+        max = max - 1
 
-	if var &lt; 0:
-		if unit:
-			return ansi['default'] + '-'.rjust(max) + ' '
-		else:
-			return ansi['default'] + '-'.rjust(max)
+    if var &lt; 0:
+        if unit:
+            return ansi['default'] + '-'.rjust(max) + ' '
+        else:
+            return ansi['default'] + '-'.rjust(max)
 
-	if base == 1024:
-		units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
-	else:
-		units = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+    if base == 1024:
+        units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+    else:
+        units = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
 
-	if step == op.delay:
-		colors = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
-	else:
-		colors = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
+    if step == op.delay:
+        colors = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
+    else:
+        colors = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
 
-	if op.integer and type in ('d', 'p', 'f'):
-		ret, c = dchg(var, max, base)
-	elif type in ('d', 'p'):
-		ret, c = dchg(var, max, base)
-	elif type in ('f'):
-		ret, c = fchg(var, max, base)
-	elif type in ('t'):
-		ret, c = fchg(var, max+1, base)
-	else:
-		ret = str(var)
+    if op.integer and type in ('d', 'p', 'f'):
+        ret, c = dchg(var, max, base)
+    elif type in ('d', 'p'):
+        ret, c = dchg(var, max, base)
+    elif type in ('f'):
+        ret, c = fchg(var, max, base)
+    elif type in ('t'):
+        ret, c = fchg(var, max+1, base)
+    else:
+        ret = str(var)
 
-	if ret == '0':
-		color = 'default'
-	elif type in ('d', 'p'):
-		color = colors[int(var/mp)%len(colors)]
-	elif type in ('f'):
-		color = colors[c%len(colors)]
-	else:
-		color = 'default'
+    if ret == '0':
+        color = 'default'
+    elif type in ('d', 'p'):
+        color = colors[int(var/mp)%len(colors)]
+    elif type in ('f'):
+        color = colors[c%len(colors)]
+    else:
+        color = 'default'
 
-	if type in ('s',):
-		ret = ansi['default'] + ret.ljust(max)
-	else:
-		ret = ansi[color] + ret.rjust(max)
+    if type in ('s',):
+        ret = ansi['default'] + ret.ljust(max)
+    else:
+        ret = ansi[color] + ret.rjust(max)
 
-	if unit:
-		if c != -1 and round(var) != 0:
-			ret = ret + units[c]
-		else:
-			ret = ret + ' '
+    if unit:
+        if c != -1 and round(var) != 0:
+            ret = ret + units[c]
+        else:
+            ret = ret + ' '
 
-	return ret
+    return ret
 
 def showtitle(nr, totlist, vislist, midchar, endchar):
-	line = ''
-	for o in vislist:
-		line = line + o.title(nr)
-		if o is not vislist[-1]:
-			line = line + midchar
-		elif totlist != vislist:
-			line = line + endchar
-	sys.stdout.write(line + '\n')
+    line = ''
+    for o in vislist:
+        line = line + o.title(nr)
+        if o is not vislist[-1]:
+            line = line + midchar
+        elif totlist != vislist:
+            line = line + endchar
+    sys.stdout.write(line + '\n')
 
 def showcsvtitle(nr, totlist):
-	line = ''
-	for o in totlist:
-		line = line + o.titlecsv(nr)
-		if o is not totlist[-1]:
-			line = line + ','
-	outputfile.write(line + '\n')
+    line = ''
+    for o in totlist:
+        line = line + o.titlecsv(nr)
+        if o is not totlist[-1]:
+            line = line + ','
+    outputfile.write(line + '\n')
 
 def info(level, str):
-	&quot;Output info message&quot;
-#	if level &lt;= op.verbose:
-	print str
+    &quot;Output info message&quot;
+#   if level &lt;= op.verbose:
+    print str
 
 def die(ret, str):
-	&quot;Print error and exit with errorcode&quot;
-	info(0, str)
-	exit(ret)
+    &quot;Print error and exit with errorcode&quot;
+    info(0, str)
+    exit(ret)
 
 def initterm():
-	&quot;Initialise terminal&quot;
-	global termsize
+    &quot;Initialise terminal&quot;
+    global termsize
 
-	termsize = None, None
+    termsize = None, None
 
-	### Unbuffered sys.stdout
-	sys.stdout = os.fdopen(1, 'w', 0)
+    ### Unbuffered sys.stdout
+    sys.stdout = os.fdopen(1, 'w', 0)
 
-	try:
-		global fcntl, struct, termios
-		import fcntl, struct, termios
-		termios.TIOCGWINSZ
-	except:
-		try:
-			curses.setupterm()
-			curses.tigetnum('lines'), curses.tigetnum('cols')
-		except:
-			pass
-		else:
-			termsize = None, 2
-	else:
-		termsize = None, 1
+    try:
+        global fcntl, struct, termios
+        import fcntl, struct, termios
+        termios.TIOCGWINSZ
+    except:
+        try:
+            curses.setupterm()
+            curses.tigetnum('lines'), curses.tigetnum('cols')
+        except:
+            pass
+        else:
+            termsize = None, 2
+    else:
+        termsize = None, 1
 
 def gettermsize():
-	&quot;Return the dynamic terminal geometry&quot;
-	global termsize
+    &quot;Return the dynamic terminal geometry&quot;
+    global termsize
 
-	if not termsize[0]:
-		try:
-			if termsize[1] == 1:
-				s = struct.pack('HHHH', 0, 0, 0, 0)
-				x = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, s)
-				return struct.unpack('HHHH', x)[:2]
-			elif termsize[1] == 2:
-				curses.setupterm()
-				return curses.tigetnum('lines'), curses.tigetnum('cols')
-			else:
-				termsize = (int(os.environ['LINES']), int(os.environ['COLUMNS']))
-		except:
-			termsize = 25, 80
-	return termsize
+    if not termsize[0]:
+        try:
+            if termsize[1] == 1:
+                s = struct.pack('HHHH', 0, 0, 0, 0)
+                x = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, s)
+                return struct.unpack('HHHH', x)[:2]
+            elif termsize[1] == 2:
+                curses.setupterm()
+                return curses.tigetnum('lines'), curses.tigetnum('cols')
+            else:
+                termsize = (int(os.environ['LINES']), int(os.environ['COLUMNS']))
+        except:
+            termsize = 25, 80
+    return termsize
 
 def getcpunr():
-	&quot;Return the number of CPUs in the system&quot;
-	cpunr = -1
-	for line in dopen('/proc/stat').readlines():
-		if line[0:3] == 'cpu':
-			cpunr = cpunr + 1
-	if cpunr &lt; 0:
-		raise &quot;Problem finding number of CPUs in system.&quot;
-	return cpunr
+    &quot;Return the number of CPUs in the system&quot;
+    cpunr = -1
+    for line in dopen('/proc/stat').readlines():
+        if line[0:3] == 'cpu':
+            cpunr = cpunr + 1
+    if cpunr &lt; 0:
+        raise &quot;Problem finding number of CPUs in system.&quot;
+    return cpunr
 
 ### FIXME: Add scsi support too and improve
 def sysfs_dev(device):
-	&quot;Convert sysfs device names into device names&quot;
-	m = re.match('ide/host([0-9])/bus([0-9])/target([0-9])/lun([0-9])/disc', device)
-	if m:
-		l = m.groups()
-		# ide/host0/bus0/target0/lun0/disc -&gt; 0 -&gt; hda
-		# ide/host0/bus1/target0/lun0/disc -&gt; 2 -&gt; hdc
-		nr = int(l[1]) * 2 + int(l[3])
-		return 'hd' + chr(ord('a') + nr)
-	m = re.match('placeholder', device)
-	if m:
-		return 'sdX'
-	return device
+    &quot;Convert sysfs device names into device names&quot;
+    m = re.match('ide/host([0-9])/bus([0-9])/target([0-9])/lun([0-9])/disc', device)
+    if m:
+        l = m.groups()
+        # ide/host0/bus0/target0/lun0/disc -&gt; 0 -&gt; hda
+        # ide/host0/bus1/target0/lun0/disc -&gt; 2 -&gt; hdc
+        nr = int(l[1]) * 2 + int(l[3])
+        return 'hd' + chr(ord('a') + nr)
+    m = re.match('placeholder', device)
+    if m:
+        return 'sdX'
+    return device
 
 def dev(maj, min):
-	&quot;Convert major/minor pairs into device names&quot;
-	ram = [1, ]
-	ide = [3, 22, 33, 34, 56, 57, 88, 89, 90, 91]
-	loop = [7, ]
-	scsi = [8, 65, 66, 67, 68, 69, 70, 71, 128, 129, 130, 131, 132, 133, 134, 135]
-	md = [9, ]
-	ida = [72, 73, 74, 75, 76, 77, 78, 79]
-	ubd = [98,]
-	cciss = [104,]
-	dm =  [253,]
-	if maj in scsi:
-		disc = chr(ord('a') + scsi.index(maj) * 16 + min / 16)
-		part = min % 16
-		if not part: return 'sd%s' % disc
-		return 'sd%s%d' % (disc, part)
-	elif maj in ide:
-		disc = chr(ord('a') + ide.index(maj) * 2 + min / 64)
-		part = min % 64
-		if not part: return 'hd%s' % disc
-		return 'hd%s%d' % (disc, part)
-	elif maj in dm:
-		return 'dm-%d' % min
-	elif maj in md:
-		return 'md%d' % min
-	elif maj in loop:
-		return 'loop%d' % min
-	elif maj in ram:
-		return 'ram%d' % min
-	elif maj in cciss:
-		disc = cciss.index(maj) * 16 + min / 16
-		part = min % 16
-		if not part: return 'c0d%d' % disc
-		return 'c0d%dp%d' % (disc, part)
-	elif maj in ida:
-		cont = ida.index(maj)
-		disc = min / 16
-		part = min % 16
-		if not part: return 'ida%d-%d' % (cont, disc)
-		return 'ida%d-%d-%d' % (cont, disc, part)
-	elif maj in ubd:
-		disc = ubd.index(maj) * 16 + min / 16
-		part = min % 16
-		if not part: return 'ubd%d' % disc
-		return 'ubd%d-%d' % (disc, part)
-	else:
-		return 'dev%d-%d' % (maj, min)
+    &quot;Convert major/minor pairs into device names&quot;
+    ram = [1, ]
+    ide = [3, 22, 33, 34, 56, 57, 88, 89, 90, 91]
+    loop = [7, ]
+    scsi = [8, 65, 66, 67, 68, 69, 70, 71, 128, 129, 130, 131, 132, 133, 134, 135]
+    md = [9, ]
+    ida = [72, 73, 74, 75, 76, 77, 78, 79]
+    ubd = [98,]
+    cciss = [104,]
+    dm =  [253,]
+    if maj in scsi:
+        disc = chr(ord('a') + scsi.index(maj) * 16 + min / 16)
+        part = min % 16
+        if not part: return 'sd%s' % disc
+        return 'sd%s%d' % (disc, part)
+    elif maj in ide:
+        disc = chr(ord('a') + ide.index(maj) * 2 + min / 64)
+        part = min % 64
+        if not part: return 'hd%s' % disc
+        return 'hd%s%d' % (disc, part)
+    elif maj in dm:
+        return 'dm-%d' % min
+    elif maj in md:
+        return 'md%d' % min
+    elif maj in loop:
+        return 'loop%d' % min
+    elif maj in ram:
+        return 'ram%d' % min
+    elif maj in cciss:
+        disc = cciss.index(maj) * 16 + min / 16
+        part = min % 16
+        if not part: return 'c0d%d' % disc
+        return 'c0d%dp%d' % (disc, part)
+    elif maj in ida:
+        cont = ida.index(maj)
+        disc = min / 16
+        part = min % 16
+        if not part: return 'ida%d-%d' % (cont, disc)
+        return 'ida%d-%d-%d' % (cont, disc, part)
+    elif maj in ubd:
+        disc = ubd.index(maj) * 16 + min / 16
+        part = min % 16
+        if not part: return 'ubd%d' % disc
+        return 'ubd%d-%d' % (disc, part)
+    else:
+        return 'dev%d-%d' % (maj, min)
 
 #def mountpoint(dev):
-#	&quot;Return the mountpoint of a mounted device/file&quot;
-#	for entry in dopen('/etc/mtab').readlines():
-#		if entry:
-#			list = entry.split()
-#			if dev == list[0]:
-#				return list[1]
+#   &quot;Return the mountpoint of a mounted device/file&quot;
+#   for entry in dopen('/etc/mtab').readlines():
+#       if entry:
+#           list = entry.split()
+#           if dev == list[0]:
+#               return list[1]
 
 def readfile(file):
-	ret = ''
-	for line in open(file,'r').readlines():
-		ret = ret + line
-	return ret
+    ret = ''
+    for line in open(file,'r').readlines():
+        ret = ret + line
+    return ret
 
 def signaler(signum, frame):
-	signal.alarm(interval)
+    signal.alarm(interval)
 
 def exit(ret):
-	signal.signal(signal.SIGALRM, signal.SIG_IGN)
-	sys.stdout.write(ansi['reset'])
-	sys.exit(ret)
+    signal.signal(signal.SIGALRM, signal.SIG_IGN)
+    sys.stdout.write(ansi['reset'])
+    sys.exit(ret)
 
 def listmodules():
-	import glob
-	rows, cols = gettermsize()
-	remod = re.compile('.+/dstat_(.+).py$')
-	for path in sys.path:
-		list = []
-		for file in glob.glob(path + '/dstat_*.py'):
-			list.append(remod.match(file).groups()[0])
-		if not list: continue
-		list.sort()
-		cols2 = cols - 8
-		print '%s:\n\t' % os.path.abspath(path),
-		for mod in list:
-			cols2 = cols2 - len(mod) - 2
-			if cols2 &lt;= 0:
-				print '\n\t',
-				cols2 = cols - len(mod) - 10
-			print mod + ',',
-		print
+    import glob
+    rows, cols = gettermsize()
+    remod = re.compile('.+/dstat_(.+).py$')
+    for path in sys.path:
+        list = []
+        for file in glob.glob(path + '/dstat_*.py'):
+            list.append(remod.match(file).groups()[0])
+        if not list: continue
+        list.sort()
+        cols2 = cols - 8
+        print '%s:\n\t' % os.path.abspath(path),
+        for mod in list:
+            cols2 = cols2 - len(mod) - 2
+            if cols2 &lt;= 0:
+                print '\n\t',
+                cols2 = cols - len(mod) - 10
+            print mod + ',',
+        print
 
 def main():
-	global update, loop, step, pagesize, cpunr, ansi, interval, outputfile, tick, cols
+    global update, loop, step, pagesize, cpunr, ansi, interval, outputfile, tick, cols
 
-	loop = update = 0
-	step = op.delay
-	tick = ticks()
-	pagesize = resource.getpagesize()
-	cpunr = getcpunr()
-#	hz = os.sysconf('SC_CLK_TCK')
-	interval = 1
+    loop = update = 0
+    step = op.delay
+    tick = ticks()
+    pagesize = resource.getpagesize()
+    cpunr = getcpunr()
+#   hz = os.sysconf('SC_CLK_TCK')
+    interval = 1
 
-	user = getpass.getuser()
-	hostname = os.uname()[1].split('.')[0]
+    user = getpass.getuser()
+    hostname = os.uname()[1].split('.')[0]
 
-	rows, cols = gettermsize()
+    rows, cols = gettermsize()
 
-	### Write term-title
-	if op.isatty:
-		shell = os.getenv('XTERM_SHELL')
-		term = os.getenv('TERM')
-		if shell == '/bin/bash' and term and re.compile('(screen*|xterm*)').match(term):
-			sys.stdout.write('\033]0;(%s@%s) %s %s\007' % (user, hostname, os.path.basename(sys.argv[0]), ' '.join(op.args)))
+    ### Write term-title
+    if op.isatty:
+        shell = os.getenv('XTERM_SHELL')
+        term = os.getenv('TERM')
+        if shell == '/bin/bash' and term and re.compile('(screen*|xterm*)').match(term):
+            sys.stdout.write('\033]0;(%s@%s) %s %s\007' % (user, hostname, os.path.basename(sys.argv[0]), ' '.join(op.args)))
 
-	### Check background color (rxvt)
-	### COLORFGBG=&quot;15;default;0&quot;
-#	if os.environ['COLORFGBG'] and len(os.environ['COLORFGBG'].split(';')) &gt;= 3:
-#		l = os.environ['COLORFGBG'].split(';')
-#		bg = int(l[2])
-#		if bg &lt; 7:
-#			print 'Background is dark'
-#		else:
-#			print 'Background is light'
-#	else:
-#		print 'Background is unknown, assuming dark.'
+    ### Check background color (rxvt)
+    ### COLORFGBG=&quot;15;default;0&quot;
+#   if os.environ['COLORFGBG'] and len(os.environ['COLORFGBG'].split(';')) &gt;= 3:
+#       l = os.environ['COLORFGBG'].split(';')
+#       bg = int(l[2])
+#       if bg &lt; 7:
+#           print 'Background is dark'
+#       else:
+#           print 'Background is light'
+#   else:
+#       print 'Background is unknown, assuming dark.'
 
-	### Check terminal capabilities
-	if op.isatty:
-		op.color = True
-		try:
-			import curses
-			curses.setupterm()
-			if curses.tigetnum('colors') &lt; 0:
-				op.color = False
-		except:
-			op.color = False
+    ### Check terminal capabilities
+    if op.isatty:
+        op.color = True
+        try:
+            import curses
+            curses.setupterm()
+            if curses.tigetnum('colors') &lt; 0:
+                op.color = False
+        except:
+            op.color = False
 
-	if op.output:
-		if os.path.exists(op.output):
-			outputfile = open(op.output, 'a', 0)
-			outputfile.write('\n\n')
-		else:
-			outputfile = open(op.output, 'w', 0)
-			outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
-			outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
+    if op.output:
+        if os.path.exists(op.output):
+            outputfile = open(op.output, 'a', 0)
+            outputfile.write('\n\n')
+        else:
+            outputfile = open(op.output, 'w', 0)
+            outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
+            outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
 
-		outputfile.write('&quot;Host:&quot;,&quot;%s&quot;,,,,&quot;User:&quot;,&quot;%s&quot;\n' % (hostname, user))
-		outputfile.write('&quot;Cmdline:&quot;,&quot;dstat %s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n\n' % (' '.join(op.args), time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
+        outputfile.write('&quot;Host:&quot;,&quot;%s&quot;,,,,&quot;User:&quot;,&quot;%s&quot;\n' % (hostname, user))
+        outputfile.write('&quot;Cmdline:&quot;,&quot;dstat %s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n\n' % (' '.join(op.args), time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
 
-	### Empty ansi database if no colors are requested
-	if not op.color:
-		op.update = False
-		for key in ansi.keys():
-			ansi[key] = ''
+    ### Empty ansi database if no colors are requested
+    if not op.color:
+        op.update = False
+        for key in ansi.keys():
+            ansi[key] = ''
 
-	if not op.update:
-		interval = op.delay
+    if not op.update:
+        interval = op.delay
 
-	### Build list of requested modules
-	linewidth = 0
-	oldvislist = []
-	totlist = []
-	for module in op.modlist:
-		if module in ('list', 'help'):
-			listmodules()
-			exit(0)
-		elif module == 'cpu':  mods = ( 'cpu', 'cpu24' )
-		elif module == 'disk': mods = ( 'disk', 'disk24', 'disk24old' )
-		elif module == 'int':  mods = ( 'int', 'int24' )
-		elif module == 'page': mods = ( 'page', 'page24' )
-		elif module == 'swap': mods = ( 'swap', 'swapold' )
-		else: mods = ( module, )
+    ### Build list of requested modules
+    linewidth = 0
+    oldvislist = []
+    totlist = []
+    for module in op.modlist:
+        if module in ('list', 'help'):
+            listmodules()
+            exit(0)
+        elif module == 'cpu':  mods = ( 'cpu', 'cpu24' )
+        elif module == 'disk': mods = ( 'disk', 'disk24', 'disk24old' )
+        elif module == 'int':  mods = ( 'int', 'int24' )
+        elif module == 'page': mods = ( 'page', 'page24' )
+        elif module == 'swap': mods = ( 'swap', 'swapold' )
+        else: mods = ( module, )
 
-		for mod in mods:
-			if 'dstat_'+mod not in globals().keys():
-				try:
-					import imp
-					file, pathname, description = imp.find_module('dstat_'+mod)
-#					exec compile(readfile(pathname), pathname, 'exec')
-					execfile(pathname)
-				except Exception, e:
-					info(1, 'Module %s failed to load. (%s)' % (mod, e))
-#					tb = sys.exc_info()[2]
-					continue
+        for mod in mods:
+            if 'dstat_'+mod not in globals().keys():
+                try:
+                    import imp
+                    file, pathname, description = imp.find_module('dstat_'+mod)
+#                   exec compile(readfile(pathname), pathname, 'exec')
+                    execfile(pathname)
+                except Exception, e:
+                    info(1, 'Module %s failed to load. (%s)' % (mod, e))
+#                   tb = sys.exc_info()[2]
+                    continue
 
-			try:
-#				exec compile('o = dstat_%s()' % mod, '&lt;string&gt;', 'single')
-				exec 'o = dstat_%s()' % mod
+            try:
+#               exec compile('o = dstat_%s()' % mod, '&lt;string&gt;', 'single')
+                exec 'o = dstat_%s()' % mod
 
-				### Remove defect stat objects and calculate line length
-				if not o.check():
-					raise Exception, 'Unknown problem, please report'
+                ### Remove defect stat objects and calculate line length
+                if not o.check():
+                    raise Exception, 'Unknown problem, please report'
 
-				linewidth = linewidth + o.statwidth() + 1
-				totlist.append(o)
-				break
+                linewidth = linewidth + o.statwidth() + 1
+                totlist.append(o)
+                break
 
-			except Exception, e:
-				if mod == mods[-1]:
-					info(1, 'Module %s has problems. (%s)' % (mod, e))
-					if op.debug:
-						raise
-				continue
+            except Exception, e:
+                if mod == mods[-1]:
+                    info(1, 'Module %s has problems. (%s)' % (mod, e))
+                    if op.debug:
+                        raise
+                continue
 
-	if not totlist:
-		die(8, 'None of the stats you selected are available.')
+    if not totlist:
+        die(8, 'None of the stats you selected are available.')
 
-	if op.debug:
-		for o in totlist:
-			print 'Module', str(o.__class__).split('.')[1],
-			if hasattr(o, 'file'): print 'requires', o.file,
-			print
+    if op.debug:
+        for o in totlist:
+            print 'Module', str(o.__class__).split('.')[1],
+            if hasattr(o, 'file'): print 'requires', o.file,
+            print
 
-	if op.output:
-		showcsvtitle(1, totlist)
-		showcsvtitle(2, totlist)
+    if op.output:
+        showcsvtitle(1, totlist)
+        showcsvtitle(2, totlist)
 
-	### Increase precision if we're root (does not seem to have effect)
-#	if os.geteuid() == 0:
-#		os.nice(-20)
-#	sys.setcheckinterval(op.delay / 10000)
+    ### Increase precision if we're root (does not seem to have effect)
+#   if os.geteuid() == 0:
+#       os.nice(-20)
+#   sys.setcheckinterval(op.delay / 10000)
 
-	### Always show header the first time
-	showheader = True
+    ### Always show header the first time
+    showheader = True
 
-	signal.signal(signal.SIGALRM, signaler)
-	signal.alarm(interval)
+    signal.signal(signal.SIGALRM, signaler)
+    signal.alarm(interval)
 
-	tt = 0
+    tt = 0
 
-	### Let the games begin
-	while update &lt;= op.delay * op.count or op.count == -1:
+    ### Let the games begin
+    while update &lt;= op.delay * op.count or op.count == -1:
 
-		if op.debug:
-			if step == 1: tt = 0
-			t1 = time.time()
-			curwidth = 8
-		else:
-			curwidth = 0
+        if op.debug:
+            if step == 1: tt = 0
+            t1 = time.time()
+            curwidth = 8
+        else:
+            curwidth = 0
 
-		### Trim object list to what is visible on screen
-		if op.isatty:
-			rows, cols = gettermsize()
-			vislist = []
-			for o in totlist:
-				newwidth = curwidth + o.statwidth() + 1
-				if newwidth &lt;= cols or ( vislist == totlist[:-1] and newwidth &lt; cols ):
-					vislist.append(o)
-					curwidth = newwidth
-	
-			### Check when to display the header
-			if op.header and rows &gt;= 6:
-				if oldvislist != vislist:
-					showheader = True
-				elif step == 1 and loop % (rows - 1) == 0:
-					showheader = True
+        ### Trim object list to what is visible on screen
+        if op.isatty:
+            rows, cols = gettermsize()
+            vislist = []
+            for o in totlist:
+                newwidth = curwidth + o.statwidth() + 1
+                if newwidth &lt;= cols or ( vislist == totlist[:-1] and newwidth &lt; cols ):
+                    vislist.append(o)
+                    curwidth = newwidth
+    
+            ### Check when to display the header
+            if op.header and rows &gt;= 6:
+                if oldvislist != vislist:
+                    showheader = True
+                elif step == 1 and loop % (rows - 1) == 0:
+                    showheader = True
 
-			oldvislist = vislist
-		else:
-			vislist = totlist
+            oldvislist = vislist
+        else:
+            vislist = totlist
 
-		if showheader:
-			if loop == 0 and totlist != vislist:
-				info(1, 'Terminal width too small, trimming output.')
-			showheader = False
-			showtitle(1, totlist, vislist, ansi['darkblue'] + char['space'], ansi['darkblue'] + char['gt'])
-			showtitle(2, totlist, vislist, ansi['gray'] + char['pipe'], ansi['darkblue'] + char['gt'])
+        if showheader:
+            if loop == 0 and totlist != vislist:
+                info(1, 'Terminal width too small, trimming output.')
+            showheader = False
+            showtitle(1, totlist, vislist, ansi['darkblue'] + char['space'], ansi['darkblue'] + char['gt'])
+            showtitle(2, totlist, vislist, ansi['gray'] + char['pipe'], ansi['darkblue'] + char['gt'])
 
-		### Prepare the colors for intermediate updates, last step in a loop is definitive
-		if step == op.delay:
-			ansi['default'] = ansi['reset']
-		else:
-			ansi['default'] = ansi['gray']
-		line = ansi['default']
+        ### Prepare the colors for intermediate updates, last step in a loop is definitive
+        if step == op.delay:
+            ansi['default'] = ansi['reset']
+        else:
+            ansi['default'] = ansi['gray']
+        line = ansi['default']
 
-		### Calculate all objects (visible, invisible)
-		oline = ''
-		for o in totlist:
-			o.extract()
-			if o in vislist:
-				line = line + o.show() + o.showend(totlist, vislist)
-			if op.output and step == op.delay:
-				oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
+        ### Calculate all objects (visible, invisible)
+        oline = ''
+        for o in totlist:
+            o.extract()
+            if o in vislist:
+                line = line + o.show() + o.showend(totlist, vislist)
+            if op.output and step == op.delay:
+                oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
 
-		### Print stats
-		sys.stdout.write(line + ansi['default'])
-		if op.output and step == op.delay:
-			outputfile.write(oline + '\n')
+        ### Print stats
+        sys.stdout.write(line + ansi['default'])
+        if op.output and step == op.delay:
+            outputfile.write(oline + '\n')
 
-		### Print debugging output
-		if op.debug:
-			t2 = time.time();
-			tt = tt + (t2 - t1) * 1000.0
-			if loop == 0: tt = tt * step
-			if op.debug == 1:
-				sys.stdout.write('%6.2fms' % (tt / step))
-			elif op.debug &gt; 1:
-				sys.stdout.write('%6.2f [%d:%d:%d]' % (tt / step, loop, step, update))
+        ### Print debugging output
+        if op.debug:
+            t2 = time.time();
+            tt = tt + (t2 - t1) * 1000.0
+            if loop == 0: tt = tt * step
+            if op.debug == 1:
+                sys.stdout.write('%6.2fms' % (tt / step))
+            elif op.debug &gt; 1:
+                sys.stdout.write('%6.2f [%d:%d:%d]' % (tt / step, loop, step, update))
 
-		### If intermediate results, update increases with 1 sec (=interval)
-		update = update + interval
+        ### If intermediate results, update increases with 1 sec (=interval)
+        update = update + interval
 
-		if not op.update:
-			sys.stdout.write('\n')
+        if not op.update:
+            sys.stdout.write('\n')
 
-		### Do not pause when this is the final loop
-		if update &lt;= op.delay * op.count or op.count == -1:
-			signal.pause()
+        ### Do not pause when this is the final loop
+        if update &lt;= op.delay * op.count or op.count == -1:
+            signal.pause()
 
-		### The last step in a loop is to show the definitive line on its own line
-		if op.update:
-			if step == op.delay:
-				sys.stdout.write('\n' + ansi['reset'] + ansi['clearline'] + ansi['save'])
-#				import gc
-#				for object in gc.get_objects():
-#					if isinstance(object, dstat):
-#						print dir(object)
-#						for object2 in gc.get_referents(object):
-#							print object2
-			else:
-				sys.stdout.write(ansi['restore'])
+        ### The last step in a loop is to show the definitive line on its own line
+        if op.update:
+            if step == op.delay:
+                sys.stdout.write('\n' + ansi['reset'] + ansi['clearline'] + ansi['save'])
+#               import gc
+#               for object in gc.get_objects():
+#                   if isinstance(object, dstat):
+#                       print dir(object)
+#                       for object2 in gc.get_referents(object):
+#                           print object2
+            else:
+                sys.stdout.write(ansi['restore'])
 
-		loop = (update + op.delay - 1) / op.delay
-		step = ((update - 1) % op.delay) + 1
-		tick = step
+        loop = (update + op.delay - 1) / op.delay
+        step = ((update - 1) % op.delay) + 1
+        tick = step
 
-	signal.signal(signal.SIGALRM, signal.SIG_IGN)
+    signal.signal(signal.SIGALRM, signal.SIG_IGN)
 
 ### Main entrance
 if __name__ == '__main__':
-	try:
-		initterm()
-		op = Options(sys.argv[1:])
-		main()
-	except KeyboardInterrupt, e:
-		print
-#	except IOError, e:
-#		if e.errno != 32:				## [Errno 32] Broken pipe
-#			print
-#			print 'IOError: %s' % e
-#			exit(7)
-#	except OSError, e:
-#		print
-#		print 'OSError: %s' % e
-#		exit(7)
-	exit(0)
+    try:
+        initterm()
+        op = Options(sys.argv[1:])
+        main()
+    except KeyboardInterrupt, e:
+        print
+#   except IOError, e:
+#       if e.errno != 32:               ## [Errno 32] Broken pipe
+#           print
+#           print 'IOError: %s' % e
+#           exit(7)
+#   except OSError, e:
+#       print
+#       print 'OSError: %s' % e
+#       exit(7)
+    exit(0)
 else:
-	op = Options('')
-	step = 1
-	tick = ticks()
+    op = Options('')
+    step = 1
+    tick = ticks()
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/dstat15
===================================================================
--- trunk/tools/dstat/dstat15	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/dstat15	2007-05-12 04:12:27 UTC (rev 5392)
@@ -19,211 +19,211 @@
 VERSION = '0.6.6'
 
 def inspath(path):
-	if os.path.isdir(path) and path not in sys.path:
-		sys.path.insert(1, path)
+    if os.path.isdir(path) and path not in sys.path:
+        sys.path.insert(1, path)
 
 try:
-	import sys, signal, os, re, time, string
-	import types, signal, resource, getpass
-	inspath('/usr/local/share/dstat/')
-	inspath('/usr/share/dstat/')
-	inspath(os.path.abspath(os.path.dirname(sys.argv[0])) + '/plugins/')	# binary path + /plugins/
-	inspath(os.getcwd() + '/plugins/')										# current path + /plugins/
-	inspath(os.getcwd())													# current path
-	inspath(os.path.expanduser('~/.dstat/'))								# home + /.dstat/
+    import sys, signal, os, re, time, string
+    import types, signal, resource, getpass
+    inspath('/usr/local/share/dstat/')
+    inspath('/usr/share/dstat/')
+    inspath(os.path.abspath(os.path.dirname(sys.argv[0])) + '/plugins/')    # binary path + /plugins/
+    inspath(os.getcwd() + '/plugins/')                                      # current path + /plugins/
+    inspath(os.getcwd())                                                    # current path
+    inspath(os.path.expanduser('~/.dstat/'))                                # home + /.dstat/
 except KeyboardInterrupt, e:
-	pass
+    pass
 
 #if sys.version_info &lt; (1, 5):
-#	sys.exit('error: Python 1.5 or later required')
+#   sys.exit('error: Python 1.5 or later required')
 
 ### Workaround for python &lt;= 2.2.1
 try:
-	True, False
+    True, False
 except NameError:
-	True = 1
-	False = 0
+    True = 1
+    False = 0
 
 ### Workaround for python &lt; 2.3 (FIXME: check for sys.version_info existence)
 if True:
-	def enumerate(sequence):
-		index = 0
-		list = []
-		for item in sequence:
-			list.append((index, item))
-			index = index + 1
-		return list
+    def enumerate(sequence):
+        index = 0
+        list = []
+        for item in sequence:
+            list.append((index, item))
+            index = index + 1
+        return list
 
 ### Workaround for python &lt; 2.3
 if True:
-	def sum(sequence):
-		ret = 0
-		for i in sequence:
-			ret = ret + i
-		return ret
+    def sum(sequence):
+        ret = 0
+        for i in sequence:
+            ret = ret + i
+        return ret
 
 class Options:
-	def __init__(self, args):
-		self.args = args
-		self.count = -1
-		self.cpulist = None
-		self.debug = 0
-		self.delay = 1
-		self.disklist = None
-		self.full = False
-		self.integer = False
-		self.intlist = None
-		self.netlist = None
-		self.swaplist = None
-		self.color = False
-		self.update = True
-		self.header = True
-		self.output = False
-		self.isatty = sys.stdout.isatty()
+    def __init__(self, args):
+        self.args = args
+        self.count = -1
+        self.cpulist = None
+        self.debug = 0
+        self.delay = 1
+        self.disklist = None
+        self.full = False
+        self.integer = False
+        self.intlist = None
+        self.netlist = None
+        self.swaplist = None
+        self.color = False
+        self.update = True
+        self.header = True
+        self.output = False
+        self.isatty = sys.stdout.isatty()
 
-		### Implicit if no terminal is used
-		if not self.isatty:
-			self.update = False
-			self.header = False
+        ### Implicit if no terminal is used
+        if not self.isatty:
+            self.update = False
+            self.header = False
 
-		### Temporary hardcoded for my own project
-		self.diskset = {
-			'local': ('sda', 'hd[a-d]'),
-			'lores': ('sd[b-k]', 'sd[v-z]', 'sda[a-e]'),
-			'hires': ('sd[l-u]', 'sda[f-o]'),
-		}
+        ### Temporary hardcoded for my own project
+        self.diskset = {
+            'local': ('sda', 'hd[a-d]'),
+            'lores': ('sd[b-k]', 'sd[v-z]', 'sda[a-e]'),
+            'hires': ('sd[l-u]', 'sda[f-o]'),
+        }
 
-		try:
-			import getopt
-			opts, args = getopt.getopt (args, 'acdfghilmno:pstTvyC:D:I:M:N:S:V',
-				['cpu', 'disk', 'epoch', 'int', 'ipc', 'load', 'lock', 'mem', 'net',
-				'page', 'proc', 'raw', 'swap', 'sys', 'tcp', 'time', 'udp', 'unix', 
-				'all', 'debug', 'full', 'help', 'integer', 'mods', 'modules', 'nocolor',
-				'noheaders', 'noupdate', 'output=', 'version', 'vmstat'])
-		except getopt.error, exc:
-			print 'dstat: %s, try dstat -h for a list of all the options' % str(exc)
-			exit(1)
+        try:
+            import getopt
+            opts, args = getopt.getopt (args, 'acdfghilmno:pstTvyC:D:I:M:N:S:V',
+                ['cpu', 'disk', 'epoch', 'int', 'ipc', 'load', 'lock', 'mem', 'net',
+                'page', 'proc', 'raw', 'swap', 'sys', 'tcp', 'time', 'udp', 'unix', 
+                'all', 'debug', 'full', 'help', 'integer', 'mods', 'modules', 'nocolor',
+                'noheaders', 'noupdate', 'output=', 'version', 'vmstat'])
+        except getopt.error, exc:
+            print 'dstat: %s, try dstat -h for a list of all the options' % str(exc)
+            exit(1)
 
-		self.modlist = []
+        self.modlist = []
 
-		for opt, arg in opts:
-			if opt in ['-c', '--cpu']:
-				self.modlist.append('cpu')
-			elif opt in ['-C']:
-				self.cpulist = string.split(arg, ',')
-			elif opt in ['-d', '--disk']:
-				self.modlist.append('disk')
-			elif opt in ['-D']:
-				self.disklist = string.split(arg, ',')
-			elif opt in ['--debug']:
-				self.debug = self.debug + 1
-			elif opt in ['-g', '--page']:
-				self.modlist.append('page')
-			elif opt in ['-i', '--int']:
-				self.modlist.append('int')
-			elif opt in ['-I']:
-				self.intlist = string.split(arg, ',')
-			elif opt in ['--ipc']:
-				self.modlist.append('ipc')
-			elif opt in ['-l', '--load']:
-				self.modlist.append('load')
-			elif opt in ['--lock']:
-				self.modlist.append('lock')
-			elif opt in ['-m', '--mem']:
-				self.modlist.append('mem')
-			elif opt in ['-M', '--mods', '--modules']:
-				self.modlist = self.modlist + string.split(arg, ',')
-			elif opt in ['-n', '--net']:
-				self.modlist.append('net')
-			elif opt in ['-N']:
-				self.netlist = string.split(arg, ',')
-			elif opt in ['-p', '--proc']:
-				self.modlist.append('proc')
-			elif opt in ['--raw']:
-				self.modlist.append('raw')
-			elif opt in ['-s', '--swap']:
-				self.modlist.append('swap')
-			elif opt in ['-S']:
-				self.swaplist = string.split(arg, ',')
-			elif opt in ['--tcp']:
-				self.modlist.append('tcp')
-			elif opt in ['-t', '--time']:
-				self.modlist.append('time')
-			elif opt in ['-T', '--epoch']:
-				self.modlist.append('epoch')
-			elif opt in ['--udp']:
-				self.modlist.append('udp')
-			elif opt in ['--unix']:
-				self.modlist.append('unix')
-			elif opt in ['-y', '--sys']:
-				self.modlist.append('sys')
+        for opt, arg in opts:
+            if opt in ['-c', '--cpu']:
+                self.modlist.append('cpu')
+            elif opt in ['-C']:
+                self.cpulist = string.split(arg, ',')
+            elif opt in ['-d', '--disk']:
+                self.modlist.append('disk')
+            elif opt in ['-D']:
+                self.disklist = string.split(arg, ',')
+            elif opt in ['--debug']:
+                self.debug = self.debug + 1
+            elif opt in ['-g', '--page']:
+                self.modlist.append('page')
+            elif opt in ['-i', '--int']:
+                self.modlist.append('int')
+            elif opt in ['-I']:
+                self.intlist = string.split(arg, ',')
+            elif opt in ['--ipc']:
+                self.modlist.append('ipc')
+            elif opt in ['-l', '--load']:
+                self.modlist.append('load')
+            elif opt in ['--lock']:
+                self.modlist.append('lock')
+            elif opt in ['-m', '--mem']:
+                self.modlist.append('mem')
+            elif opt in ['-M', '--mods', '--modules']:
+                self.modlist = self.modlist + string.split(arg, ',')
+            elif opt in ['-n', '--net']:
+                self.modlist.append('net')
+            elif opt in ['-N']:
+                self.netlist = string.split(arg, ',')
+            elif opt in ['-p', '--proc']:
+                self.modlist.append('proc')
+            elif opt in ['--raw']:
+                self.modlist.append('raw')
+            elif opt in ['-s', '--swap']:
+                self.modlist.append('swap')
+            elif opt in ['-S']:
+                self.swaplist = string.split(arg, ',')
+            elif opt in ['--tcp']:
+                self.modlist.append('tcp')
+            elif opt in ['-t', '--time']:
+                self.modlist.append('time')
+            elif opt in ['-T', '--epoch']:
+                self.modlist.append('epoch')
+            elif opt in ['--udp']:
+                self.modlist.append('udp')
+            elif opt in ['--unix']:
+                self.modlist.append('unix')
+            elif opt in ['-y', '--sys']:
+                self.modlist.append('sys')
 
-			elif opt in ['-a', '--all']:
-				self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys' ]
-			elif opt in ['-v', '--vmstat']:
-				self.modlist = self.modlist + [ 'proc', 'mem', 'page', 'disk', 'sys', 'cpu' ]
-			elif opt in ['-f', '--full']:
-				self.full = True
+            elif opt in ['-a', '--all']:
+                self.modlist = self.modlist + [ 'cpu', 'disk', 'net', 'page', 'sys' ]
+            elif opt in ['-v', '--vmstat']:
+                self.modlist = self.modlist + [ 'proc', 'mem', 'page', 'disk', 'sys', 'cpu' ]
+            elif opt in ['-f', '--full']:
+                self.full = True
 
-			elif opt in ['--integer']:
-				self.integer = True
-			elif opt in ['--nocolor']:
-				self.color = False
-				self.update = False
-			elif opt in ['--noheaders']:
-				self.header = False
-			elif opt in ['--noupdate']:
-				self.update = False
-			elif opt in ['-o', '--output']:
-				self.output = arg
-			elif opt in ['-h', '--help']:
-				self.usage()
-				self.help()
-				exit(0)
-			elif opt in ['-V', '--version']:
-				self.version()
-				exit(0)
+            elif opt in ['--integer']:
+                self.integer = True
+            elif opt in ['--nocolor']:
+                self.color = False
+                self.update = False
+            elif opt in ['--noheaders']:
+                self.header = False
+            elif opt in ['--noupdate']:
+                self.update = False
+            elif opt in ['-o', '--output']:
+                self.output = arg
+            elif opt in ['-h', '--help']:
+                self.usage()
+                self.help()
+                exit(0)
+            elif opt in ['-V', '--version']:
+                self.version()
+                exit(0)
 
-		if not self.modlist:
-			self.modlist = [ 'cpu', 'disk', 'net', 'page', 'sys' ]
+        if not self.modlist:
+            self.modlist = [ 'cpu', 'disk', 'net', 'page', 'sys' ]
 
-		try:
-			if len(args) &gt; 0: self.delay = int(args[0])
-			if len(args) &gt; 1: self.count = int(args[1])
-		except:
-			print 'dstat: incorrect argument, try dstat -h for the correct syntax'
-			exit(1)
+        try:
+            if len(args) &gt; 0: self.delay = int(args[0])
+            if len(args) &gt; 1: self.count = int(args[1])
+        except:
+            print 'dstat: incorrect argument, try dstat -h for the correct syntax'
+            exit(1)
 
-		if self.delay &lt;= 0:
-			print 'dstat: delay must be an integer, greater than zero'
-			exit(1)
+        if self.delay &lt;= 0:
+            print 'dstat: delay must be an integer, greater than zero'
+            exit(1)
 
-	def version(self):
-		print 'Dstat %s' % VERSION
-		print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
-		print 'Homepage at <A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>'
-		print
-		print 'Platform %s/%s' % (os.name, sys.platform)
-		print 'Kernel %s' % os.uname()[2]
-		print 'Python %s' % sys.version
-		print
-		rows, cols = gettermsize()
-		print 'Terminal size: %d lines, %d columns' % (rows, cols)
-		print
-		print 'Processors: %d' % getcpunr()
-		print 'Pagesize: %d' % resource.getpagesize()
-#		print 'Clock ticks per secs: %d' % os.sysconf('SC_CLK_TCK')
-		print
+    def version(self):
+        print 'Dstat %s' % VERSION
+        print 'Written by Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;'
+        print 'Homepage at <A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>'
+        print
+        print 'Platform %s/%s' % (os.name, sys.platform)
+        print 'Kernel %s' % os.uname()[2]
+        print 'Python %s' % sys.version
+        print
+        rows, cols = gettermsize()
+        print 'Terminal size: %d lines, %d columns' % (rows, cols)
+        print
+        print 'Processors: %d' % getcpunr()
+        print 'Pagesize: %d' % resource.getpagesize()
+#       print 'Clock ticks per secs: %d' % os.sysconf('SC_CLK_TCK')
+        print
 
-		global op
-		op = self
-		listmodules()
+        global op
+        op = self
+        listmodules()
 
-	def usage(self):
-		print 'Usage: dstat [-afv] [options..] [delay [count]]'
+    def usage(self):
+        print 'Usage: dstat [-afv] [options..] [delay [count]]'
 
-	def help(self):
-		print '''Versatile tool for generating system resource statistics
+    def help(self):
+        print '''Versatile tool for generating system resource statistics
 
 Dstat options:
   -c, --cpu              enable cpu stats
@@ -270,1698 +270,1698 @@
 
 ### START STATS DEFINITIONS ###
 class dstat:
-	### Initialise default variables
-	def init(self, vars=(), len=0):
-		if vars:
-			self.val = {}; self.cn1 = {}; self.cn2 = {}
-			for name in vars:
-				if len &lt;= 1:
-					self.val[name] = self.cn1[name] = self.cn2[name] = 0
-				else:
-					self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
-					for i in range(len):
-						self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
+    ### Initialise default variables
+    def init(self, vars=(), len=0):
+        if vars:
+            self.val = {}; self.cn1 = {}; self.cn2 = {}
+            for name in vars:
+                if len &lt;= 1:
+                    self.val[name] = self.cn1[name] = self.cn2[name] = 0
+                else:
+                    self.val[name] = self.cn1[name] = self.cn2[name] = range(len)
+                    for i in range(len):
+                        self.val[name][i] = self.cn1[name][i] = self.cn2[name][i] = 0
 
-	def open(self, *files):
-		&quot;Open stat file descriptor&quot;
-		self.file = []
-		self.fd = []
-		for file in files:
-			fd = dopen(file)
-			if fd:
-				self.file.append(file)
-				self.fd.append(fd)
-			else:
-				raise Exception, 'Cannot open file %s.' % file
+    def open(self, *files):
+        &quot;Open stat file descriptor&quot;
+        self.file = []
+        self.fd = []
+        for file in files:
+            fd = dopen(file)
+            if fd:
+                self.file.append(file)
+                self.fd.append(fd)
+            else:
+                raise Exception, 'Cannot open file %s.' % file
 
-	def readlines(self):
-		ret = []
-		for fd in self.fd:
-			fd.seek(0)
-			ret = ret + fd.readlines()
-		return ret
+    def readlines(self):
+        ret = []
+        for fd in self.fd:
+            fd.seek(0)
+            ret = ret + fd.readlines()
+        return ret
 
-	def statwidth(self):
-		&quot;Return complete stat width&quot;
-		return len(self.vars) * self.width() + len(self.vars) - 1
+    def statwidth(self):
+        &quot;Return complete stat width&quot;
+        return len(self.vars) * self.width() + len(self.vars) - 1
 
-	def width(self):
-		&quot;Return column width&quot;
-		if isinstance(self.name, types.StringType):
-			return self.format[1]
-		else:
-			return len(self.nick) * self.format[1] + len(self.nick) - 1
+    def width(self):
+        &quot;Return column width&quot;
+        if isinstance(self.name, types.StringType):
+            return self.format[1]
+        else:
+            return len(self.nick) * self.format[1] + len(self.nick) - 1
 
-	def title(self, nr):
-		if nr == 1:
-			return self.title1()
-		else:
-			return self.title2()
+    def title(self, nr):
+        if nr == 1:
+            return self.title1()
+        else:
+            return self.title2()
 
-	def title1(self):
-		ret = ansi['darkblue']
-		if isinstance(self.name, types.StringType):
-			max = self.statwidth()
-			return ret + string.replace(string.center(self.name[0:max], max), ' ', '-') + ansi['default']
-		for i, name in enumerate(self.name):
-			max = self.width()
-			ret = ret + string.replace(string.center(name[0:max], max), ' ', '-')
-			if i + 1 != len(self.name):
-				if op.color:
-					ret = ret + ansi['blue'] + char['dash'] + ansi['darkblue']
-				else:
-					ret = ret + char['space']
-		return ret
+    def title1(self):
+        ret = ansi['darkblue']
+        if isinstance(self.name, types.StringType):
+            max = self.statwidth()
+            return ret + string.replace(string.center(self.name[0:max], max), ' ', '-') + ansi['default']
+        for i, name in enumerate(self.name):
+            max = self.width()
+            ret = ret + string.replace(string.center(name[0:max], max), ' ', '-')
+            if i + 1 != len(self.name):
+                if op.color:
+                    ret = ret + ansi['blue'] + char['dash'] + ansi['darkblue']
+                else:
+                    ret = ret + char['space']
+        return ret
 
-	def title2(self):
-		if isinstance(self.name, types.StringType):
-			ret = ''
-			for i, nick in enumerate(self.nick):
-				ret = ret + ansi['blue'] + ansi['underline'] + string.center(nick, self.format[1]) + ansi['default']
-				if i + 1 != len(self.nick): ret = ret + char['space']
-			return ret
-		else:
-			ret = ''
-			for i, name in enumerate(self.name):
-				for j, nick in enumerate(self.nick):
-					ret = ret + ansi['blue'] + ansi['underline'] + string.center(nick, self.format[1]) + ansi['default']
-					if j + 1 != len(self.nick): ret = ret + char['space']
-				if i + 1 != len(self.name): ret = ret + ansi['gray'] + char['colon']
-			return ret
+    def title2(self):
+        if isinstance(self.name, types.StringType):
+            ret = ''
+            for i, nick in enumerate(self.nick):
+                ret = ret + ansi['blue'] + ansi['underline'] + string.center(nick, self.format[1]) + ansi['default']
+                if i + 1 != len(self.nick): ret = ret + char['space']
+            return ret
+        else:
+            ret = ''
+            for i, name in enumerate(self.name):
+                for j, nick in enumerate(self.nick):
+                    ret = ret + ansi['blue'] + ansi['underline'] + string.center(nick, self.format[1]) + ansi['default']
+                    if j + 1 != len(self.nick): ret = ret + char['space']
+                if i + 1 != len(self.name): ret = ret + ansi['gray'] + char['colon']
+            return ret
 
-	def titlecsv(self, nr):
-		if nr == 1:
-			return self.titlecsv1()
-		else:
-			return self.titlecsv2()
+    def titlecsv(self, nr):
+        if nr == 1:
+            return self.titlecsv1()
+        else:
+            return self.titlecsv2()
 
-	def titlecsv1(self):
-		if isinstance(self.name, types.StringType):
-			return '&quot;' + self.name + '&quot;' + ',' * (len(self.nick) - 1)
-		else:
-			ret = ''
-			for i, name in enumerate(self.name):
-				ret = ret + '&quot;' + name + '&quot;' + ',' * (len(self.nick) - 1)
-				if i + 1 != len(self.name): ret = ret + ','
-			return ret
+    def titlecsv1(self):
+        if isinstance(self.name, types.StringType):
+            return '&quot;' + self.name + '&quot;' + ',' * (len(self.nick) - 1)
+        else:
+            ret = ''
+            for i, name in enumerate(self.name):
+                ret = ret + '&quot;' + name + '&quot;' + ',' * (len(self.nick) - 1)
+                if i + 1 != len(self.name): ret = ret + ','
+            return ret
 
-	def titlecsv2(self):
-		if isinstance(self.name, types.StringType):
-			ret = ''
-			for i, nick in enumerate(self.nick):
-				ret = ret + '&quot;' + nick + '&quot;'
-				if i + 1 != len(self.nick): ret = ret + ','
-			return ret
-		else:
-			ret = ''
-			for i, name in enumerate(self.name):
-				for j, nick in enumerate(self.nick):
-					ret = ret + '&quot;' + nick + '&quot;'
-					if j + 1 != len(self.nick): ret = ret + ','
-				if i + 1 != len(self.name): ret = ret + ','
-			return ret
+    def titlecsv2(self):
+        if isinstance(self.name, types.StringType):
+            ret = ''
+            for i, nick in enumerate(self.nick):
+                ret = ret + '&quot;' + nick + '&quot;'
+                if i + 1 != len(self.nick): ret = ret + ','
+            return ret
+        else:
+            ret = ''
+            for i, name in enumerate(self.name):
+                for j, nick in enumerate(self.nick):
+                    ret = ret + '&quot;' + nick + '&quot;'
+                    if j + 1 != len(self.nick): ret = ret + ','
+                if i + 1 != len(self.name): ret = ret + ','
+            return ret
 
-	def check(self):
-		&quot;Check if stat is applicable&quot;
-#		if hasattr(self, 'fd') and not self.fd:
-#			raise Exception, 'File %s does not exist' % self.file
-		if not self.vars:
-			raise Exception, 'No objects found, no stats available'
-		if not self.discover:
-			raise Exception, 'No objects discovered, no stats available'
-		if self.width():
-			return True
-		raise Exception, 'Unknown problem, please report'
+    def check(self):
+        &quot;Check if stat is applicable&quot;
+#       if hasattr(self, 'fd') and not self.fd:
+#           raise Exception, 'File %s does not exist' % self.file
+        if not self.vars:
+            raise Exception, 'No objects found, no stats available'
+        if not self.discover:
+            raise Exception, 'No objects discovered, no stats available'
+        if self.width():
+            return True
+        raise Exception, 'Unknown problem, please report'
 
-	def discover(self):
-		return True
+    def discover(self):
+        return True
 
-	def show(self):
-		&quot;Display stat results&quot;
-		line = ''
-		for i, name in enumerate(self.vars):
-			if isinstance(self.val[name], types.TupleType) or isinstance(self.val[name], types.ListType):
-				line = line + cprintlist(self.val[name], self.format)
-				sep = ansi['gray'] + char['colon']
-			else:
-				line = line + cprint(self.val[name], self.format)
-				sep = char['space']
-			if i + 1 != len(self.vars):
-				line = line + sep
-		return line
+    def show(self):
+        &quot;Display stat results&quot;
+        line = ''
+        for i, name in enumerate(self.vars):
+            if isinstance(self.val[name], types.TupleType) or isinstance(self.val[name], types.ListType):
+                line = line + cprintlist(self.val[name], self.format)
+                sep = ansi['gray'] + char['colon']
+            else:
+                line = line + cprint(self.val[name], self.format)
+                sep = char['space']
+            if i + 1 != len(self.vars):
+                line = line + sep
+        return line
 
-	def showend(self, totlist, vislist):
-		if self is not vislist[-1]:
-			return ansi['gray'] + char['pipe']
-		elif totlist != vislist:
-			return ansi['gray'] + char['gt']
-		return ''
+    def showend(self, totlist, vislist):
+        if self is not vislist[-1]:
+            return ansi['gray'] + char['pipe']
+        elif totlist != vislist:
+            return ansi['gray'] + char['gt']
+        return ''
 
-	def showcsv(self):
-		def printcsv(var):
-			if var != round(var):
-				return '%.3f' % var
-			return '%s' % round(var)
+    def showcsv(self):
+        def printcsv(var):
+            if var != round(var):
+                return '%.3f' % var
+            return '%s' % round(var)
 
-		line = ''
-		for i, name in enumerate(self.vars):
-			if isinstance(self.val[name], types.ListType) or isinstance(self.val[name], types.TupleType):
-				for j, val in enumerate(self.val[name]):
-					line = line + printcsv(val)
-					if j + 1 != len(self.val[name]):
-						line = line + ','
-			elif isinstance(self.val[name], types.StringType):
-				line = line + self.val[name]
-			else:
-				line = line + printcsv(self.val[name])
-			if i + 1 != len(self.vars):
-				line = line + ','
-		return line
+        line = ''
+        for i, name in enumerate(self.vars):
+            if isinstance(self.val[name], types.ListType) or isinstance(self.val[name], types.TupleType):
+                for j, val in enumerate(self.val[name]):
+                    line = line + printcsv(val)
+                    if j + 1 != len(self.val[name]):
+                        line = line + ','
+            elif isinstance(self.val[name], types.StringType):
+                line = line + self.val[name]
+            else:
+                line = line + printcsv(self.val[name])
+            if i + 1 != len(self.vars):
+                line = line + ','
+        return line
 
-	def showcsvend(self, totlist, vislist):
-		if self is not vislist[-1]:
-			return ','
-		elif self is not totlist[-1]:
-			return ','
-		return ''
+    def showcsvend(self, totlist, vislist):
+        if self is not vislist[-1]:
+            return ','
+        elif self is not totlist[-1]:
+            return ','
+        return ''
 
 class dstat_cpu(dstat):
-	def __init__(self):
-		self.format = ('p', 3, 34)
-		self.open('/proc/stat')
-		self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = self.name()
-		self.init(self.vars + ['total',], 6)
+    def __init__(self):
+        self.format = ('p', 3, 34)
+        self.open('/proc/stat')
+        self.nick = ( 'usr', 'sys', 'idl', 'wai', 'hiq', 'siq' )
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = self.name()
+        self.init(self.vars + ['total',], 6)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
-			ret.append(l[0][3:])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 8 or l[0][0:3] != 'cpu': continue
+            ret.append(l[0][3:])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def name(self):
-		ret = []
-		for name in self.vars:
-			if name == 'total':
-				ret.append('total cpu usage')
-			else:
-				ret.append('cpu' + name + ' usage')
-		return ret
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name == 'total':
+                ret.append('total cpu usage')
+            else:
+                ret.append('cpu' + name + ' usage')
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.cpulist:
-			list = op.cpulist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = []
-			cpu = 0
-			while cpu &lt; cpunr:
-				list.append(str(cpu))
-				cpu = cpu + 1
-#			if len(list) &gt; 2: list = list[0:2]
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.cpulist:
+            list = op.cpulist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = []
+            cpu = 0
+            while cpu &lt; cpunr:
+                list.append(str(cpu))
+                cpu = cpu + 1
+#           if len(list) &gt; 2: list = list[0:2]
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 8: continue
-			for name in self.vars:
-				if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-					self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
-		for name in self.vars:
-			for i in range(6):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 8: continue
+            for name in self.vars:
+                if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
+                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]), long(l[5]), long(l[6]), long(l[7]) )
+        for name in self.vars:
+            for i in range(6):
+                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_cpu24(dstat):
-	def __init__(self):
-		self.format = ('p', 3, 34)
-		self.open('/proc/stat')
-		self.nick = ( 'usr', 'sys', 'idl')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = self.name()
-		self.init(self.vars + ['total',], 3)
+    def __init__(self):
+        self.format = ('p', 3, 34)
+        self.open('/proc/stat')
+        self.nick = ( 'usr', 'sys', 'idl')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = self.name()
+        self.init(self.vars + ['total',], 3)
 
-	def name(self):
-		ret = []
-		for name in self.vars:
-			if name:
-				ret.append('cpu' + name)
-			else:
-				ret.append('cpu total')
-		return ret
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name:
+                ret.append('cpu' + name)
+            else:
+                ret.append('cpu total')
+        return ret
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) != 5 or l[0][0:3] != 'cpu': continue
-			ret.append(l[0][3:])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) != 5 or l[0][0:3] != 'cpu': continue
+            ret.append(l[0][3:])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.cpulist:
-			list = op.cpulist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = []
-			cpu = 0
-			while cpu &lt; cpunr:
-				list.append(str(cpu))
-				cpu = cpu + 1
-#			if len(list) &gt; 2: list = list[0:2]
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.cpulist:
+            list = op.cpulist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = []
+            cpu = 0
+            while cpu &lt; cpunr:
+                list.append(str(cpu))
+                cpu = cpu + 1
+#           if len(list) &gt; 2: list = list[0:2]
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			for name in self.vars:
-				if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
-					self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
-		for name in self.vars:
-			for i in range(3):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            for name in self.vars:
+                if l[0] == 'cpu' + name or ( l[0] == 'cpu' and name == 'total' ):
+                    self.cn2[name] = ( long(l[1]) + long(l[2]), long(l[3]), long(l[4]) )
+        for name in self.vars:
+            for i in range(3):
+                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_disk(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/diskstats')
-		self.nick = ('read', 'writ')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = []
-		for name in self.vars: self.name.append('dsk/' + name)
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/diskstats')
+        self.nick = ('read', 'writ')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = []
+        for name in self.vars: self.name.append('dsk/' + name)
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 13: continue
-			if l[3:] == ['0',] * 11: continue
-			name = l[2]
-			if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
-			ret.append(name)
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 13: continue
+            if l[3:] == ['0',] * 11: continue
+            name = l[2]
+            if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
+            ret.append(name)
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.disklist:
-			list = op.disklist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total'] + op.diskset.keys():
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.disklist:
+            list = op.disklist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total'] + op.diskset.keys():
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 13: continue
-			if l[5] == '0' and l[9] == '0': continue
-			name = l[2]
-			if l[3:] == ['0',] * 11: continue
-			if not re.match('(md[0-9]+|dm-[0-9]+)', name):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
-			if name in self.vars and name != 'total':
-				self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
-			for set in self.vars:
-				if set in op.diskset.keys():
-					for disk in op.diskset[set]:
-						if re.match('^'+disk+'$', name):
-							self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
-		for name in self.cn2.keys():
-			self.val[name] = ( 
-				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-			)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for name in self.vars: self.cn2[name] = (0, 0)
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 13: continue
+            if l[5] == '0' and l[9] == '0': continue
+            name = l[2]
+            if l[3:] == ['0',] * 11: continue
+            if not re.match('(md[0-9]+|dm-[0-9]+)', name):
+                self.cn2['total'] = ( self.cn2['total'][0] + long(l[5]), self.cn2['total'][1] + long(l[9]) )
+            if name in self.vars and name != 'total':
+                self.cn2[name] = ( self.cn2[name][0] + long(l[5]), self.cn2[name][1] + long(l[9]) )
+            for set in self.vars:
+                if set in op.diskset.keys():
+                    for disk in op.diskset[set]:
+                        if re.match('^'+disk+'$', name):
+                            self.cn2[set] = ( self.cn2[set][0] + long(l[5]), self.cn2[set][1] + long(l[9]) )
+        for name in self.cn2.keys():
+            self.val[name] = ( 
+                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+            )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_disk24(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/partitions')
-		self.nick = ('read', 'writ')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		if self.fd and not self.discover:
-			raise Exception, 'Kernel is not compiled with CONFIG_BLK_STATS'
-		self.name = []
-		for name in self.vars: self.name.append('dsk/' + sysfs_dev(name))
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/partitions')
+        self.nick = ('read', 'writ')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        if self.fd and not self.discover:
+            raise Exception, 'Kernel is not compiled with CONFIG_BLK_STATS'
+        self.name = []
+        for name in self.vars: self.name.append('dsk/' + sysfs_dev(name))
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
-			name = l[3]
-			if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
-			ret.append(name)	
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
+            name = l[3]
+            if re.match('(md[0-9]+|dm-[0-9]+)', name): continue
+            ret.append(name)    
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.disklist:
-			list = op.disklist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total'] + op.diskset.keys():
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.disklist:
+            list = op.disklist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total'] + op.diskset.keys():
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
-			name = l[3]
-			if not re.match('(md[0-9]+|dm-[0-9]+)', name):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]) )
-			if name in self.vars:
-				self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
-			for set in self.vars:
-				if set in op.diskset.keys():
-					for disk in op.diskset[set]:
-						if re.match('^'+disk+'$', name):
-							self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
-		for name in self.cn2.keys():
-			self.val[name] = ( 
-				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-			)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for name in self.vars: self.cn2[name] = (0, 0)
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 15 or l[0] == 'major' or int(l[1]) % 16 != 0: continue
+            name = l[3]
+            if not re.match('(md[0-9]+|dm-[0-9]+)', name):
+                self.cn2['total'] = ( self.cn2['total'][0] + long(l[6]), self.cn2['total'][1] + long(l[10]) )
+            if name in self.vars:
+                self.cn2[name] = ( self.cn2[name][0] + long(l[6]), self.cn2[name][1] + long(l[10]) )
+            for set in self.vars:
+                if set in op.diskset.keys():
+                    for disk in op.diskset[set]:
+                        if re.match('^'+disk+'$', name):
+                            self.cn2[set] = ( self.cn2[set][0] + long(l[6]), self.cn2[set][1] + long(l[10]) )
+        for name in self.cn2.keys():
+            self.val[name] = ( 
+                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+            )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 ### FIXME: Needs rework, does anyone care ?
 class dstat_disk24old(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/stat')
-		self.nick = ('read', 'writ')
-		self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = []
-		for name in self.vars: self.name.append('dsk/' + name)
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/stat')
+        self.nick = ('read', 'writ')
+        self.regexp = re.compile('^\((\d+),(\d+)\):\(\d+,\d+,(\d+),\d+,(\d+)\)$')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = []
+        for name in self.vars: self.name.append('dsk/' + name)
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line, ':')
-			if len(l) &lt; 3: continue
-			name = l[0]
-			if name != 'disk_io': continue
-			for pair in string.split(line)[1:]:
-				m = self.regexp.match(pair)
-				if not m: continue
-				l = m.groups()
-				if len(l) &lt; 4: continue
-				name = dev(int(l[0]), int(l[1]))
-				ret.append(name)
-			break
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line, ':')
+            if len(l) &lt; 3: continue
+            name = l[0]
+            if name != 'disk_io': continue
+            for pair in string.split(line)[1:]:
+                m = self.regexp.match(pair)
+                if not m: continue
+                l = m.groups()
+                if len(l) &lt; 4: continue
+                name = dev(int(l[0]), int(l[1]))
+                ret.append(name)
+            break
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.disklist:
-			list = op.disklist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total'] + op.diskset.keys():
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.disklist:
+            list = op.disklist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total'] + op.diskset.keys():
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for name in self.vars: self.cn2[name] = (0, 0)
-		for line in self.readlines():
-			l = string.split(line, ':')
-			if len(l) &lt; 3: continue
-			name = l[0]
-			if name != 'disk_io': continue
-			for pair in string.split(line)[1:]:
-				m = self.regexp.match(pair)
-				if not m: continue
-				l = m.groups()
-				if len(l) &lt; 4: continue
-				name = dev(int(l[0]), int(l[1]))
-				if not re.match('(md[0-9]+)', name):
-					self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
-				if name in self.vars and name != 'total':
-					self.cn2[name] = ( self.cn2[name][0] + long(l[2]), self.cn2[name][1] + long(l[3]) )
-				for set in self.vars:
-					if set in op.diskset.keys():
-						for disk in op.diskset[set]:
-							if re.match('^'+disk+'$', name):
-								self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
-			break
-		for name in self.cn2.keys():
-			self.val[name] = (
-				(self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
-				(self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
-			)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for name in self.vars: self.cn2[name] = (0, 0)
+        for line in self.readlines():
+            l = string.split(line, ':')
+            if len(l) &lt; 3: continue
+            name = l[0]
+            if name != 'disk_io': continue
+            for pair in string.split(line)[1:]:
+                m = self.regexp.match(pair)
+                if not m: continue
+                l = m.groups()
+                if len(l) &lt; 4: continue
+                name = dev(int(l[0]), int(l[1]))
+                if not re.match('(md[0-9]+)', name):
+                    self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[3]) )
+                if name in self.vars and name != 'total':
+                    self.cn2[name] = ( self.cn2[name][0] + long(l[2]), self.cn2[name][1] + long(l[3]) )
+                for set in self.vars:
+                    if set in op.diskset.keys():
+                        for disk in op.diskset[set]:
+                            if re.match('^'+disk+'$', name):
+                                self.cn2[set] = ( self.cn2[set][0] + long(l[2]), self.cn2[set][1] + long(l[3]) )
+            break
+        for name in self.cn2.keys():
+            self.val[name] = (
+                (self.cn2[name][0] - self.cn1[name][0]) * 512.0 / tick,
+                (self.cn2[name][1] - self.cn1[name][1]) * 512.0 / tick,
+            )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_epoch(dstat):
-	def __init__(self):
-		self.name = 'epoch'
-		self.format = ('t', 10, 0)
-		if op.debug:
-			self.format = ('t', 14, 0)
-		self.nick = ('epoch',)
-		self.vars = self.nick
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'epoch'
+        self.format = ('t', 10, 0)
+        if op.debug:
+            self.format = ('t', 14, 0)
+        self.nick = ('epoch',)
+        self.vars = self.nick
+        self.init(self.vars, 1)
 
-	def extract(self):
-		self.val['epoch'] = time.time()
+    def extract(self):
+        self.val['epoch'] = time.time()
 
-#	def show(self):
-#		return ansi['reset'] + ( '%10.2f' % self.val['epoch'] )
+#   def show(self):
+#       return ansi['reset'] + ( '%10.2f' % self.val['epoch'] )
 
 class dstat_int(dstat):
-	def __init__(self):
-		self.name = 'interrupts'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/stat')
-		self.discover = self.discover()
-		self.intmap = self.intmap()
-		self.vars = self.vars()
-		self.nick = self.vars
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'interrupts'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/stat')
+        self.discover = self.discover()
+        self.intmap = self.intmap()
+        self.vars = self.vars()
+        self.nick = self.vars
+        self.init(self.vars, 1)
 
-	def intmap(self):
-		ret = {}
-		for line in dopen('/proc/interrupts').readlines():
-			l = string.split(line)
-			if len(l) &lt;= cpunr: continue
-			l1 = string.split(l[0], ':')[0]
-			l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
-			ret[l1] = l1
-			for name in l2:
-				name = string.lower(string.strip(name))
-				ret[name] = l1
-		return ret
+    def intmap(self):
+        ret = {}
+        for line in dopen('/proc/interrupts').readlines():
+            l = string.split(line)
+            if len(l) &lt;= cpunr: continue
+            l1 = string.split(l[0], ':')[0]
+            l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
+            ret[l1] = l1
+            for name in l2:
+                name = string.lower(string.strip(name))
+                ret[name] = l1
+        return ret
 
-	def discover(self):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if l[0] != 'intr': continue
-			for name, i in enumerate(l[2:]):
-				if long(i) &gt; 10: ret.append(str(name))
-		return ret
+    def discover(self):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if l[0] != 'intr': continue
+            for name, i in enumerate(l[2:]):
+                if long(i) &gt; 10: ret.append(str(name))
+        return ret
 
-#	def check(self):
-#		if self.fd[0] and self.vars:
-#			self.fd[0].seek(0)
-#			for line in self.fd[0].readlines():
-#				l = string.split(line)
-#				if l[0] != 'intr': continue
-#				return True
-#		return False
+#   def check(self):
+#       if self.fd[0] and self.vars:
+#           self.fd[0].seek(0)
+#           for line in self.fd[0].readlines():
+#               l = string.split(line)
+#               if l[0] != 'intr': continue
+#               return True
+#       return False
 
-	def vars(self):
-		ret = []
-		if op.intlist:
-			list = op.intlist
-		else:
-			list = self.discover
-			for name in list:
-				if name in ('0', '1', '2', '8', 'NMI', 'LOC', 'MIS', 'CPU0'):
-					list.remove(name)
-			if not op.full and len(list) &gt; 3: list = list[-3:]
-		for name in list:
-			if name in self.discover:
-				ret.append(name)
-			elif string.lower(name) in self.intmap.keys():
-				ret.append(self.intmap[string.lower(name)])
-		return ret
+    def vars(self):
+        ret = []
+        if op.intlist:
+            list = op.intlist
+        else:
+            list = self.discover
+            for name in list:
+                if name in ('0', '1', '2', '8', 'NMI', 'LOC', 'MIS', 'CPU0'):
+                    list.remove(name)
+            if not op.full and len(list) &gt; 3: list = list[-3:]
+        for name in list:
+            if name in self.discover:
+                ret.append(name)
+            elif string.lower(name) in self.intmap.keys():
+                ret.append(self.intmap[string.lower(name)])
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if not l or l[0] != 'intr': continue
-			for name in self.vars:
-				self.cn2[name] = long(l[int(name) + 2])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if not l or l[0] != 'intr': continue
+            for name in self.vars:
+                self.cn2[name] = long(l[int(name) + 2])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_int24(dstat):
-	def __init__(self):
-		self.name = 'interrupts'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/interrupts')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.nick = self.vars
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'interrupts'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/interrupts')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.nick = self.vars
+        self.init(self.vars, 1)
 
-	def intmap(self):
-		ret = {}
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt;= cpunr: continue
-			l1 = string.split(l[0], ':')[0]
-			l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
-			ret[l1] = l1
-			for name in l2:
-				name = string.lower(string.strip(name))
-				ret[name] = l1
-		return ret
+    def intmap(self):
+        ret = {}
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt;= cpunr: continue
+            l1 = string.split(l[0], ':')[0]
+            l2 = string.split(string.join(l[cpunr+2:], ' '), ',')
+            ret[l1] = l1
+            for name in l2:
+                name = string.lower(string.strip(name))
+                ret[name] = l1
+        return ret
 
-	def discover(self):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; cpunr+1: continue
-			name = string.split(l[0], ':')[0]
-			if long(l[1]) &gt; 10:
-				ret.append(name)
-		return ret
+    def discover(self):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; cpunr+1: continue
+            name = string.split(l[0], ':')[0]
+            if long(l[1]) &gt; 10:
+                ret.append(name)
+        return ret
 
-#	def check(self):
-#		if self.fd and self.discover:
-#			self.fd[0].seek(0)
-#			for line in self.fd[0].readlines():
-#				l = string.split(line)
-#				if l[0] != 'intr' or len(l) &gt; 2: continue
-#				return True
-#		return False
+#   def check(self):
+#       if self.fd and self.discover:
+#           self.fd[0].seek(0)
+#           for line in self.fd[0].readlines():
+#               l = string.split(line)
+#               if l[0] != 'intr' or len(l) &gt; 2: continue
+#               return True
+#       return False
 
-	def vars(self):
-		ret = []
-		if op.intlist:
-			list = op.intlist
-		else:
-			list = self.discover
-			for name in list:
-				if name in ('0', '1', '2', '8', 'CPU0', 'ERR', 'LOC', 'MIS', 'NMI'):
-					list.remove(name)
-			if not op.full and len(list) &gt; 3: list = list[-3:]
-		for name in list:
-			if name in self.discover:
-				ret.append(name)
-			elif string.lower(name) in self.intmap.keys():
-				ret.append(self.intmap[string.lower(name)])
-		return ret
+    def vars(self):
+        ret = []
+        if op.intlist:
+            list = op.intlist
+        else:
+            list = self.discover
+            for name in list:
+                if name in ('0', '1', '2', '8', 'CPU0', 'ERR', 'LOC', 'MIS', 'NMI'):
+                    list.remove(name)
+            if not op.full and len(list) &gt; 3: list = list[-3:]
+        for name in list:
+            if name in self.discover:
+                ret.append(name)
+            elif string.lower(name) in self.intmap.keys():
+                ret.append(self.intmap[string.lower(name)])
+        return ret
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; cpunr+1: continue
-			name = string.split(l[0], ':')[0]
-			if name in self.vars:
-				self.cn2[name] = 0
-				for i in l[1:1+cpunr]:
-					self.cn2[name] = self.cn2[name] + long(i)
-#			elif len(l) &gt; 2 + cpunr:
-#				for hw in self.vars:
-#					for mod in l[2+cpunr:]:
-#						self.cn2[mod] = long(l[1])
-		for name in self.cn2.keys():
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; cpunr+1: continue
+            name = string.split(l[0], ':')[0]
+            if name in self.vars:
+                self.cn2[name] = 0
+                for i in l[1:1+cpunr]:
+                    self.cn2[name] = self.cn2[name] + long(i)
+#           elif len(l) &gt; 2 + cpunr:
+#               for hw in self.vars:
+#                   for mod in l[2+cpunr:]:
+#                       self.cn2[mod] = long(l[1])
+        for name in self.cn2.keys():
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_ipc(dstat):
-	def __init__(self):
-		self.name = 'sysv ipc'
-		self.format = ('d', 3, 10)
-		self.vars = ('msg', 'sem', 'shm')
-		self.nick = self.vars
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'sysv ipc'
+        self.format = ('d', 3, 10)
+        self.vars = ('msg', 'sem', 'shm')
+        self.nick = self.vars
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars:
-			self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
+    def extract(self):
+        for name in self.vars:
+            self.val[name] = len(dopen('/proc/sysvipc/'+name).readlines()) - 1
 
 class dstat_load(dstat):
-	def __init__(self):
-		self.name = 'load avg'
-		self.format = ('f', 4, 10)
-		self.open('/proc/loadavg')
-		self.nick = ('1m', '5m', '15m')
-		self.vars = ('load1', 'load5', 'load15')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'load avg'
+        self.format = ('f', 4, 10)
+        self.open('/proc/loadavg')
+        self.nick = ('1m', '5m', '15m')
+        self.vars = ('load1', 'load5', 'load15')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 3: continue
-			self.val['load1'] = float(l[0])
-			self.val['load5'] = float(l[1])
-			self.val['load15'] = float(l[2])
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 3: continue
+            self.val['load1'] = float(l[0])
+            self.val['load5'] = float(l[1])
+            self.val['load15'] = float(l[2])
 
 class dstat_lock(dstat):
-	def __init__(self):
-		self.name = 'file locks'
-		self.format = ('f', 3, 10)
-		self.open('/proc/locks')
-		self.nick = ('pos', 'lck', 'rea', 'wri')
-		self.vars = ('posix', 'flock', 'read', 'write')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'file locks'
+        self.format = ('f', 3, 10)
+        self.open('/proc/locks')
+        self.nick = ('pos', 'lck', 'rea', 'wri')
+        self.vars = ('posix', 'flock', 'read', 'write')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 4: continue
-			if l[1] == 'POSIX':
-				self.val['posix'] = self.val['posix'] + 1
-			elif l[1] == 'FLOCK':
-				self.val['flock'] = self.val['flock'] + 1
-			if l[3] == 'READ':
-				self.val['read'] = self.val['read'] + 1
-			elif l[3] == 'WRITE':
-				self.val['write'] = self.val['write'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 4: continue
+            if l[1] == 'POSIX':
+                self.val['posix'] = self.val['posix'] + 1
+            elif l[1] == 'FLOCK':
+                self.val['flock'] = self.val['flock'] + 1
+            if l[3] == 'READ':
+                self.val['read'] = self.val['read'] + 1
+            elif l[3] == 'WRITE':
+                self.val['write'] = self.val['write'] + 1
 
 class dstat_mem(dstat):
-	def __init__(self):
-		self.name = 'memory usage'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/meminfo')
-		self.nick = ('used', 'buff', 'cach', 'free')
-		self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'memory usage'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/meminfo')
+        self.nick = ('used', 'buff', 'cach', 'free')
+        self.vars = ('MemUsed', 'Buffers', 'Cached', 'MemFree')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 2: continue
-			name = string.split(l[0], ':')[0]
-			if name in self.vars + ('MemTotal', ):
-				self.val[name] = long(l[1]) * 1024.0
-		self.val['MemUsed'] = self.val['MemTotal'] - self.val['MemFree'] - self.val['Buffers'] - self.val['Cached']
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 2: continue
+            name = string.split(l[0], ':')[0]
+            if name in self.vars + ('MemTotal', ):
+                self.val[name] = long(l[1]) * 1024.0
+        self.val['MemUsed'] = self.val['MemTotal'] - self.val['MemFree'] - self.val['Buffers'] - self.val['Cached']
 
 class dstat_net(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/proc/net/dev')
-		self.nick = ('recv', 'send')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = []
-		for name in self.vars: self.name.append('net/' + name)
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/proc/net/dev')
+        self.nick = ('recv', 'send')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = []
+        for name in self.vars: self.name.append('net/' + name)
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = string.split(string.replace(line, ':', ' '))
-			if len(l) &lt; 17: continue
-			if l[2] == '0' and l[10] == '0': continue
-			name = l[0]
-			if name not in ('lo', 'face'):
-				ret.append(name)
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = string.split(string.replace(line, ':', ' '))
+            if len(l) &lt; 17: continue
+            if l[2] == '0' and l[10] == '0': continue
+            name = l[0]
+            if name not in ('lo', 'face'):
+                ret.append(name)
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.netlist:
-			list = op.netlist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total', 'lo']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.netlist:
+            list = op.netlist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total', 'lo']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		self.cn2['total'] = [0, 0]
-		for line in self.readlines():
-			l = string.split(string.replace(line, ':', ' '))
-			if len(l) &lt; 17: continue
-			if l[2] == '0' and l[10] == '0': continue
-			name = l[0]
-			if name in self.vars :
-				self.cn2[name] = ( long(l[1]), long(l[9]) )
-			if name not in ('lo','face'):
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[9]))
-		if update:
-			for name in self.cn2.keys():
-				self.val[name] = ( 
-					(self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
-					(self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
-				 )
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        self.cn2['total'] = [0, 0]
+        for line in self.readlines():
+            l = string.split(string.replace(line, ':', ' '))
+            if len(l) &lt; 17: continue
+            if l[2] == '0' and l[10] == '0': continue
+            name = l[0]
+            if name in self.vars :
+                self.cn2[name] = ( long(l[1]), long(l[9]) )
+            if name not in ('lo','face'):
+                self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[9]))
+        if update:
+            for name in self.cn2.keys():
+                self.val[name] = ( 
+                    (self.cn2[name][0] - self.cn1[name][0]) * 1.0 / tick,
+                    (self.cn2[name][1] - self.cn1[name][1]) * 1.0 / tick,
+                 )
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_page(dstat):
-	def __init__(self):
-		self.name = 'paging'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/vmstat')
-		self.nick = ('in', 'out')
-		self.vars = ('pswpin', 'pswpout')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'paging'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/vmstat')
+        self.nick = ('in', 'out')
+        self.vars = ('pswpin', 'pswpout')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 2: continue
-			name = l[0]
-			if name in self.vars:
-				self.cn2[name] = long(l[1])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 2: continue
+            name = l[0]
+            if name in self.vars:
+                self.cn2[name] = long(l[1])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_page24(dstat):
-	def __init__(self):
-		self.name = 'paging'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/stat')
-		self.nick = ('in', 'out')
-		self.vars = ('pswpin', 'pswpout')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'paging'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/stat')
+        self.nick = ('in', 'out')
+        self.vars = ('pswpin', 'pswpout')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 3: continue
-			name = l[0]
-			if name != 'swap': continue
-			self.cn2['pswpin'] = long(l[1])
-			self.cn2['pswpout'] = long(l[2])
-			break
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 3: continue
+            name = l[0]
+            if name != 'swap': continue
+            self.cn2['pswpin'] = long(l[1])
+            self.cn2['pswpout'] = long(l[2])
+            break
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * pagesize * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_proc(dstat):
-	def __init__(self):
-		self.name = 'procs'
-		self.format = ('f', 3, 10)
-		self.open('/proc/stat')
-		self.nick = ('run', 'blk', 'new')
-		self.vars = ('procs_running', 'procs_blocked', 'processes')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'procs'
+        self.format = ('f', 3, 10)
+        self.open('/proc/stat')
+        self.nick = ('run', 'blk', 'new')
+        self.vars = ('procs_running', 'procs_blocked', 'processes')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 2: continue
-			name = l[0]
-			if name == 'processes':
-				self.val['processes'] = 0
-				self.cn2[name] = long(l[1])
-			elif name == 'procs_running':
-				self.cn2[name] = self.cn2[name] + long(l[1]) - 1
-			elif name == 'procs_blocked':
-				self.cn2[name] = self.cn2[name] + long(l[1])
-		self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
-		for name in ('procs_running', 'procs_blocked'):
-			self.val[name] = self.cn2[name] * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
-			for name in ('procs_running', 'procs_blocked'):
-				self.cn2[name] = 0
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 2: continue
+            name = l[0]
+            if name == 'processes':
+                self.val['processes'] = 0
+                self.cn2[name] = long(l[1])
+            elif name == 'procs_running':
+                self.cn2[name] = self.cn2[name] + long(l[1]) - 1
+            elif name == 'procs_blocked':
+                self.cn2[name] = self.cn2[name] + long(l[1])
+        self.val['processes'] = (self.cn2['processes'] - self.cn1['processes']) * 1.0 / tick
+        for name in ('procs_running', 'procs_blocked'):
+            self.val[name] = self.cn2[name] * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
+            for name in ('procs_running', 'procs_blocked'):
+                self.cn2[name] = 0
 
 class dstat_raw(dstat):
-	def __init__(self):
-		self.name = 'raw'
-		self.format = ('f', 3, 10)
-		self.open('/proc/net/raw')
-		self.nick = ('soc',)
-		self.vars = ('sockets',)
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'raw'
+        self.format = ('f', 3, 10)
+        self.open('/proc/net/raw')
+        self.nick = ('soc',)
+        self.vars = ('sockets',)
+        self.init(self.vars, 1)
 
-	def extract(self):
-		self.val['sockets'] = len(self.readlines()) - 1
+    def extract(self):
+        self.val['sockets'] = len(self.readlines()) - 1
 
 class dstat_swap(dstat):
-	def __init__(self):
-		self.name = 'swap'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/swaps')
-		self.nick = ('used', 'free')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = []
-		for name in self.vars: self.name.append('swp/'+improve(name))
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.name = 'swap'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/swaps')
+        self.nick = ('used', 'free')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = []
+        for name in self.vars: self.name.append('swp/'+improve(name))
+        self.init(self.vars + ['total',], 2)
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 5: continue
-			if l[0] == 'Filename': continue
-#			ret.append(improve(l[0]))
-			ret.append(l[0])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 5: continue
+            if l[0] == 'Filename': continue
+#           ret.append(improve(l[0]))
+            ret.append(l[0])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.swaplist:
-			list = op.swaplist
-		elif not op.full:
-			list = ('total', )
-		else:
-			list = self.discover
-#			if len(list) &gt; 2: list = list[0:2]
-		list.sort()
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if op.swaplist:
+            list = op.swaplist
+        elif not op.full:
+            list = ('total', )
+        else:
+            list = self.discover
+#           if len(list) &gt; 2: list = list[0:2]
+        list.sort()
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		self.val['total'] = [0, 0]
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 5 or l[0] == 'Filename': continue
-			name = l[0]
-			self.val[name] = ( long(l[3]) * 1024.0, (long(l[2]) - long(l[3])) * 1024.0 )
-			self.val['total'] = ( self.val['total'][0] + self.val[name][0], self.val['total'][1] + self.val[name][1])
+    def extract(self):
+        self.val['total'] = [0, 0]
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 5 or l[0] == 'Filename': continue
+            name = l[0]
+            self.val[name] = ( long(l[3]) * 1024.0, (long(l[2]) - long(l[3])) * 1024.0 )
+            self.val['total'] = ( self.val['total'][0] + self.val[name][0], self.val['total'][1] + self.val[name][1])
 
 class dstat_swapold(dstat):
-	def __init__(self):
-		self.name = 'swap'
-		self.format = ('f', 5, 1024)
-		self.open('/proc/meminfo')
-		self.nick = ('used', 'free')
-		self.vars = ('SwapUsed', 'SwapFree')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'swap'
+        self.format = ('f', 5, 1024)
+        self.open('/proc/meminfo')
+        self.nick = ('used', 'free')
+        self.vars = ('SwapUsed', 'SwapFree')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 2: continue
-			name = string.split(l[0], ':')[0]
-			if name in self.vars + ('SwapTotal',):
-				self.val[name] = long(l[1]) * 1024.0
-		self.val['SwapUsed'] = self.val['SwapTotal'] - self.val['SwapFree']
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 2: continue
+            name = string.split(l[0], ':')[0]
+            if name in self.vars + ('SwapTotal',):
+                self.val[name] = long(l[1]) * 1024.0
+        self.val['SwapUsed'] = self.val['SwapTotal'] - self.val['SwapFree']
 
 class dstat_sys(dstat):
-	def __init__(self):
-		self.name = 'system'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/stat')
-		self.nick = ('int', 'csw')
-		self.vars = ('intr', 'ctxt')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'system'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/stat')
+        self.nick = ('int', 'csw')
+        self.vars = ('intr', 'ctxt')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 2: continue
-			name = l[0]
-			if name in self.vars:
-				self.cn2[name] = long(l[1])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 2: continue
+            name = l[0]
+            if name in self.vars:
+                self.cn2[name] = long(l[1])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 class dstat_tcp(dstat):
-	def __init__(self):
-		self.name = 'tcp sockets'
-		self.format = ('f', 3, 100)
-		self.open('/proc/net/tcp', '/proc/net/tcp6')
-		self.nick = ('lis', 'act', 'syn', 'tim', 'clo')
-		self.vars = ('listen', 'established', 'syn', 'wait', 'close')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'tcp sockets'
+        self.format = ('f', 3, 100)
+        self.open('/proc/net/tcp', '/proc/net/tcp6')
+        self.nick = ('lis', 'act', 'syn', 'tim', 'clo')
+        self.vars = ('listen', 'established', 'syn', 'wait', 'close')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 12: continue
-			### 01: established, 02: syn_sent,  03: syn_recv, 04: fin_wait1,
-			### 05: fin_wait2,   06: time_wait, 07: close,    08: close_wait,
-			### 09: last_ack,    0A: listen,    0B: closing
-			if l[3] in ('0A',): self.val['listen'] = self.val['listen'] + 1
-			elif l[3] in ('01',): self.val['established'] = self.val['established'] + 1
-			elif l[3] in ('02', '03', '09',): self.val['syn'] = self.val['syn'] + 1
-			elif l[3] in ('06',): self.val['wait'] = self.val['wait'] + 1
-			elif l[3] in ('04', '05', '07', '08', '0B',): self.val['close'] = self.val['close'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 12: continue
+            ### 01: established, 02: syn_sent,  03: syn_recv, 04: fin_wait1,
+            ### 05: fin_wait2,   06: time_wait, 07: close,    08: close_wait,
+            ### 09: last_ack,    0A: listen,    0B: closing
+            if l[3] in ('0A',): self.val['listen'] = self.val['listen'] + 1
+            elif l[3] in ('01',): self.val['established'] = self.val['established'] + 1
+            elif l[3] in ('02', '03', '09',): self.val['syn'] = self.val['syn'] + 1
+            elif l[3] in ('06',): self.val['wait'] = self.val['wait'] + 1
+            elif l[3] in ('04', '05', '07', '08', '0B',): self.val['close'] = self.val['close'] + 1
 
 class dstat_time(dstat):
-	def __init__(self):
-		self.name = 'time'
-		self.format = ('s', 14, 0)
-		self.nick = ('date/time',)
-		self.vars = ('time',)
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'time'
+        self.format = ('s', 14, 0)
+        self.nick = ('date/time',)
+        self.vars = ('time',)
+        self.init(self.vars, 1)
 
-	def extract(self):
-		self.val['time'] = time.strftime('%d-%m %H:%M:%S', time.localtime())
+    def extract(self):
+        self.val['time'] = time.strftime('%d-%m %H:%M:%S', time.localtime())
 
-	def show(self):
-		if step == op.delay:
-			color = 'silver'
-		else:
-			color = 'gray'
-		return ansi[color] + self.val['time']
+    def show(self):
+        if step == op.delay:
+            color = 'silver'
+        else:
+            color = 'gray'
+        return ansi[color] + self.val['time']
 
 class dstat_udp(dstat):
-	def __init__(self):
-		self.name = 'udp'
-		self.format = ('f', 3, 100)
-		self.open('/proc/net/udp', '/proc/net/udp6')
-		self.nick = ('lis', 'act')
-		self.vars = ('listen', 'established')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'udp'
+        self.format = ('f', 3, 100)
+        self.open('/proc/net/udp', '/proc/net/udp6')
+        self.nick = ('lis', 'act')
+        self.vars = ('listen', 'established')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = string.split(line)
-			if l[3] == '07': self.val['listen'] = self.val['listen'] + 1
-			elif l[3] == '01': self.val['established'] = self.val['established'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = string.split(line)
+            if l[3] == '07': self.val['listen'] = self.val['listen'] + 1
+            elif l[3] == '01': self.val['established'] = self.val['established'] + 1
 
 class dstat_unix(dstat):
-	def __init__(self):
-		self.name = 'unix sockets'
-		self.format = ('d', 4, 100)
-		self.open('/proc/net/unix')
-		self.nick = ('dgrm', 'strm', 'lis', 'act')
-		self.vars = ('datagram', 'stream', 'listen', 'established')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'unix sockets'
+        self.format = ('d', 4, 100)
+        self.open('/proc/net/unix')
+        self.nick = ('dgrm', 'strm', 'lis', 'act')
+        self.vars = ('datagram', 'stream', 'listen', 'established')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for line in self.readlines():
-			l = string.split(line)
-			if l[4] == '0002':
-				self.val['datagram'] = self.val['datagram'] + 1
-			elif l[4] == '0001':
-				self.val['stream'] = self.val['stream'] + 1
-				if l[5] == '01':
-					self.val['listen'] = self.val['listen'] + 1
-				elif l[5] == '03':
-					self.val['established'] = self.val['established'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for line in self.readlines():
+            l = string.split(line)
+            if l[4] == '0002':
+                self.val['datagram'] = self.val['datagram'] + 1
+            elif l[4] == '0001':
+                self.val['stream'] = self.val['stream'] + 1
+                if l[5] == '01':
+                    self.val['listen'] = self.val['listen'] + 1
+                elif l[5] == '03':
+                    self.val['established'] = self.val['established'] + 1
 
 ### END STATS DEFINITIONS ###
 
 ansi = {
-	'black': '\033[0;30m',
-	'darkred': '\033[0;31m',
-	'darkgreen': '\033[0;32m',
-	'darkyellow': '\033[0;33m',
-	'darkblue': '\033[0;34m',
-	'darkmagenta': '\033[0;35m',
-	'darkcyan': '\033[0;36m',
-	'silver': '\033[0;37m',
+    'black': '\033[0;30m',
+    'darkred': '\033[0;31m',
+    'darkgreen': '\033[0;32m',
+    'darkyellow': '\033[0;33m',
+    'darkblue': '\033[0;34m',
+    'darkmagenta': '\033[0;35m',
+    'darkcyan': '\033[0;36m',
+    'silver': '\033[0;37m',
 
-	'gray': '\033[1;30m',
-	'red': '\033[1;31m',
-	'green': '\033[1;32m',
-	'yellow': '\033[1;33m',
-	'blue': '\033[1;34m',
-	'magenta': '\033[1;35m',
-	'cyan': '\033[1;36m',
-	'white': '\033[1;37m',
+    'gray': '\033[1;30m',
+    'red': '\033[1;31m',
+    'green': '\033[1;32m',
+    'yellow': '\033[1;33m',
+    'blue': '\033[1;34m',
+    'magenta': '\033[1;35m',
+    'cyan': '\033[1;36m',
+    'white': '\033[1;37m',
 
-	'blackbg': '\033[40m',
-	'redbg': '\033[41m',
-	'greenbg': '\033[42m',
-	'yellowbg': '\033[43m',
-	'bluebg': '\033[44m',
-	'magentabg': '\033[45m',
-	'cyanbg': '\033[46m',
-	'whitebg': '\033[47m',
+    'blackbg': '\033[40m',
+    'redbg': '\033[41m',
+    'greenbg': '\033[42m',
+    'yellowbg': '\033[43m',
+    'bluebg': '\033[44m',
+    'magentabg': '\033[45m',
+    'cyanbg': '\033[46m',
+    'whitebg': '\033[47m',
 
-	'reset': '\033[0;0m',
-	'bold': '\033[1m',
-	'reverse': '\033[2m',
-	'underline': '\033[4m',
+    'reset': '\033[0;0m',
+    'bold': '\033[1m',
+    'reverse': '\033[2m',
+    'underline': '\033[4m',
 
-	'clear': '\033[2J',
-#	'clearline': '\033[K',
-	'clearline': '\033[2K',
-#	'save': '\033[s',
-#	'restore': '\033[u',
-	'save': '\0337',
-	'restore': '\0338',
+    'clear': '\033[2J',
+#   'clearline': '\033[K',
+    'clearline': '\033[2K',
+#   'save': '\033[s',
+#   'restore': '\033[u',
+    'save': '\0337',
+    'restore': '\0338',
 
-	'up': '\033[1A',
-	'down': '\033[1B',
-	'right': '\033[1C',
-	'left': '\033[1D',
+    'up': '\033[1A',
+    'down': '\033[1B',
+    'right': '\033[1C',
+    'left': '\033[1D',
 
-	'default': '\033[0;0m',
+    'default': '\033[0;0m',
 }
 
 char = {
-	'pipe': '|',
-	'colon': ':',
-	'gt': '&gt;',
-	'space': ' ',
-	'dash': '-',
+    'pipe': '|',
+    'colon': ':',
+    'gt': '&gt;',
+    'space': ' ',
+    'dash': '-',
 }
 
 def ticks():
-	&quot;Return the number of 'ticks' since bootup&quot;
-	try:
-		for line in open('/proc/uptime', 'r', 0).readlines():
-			l = string.split(line)
-			if len(l) &lt; 2: continue
-			return float(l[0])
-	except:
-		for line in dopen('/proc/stat').readlines():
-			l = string.split(line)
-			if len(l) &lt; 2: continue
-			if l[0] == 'btime':
-				return time.time() - long(l[1])
+    &quot;Return the number of 'ticks' since bootup&quot;
+    try:
+        for line in open('/proc/uptime', 'r', 0).readlines():
+            l = string.split(line)
+            if len(l) &lt; 2: continue
+            return float(l[0])
+    except:
+        for line in dopen('/proc/stat').readlines():
+            l = string.split(line)
+            if len(l) &lt; 2: continue
+            if l[0] == 'btime':
+                return time.time() - long(l[1])
 
 def improve(str):
-	&quot;Improve a device name&quot;
-	if str.startswith('/dev/mapper/'):
-		str = string.split(str, '/')[3]
-	elif str.startswith('/dev/'):
-		str = string.split(str, '/')[2]
-	return str
+    &quot;Improve a device name&quot;
+    if str.startswith('/dev/mapper/'):
+        str = string.split(str, '/')[3]
+    elif str.startswith('/dev/'):
+        str = string.split(str, '/')[2]
+    return str
 
 def dopen(file):
-	&quot;Open a file for reuse, if already opened, return file descriptor&quot;
-	global fds
-	if not os.path.exists(file): return None
-	if 'fds' not in globals().keys(): fds = {}
-	if file not in fds.keys():
-		fds[file] = open(file, 'r', 0)
-	else:
-		fds[file].seek(0)
-	return fds[file]
+    &quot;Open a file for reuse, if already opened, return file descriptor&quot;
+    global fds
+    if not os.path.exists(file): return None
+    if 'fds' not in globals().keys(): fds = {}
+    if file not in fds.keys():
+        fds[file] = open(file, 'r', 0)
+    else:
+        fds[file].seek(0)
+    return fds[file]
 
 def dclose(file):
-	&quot;Close an open file and remove file descriptor from list&quot;
-	global fds
-	if not 'fds' in globals(): fds = {}
-	if file in fds:
-		fds[file].close()
-		del(fds[file])
+    &quot;Close an open file and remove file descriptor from list&quot;
+    global fds
+    if not 'fds' in globals(): fds = {}
+    if file in fds:
+        fds[file].close()
+        del(fds[file])
 
 def dpopen(cmd):
-	&quot;Open a pipe for reuse, if already opened, return pipes&quot;
-	global pipes
-	if 'pipes' not in globals().keys(): pipes = {}
-	if cmd not in pipes.keys():
-		pipes[cmd] = os.popen3(cmd, 't', 0)
-	return pipes[cmd]
+    &quot;Open a pipe for reuse, if already opened, return pipes&quot;
+    global pipes
+    if 'pipes' not in globals().keys(): pipes = {}
+    if cmd not in pipes.keys():
+        pipes[cmd] = os.popen3(cmd, 't', 0)
+    return pipes[cmd]
 
 def readpipe(file, tmout = 0.001):
-	&quot;Read available data from pipe in a non-blocking fashion&quot;
-	ret = ''
-	while not select.select([file.fileno()], [], [], tmout)[0]:
-		pass
-	while select.select([file.fileno()], [], [], tmout)[0]:
-		ret = ret + file.read(1)
-	return string.split(ret, '\n')
-#	return ret
+    &quot;Read available data from pipe in a non-blocking fashion&quot;
+    ret = ''
+    while not select.select([file.fileno()], [], [], tmout)[0]:
+        pass
+    while select.select([file.fileno()], [], [], tmout)[0]:
+        ret = ret + file.read(1)
+    return string.split(ret, '\n')
+#   return ret
 
 def dchg(var, max, base):
-	&quot;Convert decimal to string given base and length&quot;
-	c = 0
-	while True:
-		ret = str(int(round(var)))
-		if len(ret) &lt;= max:
-			break
-		var = var / base
-		c = c + 1
-	else:
-		c = -1
-	return ret, c
+    &quot;Convert decimal to string given base and length&quot;
+    c = 0
+    while True:
+        ret = str(int(round(var)))
+        if len(ret) &lt;= max:
+            break
+        var = var / base
+        c = c + 1
+    else:
+        c = -1
+    return ret, c
 
 def fchg(var, max, base):
-	&quot;Convert float to string given base and length&quot;
-	c = 0
-	while True:
-		if var == 0:
-			ret = str('0')
-			break
-#		ret = repr(round(var))
-#		ret = repr(long(round(var,max)))
-		ret = str(long(round(var,max)))
-		if len(ret) &lt;= max:
-			i = max - len(ret)
-			while i &gt; 0:
-				ret = ('%.'+str(i)+'f') % var
-				if len(ret) &lt; max and ret != repr(round(var)):
-					break
-				i = i - 1
-			else:
-				ret = str(int(round(var)))
-			break
-		var = var / base
-		c = c + 1
-	else:
-		c = -1
-	return ret, c
+    &quot;Convert float to string given base and length&quot;
+    c = 0
+    while True:
+        if var == 0:
+            ret = str('0')
+            break
+#       ret = repr(round(var))
+#       ret = repr(long(round(var,max)))
+        ret = str(long(round(var,max)))
+        if len(ret) &lt;= max:
+            i = max - len(ret)
+            while i &gt; 0:
+                ret = ('%.'+str(i)+'f') % var
+                if len(ret) &lt; max and ret != repr(round(var)):
+                    break
+                i = i - 1
+            else:
+                ret = str(int(round(var)))
+            break
+        var = var / base
+        c = c + 1
+    else:
+        c = -1
+    return ret, c
 
 def cprintlist(list, format):
-	ret = sep = ''
-	for var in list:
-		ret = ret + sep + cprint(var, format)
-		sep = ' '
-	return ret
+    ret = sep = ''
+    for var in list:
+        ret = ret + sep + cprint(var, format)
+        sep = ' '
+    return ret
 
 def cprint(var, format = ('f', 4, 1000)):
-	c = -1
-	type = format[0]
-	max = format[1]
-	mp = format[2]
+    c = -1
+    type = format[0]
+    max = format[1]
+    mp = format[2]
 
-	base = 1000
-	if mp == 1024:
-		base = 1024
+    base = 1000
+    if mp == 1024:
+        base = 1024
 
-	unit = False
-	if mp in (1000, 1024) and max &gt;= len(str(base)):
-		unit = True
-		max = max - 1
+    unit = False
+    if mp in (1000, 1024) and max &gt;= len(str(base)):
+        unit = True
+        max = max - 1
 
-	if var &lt; 0:
-		if unit:
-			return ansi['default'] + string.rjust('-', max) + ' '
-		else:
-			return ansi['default'] + string.rjust('-', max)
+    if var &lt; 0:
+        if unit:
+            return ansi['default'] + string.rjust('-', max) + ' '
+        else:
+            return ansi['default'] + string.rjust('-', max)
 
-	if base == 1024:
-		units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
-	else:
-		units = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+    if base == 1024:
+        units = ('B', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
+    else:
+        units = (' ', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
 
-	if step == op.delay:
-		colors = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
-	else:
-		colors = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
+    if step == op.delay:
+        colors = ('red', 'yellow', 'green', 'blue', 'magenta', 'cyan', 'white', 'darkred', 'darkgreen')
+    else:
+        colors = ('darkred', 'darkyellow', 'darkgreen', 'darkblue', 'darkmagenta', 'darkcyan', 'silver', 'red', 'green')
 
-	if op.integer and type in ('d', 'p', 'f'):
-		ret, c = dchg(var, max, base)
-	elif type in ('d', 'p'):
-		ret, c = dchg(var, max, base)
-	elif type in ('f'):
-		ret, c = fchg(var, max, base)
-	elif type in ('t'):
-		ret, c = fchg(var, max+1, base)
-	else:
-		ret = str(var)
+    if op.integer and type in ('d', 'p', 'f'):
+        ret, c = dchg(var, max, base)
+    elif type in ('d', 'p'):
+        ret, c = dchg(var, max, base)
+    elif type in ('f'):
+        ret, c = fchg(var, max, base)
+    elif type in ('t'):
+        ret, c = fchg(var, max+1, base)
+    else:
+        ret = str(var)
 
-	if ret == '0':
-		color = 'default'
-	elif type in ('d', 'p'):
-		color = colors[int(var/mp)%len(colors)]
-	elif type in ('f'):
-		color = colors[c%len(colors)]
-	else:
-		color = 'default'
+    if ret == '0':
+        color = 'default'
+    elif type in ('d', 'p'):
+        color = colors[int(var/mp)%len(colors)]
+    elif type in ('f'):
+        color = colors[c%len(colors)]
+    else:
+        color = 'default'
 
-	if type in ('s',):
-		ret = ansi['default'] + string.ljust(ret, max)
-	else:
-		ret = ansi[color] + string.rjust(ret, max)
+    if type in ('s',):
+        ret = ansi['default'] + string.ljust(ret, max)
+    else:
+        ret = ansi[color] + string.rjust(ret, max)
 
-	if unit:
-		if c != -1 and round(var) != 0:
-			ret = ret + units[c]
-		else:
-			ret = ret + ' '
+    if unit:
+        if c != -1 and round(var) != 0:
+            ret = ret + units[c]
+        else:
+            ret = ret + ' '
 
-	return ret
+    return ret
 
 def showtitle(nr, totlist, vislist, midchar, endchar):
-	line = ''
-	for o in vislist:
-		line = line + o.title(nr)
-		if o is not vislist[-1]:
-			line = line + midchar
-		elif totlist != vislist:
-			line = line + endchar
-	sys.stdout.write(line + '\n')
+    line = ''
+    for o in vislist:
+        line = line + o.title(nr)
+        if o is not vislist[-1]:
+            line = line + midchar
+        elif totlist != vislist:
+            line = line + endchar
+    sys.stdout.write(line + '\n')
 
 def showcsvtitle(nr, totlist):
-	line = ''
-	for o in totlist:
-		line = line + o.titlecsv(nr)
-		if o is not totlist[-1]:
-			line = line + ','
-	outputfile.write(line + '\n')
+    line = ''
+    for o in totlist:
+        line = line + o.titlecsv(nr)
+        if o is not totlist[-1]:
+            line = line + ','
+    outputfile.write(line + '\n')
 
 def info(level, str):
-	&quot;Output info message&quot;
-#	if level &lt;= op.verbose:
-	print str
+    &quot;Output info message&quot;
+#   if level &lt;= op.verbose:
+    print str
 
 def die(ret, str):
-	&quot;Print error and exit with errorcode&quot;
-	info(0, str)
-	exit(ret)
+    &quot;Print error and exit with errorcode&quot;
+    info(0, str)
+    exit(ret)
 
 def initterm():
-	&quot;Initialise terminal&quot;
-	global termsize
+    &quot;Initialise terminal&quot;
+    global termsize
 
-	termsize = None, None
+    termsize = None, None
 
-	### Unbuffered sys.stdout
-	sys.stdout = os.fdopen(1, 'w', 0)
+    ### Unbuffered sys.stdout
+    sys.stdout = os.fdopen(1, 'w', 0)
 
-	try:
-		global fcntl, struct, termios
-		import fcntl, struct, termios
-		termios.TIOCGWINSZ
-	except:
-		try:
-			curses.setupterm()
-			curses.tigetnum('lines'), curses.tigetnum('cols')
-		except:
-			pass
-		else:
-			termsize = None, 2
-	else:
-		termsize = None, 1
+    try:
+        global fcntl, struct, termios
+        import fcntl, struct, termios
+        termios.TIOCGWINSZ
+    except:
+        try:
+            curses.setupterm()
+            curses.tigetnum('lines'), curses.tigetnum('cols')
+        except:
+            pass
+        else:
+            termsize = None, 2
+    else:
+        termsize = None, 1
 
 def gettermsize():
-	&quot;Return the dynamic terminal geometry&quot;
-	global termsize
+    &quot;Return the dynamic terminal geometry&quot;
+    global termsize
 
-	if not termsize[0]:
-		try:
-			if termsize[1] == 1:
-				s = struct.pack('HHHH', 0, 0, 0, 0)
-				x = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, s)
-				return struct.unpack('HHHH', x)[:2]
-			elif termsize[1] == 2:
-				curses.setupterm()
-				return curses.tigetnum('lines'), curses.tigetnum('cols')
-			else:
-				termsize = (int(os.environ['LINES']), int(os.environ['COLUMNS']))
-		except:
-			termsize = 25, 80
-	return termsize
+    if not termsize[0]:
+        try:
+            if termsize[1] == 1:
+                s = struct.pack('HHHH', 0, 0, 0, 0)
+                x = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, s)
+                return struct.unpack('HHHH', x)[:2]
+            elif termsize[1] == 2:
+                curses.setupterm()
+                return curses.tigetnum('lines'), curses.tigetnum('cols')
+            else:
+                termsize = (int(os.environ['LINES']), int(os.environ['COLUMNS']))
+        except:
+            termsize = 25, 80
+    return termsize
 
 def getcpunr():
-	&quot;Return the number of CPUs in the system&quot;
-	cpunr = -1
-	for line in dopen('/proc/stat').readlines():
-		if line[0:3] == 'cpu':
-			cpunr = cpunr + 1
-	if cpunr &lt; 0:
-		raise &quot;Problem finding number of CPUs in system.&quot;
-	return cpunr
+    &quot;Return the number of CPUs in the system&quot;
+    cpunr = -1
+    for line in dopen('/proc/stat').readlines():
+        if line[0:3] == 'cpu':
+            cpunr = cpunr + 1
+    if cpunr &lt; 0:
+        raise &quot;Problem finding number of CPUs in system.&quot;
+    return cpunr
 
 ### FIXME: Add scsi support too and improve
 def sysfs_dev(device):
-	&quot;Convert sysfs device names into device names&quot;
-	m = re.match('ide/host([0-9])/bus([0-9])/target([0-9])/lun([0-9])/disc', device)
-	if m:
-		l = m.groups()
-		# ide/host0/bus0/target0/lun0/disc -&gt; 0 -&gt; hda
-		# ide/host0/bus1/target0/lun0/disc -&gt; 2 -&gt; hdc
-		nr = int(l[1]) * 2 + int(l[3])
-		return 'hd' + chr(ord('a') + nr)
-	m = re.match('placeholder', device)
-	if m:
-		return 'sdX'
-	return device
+    &quot;Convert sysfs device names into device names&quot;
+    m = re.match('ide/host([0-9])/bus([0-9])/target([0-9])/lun([0-9])/disc', device)
+    if m:
+        l = m.groups()
+        # ide/host0/bus0/target0/lun0/disc -&gt; 0 -&gt; hda
+        # ide/host0/bus1/target0/lun0/disc -&gt; 2 -&gt; hdc
+        nr = int(l[1]) * 2 + int(l[3])
+        return 'hd' + chr(ord('a') + nr)
+    m = re.match('placeholder', device)
+    if m:
+        return 'sdX'
+    return device
 
 def dev(maj, min):
-	&quot;Convert major/minor pairs into device names&quot;
-	ram = [1, ]
-	ide = [3, 22, 33, 34, 56, 57, 88, 89, 90, 91]
-	loop = [7, ]
-	scsi = [8, 65, 66, 67, 68, 69, 70, 71, 128, 129, 130, 131, 132, 133, 134, 135]
-	md = [9, ]
-	ida = [72, 73, 74, 75, 76, 77, 78, 79]
-	ubd = [98,]
-	cciss = [104,]
-	dm =  [253,]
-	if maj in scsi:
-		disc = chr(ord('a') + scsi.index(maj) * 16 + min / 16)
-		part = min % 16
-		if not part: return 'sd%s' % disc
-		return 'sd%s%d' % (disc, part)
-	elif maj in ide:
-		disc = chr(ord('a') + ide.index(maj) * 2 + min / 64)
-		part = min % 64
-		if not part: return 'hd%s' % disc
-		return 'hd%s%d' % (disc, part)
-	elif maj in dm:
-		return 'dm-%d' % min
-	elif maj in md:
-		return 'md%d' % min
-	elif maj in loop:
-		return 'loop%d' % min
-	elif maj in ram:
-		return 'ram%d' % min
-	elif maj in cciss:
-		disc = cciss.index(maj) * 16 + min / 16
-		part = min % 16
-		if not part: return 'c0d%d' % disc
-		return 'c0d%dp%d' % (disc, part)
-	elif maj in ida:
-		cont = ida.index(maj)
-		disc = min / 16
-		part = min % 16
-		if not part: return 'ida%d-%d' % (cont, disc)
-		return 'ida%d-%d-%d' % (cont, disc, part)
-	elif maj in ubd:
-		disc = ubd.index(maj) * 16 + min / 16
-		part = min % 16
-		if not part: return 'ubd%d' % disc
-		return 'ubd%d-%d' % (disc, part)
-	else:
-		return 'dev%d-%d' % (maj, min)
+    &quot;Convert major/minor pairs into device names&quot;
+    ram = [1, ]
+    ide = [3, 22, 33, 34, 56, 57, 88, 89, 90, 91]
+    loop = [7, ]
+    scsi = [8, 65, 66, 67, 68, 69, 70, 71, 128, 129, 130, 131, 132, 133, 134, 135]
+    md = [9, ]
+    ida = [72, 73, 74, 75, 76, 77, 78, 79]
+    ubd = [98,]
+    cciss = [104,]
+    dm =  [253,]
+    if maj in scsi:
+        disc = chr(ord('a') + scsi.index(maj) * 16 + min / 16)
+        part = min % 16
+        if not part: return 'sd%s' % disc
+        return 'sd%s%d' % (disc, part)
+    elif maj in ide:
+        disc = chr(ord('a') + ide.index(maj) * 2 + min / 64)
+        part = min % 64
+        if not part: return 'hd%s' % disc
+        return 'hd%s%d' % (disc, part)
+    elif maj in dm:
+        return 'dm-%d' % min
+    elif maj in md:
+        return 'md%d' % min
+    elif maj in loop:
+        return 'loop%d' % min
+    elif maj in ram:
+        return 'ram%d' % min
+    elif maj in cciss:
+        disc = cciss.index(maj) * 16 + min / 16
+        part = min % 16
+        if not part: return 'c0d%d' % disc
+        return 'c0d%dp%d' % (disc, part)
+    elif maj in ida:
+        cont = ida.index(maj)
+        disc = min / 16
+        part = min % 16
+        if not part: return 'ida%d-%d' % (cont, disc)
+        return 'ida%d-%d-%d' % (cont, disc, part)
+    elif maj in ubd:
+        disc = ubd.index(maj) * 16 + min / 16
+        part = min % 16
+        if not part: return 'ubd%d' % disc
+        return 'ubd%d-%d' % (disc, part)
+    else:
+        return 'dev%d-%d' % (maj, min)
 
 #def mountpoint(dev):
-#	&quot;Return the mountpoint of a mounted device/file&quot;
-#	for entry in dopen('/etc/mtab').readlines():
-#		if entry:
-#			list = string.split(entry)
-#			if dev == list[0]:
-#				return list[1]
+#   &quot;Return the mountpoint of a mounted device/file&quot;
+#   for entry in dopen('/etc/mtab').readlines():
+#       if entry:
+#           list = string.split(entry)
+#           if dev == list[0]:
+#               return list[1]
 
 def readfile(file):
-	ret = ''
-	for line in open(file,'r').readlines():
-		ret = ret + line
-	return ret
+    ret = ''
+    for line in open(file,'r').readlines():
+        ret = ret + line
+    return ret
 
 def signaler(signum, frame):
-	signal.alarm(interval)
+    signal.alarm(interval)
 
 def exit(ret):
-	signal.signal(signal.SIGALRM, signal.SIG_IGN)
-	sys.stdout.write(ansi['reset'])
-	sys.exit(ret)
+    signal.signal(signal.SIGALRM, signal.SIG_IGN)
+    sys.stdout.write(ansi['reset'])
+    sys.exit(ret)
 
 def listmodules():
-	import glob
-	rows, cols = gettermsize()
-	remod = re.compile('.+/dstat_(.+).py$')
-	for path in sys.path:
-		list = []
-		for file in glob.glob(path + '/dstat_*.py'):
-			list.append(remod.match(file).groups()[0])
-		if not list: continue
-		list.sort()
-		cols2 = cols - 8
-		print '%s:\n\t' % os.path.abspath(path),
-		for mod in list:
-			cols2 = cols2 - len(mod) - 2
-			if cols2 &lt;= 0:
-				print '\n\t',
-				cols2 = cols - len(mod) - 10
-			print mod + ',',
-		print
+    import glob
+    rows, cols = gettermsize()
+    remod = re.compile('.+/dstat_(.+).py$')
+    for path in sys.path:
+        list = []
+        for file in glob.glob(path + '/dstat_*.py'):
+            list.append(remod.match(file).groups()[0])
+        if not list: continue
+        list.sort()
+        cols2 = cols - 8
+        print '%s:\n\t' % os.path.abspath(path),
+        for mod in list:
+            cols2 = cols2 - len(mod) - 2
+            if cols2 &lt;= 0:
+                print '\n\t',
+                cols2 = cols - len(mod) - 10
+            print mod + ',',
+        print
 
 def main():
-	global update, loop, step, pagesize, cpunr, ansi, interval, outputfile, tick, cols
+    global update, loop, step, pagesize, cpunr, ansi, interval, outputfile, tick, cols
 
-	loop = update = 0
-	step = op.delay
-	tick = ticks()
-	pagesize = resource.getpagesize()
-	cpunr = getcpunr()
-#	hz = os.sysconf('SC_CLK_TCK')
-	interval = 1
+    loop = update = 0
+    step = op.delay
+    tick = ticks()
+    pagesize = resource.getpagesize()
+    cpunr = getcpunr()
+#   hz = os.sysconf('SC_CLK_TCK')
+    interval = 1
 
-	user = getpass.getuser()
-	hostname = string.split(os.uname()[1], '.')[0]
+    user = getpass.getuser()
+    hostname = string.split(os.uname()[1], '.')[0]
 
-	rows, cols = gettermsize()
+    rows, cols = gettermsize()
 
-	### Write term-title
-	if op.isatty:
-		term = os.environ['TERM']
-		if term and re.compile('(screen*|xterm*)').match(term):
-			sys.stdout.write('\033]0;(%s@%s) %s %s\007' % (user, hostname, os.path.basename(sys.argv[0]), string.join(op.args, ' ')))
+    ### Write term-title
+    if op.isatty:
+        term = os.environ['TERM']
+        if term and re.compile('(screen*|xterm*)').match(term):
+            sys.stdout.write('\033]0;(%s@%s) %s %s\007' % (user, hostname, os.path.basename(sys.argv[0]), string.join(op.args, ' ')))
 
-	### Check terminal capabilities
-	if op.isatty:
-		op.color = True
-		try:
-			import curses
-			curses.setupterm()
-			if curses.tigetnum('colors') &lt; 0:
-				op.color = False
-		except:
-			op.color = False
+    ### Check terminal capabilities
+    if op.isatty:
+        op.color = True
+        try:
+            import curses
+            curses.setupterm()
+            if curses.tigetnum('colors') &lt; 0:
+                op.color = False
+        except:
+            op.color = False
 
-	if op.output:
-		if os.path.exists(op.output):
-			outputfile = open(op.output, 'a', 0)
-			outputfile.write('\n\n')
-		else:
-			outputfile = open(op.output, 'w', 0)
-			outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
-			outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
+    if op.output:
+        if os.path.exists(op.output):
+            outputfile = open(op.output, 'a', 0)
+            outputfile.write('\n\n')
+        else:
+            outputfile = open(op.output, 'w', 0)
+            outputfile.write('&quot;Dstat %s CSV output&quot;\n' % VERSION)
+            outputfile.write('&quot;Author:&quot;,&quot;Dag Wieers &lt;<A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>&gt;&quot;,,,,&quot;URL:&quot;,&quot;<A HREF="http://dag.wieers.com/home-made/dstat/">http://dag.wieers.com/home-made/dstat/</A>&quot;\n')
 
-		outputfile.write('&quot;Host:&quot;,&quot;%s&quot;,,,,&quot;User:&quot;,&quot;%s&quot;\n' % (hostname, user))
-		outputfile.write('&quot;Cmdline:&quot;,&quot;dstat %s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n\n' % (' '.join(op.args), time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
+        outputfile.write('&quot;Host:&quot;,&quot;%s&quot;,,,,&quot;User:&quot;,&quot;%s&quot;\n' % (hostname, user))
+        outputfile.write('&quot;Cmdline:&quot;,&quot;dstat %s&quot;,,,,&quot;Date:&quot;,&quot;%s&quot;\n\n' % (' '.join(op.args), time.strftime('%d %b %Y %H:%M:%S %Z', time.localtime())))
 
-	### Empty ansi database if no colors are requested
-	if not op.color:
-		op.update = False
-		for key in ansi.keys():
-			ansi[key] = ''
+    ### Empty ansi database if no colors are requested
+    if not op.color:
+        op.update = False
+        for key in ansi.keys():
+            ansi[key] = ''
 
-	if not op.update:
-		interval = op.delay
+    if not op.update:
+        interval = op.delay
 
-	### Build list of requested modules
-	linewidth = 0
-	oldvislist = []
-	totlist = []
-	for module in op.modlist:
-		if module in ('list', 'help'):
-			listmodules()
-			exit(0)
-		elif module == 'cpu':  mods = ( 'cpu', 'cpu24' )
-		elif module == 'disk': mods = ( 'disk', 'disk24', 'disk24old' )
-		elif module == 'int':  mods = ( 'int', 'int24' )
-		elif module == 'page': mods = ( 'page', 'page24' )
-		elif module == 'swap': mods = ( 'swap', 'swapold' )
-		else: mods = ( module, )
+    ### Build list of requested modules
+    linewidth = 0
+    oldvislist = []
+    totlist = []
+    for module in op.modlist:
+        if module in ('list', 'help'):
+            listmodules()
+            exit(0)
+        elif module == 'cpu':  mods = ( 'cpu', 'cpu24' )
+        elif module == 'disk': mods = ( 'disk', 'disk24', 'disk24old' )
+        elif module == 'int':  mods = ( 'int', 'int24' )
+        elif module == 'page': mods = ( 'page', 'page24' )
+        elif module == 'swap': mods = ( 'swap', 'swapold' )
+        else: mods = ( module, )
 
-		for mod in mods:
-			if 'dstat_'+mod not in globals().keys():
-				try:
-					import imp
-					file, pathname, description = imp.find_module('dstat_'+mod)
-#					exec compile(readfile(pathname), pathname, 'exec')
-					execfile(pathname)
-				except Exception, e:
-					info(1, 'Module %s failed to load. (%s)' % (mod, e))
-#					tb = sys.exc_info()[2]
-					continue
+        for mod in mods:
+            if 'dstat_'+mod not in globals().keys():
+                try:
+                    import imp
+                    file, pathname, description = imp.find_module('dstat_'+mod)
+#                   exec compile(readfile(pathname), pathname, 'exec')
+                    execfile(pathname)
+                except Exception, e:
+                    info(1, 'Module %s failed to load. (%s)' % (mod, e))
+#                   tb = sys.exc_info()[2]
+                    continue
 
-			try:
-#				exec compile('o = dstat_%s()' % mod, '&lt;string&gt;', 'single')
-				exec 'o = dstat_%s()' % mod
+            try:
+#               exec compile('o = dstat_%s()' % mod, '&lt;string&gt;', 'single')
+                exec 'o = dstat_%s()' % mod
 
-				### Remove defect stat objects and calculate line length
-				if not o.check():
-					raise Exception, 'Unknown problem, please report'
+                ### Remove defect stat objects and calculate line length
+                if not o.check():
+                    raise Exception, 'Unknown problem, please report'
 
-				linewidth = linewidth + o.statwidth() + 1
-				totlist.append(o)
-				break
+                linewidth = linewidth + o.statwidth() + 1
+                totlist.append(o)
+                break
 
-			except Exception, e:
-				if mod == mods[-1]:
-					info(1, 'Module %s has problems. (%s)' % (mod, e))
-					if op.debug:
-						raise
-				continue
+            except Exception, e:
+                if mod == mods[-1]:
+                    info(1, 'Module %s has problems. (%s)' % (mod, e))
+                    if op.debug:
+                        raise
+                continue
 
-	if not totlist:
-		die(8, 'None of the stats you selected are available.')
+    if not totlist:
+        die(8, 'None of the stats you selected are available.')
 
-	if op.debug:
-		for o in totlist:
-			print 'Module', string.split(str(o.__class__), '.')[1],
-			if hasattr(o, 'file'): print 'requires', o.file,
-			print
+    if op.debug:
+        for o in totlist:
+            print 'Module', string.split(str(o.__class__), '.')[1],
+            if hasattr(o, 'file'): print 'requires', o.file,
+            print
 
-	if op.output:
-		showcsvtitle(1, totlist)
-		showcsvtitle(2, totlist)
+    if op.output:
+        showcsvtitle(1, totlist)
+        showcsvtitle(2, totlist)
 
-	### Increase precision if we're root (does not seem to have effect)
-#	if os.geteuid() == 0:
-#		os.nice(-20)
-#	sys.setcheckinterval(op.delay / 10000)
+    ### Increase precision if we're root (does not seem to have effect)
+#   if os.geteuid() == 0:
+#       os.nice(-20)
+#   sys.setcheckinterval(op.delay / 10000)
 
-	### Always show header the first time
-	showheader = True
+    ### Always show header the first time
+    showheader = True
 
-	signal.signal(signal.SIGALRM, signaler)
-	signal.alarm(interval)
+    signal.signal(signal.SIGALRM, signaler)
+    signal.alarm(interval)
 
-	tt = 0
+    tt = 0
 
-	### Let the games begin
-	while update &lt;= op.delay * op.count or op.count == -1:
+    ### Let the games begin
+    while update &lt;= op.delay * op.count or op.count == -1:
 
-		if op.debug:
-			if step == 1: tt = 0
-			t1 = time.time()
-			curwidth = 8
-		else:
-			curwidth = 0
+        if op.debug:
+            if step == 1: tt = 0
+            t1 = time.time()
+            curwidth = 8
+        else:
+            curwidth = 0
 
-		### Trim object list to what is visible on screen
-		if op.isatty:
-			rows, cols = gettermsize()
-			vislist = []
-			for o in totlist:
-				newwidth = curwidth + o.statwidth() + 1
-				if newwidth &lt;= cols or ( vislist == totlist[:-1] and newwidth &lt; cols ):
-					vislist.append(o)
-					curwidth = newwidth
-	
-			### Check when to display the header
-			if op.header and rows &gt;= 6:
-				if oldvislist != vislist:
-					showheader = True
-				elif step == 1 and loop % (rows - 1) == 0:
-					showheader = True
+        ### Trim object list to what is visible on screen
+        if op.isatty:
+            rows, cols = gettermsize()
+            vislist = []
+            for o in totlist:
+                newwidth = curwidth + o.statwidth() + 1
+                if newwidth &lt;= cols or ( vislist == totlist[:-1] and newwidth &lt; cols ):
+                    vislist.append(o)
+                    curwidth = newwidth
+    
+            ### Check when to display the header
+            if op.header and rows &gt;= 6:
+                if oldvislist != vislist:
+                    showheader = True
+                elif step == 1 and loop % (rows - 1) == 0:
+                    showheader = True
 
-			oldvislist = vislist
-		else:
-			vislist = totlist
+            oldvislist = vislist
+        else:
+            vislist = totlist
 
-		if showheader:
-			if loop == 0 and totlist != vislist:
-				info(1, 'Terminal width too small, trimming output.')
-			showheader = False
-			showtitle(1, totlist, vislist, ansi['darkblue'] + char['space'], ansi['darkblue'] + char['gt'])
-			showtitle(2, totlist, vislist, ansi['gray'] + char['pipe'], ansi['darkblue'] + char['gt'])
+        if showheader:
+            if loop == 0 and totlist != vislist:
+                info(1, 'Terminal width too small, trimming output.')
+            showheader = False
+            showtitle(1, totlist, vislist, ansi['darkblue'] + char['space'], ansi['darkblue'] + char['gt'])
+            showtitle(2, totlist, vislist, ansi['gray'] + char['pipe'], ansi['darkblue'] + char['gt'])
 
-		### Prepare the colors for intermediate updates, last step in a loop is definitive
-		if step == op.delay:
-			ansi['default'] = ansi['reset']
-		else:
-			ansi['default'] = ansi['gray']
-		line = ansi['default']
+        ### Prepare the colors for intermediate updates, last step in a loop is definitive
+        if step == op.delay:
+            ansi['default'] = ansi['reset']
+        else:
+            ansi['default'] = ansi['gray']
+        line = ansi['default']
 
-		### Calculate all objects (visible, invisible)
-		oline = ''
-		for o in totlist:
-			o.extract()
-			if o in vislist:
-				line = line + o.show() + o.showend(totlist, vislist)
-			if op.output and step == op.delay:
-				oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
+        ### Calculate all objects (visible, invisible)
+        oline = ''
+        for o in totlist:
+            o.extract()
+            if o in vislist:
+                line = line + o.show() + o.showend(totlist, vislist)
+            if op.output and step == op.delay:
+                oline = oline + o.showcsv() + o.showcsvend(totlist, vislist)
 
-		### Print stats
-		sys.stdout.write(line + ansi['default'])
-		if op.output and step == op.delay:
-			outputfile.write(oline + '\n')
+        ### Print stats
+        sys.stdout.write(line + ansi['default'])
+        if op.output and step == op.delay:
+            outputfile.write(oline + '\n')
 
-		### Print debugging output
-		if op.debug:
-			t2 = time.time();
-			tt = tt + (t2 - t1) * 1000.0
-			if loop == 0: tt = tt * step
-			if op.debug == 1:
-				sys.stdout.write('%6.2fms' % (tt / step))
-			elif op.debug &gt; 1:
-				sys.stdout.write('%6.2f [%d:%d:%d]' % (tt / step, loop, step, update))
+        ### Print debugging output
+        if op.debug:
+            t2 = time.time();
+            tt = tt + (t2 - t1) * 1000.0
+            if loop == 0: tt = tt * step
+            if op.debug == 1:
+                sys.stdout.write('%6.2fms' % (tt / step))
+            elif op.debug &gt; 1:
+                sys.stdout.write('%6.2f [%d:%d:%d]' % (tt / step, loop, step, update))
 
-		### If intermediate results, update increases with 1 sec (=interval)
-		update = update + interval
+        ### If intermediate results, update increases with 1 sec (=interval)
+        update = update + interval
 
-		if not op.update:
-			sys.stdout.write('\n')
+        if not op.update:
+            sys.stdout.write('\n')
 
-		### Do not pause when this is the final loop
-		if update &lt;= op.delay * op.count or op.count == -1:
-			signal.pause()
+        ### Do not pause when this is the final loop
+        if update &lt;= op.delay * op.count or op.count == -1:
+            signal.pause()
 
-		### The last step in a loop is to show the definitive line on its own line
-		if op.update:
-			if step == op.delay:
-				sys.stdout.write('\n' + ansi['reset'] + ansi['clearline'] + ansi['save'])
-			else:
-				sys.stdout.write(ansi['restore'])
+        ### The last step in a loop is to show the definitive line on its own line
+        if op.update:
+            if step == op.delay:
+                sys.stdout.write('\n' + ansi['reset'] + ansi['clearline'] + ansi['save'])
+            else:
+                sys.stdout.write(ansi['restore'])
 
-		loop = (update + op.delay - 1) / op.delay
-		step = ((update - 1) % op.delay) + 1
-		tick = step
+        loop = (update + op.delay - 1) / op.delay
+        step = ((update - 1) % op.delay) + 1
+        tick = step
 
-	signal.signal(signal.SIGALRM, signal.SIG_IGN)
+    signal.signal(signal.SIGALRM, signal.SIG_IGN)
 
 ### Main entrance
 if __name__ == '__main__':
-	try:
-		initterm()
-		op = Options(sys.argv[1:])
-		main()
-	except KeyboardInterrupt, e:
-		print
-#	except IOError, e:
-#		if e.errno != 32:				## [Errno 32] Broken pipe
-#			print
-#			print 'IOError: %s' % e
-#			exit(7)
-#	except OSError, e:
-#		print
-#		print 'OSError: %s' % e
-#		exit(7)
-	exit(0)
+    try:
+        initterm()
+        op = Options(sys.argv[1:])
+        main()
+    except KeyboardInterrupt, e:
+        print
+#   except IOError, e:
+#       if e.errno != 32:               ## [Errno 32] Broken pipe
+#           print
+#           print 'IOError: %s' % e
+#           exit(7)
+#   except OSError, e:
+#       print
+#       print 'OSError: %s' % e
+#       exit(7)
+    exit(0)
 else:
-	op = Options('')
-	step = 1
-	tick = ticks()
+    op = Options('')
+    step = 1
+    tick = ticks()
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/examples/curstest
===================================================================
--- trunk/tools/dstat/examples/curstest	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/examples/curstest	2007-05-12 04:12:27 UTC (rev 5392)
@@ -6,7 +6,7 @@
 #curses.start_color()
 #print &quot;TERM is&quot;, curses.termname()
 #if curses.has_colors():
-#	print &quot;Has colors&quot;#
+#   print &quot;Has colors&quot;#
 #print curses.color_pair(curses.COLOR_RED), &quot;Red&quot;
 #curses.endwin()
 
@@ -14,10 +14,10 @@
 curses.setupterm()
 
 if sys.stdout.isatty():
-	print &quot;Is a TTY&quot;
+    print &quot;Is a TTY&quot;
 
 print &quot;Size is %sx%s&quot; % (curses.tigetnum('lines'), curses.tigetnum('cols'))
 
 if curses.tigetnum('colors') &gt; 0:
-	print &quot;Has colors&quot;
-	print curses.tigetnum('colors')
+    print &quot;Has colors&quot;
+    print curses.tigetnum('colors')

Modified: trunk/tools/dstat/examples/devtest.py
===================================================================
--- trunk/tools/dstat/examples/devtest.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/examples/devtest.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -5,28 +5,28 @@
 import dstat, time
 
 devices = ( 
-	(  1,   0, 'ram0'),
-	(  1,   1, 'ram1'),
-	(  3,   1, 'hda1'),
-	( 33,   0, 'hde'),
-	(  7,   0, 'loop0'),
-	(  7,   1, 'loop1'),
-	(  8,   0, '/dev/sda'),
-	(  8,   1, '/dev/sda1'),
-	(  8,  18, '/dev/sdb2'),
-	(  8,  37, '/dev/sdc5'),
-	(  9,   0, 'md0'),
-	(  9,   1, 'md1'),
-	(  9,   2, 'md2'),
-	( 74,  16, '/dev/ida/c2d1'),
-	( 77, 241, '/dev/ida/c5d15p1'),
-	( 98,   0, 'ubd/disc0/disc'),
-	( 98,  16, 'ubd/disc1/disc'),
-	(104,   0, 'cciss/c0d0'),
-	(104,   2, 'cciss/c0d0p2'),
-	(253,   0, 'dm-0'),
-	(253,   1, 'dm-1'),
+    (  1,   0, 'ram0'),
+    (  1,   1, 'ram1'),
+    (  3,   1, 'hda1'),
+    ( 33,   0, 'hde'),
+    (  7,   0, 'loop0'),
+    (  7,   1, 'loop1'),
+    (  8,   0, '/dev/sda'),
+    (  8,   1, '/dev/sda1'),
+    (  8,  18, '/dev/sdb2'),
+    (  8,  37, '/dev/sdc5'),
+    (  9,   0, 'md0'),
+    (  9,   1, 'md1'),
+    (  9,   2, 'md2'),
+    ( 74,  16, '/dev/ida/c2d1'),
+    ( 77, 241, '/dev/ida/c5d15p1'),
+    ( 98,   0, 'ubd/disc0/disc'),
+    ( 98,  16, 'ubd/disc1/disc'),
+    (104,   0, 'cciss/c0d0'),
+    (104,   2, 'cciss/c0d0p2'),
+    (253,   0, 'dm-0'),
+    (253,   1, 'dm-1'),
 )
 
 for maj, min, device in devices:
-	print device, '-&gt;', dstat.dev(maj, min)
+    print device, '-&gt;', dstat.dev(maj, min)

Modified: trunk/tools/dstat/examples/mmpipe.py
===================================================================
--- trunk/tools/dstat/examples/mmpipe.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/examples/mmpipe.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,38 +2,38 @@
 import select, sys, os
 
 def readpipe(file, tmout = 0.001):
-	&quot;Read available data from pipe&quot;
-	ret = ''
-	while not select.select([file.fileno()], [], [], tmout)[0]:
-		pass
-	while select.select([file.fileno()], [], [], tmout)[0]:
-		ret = ret + file.read(1)
-		return ret.split('\n')
+    &quot;Read available data from pipe&quot;
+    ret = ''
+    while not select.select([file.fileno()], [], [], tmout)[0]:
+        pass
+    while select.select([file.fileno()], [], [], tmout)[0]:
+        ret = ret + file.read(1)
+        return ret.split('\n')
 
 def dpopen(cmd):
-	&quot;Open a pipe for reuse, if already opened, return pipes&quot;
-	global pipes
-	if 'pipes' not in globals().keys(): pipes = {}
-	if cmd not in pipes.keys():
-		pipes[cmd] = os.popen3(cmd, 't', 0)
-	return pipes[cmd]
+    &quot;Open a pipe for reuse, if already opened, return pipes&quot;
+    global pipes
+    if 'pipes' not in globals().keys(): pipes = {}
+    if cmd not in pipes.keys():
+        pipes[cmd] = os.popen3(cmd, 't', 0)
+    return pipes[cmd]
 
 ### Unbuffered sys.stdout
 sys.stdout = os.fdopen(1, 'w', 0)
 
 ### Main entrance
 if __name__ == '__main__':
-	try:
-		stdin, stdout, stderr = dpopen('/usr/lpp/mmfs/bin/mmpmon -p -s')
-		stdin.write('reset\n')
-		readpipe(stdout)
+    try:
+        stdin, stdout, stderr = dpopen('/usr/lpp/mmfs/bin/mmpmon -p -s')
+        stdin.write('reset\n')
+        readpipe(stdout)
 
-		while True:
-			stdin.write('io_s\n')
-			for line in readpipe(stdout):
-				print line
+        while True:
+            stdin.write('io_s\n')
+            for line in readpipe(stdout):
+                print line
 
-	except KeyboardInterrupt, e:
-		print
+    except KeyboardInterrupt, e:
+        print
 
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/examples/mstat.py
===================================================================
--- trunk/tools/dstat/examples/mstat.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/examples/mstat.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -17,9 +17,9 @@
 ### Load stats
 stats = []
 for o in (dstat.dstat_epoch(), dstat.dstat_cpu(), dstat.dstat_mem(), dstat.dstat_load(), dstat.dstat_disk(), dstat.dstat_sys()):
-	try: o.check()
-	except Exception, e: print e
-	else: stats.append(o)
+    try: o.check()
+    except Exception, e: print e
+    else: stats.append(o)
 
 ### Make time stats sub-second
 stats[0].format = ('t', 14, 0)
@@ -27,17 +27,17 @@
 ### Print headers
 title1 = title2 = ''
 for o in stats:
-	title1 = title1 + '  ' + o.title1()
-	title2 = title2 + '  ' + o.title2()
+    title1 = title1 + '  ' + o.title1()
+    title2 = title2 + '  ' + o.title2()
 print '\n' + title1 + '\n' + title2
 
 ### Print stats
 for dstat.update in range(count):
-	line = ''
-	for o in stats:
-		o.extract()
-		line = line + '  ' + o.show()
-	print line + dstat.ansi['reset']
-	if dstat.update != count-1: time.sleep(delay)
-	dstat.tick = 1
+    line = ''
+    for o in stats:
+        o.extract()
+        line = line + '  ' + o.show()
+    print line + dstat.ansi['reset']
+    if dstat.update != count-1: time.sleep(delay)
+    dstat.tick = 1
 print dstat.ansi['reset']

Modified: trunk/tools/dstat/examples/tdbtest
===================================================================
--- trunk/tools/dstat/examples/tdbtest	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/examples/tdbtest	2007-05-12 04:12:27 UTC (rev 5392)
@@ -6,8 +6,8 @@
 
 key=db.firstkey()
 while key:
-	print db.fetch(key)
-	key=db.nextkey(key)
+    print db.fetch(key)
+    key=db.nextkey(key)
 
 db = tdb.tdb('/var/cache/samba/locking.tdb')
 print db.keys

Modified: trunk/tools/dstat/plugins/dstat_app.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_app.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_app.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -7,62 +7,62 @@
 import string
 
 class dstat_app(dstat):
-	def __init__(self):
-		self.name = 'most expensive'
-		self.format = ('s', 18, 0)
-		self.nick = ('process',)
-		self.vars = self.nick
-		self.pid = str(os.getpid())
-		self.cn1 = {}; self.cn2 = {}; self.val = {}
+    def __init__(self):
+        self.name = 'most expensive'
+        self.format = ('s', 18, 0)
+        self.nick = ('process',)
+        self.vars = self.nick
+        self.pid = str(os.getpid())
+        self.cn1 = {}; self.cn2 = {}; self.val = {}
 
-	def extract(self):
-		max = 0.0
-		for pid in os.listdir('/proc/'):
-			try: int(pid)
-			except: continue
-			if os.path.exists('/proc/%s/stat' % pid):
-				if pid == self.pid: continue
-				if not self.cn1.has_key(pid):
-					self.cn1[pid] = 0
+    def extract(self):
+        max = 0.0
+        for pid in os.listdir('/proc/'):
+            try: int(pid)
+            except: continue
+            if os.path.exists('/proc/%s/stat' % pid):
+                if pid == self.pid: continue
+                if not self.cn1.has_key(pid):
+                    self.cn1[pid] = 0
 
-				### Using dopen() will cause too many open files
-#				l = string.split(dopen('/proc/%s/stat' % pid).read())
-				l = string.split(open('/proc/%s/stat' % pid).read())
-				if len(l) &lt; 15: continue
-				self.cn2[pid] = int(l[13]) + int(l[14])
-				usage = (self.cn2[pid] - self.cn1[pid]) * 1.0 / tick
+                ### Using dopen() will cause too many open files
+#               l = string.split(dopen('/proc/%s/stat' % pid).read())
+                l = string.split(open('/proc/%s/stat' % pid).read())
+                if len(l) &lt; 15: continue
+                self.cn2[pid] = int(l[13]) + int(l[14])
+                usage = (self.cn2[pid] - self.cn1[pid]) * 1.0 / tick
 
-				### Get the process that spends the most jiffies
-				if usage &gt; max:
-					max = usage
-					self.val['name'] = l[1][1:-1]
-					self.val['pid'] = pid
+                ### Get the process that spends the most jiffies
+                if usage &gt; max:
+                    max = usage
+                    self.val['name'] = l[1][1:-1]
+                    self.val['pid'] = pid
 
-		if max == 0.0:
-			self.val['process'] = ''
-		else:
-			### If the name is a known interpreter, take the second argument from the cmdline
-			if self.val['name'] in ('bash', 'csh', 'ksh', 'perl', 'python', 'sh'):
-				### Using dopen() will cause too many open files
-#				l = string.split(dopen('/proc/%s/cmdline' % self.val['pid']).read(), '\0')
-				l = string.split(open('/proc/%s/cmdline' % self.val['pid']).read(), '\0')
-				if len(l) &gt; 2:
-					self.val['name'] = os.path.basename(l[1])
+        if max == 0.0:
+            self.val['process'] = ''
+        else:
+            ### If the name is a known interpreter, take the second argument from the cmdline
+            if self.val['name'] in ('bash', 'csh', 'ksh', 'perl', 'python', 'sh'):
+                ### Using dopen() will cause too many open files
+#               l = string.split(dopen('/proc/%s/cmdline' % self.val['pid']).read(), '\0')
+                l = string.split(open('/proc/%s/cmdline' % self.val['pid']).read(), '\0')
+                if len(l) &gt; 2:
+                    self.val['name'] = os.path.basename(l[1])
 
-#				l = l.reverse()
-#				for x in l:
-#					print x
-#					if x[0] != '-':
-#						self.val['name'] = os.path.basename(x)
-#						break
+#               l = l.reverse()
+#               for x in l:
+#                   print x
+#                   if x[0] != '-':
+#                       self.val['name'] = os.path.basename(x)
+#                       break
 
-			### Show yellow usage
-			self.val['process'] = '%-*s%s%3d' % (self.format[1]-3, self.val['name'], ansi['yellow'], round(max))
+            ### Show yellow usage
+            self.val['process'] = '%-*s%s%3d' % (self.format[1]-3, self.val['name'], ansi['yellow'], round(max))
 
-			### Debug (show PID)
-#			self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.format[1]-6, self.val['name'])
+            ### Debug (show PID)
+#           self.val['process'] = '%*s %-*s' % (5, self.val['pid'], self.format[1]-6, self.val['name'])
 
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_battery.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_battery.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_battery.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -7,39 +7,39 @@
 import string
 
 class dstat_battery(dstat):
-	def __init__(self):
-		self.name = 'battery'
-		self.format = ('f', 4, 34)
-		self.vars = []
-		for battery in os.listdir('/proc/acpi/battery/'):
-			for line in dopen('/proc/acpi/battery/'+battery+'/state').readlines():
-				l = string.split(line)
-				if len(l) &lt; 2: continue
-				if l[0] == 'present:' and l[1] == 'yes':
-					self.vars.append(battery)
-#		self.nick = [string.lower(name) for name in self.vars]
-		self.nick = []
-		for name in self.vars:
-			self.nick.append(string.lower(name))
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'battery'
+        self.format = ('f', 4, 34)
+        self.vars = []
+        for battery in os.listdir('/proc/acpi/battery/'):
+            for line in dopen('/proc/acpi/battery/'+battery+'/state').readlines():
+                l = string.split(line)
+                if len(l) &lt; 2: continue
+                if l[0] == 'present:' and l[1] == 'yes':
+                    self.vars.append(battery)
+#       self.nick = [string.lower(name) for name in self.vars]
+        self.nick = []
+        for name in self.vars:
+            self.nick.append(string.lower(name))
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for battery in self.vars:
-			for line in dopen('/proc/acpi/battery/'+battery+'/info').readlines():
-				l = string.split(line)
-				if len(l) &lt; 4: continue
-				if l[0] == 'last':
-					full = int(l[3])
-					break
-			for line in dopen('/proc/acpi/battery/'+battery+'/state').readlines():
-				l = string.split(line)
-				if len(l) &lt; 3: continue
-				if l[0] == 'remaining':
-					current = int(l[2])
-					break
-			if current:
-				self.val[battery] = current * 100.0 / full
-			else:
-				self.val[battery] = -1
+    def extract(self):
+        for battery in self.vars:
+            for line in dopen('/proc/acpi/battery/'+battery+'/info').readlines():
+                l = string.split(line)
+                if len(l) &lt; 4: continue
+                if l[0] == 'last':
+                    full = int(l[3])
+                    break
+            for line in dopen('/proc/acpi/battery/'+battery+'/state').readlines():
+                l = string.split(line)
+                if len(l) &lt; 3: continue
+                if l[0] == 'remaining':
+                    current = int(l[2])
+                    break
+            if current:
+                self.val[battery] = current * 100.0 / full
+            else:
+                self.val[battery] = -1
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_cpufreq.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_cpufreq.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_cpufreq.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -7,34 +7,34 @@
 import string
 
 class dstat_cpufreq(dstat):
-	def __init__(self):
-		self.name = 'frequency'
-		self.format = ('p', 4, 34)
-		self.vars = os.listdir('/sys/devices/system/cpu/')
-#		self.nick = [string.lower(name) for name in self.vars]
-		self.nick = []
-		for name in self.vars:
-			self.nick.append(string.lower(name))
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'frequency'
+        self.format = ('p', 4, 34)
+        self.vars = os.listdir('/sys/devices/system/cpu/')
+#       self.nick = [string.lower(name) for name in self.vars]
+        self.nick = []
+        for name in self.vars:
+            self.nick.append(string.lower(name))
+        self.init(self.vars, 1)
 
-	def check(self): 
-		if self.vars:
-			for cpu in self.vars:
-				if not os.access('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq', os.R_OK):
-					raise Exception, 'Cannot access acpi cpu frequency information'
-			return True
-		raise Exception, 'No statistics found'
+    def check(self): 
+        if self.vars:
+            for cpu in self.vars:
+                if not os.access('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq', os.R_OK):
+                    raise Exception, 'Cannot access acpi cpu frequency information'
+            return True
+        raise Exception, 'No statistics found'
 
-	def extract(self):
-		for cpu in self.vars:
-			for line in dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_max_freq').readlines():
-				l = string.split(line)
-				max = int(l[0])
-			for line in dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq').readlines():
-				l = string.split(line)
-				cur = int(l[0])
-			### Need to close because of bug in sysfs (?)
-			dclose('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq')
-			self.val[cpu] = cur * 100.0 / max
+    def extract(self):
+        for cpu in self.vars:
+            for line in dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_max_freq').readlines():
+                l = string.split(line)
+                max = int(l[0])
+            for line in dopen('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq').readlines():
+                l = string.split(line)
+                cur = int(l[0])
+            ### Need to close because of bug in sysfs (?)
+            dclose('/sys/devices/system/cpu/'+cpu+'/cpufreq/cpuinfo_cur_freq')
+            self.val[cpu] = cur * 100.0 / max
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_dbus.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_dbus.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_dbus.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -4,38 +4,38 @@
 ### Authority: <A HREF="http://lists.repoforge.org/mailman/listinfo/commits">dag at wieers.com</A>
 
 class dstat_dbus(dstat):
-	def __init__(self):
-		self.name = 'dbus'
-		self.format = ('d', 3, 100)
-		self.nick = ('sys', 'ses')
-		self.vars = ('system', 'session')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'dbus'
+        self.format = ('d', 3, 100)
+        self.nick = ('sys', 'ses')
+        self.vars = ('system', 'session')
+        self.init(self.vars, 1)
 
-	def check(self): 
-#		dstat.info(1, 'The dbus module is an EXPERIMENTAL module.')
-		try:
-			global dbus
-			import dbus
-			try:
-				self.sysbus = dbus.Bus(dbus.Bus.TYPE_SYSTEM).get_service('org.freedesktop.DBus').get_object('/org/freedesktop/DBus', 'org.freedesktop.DBus')
-				try:
-					self.sesbus = dbus.Bus(dbus.Bus.TYPE_SESSION).get_service('org.freedesktop.DBus').get_object('/org/freedesktop/DBus', 'org.freedesktop.DBus')
-				except:
-					self.sesbus = None
-			except:
-				raise Exception, 'Unable to connect to dbus message bus'
-			return True
-		except:
-			raise Exception, 'Needs python-dbus module'
+    def check(self): 
+#       dstat.info(1, 'The dbus module is an EXPERIMENTAL module.')
+        try:
+            global dbus
+            import dbus
+            try:
+                self.sysbus = dbus.Bus(dbus.Bus.TYPE_SYSTEM).get_service('org.freedesktop.DBus').get_object('/org/freedesktop/DBus', 'org.freedesktop.DBus')
+                try:
+                    self.sesbus = dbus.Bus(dbus.Bus.TYPE_SESSION).get_service('org.freedesktop.DBus').get_object('/org/freedesktop/DBus', 'org.freedesktop.DBus')
+                except:
+                    self.sesbus = None
+            except:
+                raise Exception, 'Unable to connect to dbus message bus'
+            return True
+        except:
+            raise Exception, 'Needs python-dbus module'
 
-	def extract(self):
-		self.val['system'] = len(self.sysbus.ListServices()) - 1
-		try:
-			self.val['session'] = len(self.sesbus.ListServices()) - 1
-		except:
-			self.val['session'] = -1
-#		print dir(b); print dir(s); print dir(d); print d.ListServices()
-#		print dir(d)
-#		print d.ListServices()
+    def extract(self):
+        self.val['system'] = len(self.sysbus.ListServices()) - 1
+        try:
+            self.val['session'] = len(self.sesbus.ListServices()) - 1
+        except:
+            self.val['session'] = -1
+#       print dir(b); print dir(s); print dir(d); print d.ListServices()
+#       print dir(d)
+#       print d.ListServices()
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_freespace.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_freespace.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_freespace.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -6,36 +6,36 @@
 import string
 
 class dstat_freespace(dstat):
-	def __init__(self):
-		self.format = ('f', 5, 1024)
-		self.open('/etc/mtab')
-		self.vars = self.vars()
-#		self.name = ['/' + os.path.basename(name) for name in self.vars]
-		self.name = []
-		for name in self.vars:
-			self.name.append('/' + os.path.basename(name))
-		self.nick = ('used', 'free')
-		self.init(self.vars + ['total',], 2)
+    def __init__(self):
+        self.format = ('f', 5, 1024)
+        self.open('/etc/mtab')
+        self.vars = self.vars()
+#       self.name = ['/' + os.path.basename(name) for name in self.vars]
+        self.name = []
+        for name in self.vars:
+            self.name.append('/' + os.path.basename(name))
+        self.nick = ('used', 'free')
+        self.init(self.vars + ['total',], 2)
 
-	def vars(self):
-		ret = []
-		for line in self.readlines():
-			l = string.split(line)
-			if len(l) &lt; 6: continue
-			if l[2] in ('binfmt_misc', 'devpts', 'iso9660', 'none', 'proc', 'sysfs', 'usbfs'): continue
-			### FIXME: Excluding 'none' here may not be what people want (/dev/shm)
-			if l[0] in ('devpts', 'none', 'proc', 'sunrpc', 'usbfs'): continue
-			name = l[1] 
-			res = os.statvfs(name)
-			if res[0] == 0: continue ### Skip zero block filesystems
-			ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        for line in self.readlines():
+            l = string.split(line)
+            if len(l) &lt; 6: continue
+            if l[2] in ('binfmt_misc', 'devpts', 'iso9660', 'none', 'proc', 'sysfs', 'usbfs'): continue
+            ### FIXME: Excluding 'none' here may not be what people want (/dev/shm)
+            if l[0] in ('devpts', 'none', 'proc', 'sunrpc', 'usbfs'): continue
+            name = l[1] 
+            res = os.statvfs(name)
+            if res[0] == 0: continue ### Skip zero block filesystems
+            ret.append(name)
+        return ret
 
-	def extract(self):
-		self.val['total'] = (0, 0)
-		for name in self.vars:
-			res = os.statvfs(name)
-			self.val[name] = ( (float(res.f_blocks) - float(res.f_bavail)) * long(res.f_frsize), float(res.f_bavail) * float(res.f_frsize) )
-			self.val['total'] = (self.val['total'][0] + self.val[name][0], self.val['total'][1] + self.val[name][1])
+    def extract(self):
+        self.val['total'] = (0, 0)
+        for name in self.vars:
+            res = os.statvfs(name)
+            self.val[name] = ( (float(res.f_blocks) - float(res.f_bavail)) * long(res.f_frsize), float(res.f_bavail) * float(res.f_frsize) )
+            self.val['total'] = (self.val['total'][0] + self.val[name][0], self.val['total'][1] + self.val[name][1])
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_gpfs.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_gpfs.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_gpfs.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,43 +2,43 @@
 import string, select
 
 class dstat_gpfs(dstat):
-	def __init__(self):
-		self.name = 'gpfs i/o'
-		self.format = ('f', 5, 1024)
-		self.vars = ('_br_', '_bw_')
-		self.nick = ('read', 'write')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'gpfs i/o'
+        self.format = ('f', 5, 1024)
+        self.vars = ('_br_', '_bw_')
+        self.nick = ('read', 'write')
+        self.init(self.vars, 1)
 
-	def check(self): 
-		if os.access('/usr/lpp/mmfs/bin/mmpmon', os.X_OK):
-			try:
-				self.stdin, self.stdout, self.stderr = dpopen('/usr/lpp/mmfs/bin/mmpmon -p -s')
-				self.stdin.write('reset\n')
-				readpipe(self.stdout)
-			except IOError:
-				raise Exception, 'Cannot interface with gpfs mmpmon binary'
-			return True
-		raise Exception, 'Needs GPFS mmpmon binary'
+    def check(self): 
+        if os.access('/usr/lpp/mmfs/bin/mmpmon', os.X_OK):
+            try:
+                self.stdin, self.stdout, self.stderr = dpopen('/usr/lpp/mmfs/bin/mmpmon -p -s')
+                self.stdin.write('reset\n')
+                readpipe(self.stdout)
+            except IOError:
+                raise Exception, 'Cannot interface with gpfs mmpmon binary'
+            return True
+        raise Exception, 'Needs GPFS mmpmon binary'
 
-	def extract(self):
-		try:
-			self.stdin.write('io_s\n')
-#			readpipe(self.stderr)
-			for line in readpipe(self.stdout):
-				if not line: continue
-				l = line.split()
-				for name in self.vars:
-					self.cn2[name] = long(l[l.index(name)+1])
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		except IOError, e:
-			for name in self.vars: self.val[name] = -1
-#			print 'dstat_gpfs: lost pipe to mmpmon,', e
-		except Exception, e:
-			for name in self.vars: self.val[name] = -1
-#			print 'dstat_gpfs: exception', e
+    def extract(self):
+        try:
+            self.stdin.write('io_s\n')
+#           readpipe(self.stderr)
+            for line in readpipe(self.stdout):
+                if not line: continue
+                l = line.split()
+                for name in self.vars:
+                    self.cn2[name] = long(l[l.index(name)+1])
+            for name in self.vars:
+                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        except IOError, e:
+            for name in self.vars: self.val[name] = -1
+#           print 'dstat_gpfs: lost pipe to mmpmon,', e
+        except Exception, e:
+            for name in self.vars: self.val[name] = -1
+#           print 'dstat_gpfs: exception', e
 
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_gpfsop.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_gpfsop.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_gpfsop.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,43 +2,43 @@
 import string, select
 
 class dstat_gpfsop(dstat):
-	def __init__(self):
-		self.name = 'gpfs file operations'
-		self.format = ('d', 5, 1000)
-		self.vars = ('_oc_', '_cc_', '_rdc_', '_wc_', '_dir_', '_iu_')
-		self.nick = ('open', 'clos', 'read', 'writ', 'rdir', 'inod')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'gpfs file operations'
+        self.format = ('d', 5, 1000)
+        self.vars = ('_oc_', '_cc_', '_rdc_', '_wc_', '_dir_', '_iu_')
+        self.nick = ('open', 'clos', 'read', 'writ', 'rdir', 'inod')
+        self.init(self.vars, 1)
 
-	def check(self): 
-		if os.access('/usr/lpp/mmfs/bin/mmpmon', os.X_OK):
-			try:
-				self.stdin, self.stdout, self.stderr = dpopen('/usr/lpp/mmfs/bin/mmpmon -p -s')
-				self.stdin.write('reset\n')
-				readpipe(self.stdout)
-			except IOError:
-				raise Exception, 'Cannot interface with gpfs mmpmon binary'
-			return True
-		raise Exception, 'Needs GPFS mmpmon binary'
+    def check(self): 
+        if os.access('/usr/lpp/mmfs/bin/mmpmon', os.X_OK):
+            try:
+                self.stdin, self.stdout, self.stderr = dpopen('/usr/lpp/mmfs/bin/mmpmon -p -s')
+                self.stdin.write('reset\n')
+                readpipe(self.stdout)
+            except IOError:
+                raise Exception, 'Cannot interface with gpfs mmpmon binary'
+            return True
+        raise Exception, 'Needs GPFS mmpmon binary'
 
-	def extract(self):
-		try:
-			self.stdin.write('io_s\n')
-#			readpipe(self.stderr)
-			for line in readpipe(self.stdout):
-				if not line: continue
-				l = line.split()
-				for name in self.vars:
-					self.cn2[name] = long(l[l.index(name)+1])
-			for name in self.vars:
-				self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		except IOError, e:
-			for name in self.vars: self.val[name] = -1
-#			print 'dstat_gpfs: lost pipe to mmpmon,', e
-		except Exception, e:
-			for name in self.vars: self.val[name] = -1
-#			print 'dstat_gpfs: exception', e
+    def extract(self):
+        try:
+            self.stdin.write('io_s\n')
+#           readpipe(self.stderr)
+            for line in readpipe(self.stdout):
+                if not line: continue
+                l = line.split()
+                for name in self.vars:
+                    self.cn2[name] = long(l[l.index(name)+1])
+            for name in self.vars:
+                self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        except IOError, e:
+            for name in self.vars: self.val[name] = -1
+#           print 'dstat_gpfs: lost pipe to mmpmon,', e
+        except Exception, e:
+            for name in self.vars: self.val[name] = -1
+#           print 'dstat_gpfs: exception', e
 
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_nfs3.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfs3.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_nfs3.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,28 +2,28 @@
 import string
 
 class dstat_nfs3(dstat):
-	def __init__(self):
-		self.name = 'nfs3 client'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/net/rpc/nfs')
-		self.vars = ('read', 'write', 'readdir', 'inode', 'filesystem', 'commit')
-		self.nick = ('read', 'writ', 'rdir', 'inod', 'fs', 'cmmt')
-		self.init(self.vars, 1)
-		info(1, 'Module dstat_nfs3 is still experimental.')
+    def __init__(self):
+        self.name = 'nfs3 client'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/net/rpc/nfs')
+        self.vars = ('read', 'write', 'readdir', 'inode', 'filesystem', 'commit')
+        self.nick = ('read', 'writ', 'rdir', 'inod', 'fs', 'cmmt')
+        self.init(self.vars, 1)
+        info(1, 'Module dstat_nfs3 is still experimental.')
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if not l or l[0] != 'proc3': continue
-			self.cn2['read'] = long(l[8])
-			self.cn2['write'] = long(l[9])
-			self.cn2['readdir'] = long(l[17]) + long(l[18])
-			self.cn2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16])
-			self.cn2['filesystem'] = long(l[19]) + long(l[20]) + long(l[21])
-			self.cn2['commit'] = long(l[22])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if not l or l[0] != 'proc3': continue
+            self.cn2['read'] = long(l[8])
+            self.cn2['write'] = long(l[9])
+            self.cn2['readdir'] = long(l[17]) + long(l[18])
+            self.cn2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16])
+            self.cn2['filesystem'] = long(l[19]) + long(l[20]) + long(l[21])
+            self.cn2['commit'] = long(l[22])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_nfs3op.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfs3op.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_nfs3op.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,24 +2,24 @@
 import string
 
 class dstat_nfs3op(dstat):
-	def __init__(self):
-		self.name = 'extended nfs3 client operations'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/net/rpc/nfs')
-		self.vars = ('null', 'getattr', 'setattr', 'lookup', 'access', 'readlink', 'read', 'write', 'create', 'mkdir', 'symlink', 'mknod', 'remove', 'rmdir', 'rename', 'link', 'readdir', 'readdirplus', 'fsstat', 'fsinfo', 'pathconf', 'commit')
-		self.nick = ('null', 'gatr', 'satr', 'look', 'aces', 'rdln', 'read', 'writ', 'crea', 'mkdr', 'syml', 'mknd', 'rm', 'rmdr', 'ren', 'link', 'rdir', 'rdr+', 'fstt', 'fsnf', 'path', 'cmmt')
-		self.init(self.vars, 1)
-		info(1, 'Module dstat_nfs3op is still experimental.')
+    def __init__(self):
+        self.name = 'extended nfs3 client operations'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/net/rpc/nfs')
+        self.vars = ('null', 'getattr', 'setattr', 'lookup', 'access', 'readlink', 'read', 'write', 'create', 'mkdir', 'symlink', 'mknod', 'remove', 'rmdir', 'rename', 'link', 'readdir', 'readdirplus', 'fsstat', 'fsinfo', 'pathconf', 'commit')
+        self.nick = ('null', 'gatr', 'satr', 'look', 'aces', 'rdln', 'read', 'writ', 'crea', 'mkdr', 'syml', 'mknd', 'rm', 'rmdr', 'ren', 'link', 'rdir', 'rdr+', 'fstt', 'fsnf', 'path', 'cmmt')
+        self.init(self.vars, 1)
+        info(1, 'Module dstat_nfs3op is still experimental.')
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if not l or l[0] != 'proc3': continue
-			for i, name in enumerate(self.vars):
-				self.cn2[name] = long(l[i+2])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if not l or l[0] != 'proc3': continue
+            for i, name in enumerate(self.vars):
+                self.cn2[name] = long(l[i+2])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_nfsd3.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfsd3.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_nfsd3.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,28 +2,28 @@
 import string
 
 class dstat_nfsd3(dstat):
-	def __init__(self):
-		self.name = 'nfs3 server'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/net/rpc/nfsd')
-		self.vars = ('read', 'write', 'readdir', 'inode', 'filesystem', 'commit')
-		self.nick = ('read', 'writ', 'rdir', 'inod', 'fs', 'cmmt')
-		self.init(self.vars, 1)
-		info(1, 'Module dstat_nfsd3 is still experimental.')
+    def __init__(self):
+        self.name = 'nfs3 server'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/net/rpc/nfsd')
+        self.vars = ('read', 'write', 'readdir', 'inode', 'filesystem', 'commit')
+        self.nick = ('read', 'writ', 'rdir', 'inod', 'fs', 'cmmt')
+        self.init(self.vars, 1)
+        info(1, 'Module dstat_nfsd3 is still experimental.')
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if not l or l[0] != 'proc3': continue
-			self.cn2['read'] = long(l[8])
-			self.cn2['write'] = long(l[9])
-			self.cn2['readdir'] = long(l[18]) + long(l[19])
-			self.cn2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16]) + long(l[17])
-			self.cn2['filesystem'] = long(l[20]) + long(l[21]) + long(l[22])
-			self.cn2['commit'] = long(l[23])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if not l or l[0] != 'proc3': continue
+            self.cn2['read'] = long(l[8])
+            self.cn2['write'] = long(l[9])
+            self.cn2['readdir'] = long(l[18]) + long(l[19])
+            self.cn2['inode'] = long(l[3]) + long(l[4]) + long(l[5]) + long(l[6]) + long(l[7]) + long(l[10]) + long(l[11]) + long(l[12]) + long(l[13]) + long(l[14]) + long(l[15]) + long(l[16]) + long(l[17])
+            self.cn2['filesystem'] = long(l[20]) + long(l[21]) + long(l[22])
+            self.cn2['commit'] = long(l[23])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_nfsd3op.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_nfsd3op.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_nfsd3op.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,24 +2,24 @@
 import string
 
 class dstat_nfsd3op(dstat):
-	def __init__(self):
-		self.name = 'extended nfs3 server operations'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/net/rpc/nfsd')
-		self.vars = ('null', 'getattr', 'setattr', 'lookup', 'access', 'readlink', 'read', 'write', 'create', 'mkdir', 'symlink', 'mknod', 'remove', 'rmdir', 'rename', 'link', 'readdir', 'readdirplus', 'fsstat', 'fsinfo', 'pathconf', 'commit')
-		self.nick = ('null', 'gatr', 'satr', 'look', 'aces', 'rdln', 'read', 'writ', 'crea', 'mkdr', 'syml', 'mknd', 'rm', 'rmdr', 'ren', 'link', 'rdir', 'rdr+', 'fstt', 'fsnf', 'path', 'cmmt')
-		self.init(self.vars, 1)
-		info(1, 'Module dstat_nfsd3op is still experimental.')
+    def __init__(self):
+        self.name = 'extended nfs3 server operations'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/net/rpc/nfsd')
+        self.vars = ('null', 'getattr', 'setattr', 'lookup', 'access', 'readlink', 'read', 'write', 'create', 'mkdir', 'symlink', 'mknod', 'remove', 'rmdir', 'rename', 'link', 'readdir', 'readdirplus', 'fsstat', 'fsinfo', 'pathconf', 'commit')
+        self.nick = ('null', 'gatr', 'satr', 'look', 'aces', 'rdln', 'read', 'writ', 'crea', 'mkdr', 'syml', 'mknd', 'rm', 'rmdr', 'ren', 'link', 'rdir', 'rdr+', 'fstt', 'fsnf', 'path', 'cmmt')
+        self.init(self.vars, 1)
+        info(1, 'Module dstat_nfsd3op is still experimental.')
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if not l or l[0] != 'proc3': continue
-			for i, name in enumerate(self.vars):
-				self.cn2[name] = long(l[i+2])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if not l or l[0] != 'proc3': continue
+            for i, name in enumerate(self.vars):
+                self.cn2[name] = long(l[i+2])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_postfix.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_postfix.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_postfix.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,20 +2,20 @@
 import glob
 
 class dstat_postfix(dstat):
-	def __init__(self):
-		self.name = 'postfix'
-		self.format = ('d', 4, 100)
-		self.vars = ('incoming', 'active', 'deferred', 'bounce', 'defer')
-		self.nick = ('inco', 'actv', 'dfrd', 'bnce', 'defr')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'postfix'
+        self.format = ('d', 4, 100)
+        self.vars = ('incoming', 'active', 'deferred', 'bounce', 'defer')
+        self.nick = ('inco', 'actv', 'dfrd', 'bnce', 'defr')
+        self.init(self.vars, 1)
 
-	def check(self): 
-		if not os.access('/var/spool/postfix/active', os.R_OK):
-			raise Exception, 'Cannot access postfix queues'
-		return True
+    def check(self): 
+        if not os.access('/var/spool/postfix/active', os.R_OK):
+            raise Exception, 'Cannot access postfix queues'
+        return True
 
-	def extract(self):
-		for item in self.vars:
-			self.val[item] = len(glob.glob('/var/spool/postfix/'+item+'/*/*'))
+    def extract(self):
+        for item in self.vars:
+            self.val[item] = len(glob.glob('/var/spool/postfix/'+item+'/*/*'))
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_rpc.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_rpc.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_rpc.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,23 +2,23 @@
 import string
 
 class dstat_rpc(dstat):
-	def __init__(self):
-		self.name = 'rpc client'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/net/rpc/nfs')
-		self.vars = ('calls', 'retransmits', 'autorefreshes')
-		self.nick = ('call', 'retr', 'refr')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'rpc client'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/net/rpc/nfs')
+        self.vars = ('calls', 'retransmits', 'autorefreshes')
+        self.nick = ('call', 'retr', 'refr')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if not l or l[0] != 'rpc': continue
-			for i, name in enumerate(self.vars):
-				self.cn2[name] = long(l[i+1])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if not l or l[0] != 'rpc': continue
+            for i, name in enumerate(self.vars):
+                self.cn2[name] = long(l[i+1])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_rpcd.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_rpcd.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_rpcd.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,23 +2,23 @@
 import string
 
 class dstat_rpcd(dstat):
-	def __init__(self):
-		self.name = 'rpc server'
-		self.format = ('d', 5, 1000)
-		self.open('/proc/net/rpc/nfsd')
-		self.vars = ('calls', 'badcalls', 'badauth', 'badclnt', 'xdrcall')
-		self.nick = ('call', 'erca', 'erau', 'ercl', 'xdrc')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'rpc server'
+        self.format = ('d', 5, 1000)
+        self.open('/proc/net/rpc/nfsd')
+        self.vars = ('calls', 'badcalls', 'badauth', 'badclnt', 'xdrcall')
+        self.nick = ('call', 'erca', 'erau', 'ercl', 'xdrc')
+        self.init(self.vars, 1)
 
-	def extract(self):
-		for line in self.readlines():
-			l = line.split()
-			if not l or l[0] != 'rpc': continue
-			for i, name in enumerate(self.vars):
-				self.cn2[name] = long(l[i+1])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for line in self.readlines():
+            l = line.split()
+            if not l or l[0] != 'rpc': continue
+            for i, name in enumerate(self.vars):
+                self.cn2[name] = long(l[i+1])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_sendmail.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_sendmail.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_sendmail.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -3,19 +3,19 @@
 import glob
 
 class dstat_sendmail(dstat):
-	def __init__(self):
-		self.name = 'sendmail'
-		self.format = ('d', 4, 100)
-		self.vars = ('queue',)
-		self.nick = ('queu',)
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'sendmail'
+        self.format = ('d', 4, 100)
+        self.vars = ('queue',)
+        self.nick = ('queu',)
+        self.init(self.vars, 1)
 
-	def check(self):
-		if not os.access('/var/spool/mqueue', os.R_OK):
-			raise Exception, 'Cannot access sendmail queue'
-		return True
+    def check(self):
+        if not os.access('/var/spool/mqueue', os.R_OK):
+            raise Exception, 'Cannot access sendmail queue'
+        return True
 
-	def extract(self):
-		self.val['queue'] = len(glob.glob('/var/spool/mqueue/qf*'))
+    def extract(self):
+        self.val['queue'] = len(glob.glob('/var/spool/mqueue/qf*'))
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_thermal.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_thermal.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_thermal.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,39 +2,39 @@
 import string
 
 class dstat_thermal(dstat):
-	def __init__(self):
-		self.name = 'thermal'
-		self.format = ('d', 4, 20)
-		if os.path.exists('/proc/acpi/ibm/thermal'):
-			self.namelist = ['cpu', 'pci', 'hdd', 'cpu', 'bat0', 'unk', 'bat1', 'unk']
-			self.nick = []
-			for line in dopen('/proc/acpi/ibm/thermal'):
-				l = string.split(line)
-				for i, name in enumerate(self.namelist):
-					if int(l[i+1]) &gt; 0:
-						self.nick.append(name)
-			self.vars = self.nick
-		elif os.path.exists('/proc/acpi/thermal_zone/'):
-			self.vars = os.listdir('/proc/acpi/thermal_zone/')
-#			self.nick = [string.lower(name) for name in self.vars]
-			self.nick = []
-			for name in self.vars:
-				self.nick.append(string.lower(name))
-		else:
-			raise Exception, 'Needs kernel ACPI or IBM-ACPI support'
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'thermal'
+        self.format = ('d', 4, 20)
+        if os.path.exists('/proc/acpi/ibm/thermal'):
+            self.namelist = ['cpu', 'pci', 'hdd', 'cpu', 'bat0', 'unk', 'bat1', 'unk']
+            self.nick = []
+            for line in dopen('/proc/acpi/ibm/thermal'):
+                l = string.split(line)
+                for i, name in enumerate(self.namelist):
+                    if int(l[i+1]) &gt; 0:
+                        self.nick.append(name)
+            self.vars = self.nick
+        elif os.path.exists('/proc/acpi/thermal_zone/'):
+            self.vars = os.listdir('/proc/acpi/thermal_zone/')
+#           self.nick = [string.lower(name) for name in self.vars]
+            self.nick = []
+            for name in self.vars:
+                self.nick.append(string.lower(name))
+        else:
+            raise Exception, 'Needs kernel ACPI or IBM-ACPI support'
+        self.init(self.vars, 1)
 
-	def extract(self):
-		if os.path.exists('/proc/acpi/ibm/thermal'):
-			for line in dopen('/proc/acpi/ibm/thermal'):
-				l = string.split(line)
-				for i, name in enumerate(self.namelist):
-					if int(l[i+1]) &gt; 0:
-						self.val[name] = int(l[i+1])
-		elif os.path.exists('/proc/acpi/thermal_zone/'):
-			for zone in self.vars:
-				for line in dopen('/proc/acpi/thermal_zone/'+zone+'/temperature').readlines():
-					l = string.split(line)
-					self.val[zone] = int(l[1])
+    def extract(self):
+        if os.path.exists('/proc/acpi/ibm/thermal'):
+            for line in dopen('/proc/acpi/ibm/thermal'):
+                l = string.split(line)
+                for i, name in enumerate(self.namelist):
+                    if int(l[i+1]) &gt; 0:
+                        self.val[name] = int(l[i+1])
+        elif os.path.exists('/proc/acpi/thermal_zone/'):
+            for zone in self.vars:
+                for line in dopen('/proc/acpi/thermal_zone/'+zone+'/temperature').readlines():
+                    l = string.split(line)
+                    self.val[zone] = int(l[1])
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_utmp.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_utmp.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_utmp.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -1,27 +1,27 @@
 class dstat_utmp(dstat):
-	def __init__(self):
-		self.name = 'utmp'
-		self.format = ('d', 3, 10)
-		self.nick = ('ses', 'usr', 'adm' )
-		self.vars = ('sessions', 'users', 'root')
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'utmp'
+        self.format = ('d', 3, 10)
+        self.nick = ('ses', 'usr', 'adm' )
+        self.vars = ('sessions', 'users', 'root')
+        self.init(self.vars, 1)
 
-	def check(self): 
-		try:
-			global utmp
-			import utmp
-			return True
-		except:
-			raise Exception, 'Needs python-utmp module'
+    def check(self): 
+        try:
+            global utmp
+            import utmp
+            return True
+        except:
+            raise Exception, 'Needs python-utmp module'
 
-	def extract(self):
-		for name in self.vars: self.val[name] = 0
-		for u in utmp.UtmpRecord():
-#			print '# type:%s pid:%s line:%s id:%s user:%s host:%s session:%s' % (i.ut_type, i.ut_pid, i.ut_line, i.ut_id, i.ut_user, i.ut_host, i.ut_session)
-			if u.ut_type == utmp.USER_PROCESS:
-				self.val['users'] = self.val['users'] + 1
-				if u.ut_user == 'root':
-					self.val['root'] = self.val['root'] + 1
-			self.val['sessions'] = self.val['sessions'] + 1
+    def extract(self):
+        for name in self.vars: self.val[name] = 0
+        for u in utmp.UtmpRecord():
+#           print '# type:%s pid:%s line:%s id:%s user:%s host:%s session:%s' % (i.ut_type, i.ut_pid, i.ut_line, i.ut_id, i.ut_user, i.ut_host, i.ut_session)
+            if u.ut_type == utmp.USER_PROCESS:
+                self.val['users'] = self.val['users'] + 1
+                if u.ut_user == 'root':
+                    self.val['root'] = self.val['root'] + 1
+            self.val['sessions'] = self.val['sessions'] + 1
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_vmkhba.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vmkhba.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_vmkhba.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -13,74 +13,74 @@
 # # dstat -M vmkhba -d -D sda,vmhba1
 
 class dstat_vmkhba(dstat):
-	def __init__(self):
-		self.name = 'vmkhba'
-		self.discover = self.discover()
-		self.format = ('f', 5, 1024)
-		self.nick = ('read', 'writ')
-		self.vars = self.vars()
-		self.name = self.vars
-		self.init(self.vars + ['total'], 2)
+    def __init__(self):
+        self.name = 'vmkhba'
+        self.discover = self.discover()
+        self.format = ('f', 5, 1024)
+        self.nick = ('read', 'writ')
+        self.vars = self.vars()
+        self.name = self.vars
+        self.init(self.vars + ['total'], 2)
 
-	def discover(self, *list):
-	# discover will list all vmhba's found.
-	# we might want to filter out the unused vmhba's (read stats, compare with ['0', ] * 13)
-		ret = []
-		try:
-			list = os.listdir('/proc/vmware/scsi/')
-		except:
-			raise Exception, 'Needs VMware ESX'
-		for name in list:
-			for line in dopen('/proc/vmware/scsi/%s/stats' % name).readlines():
-				l = line.split()
-				if len(l) &lt; 13: continue
-				if l[0] == 'cmds': continue
-				if l == ['0', ] * 13: continue
-				ret.append(name)
-		return ret
+    def discover(self, *list):
+    # discover will list all vmhba's found.
+    # we might want to filter out the unused vmhba's (read stats, compare with ['0', ] * 13)
+        ret = []
+        try:
+            list = os.listdir('/proc/vmware/scsi/')
+        except:
+            raise Exception, 'Needs VMware ESX'
+        for name in list:
+            for line in dopen('/proc/vmware/scsi/%s/stats' % name).readlines():
+                l = line.split()
+                if len(l) &lt; 13: continue
+                if l[0] == 'cmds': continue
+                if l == ['0', ] * 13: continue
+                ret.append(name)
+        return ret
 
-	def vars(self):
-	# vars will take the argument list - when implemented - , use total, or will use discover + total
-		ret = []
-		if op.disklist:
-			list = op.disklist
-		#elif not op.full:
-		#	list = ('total', )
-		else:
-			list = self.discover
-			list.sort()
-		for name in list:
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+    # vars will take the argument list - when implemented - , use total, or will use discover + total
+        ret = []
+        if op.disklist:
+            list = op.disklist
+        #elif not op.full:
+        #   list = ('total', )
+        else:
+            list = self.discover
+            list.sort()
+        for name in list:
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def check(self): 
-		info(1, 'The vmkhba module is an EXPERIMENTAL module.')
-		ret = True
-		try:
-			os.listdir('/proc/vmware')
-		except:
-			raise Exception, 'Needs VMware ESX'
-		return ret
+    def check(self): 
+        info(1, 'The vmkhba module is an EXPERIMENTAL module.')
+        ret = True
+        try:
+            os.listdir('/proc/vmware')
+        except:
+            raise Exception, 'Needs VMware ESX'
+        return ret
 
-	def extract(self):
-		self.cn2['total'] = (0, 0)
-		for name in self.vars:
-			self.cn2[name] = (0, 0)
-		for name in os.listdir('/proc/vmware/scsi/'):
-			for line in dopen('/proc/vmware/scsi/%s/stats' % name).readlines():
-				l = line.split()
-				if len(l) &lt; 13: continue
-				if l[0] == 'cmds': continue
-				if l[2] == '0' and l[4] == '0': continue
-				if l == ['0', ] * 13: continue
-				self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[4]) )
-				if name in self.vars and name != 'total':
-					self.cn2[name] = ( long(l[2]), long(l[4]) )
-			for name in self.cn2.keys():
-				self.val[name] = (
-					(self.cn2[name][0] - self.cn1[name][0]) * 1024.0 / tick,
-					(self.cn2[name][1] - self.cn1[name][1]) * 1024.0 / tick
-				)
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        self.cn2['total'] = (0, 0)
+        for name in self.vars:
+            self.cn2[name] = (0, 0)
+        for name in os.listdir('/proc/vmware/scsi/'):
+            for line in dopen('/proc/vmware/scsi/%s/stats' % name).readlines():
+                l = line.split()
+                if len(l) &lt; 13: continue
+                if l[0] == 'cmds': continue
+                if l[2] == '0' and l[4] == '0': continue
+                if l == ['0', ] * 13: continue
+                self.cn2['total'] = ( self.cn2['total'][0] + long(l[2]), self.cn2['total'][1] + long(l[4]) )
+                if name in self.vars and name != 'total':
+                    self.cn2[name] = ( long(l[2]), long(l[4]) )
+            for name in self.cn2.keys():
+                self.val[name] = (
+                    (self.cn2[name][0] - self.cn1[name][0]) * 1024.0 / tick,
+                    (self.cn2[name][1] - self.cn1[name][1]) * 1024.0 / tick
+                )
+        if step == op.delay:
+            self.cn1.update(self.cn2)

Modified: trunk/tools/dstat/plugins/dstat_vmkint.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vmkint.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_vmkint.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -12,92 +12,92 @@
 # Look at /proc/vmware/interrupts to see which interrupt is linked to which function
 
 class dstat_vmkint(dstat):
-	def __init__(self):
-		self.name = 'vmkint'
-		self.open('/proc/vmware/interrupts')
-		self.discover = self.discover()
-		self.format = ('d', 4, 1000)
-#		self.intmap = self.intmap()
-		self.vars = self.vars()
-		self.nick = self.vars
-		self.init(self.vars, 1)
+    def __init__(self):
+        self.name = 'vmkint'
+        self.open('/proc/vmware/interrupts')
+        self.discover = self.discover()
+        self.format = ('d', 4, 1000)
+#       self.intmap = self.intmap()
+        self.vars = self.vars()
+        self.nick = self.vars
+        self.init(self.vars, 1)
 
-#	def intmap(self):
-#		ret = {}
-#		for line in dopen('/proc/vmware/interrupts').readlines():
-#			l = line.split()
-#			if len(l) &lt;= self.vmkcpunr: continue
-#			l1 = l[0].split(':')[0]
-#			l2 = ' '.join(l[vmkcpunr()+1:]).split(',')
-#			ret[l1] = l1
-#			for name in l2:
-#				ret[name.strip().lower()] = l1
-#			return ret
+#   def intmap(self):
+#       ret = {}
+#       for line in dopen('/proc/vmware/interrupts').readlines():
+#           l = line.split()
+#           if len(l) &lt;= self.vmkcpunr: continue
+#           l1 = l[0].split(':')[0]
+#           l2 = ' '.join(l[vmkcpunr()+1:]).split(',')
+#           ret[l1] = l1
+#           for name in l2:
+#               ret[name.strip().lower()] = l1
+#           return ret
 
-	def vmkcpunr(self):
-		#the service console sees only one CPU, so cpunr == 1, only the vmkernel sees all CPUs
-		ret = []
-		# default cpu number is 2
-		ret = 2
-		self.fd[0].seek(0)
-		for line in self.fd[0].readlines():
-			l = line.split()
-			if l[0] == 'Vector': 
-				ret = int( int( l[-1] ) + 1 )
-		return ret
+    def vmkcpunr(self):
+        #the service console sees only one CPU, so cpunr == 1, only the vmkernel sees all CPUs
+        ret = []
+        # default cpu number is 2
+        ret = 2
+        self.fd[0].seek(0)
+        for line in self.fd[0].readlines():
+            l = line.split()
+            if l[0] == 'Vector': 
+                ret = int( int( l[-1] ) + 1 )
+        return ret
 
-	def discover(self):
-		#interrupt names are not decimal numbers, but rather hexadecimal numbers like 0x7e
-		ret = []
-		self.fd[0].seek(0)
-		for line in self.fd[0].readlines():
-			l = line.split()
-			if l[0] == 'Vector': continue
-			if len(l) &lt; self.vmkcpunr()+1: continue
-			name = l[0].split(':')[0]
-			amount = 0
-			for i in l[1:1+self.vmkcpunr()]:
-				amount = amount + long(i)
-			if amount &gt; 20: ret.append(str(name))
-		return ret
+    def discover(self):
+        #interrupt names are not decimal numbers, but rather hexadecimal numbers like 0x7e
+        ret = []
+        self.fd[0].seek(0)
+        for line in self.fd[0].readlines():
+            l = line.split()
+            if l[0] == 'Vector': continue
+            if len(l) &lt; self.vmkcpunr()+1: continue
+            name = l[0].split(':')[0]
+            amount = 0
+            for i in l[1:1+self.vmkcpunr()]:
+                amount = amount + long(i)
+            if amount &gt; 20: ret.append(str(name))
+        return ret
 
-	def vars(self):
-		ret = []
-		if op.intlist:
-			list = op.intlist
-		else:
-			list = self.discover
-#			len(list) &gt; 5: list = list[-5:]
-		for name in list:
-			if name in self.discover:
-				ret.append(name)
-#			elif name.lower() in self.intmap.keys():
-#				ret.append(self.intmap[name.lower()])
-		return ret
+    def vars(self):
+        ret = []
+        if op.intlist:
+            list = op.intlist
+        else:
+            list = self.discover
+#           len(list) &gt; 5: list = list[-5:]
+        for name in list:
+            if name in self.discover:
+                ret.append(name)
+#           elif name.lower() in self.intmap.keys():
+#               ret.append(self.intmap[name.lower()])
+        return ret
 
-	def check(self): 
-		info(1, 'The vmkint module is an EXPERIMENTAL module.')
-		ret = True
-		try:
-			os.listdir('/proc/vmware')
-		except:
-			ret = False
-			raise Exception, 'Needs VMware ESX'
-		return ret
+    def check(self): 
+        info(1, 'The vmkint module is an EXPERIMENTAL module.')
+        ret = True
+        try:
+            os.listdir('/proc/vmware')
+        except:
+            ret = False
+            raise Exception, 'Needs VMware ESX'
+        return ret
 
-	def extract(self):
-		self.fd[0].seek(0)
-		for line in self.fd[0].readlines():
-			l = line.split()
-			if len(l) &lt; self.vmkcpunr()+1: continue
-			name = l[0].split(':')[0]
-			if name in self.vars:
-				self.cn2[name] = 0
-				for i in l[1:1+self.vmkcpunr()]:
-					self.cn2[name] = self.cn2[name] + long(i)
-		for name in self.cn2.keys():
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        self.fd[0].seek(0)
+        for line in self.fd[0].readlines():
+            l = line.split()
+            if len(l) &lt; self.vmkcpunr()+1: continue
+            name = l[0].split(':')[0]
+            if name in self.vars:
+                self.cn2[name] = 0
+                for i in l[1:1+self.vmkcpunr()]:
+                    self.cn2[name] = self.cn2[name] + long(i)
+        for name in self.cn2.keys():
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
 # vim:ts=4:sw=4

Modified: trunk/tools/dstat/plugins/dstat_vzcpu.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vzcpu.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_vzcpu.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -7,58 +7,58 @@
 #301    27188   0       7896     152899846  853267000490282  0      427043845492614 701812592320   0       0       0
 
 class dstat_vzcpu(dstat):
-	def __init__(self):
-		self.format = ('p', 3, 34)
-		self.open('/proc/vz/vestat')
-		self.nick = ('usr', 'sys', 'idl', 'nic')
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = self.name()
-		self.init(self.vars + ['total'], 4)
-		info(1, 'Module dstat_vzcpu is still experimental.')
+    def __init__(self):
+        self.format = ('p', 3, 34)
+        self.open('/proc/vz/vestat')
+        self.nick = ('usr', 'sys', 'idl', 'nic')
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = self.name()
+        self.init(self.vars + ['total'], 4)
+        info(1, 'Module dstat_vzcpu is still experimental.')
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 6 or l[0] == 'VEID': continue
-			ret.append(l[0])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 6 or l[0] == 'VEID': continue
+            ret.append(l[0])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def name(self):
-		ret = []
-		for name in self.vars:
-			if name == 'total':
-				ret.append('total ve usage')
-			else:
-				ret.append('ve ' + name + ' usage')
-		return ret
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name == 'total':
+                ret.append('total ve usage')
+            else:
+                ret.append('ve ' + name + ' usage')
+        return ret
 
-	def vars(self):
-		ret = []
-		if not op.full:
-			list = ('total', )
-		else: 
-			list = self.discover
-		for name in list: 
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if not op.full:
+            list = ('total', )
+        else: 
+            list = self.discover
+        for name in list: 
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		self.cn2['total'] = [0, 0, 0, 0]
-		for line in self.readlines():
-			l = line.split() 
-			if len(l) &lt; 6 or l[0] == 'VEID': continue
-			name = l[0]
-			self.cn2[name] = ( long(l[1]), long(l[3]), long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), long(l[2]) )
-			self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[3]), self.cn2['total'][2] + long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), self.cn2['total'][3] + long(l[2]) )
-		for name in self.vars:
-			for i in range(4):
-				self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        self.cn2['total'] = [0, 0, 0, 0]
+        for line in self.readlines():
+            l = line.split() 
+            if len(l) &lt; 6 or l[0] == 'VEID': continue
+            name = l[0]
+            self.cn2[name] = ( long(l[1]), long(l[3]), long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), long(l[2]) )
+            self.cn2['total'] = ( self.cn2['total'][0] + long(l[1]), self.cn2['total'][1] + long(l[3]), self.cn2['total'][2] + long(l[4]) - long(l[1]) - long(l[2]) - long(l[3]), self.cn2['total'][3] + long(l[2]) )
+        for name in self.vars:
+            for i in range(4):
+                self.val[name][i] = 100.0 * (self.cn2[name][i] - self.cn1[name][i]) / (sum(self.cn2[name]) - sum(self.cn1[name]))
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_vzubc.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_vzubc.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_vzubc.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,67 +2,67 @@
 import string
 
 class dstat_vzubc(dstat):
-	def __init__(self):
-		self.format = ('d', 5, 1000)
-		self.open('/proc/user_beancounters')
-		self.nick = ('fcnt', )
-		self.discover = self.discover()
-		self.vars = self.vars()
-		self.name = self.name()
-		self.init(self.vars + ['total'], 1)
-		info(1, 'Module dstat_vzubc is still experimental.')
+    def __init__(self):
+        self.format = ('d', 5, 1000)
+        self.open('/proc/user_beancounters')
+        self.nick = ('fcnt', )
+        self.discover = self.discover()
+        self.vars = self.vars()
+        self.name = self.name()
+        self.init(self.vars + ['total'], 1)
+        info(1, 'Module dstat_vzubc is still experimental.')
 
-	def discover(self, *list):
-		ret = []
-		for line in self.readlines():
-			l = line.split()
-			if len(l) &lt; 7 or l[0] in ('uid', '0:'): continue
-			ret.append(l[0][0:-1])
-		ret.sort()
-		for item in list: ret.append(item)
-		return ret
+    def discover(self, *list):
+        ret = []
+        for line in self.readlines():
+            l = line.split()
+            if len(l) &lt; 7 or l[0] in ('uid', '0:'): continue
+            ret.append(l[0][0:-1])
+        ret.sort()
+        for item in list: ret.append(item)
+        return ret
 
-	def name(self):
-		ret = []
-		for name in self.vars:
-			if name == 'total':
-				ret.append('total failcnt')
-			else:
-				ret.append(name)
-		return ret
+    def name(self):
+        ret = []
+        for name in self.vars:
+            if name == 'total':
+                ret.append('total failcnt')
+            else:
+                ret.append(name)
+        return ret
 
-	def vars(self):
-		ret = []
-		if not op.full:
-			list = ('total', )
-		else: 
-			list = self.discover
-		for name in list: 
-			if name in self.discover + ['total']:
-				ret.append(name)
-		return ret
+    def vars(self):
+        ret = []
+        if not op.full:
+            list = ('total', )
+        else: 
+            list = self.discover
+        for name in list: 
+            if name in self.discover + ['total']:
+                ret.append(name)
+        return ret
 
-	def extract(self):
-		for name in self.vars + ['total']:
-			self.cn2[name] = 0
-		for line in self.readlines():
-			l = line.split() 
-			if len(l) &lt; 6 or l[0] == 'uid':
-				continue
-			elif len(l) == 7:
-				name = l[0][0:-1]
-				if name in self.vars:
-					self.cn2[name] = self.cn2[name] + long(l[6])
-				self.cn2['total'] = self.cn2['total'] + long(l[6])
-			elif name == '0':
-				continue
-			else:
-				if name in self.vars:
-					self.cn2[name] = self.cn2[name] + long(l[5])
-				self.cn2['total'] = self.cn2['total'] + long(l[5])
-		for name in self.vars:
-			self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
-		if step == op.delay:
-			self.cn1.update(self.cn2)
+    def extract(self):
+        for name in self.vars + ['total']:
+            self.cn2[name] = 0
+        for line in self.readlines():
+            l = line.split() 
+            if len(l) &lt; 6 or l[0] == 'uid':
+                continue
+            elif len(l) == 7:
+                name = l[0][0:-1]
+                if name in self.vars:
+                    self.cn2[name] = self.cn2[name] + long(l[6])
+                self.cn2['total'] = self.cn2['total'] + long(l[6])
+            elif name == '0':
+                continue
+            else:
+                if name in self.vars:
+                    self.cn2[name] = self.cn2[name] + long(l[5])
+                self.cn2['total'] = self.cn2['total'] + long(l[5])
+        for name in self.vars:
+            self.val[name] = (self.cn2[name] - self.cn1[name]) * 1.0 / tick
+        if step == op.delay:
+            self.cn1.update(self.cn2)
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et

Modified: trunk/tools/dstat/plugins/dstat_wifi.py
===================================================================
--- trunk/tools/dstat/plugins/dstat_wifi.py	2007-05-12 04:07:27 UTC (rev 5391)
+++ trunk/tools/dstat/plugins/dstat_wifi.py	2007-05-12 04:12:27 UTC (rev 5392)
@@ -2,31 +2,31 @@
 from pythonwifi import iwlibs
 
 class dstat_wifi(dstat):
-	def __init__(self):
-		self.name = 'wifi'
-		self.format = ('d', 3, 33)
-		self.check()
-		self.vars = iwlibs.getNICnames()
-		self.name = self.vars
-		self.nick = ('lnk', 's/n')
-		self.init(self.vars, 2)
+    def __init__(self):
+        self.name = 'wifi'
+        self.format = ('d', 3, 33)
+        self.check()
+        self.vars = iwlibs.getNICnames()
+        self.name = self.vars
+        self.nick = ('lnk', 's/n')
+        self.init(self.vars, 2)
 
-	def check(self): 
-		global iwlibs
-		try:
-			from pythonwifi import iwlibs
-		except:
-			raise Exception, 'Needs python-wifi module'
-		return True
+    def check(self): 
+        global iwlibs
+        try:
+            from pythonwifi import iwlibs
+        except:
+            raise Exception, 'Needs python-wifi module'
+        return True
 
-	def extract(self):
-		for name in self.vars:
-			wifi = iwlibs.Wireless(name)
-			stat, qual, discard, missed_beacon = wifi.getStatistics()
-#			print qual.quality, qual.signallevel, qual.noiselevel
-			if qual.quality == 0 or qual.signallevel == -101 or qual.noiselevel == -101 or qual.signallevel == -256 or qual.noiselevel == -256:
-				self.val[name] = ( -1, -1 )
-			else:
-				self.val[name] = ( qual.quality, qual.signallevel * 100 / qual.noiselevel )
+    def extract(self):
+        for name in self.vars:
+            wifi = iwlibs.Wireless(name)
+            stat, qual, discard, missed_beacon = wifi.getStatistics()
+#           print qual.quality, qual.signallevel, qual.noiselevel
+            if qual.quality == 0 or qual.signallevel == -101 or qual.noiselevel == -101 or qual.signallevel == -256 or qual.noiselevel == -256:
+                self.val[name] = ( -1, -1 )
+            else:
+                self.val[name] = ( qual.quality, qual.signallevel * 100 / qual.noiselevel )
 
-# vim:ts=4:sw=4
+# vim:ts=4:sw=4:et


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004190.html">[svn] r5391 - in trunk/tools/mrepo: . docs tests
</A></li>
	<LI>Next message: <A HREF="004192.html">[svn] r5393 - in trunk/rpms: . cft cobbler facter koan pam_shield	pan puppet python-cheetah ruby-fam ruby-rpm vncreflector
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4191">[ date ]</a>
              <a href="thread.html#4191">[ thread ]</a>
              <a href="subject.html#4191">[ subject ]</a>
              <a href="author.html#4191">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://lists.repoforge.org/mailman/listinfo/commits">More information about the commits
mailing list</a><br>
</body></html>
